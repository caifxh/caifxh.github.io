<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1585732375323">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1585732375323" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/zhuang-ya-dp/">
                        状压dp
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-01</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            棋盘类（基于连通性）状压dp
1.十字型
玉米田
输入样例：
2 3
1 1 1
0 1 0

输出样例：
9

用二进制数来描述一行中方格的状态，1表示种玉米，0表示不种玉米
样例第一行有以下5种种玉米的方案

根据题意，把每一行的状态用二进制的数表示，0代表不在这块放牛，1表示在这一块放牛。首先很容易看到，每一行的状态要符合牧场的硬件条件，即牛必须放在能放牧的方格上。这样就能排除一些状态。另外，牛与牛之间不能相邻，这样就要求每一行中不能存在两个相邻的1，这样也能排除很多状态。然后就是根据上一行的状态转移到当前行的状态的问题了。必须符合不能有两个1在同一列（两只牛也不能竖着相邻）的条件。这样也能去掉一些状态。然后，上一行的所有符合条件的状态的总的方案数就是当前行该状态的方案数。
（1）初始化所有合法状态，即找没有相邻1的二进制数。用state[]存储合法状态
（2）枚举不同合法状态之间的转移关系，只要a&amp;amp;b == 0,状态a就可转到b
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;bitset&amp;gt;
using namespace std;
const int N=15,M=1&amp;lt;&amp;lt;12,mod=1e8;
int f[N][M];
int g[N];
int n,m;
vector&amp;lt;int&amp;gt; state;
vector&amp;lt;int&amp;gt; head[M];

bool check(int state)//判断相邻两列
{
    if(state &amp;amp; state&amp;lt;&amp;lt;1)
        return false;
    return true;
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=0;j&amp;lt;m;j++)
        {
            int x;
            cin&amp;gt;&amp;gt;x;//若x为1，表示玉米田不可用
            g[i]+=!x&amp;lt;&amp;lt;(m-1-j);
        }

    for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;m;i++)
        if(check(i))
            state.push_back(i);//所有合法状态
    
    f[0][0]=1;//边界
    for(int i=1;i&amp;lt;=n+1;i++)//枚举到第n+1行，省略求和
        for(int a=0;a&amp;lt;state.size();a++)//第i行状态为a，i-1行状态为b
            for(int b=0;b&amp;lt;state.size();b++)
            {
                if((g[i] &amp;amp; state[a]) == 0 &amp;amp;&amp;amp; (state[a] &amp;amp; state[b]) == 0) //不与上一行冲突，且不能在地图上0的地方种玉米
                    f[i][a]=(f[i][a]+f[i-1][b])%mod;
                }
    
    cout&amp;lt;&amp;lt;f[n+1][0]&amp;lt;&amp;lt;endl;
    return 0;
}

炮兵阵地
状态：f[i][j][k],已经摆完前i行，第i行状态是j，第i-1行状态是k的摆放方案
属性： max
划分依据，
第i行状态不仅和第i-1行状态有关，还和第i-2行状态有关,所有f[i][j][k]第i行状态是j，第i-1行状态是k，依据i-2行状态来划分。
a表示第i行状态，b表示第i-1行状态，c表示第i-2行状态
要求：
（1）每行的意大利炮不能相互攻击到，((a &amp;amp; b) || (a &amp;amp; c) || (a &amp;amp; b))==0
（2）意大利炮只能放在平地上,(g[i] &amp;amp; a )||(g[i-1] &amp;amp; b),无需判断g[i-2]行，若g[i-2]行意大利炮放到了山地上属于不合法状态，一定为0
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
const int N=110,M=1&amp;lt;&amp;lt;10;//n的范围远大于m的范围，以列作为枚举的状态
int g[N];
int cnt[M];//状态对应的1的个数
vector&amp;lt;int&amp;gt; state;
int n,m;
int f[2][M][M];//f[i,j,k] 第i行状态是j，第i-1行状态是k

bool check(int state)
{
    if((state &amp;amp; state&amp;lt;&amp;lt;1) || (state &amp;amp; state&amp;lt;&amp;lt;2))
        return false;
    return true;
}

int count(int state)
{
    int res=0;
    for(int i=0;i&amp;lt;m;i++)
        if(state&amp;gt;&amp;gt;i &amp;amp;1)
            res++;
    return res;
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=0;j&amp;lt;m;j++)
        {
            char c;
            cin&amp;gt;&amp;gt;c;
            if(c == &#39;H&#39;)
                g[i]+=1&amp;lt;&amp;lt;(m-1-j);
        }
        
    for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;m;i++)
    {
        if(check(i))
        {
            state.push_back(i);
            cnt[i]=count(i);
        }
    }
    //f[i,j,k] 已经摆完前i行，第i行状态是j，第i-1行状态是k
    for(int i=1;i&amp;lt;=n+2;i++)
        for(int j=0;j&amp;lt;state.size();j++)
            for(int k=0;k&amp;lt;state.size();k++)
                for(int u=0;u&amp;lt;state.size();u++)
                {
                    int a=state[j],b=state[k],c=state[u];//a表示第i行状态，b表示第i-1行状态，c表示第i-2行状态
                    if((a &amp;amp; b) || (a &amp;amp; c) || (a &amp;amp; b))//相邻两行不能相互攻击到
                        continue;
                    if((g[i] &amp;amp; a )||(g[i-1] &amp;amp; b))//意大利炮不能放山地上
                        continue;
                    f[i&amp;amp;1][a][b]=max(f[i&amp;amp;1][a][b],f[i-1&amp;amp;1][b][c]+cnt[a]);
                }
                
    cout&amp;lt;&amp;lt;f[n+2&amp;amp;1][0][0]&amp;lt;&amp;lt;endl;
    return 0;
}

2.井字型
骑士
状态：f[i][j][k],已经摆完前i行，第i行摆放状态是j（二进制位为1表示摆放，0表示不摆），已经摆了k个
属性：count
状态划分：
要求：国王不能左右相邻，不能上下相邻，不能对角相邻，第i行状态为a，i-1行状态为b
（1）每行内部不能有两个1相邻,（预处理）
（2）第i行和第i-1行状态不能相互攻击到，(a &amp;amp; b) == 0 ,a|b不能有两个相邻的1
//第i行状态只跟第i-1行状态有关
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
const int N=12,M=1&amp;lt;&amp;lt;10,K=110;
typedef long long LL;
LL f[N][M][K];
vector&amp;lt;int&amp;gt; state;
int cnt[M];//每个状态对应1的数目
int n,m;

bool check(int state)
{
    for(int i=0;i&amp;lt;n;i++)
    {
        if((state&amp;gt;&amp;gt;i &amp;amp;1) &amp;amp;&amp;amp; (state&amp;gt;&amp;gt;i+1 &amp;amp;1))
            return false;
    }
    return true;
}

int count(int state)
{
    int res=0;
    for(int i=0;i&amp;lt;n;i++)    
        res+=state&amp;gt;&amp;gt;i &amp;amp;1;
    return res;
}

int main()
{
    
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    
    for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;n;i++)//如果满足左右互不相邻，则存储当前状态
        if(check(i))
        {
            state.push_back(i);
            cnt[i]=count(i);
        }
    //cout&amp;lt;&amp;lt;state.size()&amp;lt;&amp;lt;endl;
    f[0][0][0]=1;
    for(int i=1;i&amp;lt;=n+1;i++)
        for(int a=0;a&amp;lt;state.size();a++) 
            for(int k=0;k&amp;lt;=m;k++)
                for(int b=0;b&amp;lt;state.size();b++)
                {
                    int sa=state[a],sb=state[b];//sa表示第i行状态,sb表示第i-1行状态
                    if((sa &amp;amp; sb) == 0 &amp;amp;&amp;amp; check(sa|sb))
                    {
                        int c=cnt[sa];
                        //cout&amp;lt;&amp;lt;sa&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;sb&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;k&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl;
                        if(k&amp;gt;=c)
                            f[i][sa][k]+=f[i-1][sb][k-c];
                    }
                }
    
    cout&amp;lt;&amp;lt;f[n+1][0][m]&amp;lt;&amp;lt;endl;
    return 0;
}

3.插头型
蒙德里安的梦想
考虑决策——骨牌的放法：横着 或者 竖着。
如果横着：
需要两个连续的空位，并且上一行的这两个位置也得已经被覆盖。
如果竖着：
(a) 上一行对应的位置是空的，我们把那个空填上。
(b) 上一行对应的位置是被覆盖的，那么我们把这一行的位置设为空，表示下一行的对应位置必须竖放，填上这块空白
状态表示：f[i][j],表示第i行的形态为j时的摆放方案数量
j是用十进制记录的m位二进制数，其中第k（0&amp;lt;=k&amp;lt;m）位为1表示第k列是一个竖着的1*2的长方形的上面一半。

记第i-1行状态为k，第i行状态为j
k能转移到j，当且仅当：
(1)j和k执行按位与为0，保证每个数字1下必须是0，才得以补全12的长方形
(2)j和k执行按位或的结果，连续的0必须是偶数。这些0表示若干横着的12长方形，奇数个0无法满足这种摆放形态。

可以预处理出[0,2m2^{m}2m-1]内所有满足连续的0必须是偶数的整数
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 12, M = 1 &amp;lt;&amp;lt; N;
int st[M];
long long f[N][M];

int main()
{
    int n, m;
    while (cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;amp;&amp;amp; n)
    {

        for (int i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; m; i ++)
        {
            int cnt = 0;// cnt 为当前已经存在多少个连续的0
            st[i] = true;
            for (int j = 0; j &amp;lt; m; j ++)
                if (i &amp;gt;&amp;gt; j &amp;amp; 1)
                {
                    if (cnt &amp;amp; 1) //当前位为1，上一段连续为0的位置已结束
                        st[i] = false; 
                    cnt = 0;
                }
                else cnt ++;
            if (cnt &amp;amp; 1) st[i] = false; // 扫完后要判断一下最后一段有多少个连续的0
        }
    
        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for (int i = 1; i &amp;lt;= n; i ++)
            for (int j = 0; j &amp;lt; 1 &amp;lt;&amp;lt; m; j ++)
                for (int k = 0; k &amp;lt; 1 &amp;lt;&amp;lt; m; k ++)
                    if ((j &amp;amp; k) == 0 &amp;amp;&amp;amp; (st[j | k])) 
                    // j &amp;amp; k == 0 表示 i 行和 i-1 行不能同时捅出来
                    // st[j | k] == 1 表示 在 i 列状态 j， i - 1 列状态 k 的情况下（连续的0必须有偶数个）是合法的.
                        f[i][j] += f[i - 1][k];      
        cout &amp;lt;&amp;lt; f[n][0] &amp;lt;&amp;lt; endl;
    }
    return 0;
}



集合类（每个元素是否在集合里面）状压dp
最短Hamilton路径
给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。
状态表示：dp[i][j] ：所有从0走到j，走过的所有点的状态是i的最短路径
状态划分：
dp[i][j]表示所有从0走到j，当前已经走过点的为i的集合。所以这个状态转移方程就是找一个中间点k，将已经走过点的集合i中去除掉j（表示j不在经过的点的集合中），然后再加上从k到j的权值。问题在于如何表达已经走过点的集合i，其实很简单，假如走过0,1,4这三个点，我们用二进制10011就可以表示，2,3没走过所以是0。
那么走过点的集合i中去除掉点j也很容易表示i - (1 &amp;lt;&amp;lt; j)，比方说i是{0,1,4}，j是1，那么i = 10011，(1 &amp;lt;&amp;lt; j) = 10，i - (1 &amp;lt;&amp;lt; j) = 10001
那么问题的答案就应该是dp[01....111][n-1]，表示0~n-1都走过，且当前移动到n-1这个点。
下时间复杂度：
n为20的时候，外层循环(1&amp;lt;&amp;lt;20)，内层循环20，所以整体时间复杂度O(20∗22020∗2^{20}20∗220)，这比O(n∗n!)快多了
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 20, M = 1 &amp;lt;&amp;lt; N;

int n;
int w[N][N];
int f[M][N];

int main()
{
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i ++ )
        for (int j = 0; j &amp;lt; n; j ++ )
            cin &amp;gt;&amp;gt; w[i][j];

    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;//第一个点是不需要任何费用的
    /*
    注意循环顺序
    如果反过来写，不能保证在f[i][j] = min(f[i][j], f[i - (1 &amp;lt;&amp;lt; j)][k] + w[k][j])中右边的状态在左边的状态之前被计算出来。
    */
    for (int i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; n; i ++ )//i代表着是一个方案集合，其中每一个位置1和0，代表着这个点经过还是没有经过
        for (int j = 0; j &amp;lt; n; j ++ )//枚举当前到了哪一个点
            if (i &amp;gt;&amp;gt; j &amp;amp; 1)//如果i集合中第j位是1，也就是到达过这个点
                for (int k = 0; k &amp;lt; n; k ++ )//枚举到达j的点k
                    if (i &amp;gt;&amp;gt; k &amp;amp; 1)
                        f[i][j] = min(f[i][j], f[i - (1 &amp;lt;&amp;lt; j)][k] + w[k][j]);

    cout &amp;lt;&amp;lt; f[(1 &amp;lt;&amp;lt; n) - 1][n - 1];

    return 0;
}

poj2288
题意：
给出n个点，m条边的无向图，给出每个点的点权，求点权和最小的哈密顿路径，相邻两个点要加上点权的乘积，形成环要加上环上的点权
这题先占个坑，以后补。。。。
hdu1074
题意：
给了n个家庭作业，然后给了每个家庭作业的完成期限和花费的实践，如果完成时间超过了期限，那么就要扣除分数，然后让你找出一个最优方案使扣除的分数最少，当存在多种方案时，输出字典序最小的那种，因为题意已经说了家庭作业的名字是按照字典序从小到大输入的，所以处理起来就好多了。
思路
在引出正解前，我们从DFS开始引入，如果这题用DFS来写，想必大家都有思路，很好理解。因为每个作业要么写，要么不写，因此开个布尔数组搜就行了，而且这题n &amp;lt;= 15;仔细想来，加点剪枝还是可以过的没准。
如果我们把布尔数组看成一个二进制位，进行状态压缩，很明显可以知道，最多只有2的15次方位的1二进制大小的状态。因此可以用2进制所对应的10进制来表示状态，这就是状态压缩。
状态表示:dp[i]记录完成作业状态为i时的最少损失的分数。
状态划分：
1.状态a能做第i号作业的条件是a中作业i尚未完成，即a&amp;amp;i=0。
2.若有两个状态dp[a],dp[b]都能到达dp[i],那么选择能使到达i扣分小的那一条路径，若分数相同，转入3
3.这两种状态扣的分数相同，那么选择字典序小的，由于作业按字典序输入，故即dp[i].pre = min(a,b);
最后dp[2^n-1]即为最少扣分，课程安排可递归的输出
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;bitset&amp;gt;
using namespace std;
const int N=20,M=1&amp;lt;&amp;lt;15;
const int INF=0x3f3f3f3f;
struct
{
    char sbj[110];
	int deadline;
	int fintime;
}w[N];
int dp[M];//dp[i]表示当前写作业状态是i的情况下被扣分的最小值 
int pre[M];//记录前驱 
int day[M];//记录当前写作业状态是i的情况下已经过了多少天 
int n;

void print_path(int state)
{
    if(state==0)return;
    int t=0;
    for(int i=0;i&amp;lt;n;i++)
      if( (state&amp;amp;(1&amp;lt;&amp;lt;i))!=0 &amp;amp;&amp;amp; (pre[state]&amp;amp;(1&amp;lt;&amp;lt;i))==0 )
      {
          t=i;
          break;//按字典序最小输出，由于输入时已按字典序输入，找到第一个满足的break 
      }
    print_path(pre[state]);
    cout&amp;lt;&amp;lt;w[t].sbj&amp;lt;&amp;lt;endl;
}

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    while(T--)
    {
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        for(int i=0;i&amp;lt;n;i++)
          scanf(&amp;quot;%s%d%d&amp;quot;,&amp;amp;w[i].sbj,&amp;amp;w[i].deadline,&amp;amp;w[i].fintime);
        memset(dp,0x3f,sizeof dp);
        memset(day,0,sizeof day); 
        dp[0]=0;//当前还未做作业时被扣分为0 
        for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;n;i++)
        {
        	//cout&amp;lt;&amp;lt;(bitset&amp;lt;3&amp;gt;(i))&amp;lt;&amp;lt;&amp;quot; : &amp;quot;&amp;lt;&amp;lt;endl;
            for(int j=0;j&amp;lt;n;j++)
            {
                if(i&amp;amp;(1&amp;lt;&amp;lt;j))continue;//第j位为1，表示第j位上的作业已完成，continue 
                int today=0;
//                for(int k=0;k&amp;lt;n;k++)
//                  if(i&amp;amp;(1&amp;lt;&amp;lt;k))
//                     today+=w[k].fintime;
//                today+=w[j].fintime;
				today=day[i]+w[j].fintime;//today表示今天是第几天 
				int score=0; 
                if(today&amp;gt;w[j].deadline) 
					score=today-w[j].deadline;//完成日期与截止日期的差值 ，若差值&amp;lt;0,则不需扣分 
                if(dp[i|(1&amp;lt;&amp;lt;j)]&amp;gt;dp[i]+score)
                {
                    dp[i|(1&amp;lt;&amp;lt;j)]=dp[i]+score;
                    day[i|1&amp;lt;&amp;lt;j]=day[i]+w[j].fintime;
                    //cout&amp;lt;&amp;lt;&amp;quot;--&amp;quot;&amp;lt;&amp;lt;(bitset&amp;lt;3&amp;gt;(i|(1&amp;lt;&amp;lt;j)))&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;dp[i|(1&amp;lt;&amp;lt;j)]&amp;lt;&amp;lt;endl;
                    pre[i|(1&amp;lt;&amp;lt;j)]=i;
                }
            }
            //cout&amp;lt;&amp;lt;endl;
        }
        printf(&amp;quot;%d\n&amp;quot;,dp[(1&amp;lt;&amp;lt;n)-1]);
        print_path((1&amp;lt;&amp;lt;n)-1);
    }
    return 0;
}

旅行商问题(TSP)，

TSP问题是NP难度的，没有多项式时间的高效算法。

假设最短的TSP路径是path=（v0-&amp;gt;v1-&amp;gt;v2-&amp;gt;v3-&amp;gt;v4-&amp;gt;v0）
那么path=(v0-&amp;gt;v1)+(v1-&amp;gt;v2-&amp;gt;v3-&amp;gt;v0)
所以问题转变为：求经过所有城市的最短回路-&amp;gt;从某个城市回到起点的最短路径
DP状态：假设已经访问过的城市集合是S（已访问为1，未访问为0），当前所在城市是u，用dp[S][u]表示从u出发访问剩余的所有城市最后回到起点的路径费用总和的最小值。
状态转移方程：
dp[S][u]=min(dp[S∪{v}][v]+dist(u,v)|v∉S}

临界条件如果递推的话是起点，递归的话是终点
#include&amp;lt;cstring&amp;gt;//递推，输出路径 
#include&amp;lt;bitset&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int INF=0x3f3f3f3f;
int dp[1&amp;lt;&amp;lt;15][15];//dp[S][u]:S表示已经过的节点，从u出发走完所有剩余顶点回到起点的最短距离
int g[15][15];
int path[1&amp;lt;&amp;lt;15][15];//最优路径
int n,m; //n个节点，m条边

void Init()
{
    memset(dp,0x3f,sizeof(dp));
    memset(g,0x3f,sizeof(g));
    memset(path,-1,sizeof(path));
}

void Traveling()//计算dp[S][u]
{
    dp[(1&amp;lt;&amp;lt;n)-1][0]=0;//注意：1&amp;lt;&amp;lt;n一定要加括号 
	for(int S=(1&amp;lt;&amp;lt;n)-2;S&amp;gt;=0;S--)
        for(int u=0;u&amp;lt;n;u++)
            for(int v=0;v&amp;lt;n;v++)
			{//u可以等于0,起点0可看做已访问（从起点0出发回到起点0） 
            	if((u!=0&amp;amp;&amp;amp;!(S&amp;gt;&amp;gt;u&amp;amp;1))||g[u][v]==INF) continue;，//若 u!=0，则u必须已访问 
				if(!(S&amp;gt;&amp;gt;v&amp;amp;1)&amp;amp;&amp;amp;dp[S][u]&amp;gt;dp[S|1&amp;lt;&amp;lt;v][v]+g[u][v])
                {
                    dp[S][u]=dp[S|1&amp;lt;&amp;lt;v][v]+g[u][v];
                    cout&amp;lt;&amp;lt;&amp;quot;S=&amp;quot;&amp;lt;&amp;lt;(bitset&amp;lt;5&amp;gt;(S))&amp;lt;&amp;lt;&amp;quot;\t   u=&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;\tv=&amp;quot;&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot;\tdp[&amp;quot;&amp;lt;&amp;lt;(bitset&amp;lt;5&amp;gt;(S))&amp;lt;&amp;lt;&amp;quot;][&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;]=&amp;quot;;
					cout&amp;lt;&amp;lt;&amp;quot;dp[&amp;quot;&amp;lt;&amp;lt;(bitset&amp;lt;5&amp;gt;(S|1&amp;lt;&amp;lt;v))&amp;lt;&amp;lt;&amp;quot;][&amp;quot;&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot;]+&amp;quot;&amp;lt;&amp;lt;g[u][v]&amp;lt;&amp;lt;&amp;quot;=&amp;quot;&amp;lt;&amp;lt;dp[S][u]&amp;lt;&amp;lt;endl;
                    path[S][u]=v;//记录后继节点
                }
        	}
}

void print(int S,int u)//打印路径
{
    if(S==(1&amp;lt;&amp;lt;n)-1) return;
    int v=path[S][u];//u的后继v
    cout&amp;lt;&amp;lt;&amp;quot;---&amp;gt;&amp;quot;&amp;lt;&amp;lt;v;
	print(S|1&amp;lt;&amp;lt;v,v);//将v加入已走过的节点集合，再从v出发
}

int main()
{
	int u,v,w;//u,v代表城市，w代表u和v城市之间路的长度
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    Init();
    for(int i=0;i&amp;lt;m;i++)
    {
       cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v&amp;gt;&amp;gt;w;
       //g[u][v]=g[v][u]=w;//无向图 
       g[u][v]=w;//有向图 
    }
    Traveling();
    cout&amp;lt;&amp;lt;&amp;quot;最短路径: &amp;quot;&amp;lt;&amp;lt;0;
    print(0,0);
    cout&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;最短路径长度:&amp;quot;&amp;lt;&amp;lt;dp[0][0]&amp;lt;&amp;lt;endl;
    return 0;
}


#include&amp;lt;cstring&amp;gt;//记忆化递归，输出路径 
#include&amp;lt;bitset&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int INF=0x3f3f3f3f;
int dp[1&amp;lt;&amp;lt;15][15];//dp[S][u]:S表示已经过的节点，从u出发走完所有剩余顶点回到起点的最短距离
int g[15][15];
int path[1&amp;lt;&amp;lt;15][15];//最优路径
int n,m; //n个节点，m条边

void Init()
{
    memset(dp,-1,sizeof(dp));
    memset(g,0x3f,sizeof(g));
    memset(path,-1,sizeof(path));
}

int Traveling(int S,int u)//计算dp[S][u],记忆化递归 
{
    if(dp[S][u]&amp;gt;=0)
    	return dp[S][u];
	if(S==(1&amp;lt;&amp;lt;n)-1&amp;amp;&amp;amp;u==0)
		return dp[S][u]=0;//递归结束条件
    int ans=INF;
	for(int v=0;v&amp;lt;n;v++)
		if(!(S&amp;gt;&amp;gt;v&amp;amp;1)&amp;amp;&amp;amp;g[u][v]!=INF)
		{
			int tmp=Traveling(S|1&amp;lt;&amp;lt;v,v)+g[u][v];
			if(ans&amp;gt;tmp)
			{
				ans=tmp;
				cout&amp;lt;&amp;lt;&amp;quot;S=&amp;quot;&amp;lt;&amp;lt;(bitset&amp;lt;5&amp;gt;(S))&amp;lt;&amp;lt;&amp;quot;\t   u=&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;\tv=&amp;quot;&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot;\tdp[&amp;quot;&amp;lt;&amp;lt;(bitset&amp;lt;5&amp;gt;(S))&amp;lt;&amp;lt;&amp;quot;][&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;]=&amp;quot;;
				cout&amp;lt;&amp;lt;&amp;quot;dp[&amp;quot;&amp;lt;&amp;lt;(bitset&amp;lt;5&amp;gt;(S|1&amp;lt;&amp;lt;v))&amp;lt;&amp;lt;&amp;quot;][&amp;quot;&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot;]+&amp;quot;&amp;lt;&amp;lt;g[u][v]&amp;lt;&amp;lt;&amp;quot;=&amp;quot;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
				path[S][u]=v;//记录后继节点
			}		
		}
    return dp[S][u]=ans;
}

void print(int S,int u)//打印路径
{
    if(S==(1&amp;lt;&amp;lt;n)-1) return;
    int v=path[S][u];//u的后继v
    cout&amp;lt;&amp;lt;&amp;quot;---&amp;gt;&amp;quot;&amp;lt;&amp;lt;v;
	print(S|1&amp;lt;&amp;lt;v,v);//将v加入已走过的节点集合，再从v出发
}

int main()
{
	int u,v,w;//u,v代表城市，w代表u和v城市之间路的长度
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    Init();
    for(int i=0;i&amp;lt;m;i++)
    {
       cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v&amp;gt;&amp;gt;w;
       //g[u][v]=g[v][u]=w;
       g[u][v]=w;
    }
    Traveling(0,0);
    cout&amp;lt;&amp;lt;&amp;quot;最短路径: &amp;quot;&amp;lt;&amp;lt;0;
    print(0,0);
    cout&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;最短路径长度:&amp;quot;&amp;lt;&amp;lt;dp[0][0]&amp;lt;&amp;lt;endl;
    return 0;
}

例题
poj3311

思路
由于题中明确说了两个城市间的直接可达路径（即不经过其它城市结点）不一定是最短路径，所以需要借助邻接矩阵首先求出任意两个城市间的最短距离（因为这里的点可以多次遍历，并没有次数限制，所以才能用floyd的，如果有次数限制x的话，就不能用floyd预处理，而应该用x进制的状态压缩了）。这一步骤使用Floyd最短路径算法即可。然后，在此基础上来求出遍历各个城市后回到出发点的最短路径的距离，即求解TSP问题。
//求走过所有点并回到原点的最短路,可以走一个点多次.
//因为可以走一个点多次，所以，可以先求出每两个点之间的最短路，然后用经典的旅行商问题的状态压缩DP做法。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=12,M=1&amp;lt;&amp;lt;11,INF=0x3f3f3f3f;
int n;
int g[N][N];
int dp[M][N];

void Init()
{
    memset(dp,-1,sizeof(dp));
    memset(g,0x3f,sizeof(g));
}

void floyd()
{
    for(int k=0;k&amp;lt;n;k++)
        for(int i=0;i&amp;lt;n;i++)
            for(int j=0;j&amp;lt;n;j++)
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
}

int Tsp(int S,int u)//计算dp[S][u],记忆化递归 
{
	if(dp[S][u]&amp;gt;=0)
    	return dp[S][u];
	if(S==(1&amp;lt;&amp;lt;n)-1&amp;amp;&amp;amp;u==0)//递归结束条件
		return dp[S][u]=0;
    int ans=INF;
	for(int v=0;v&amp;lt;n;v++)
		if(!(S&amp;gt;&amp;gt;v&amp;amp;1)&amp;amp;&amp;amp;g[u][v]!=INF)
			ans=min(ans,Tsp(S|1&amp;lt;&amp;lt;v,v)+g[u][v]);
    return dp[S][u]=ans;
}

int main()
{
    while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n),n)
    {
        n++;//源点0加上 
		Init();
        for(int i=0;i&amp;lt;n;i++)
            for(int j=0;j&amp;lt;n;j++)
                scanf(&amp;quot;%d&amp;quot;,&amp;amp;g[i][j]);
        floyd();
        printf(&amp;quot;%d\n&amp;quot;,Tsp(0,0));
    }
    return 0;
}

递推
//求走过所有点并回到原点的最短路,可以走一个点多次.
//因为可以走一个点多次，所以，可以先求出每两个点之间的最短路，然后用经典的旅行商问题的状态压缩DP做法。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=12,M=1&amp;lt;&amp;lt;11,INF=0x3f3f3f3f;
int n;
int g[N][N];
int dp[M][N];

void Init()
{
    memset(dp,0x3f,sizeof(dp));//递推时初始化为INF，记忆化递归初始化为-1 
    memset(g,0x3f,sizeof(g));
}

void floyd()
{
    for(int k=0;k&amp;lt;n;k++)
        for(int i=0;i&amp;lt;n;i++)
            for(int j=0;j&amp;lt;n;j++)
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
}

void Tsp()//计算dp[S][u]
{
    dp[(1&amp;lt;&amp;lt;n)-1][0]=0;//注意：1&amp;lt;&amp;lt;n一定要加括号 
	for(int S=(1&amp;lt;&amp;lt;n)-2;S&amp;gt;=0;S--)
        for(int u=0;u&amp;lt;n;u++)
            for(int v=0;v&amp;lt;n;v++)
			{
            	if((u!=0&amp;amp;&amp;amp;!(S&amp;gt;&amp;gt;u&amp;amp;1))||g[u][v]==INF) continue;//可以加约束条件，不加状态多 
				if(!(S&amp;gt;&amp;gt;v&amp;amp;1))
                    dp[S][u]=min(dp[S][u],dp[S|1&amp;lt;&amp;lt;v][v]+g[u][v]);
        	}
}

int main()
{
    while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n),n)
    {
        n++;//加上源点 
		Init();
        for(int i=0;i&amp;lt;n;i++)
            for(int j=0;j&amp;lt;n;j++)
                scanf(&amp;quot;%d&amp;quot;,&amp;amp;g[i][j]);
        floyd();
		Tsp();
        printf(&amp;quot;%d\n&amp;quot;,dp[0][0]);
    }
    return 0;
}

poj2686






#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=10,M=35,INF=0x3f3f3f3f;
int n,m,p,a,b;
int t[N];
int g[M][M];
double dp[1&amp;lt;&amp;lt;8][M];//d[S][u],所用车票状态是S,从起点走到点u所需的最短时间 

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;p&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b &amp;amp;&amp;amp; n)
	{
		for(int i=0;i&amp;lt;n;i++)
			cin&amp;gt;&amp;gt;t[i];
		memset(g,0x3f,sizeof g);
		while(p--)
		{
			int a,b,c;
			cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
			g[a][b]=g[b][a]=c;
		}
		//memset(dp,0x3f,sizeof(dp));//double不可以memset 
	    for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;n;i++)
	    	fill(dp[i]+1,dp[i]+m+1,INF);
	//	for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;n;i++)
	//		for(int j=1;j&amp;lt;=m;j++)
	//			dp[i][j]=INF;
		dp[(1&amp;lt;&amp;lt;n)-1][a]=0;
		double ans=INF;
		for(int S=(1&amp;lt;&amp;lt;n)-1;S&amp;gt;=0;S--)//状态 
		{
			for(int u=1;u&amp;lt;=m;u++)//城市 
				for(int i=0;i&amp;lt;n;i++)//车票 
					if(S&amp;gt;&amp;gt;i &amp;amp; 1)
						for(int v=1;v&amp;lt;=m;v++)//城市 
							if(g[u][v] != INF)
								dp[S-(1&amp;lt;&amp;lt;i)][v]=min(dp[S-(1&amp;lt;&amp;lt;i)][v],dp[S][u]+g[u][v]/(double)t[i]);
			ans=min(ans,dp[S][b]);
		}
							
		if(ans == INF)
			puts(&amp;quot;Impossible&amp;quot;);
		else
			printf(&amp;quot;%.3f\n&amp;quot;,ans);
	}
	return 0;
}

hdu3001
题意：
ACMer 想要游玩n个城市，告诉我们每个城市间的旅行费用，并且要求每个城市最多走两遍！问最小花费是多少
本题n=10，数据很小，但是由于每个城市可以走两遍，可能的路线就变成了(2n)!,所以不能暴力
用状压dp，时间复杂度O(3nn2)O(3^{n}n^{2})O(3nn2)



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=15,M=60000,INF=0x3f3f3f3f;
int n,m;
int bit[12]={0,1,3,9,27,81,243,729,2187,6561,19683,59049};//三进制每位为1时对应十进制，如第3位是1，(100)3=9 
int tri[M][N];//dp[S][j]状态S的第j位是多少
int dp[M][N];
int g[N][N];

int main()
{
	//cout&amp;lt;&amp;lt;pow(3,10)&amp;lt;&amp;lt;endl;
	for(int i=0;i&amp;lt;59050;i++)//预处理所有合法状态 
	{
		int t=i;
		for(int j=1;j&amp;lt;=10;j++)
		{
			tri[i][j]=t%3;//预处理当前状态S下每个顶点的访问次数 
			t/=3;
			if(!t)
				break;
		}
	}
	
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)) 
	{
		int ans=INF;
		memset(g,0x3f,sizeof g);
		memset(dp,0x3f,sizeof dp);
		
		while(m--)
		{
			int a,b,c;
			cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
			g[a][b]=g[b][a]=min(g[a][b],c);
		}
		
		for(int i=1;i&amp;lt;=n;i++)
			dp[bit[i]][i]=0;//每个顶点都可以作为起点，初始化状态为tri[i]时，从i出发最小费用为0
		
		for(int S=0;S&amp;lt;bit[n+1];S++)
		{
			bool visit_all=true;//标记所有的城市都遍历1次以上 
			for(int u=1;u&amp;lt;=n;u++)
			{
				if(tri[S][u] == 0)//u点没被访问 
				{
					visit_all=false;//当前状态不能访问所有顶点至少一次 
					continue; 
				}
				for(int v=1;v&amp;lt;=n;v++)
				{
					if(tri[S][v] == 0)//v点未访问
						continue;
					if(g[u][v] != INF)
						dp[S][u]=min(dp[S][u],dp[S-bit[u]][v]+g[u][v]);//u从S中减去 
				}
			}
			if(visit_all)//所有的城市都遍历1次以上
				for(int u=1;u&amp;lt;=n;u++)
					ans=min(ans,dp[S][u]);
		}
			
		if(ans == INF)
			puts(&amp;quot;-1&amp;quot;);
		else
			cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
	}
	return 0;
}

hdu4628
有一个长度不超过 16 的字符串。
每次你可以从中删除一个子序列，但是要求这个子序列是回文的。
问最少删除几次可以把这个字符串删光。
样例：
2
aa （1次）
abb （2次）
每次可以选择一个子序列，而子序列是可以用二进制来表示的。
用一个 n 位的二进制数 s 来表示，如果第 i 位是 1，则表示第 i 个数在这个子序列中。
由此衍生出：用 f[s] 来表示把 s 这个子序列删完的最小步数。
答案自然就是 f[(1 &amp;lt;&amp;lt; n) - 1]
一个显然的想法，可以把 s 分成两个不相交的集合 x 和 y， 即 x ∩ y = ∅，x ∪ y = s
f[s] = min(f[s], f[s-x] + 1) (x 是回文子串）
如何判断x是s的子集？
x|s == s
直接枚举 x 和 y 的时间复杂度是 O(2n2^n2n)，对于每个状态都有枚举2^n,总时间复杂度是O(4n4^n4n)，无法承受。
注意到 x 和 y 都是 s 的子集。
所有集合的子集个数之和的级别是 O(3^n)
就是说一个集合,有n个元素,2n个子集,把这2n个子集的所有子集数相加就是3^n
证明可以对每个集合考虑贡献，二项式定理
空集的子集只有一个——它本身.即C(n,0)×20个.有一个元素的子集有C(n,1)=n个,它们分别有21=2个子集.共C(n,1)×21个.有两个元素的子集有C(n,2)个,它们分别有22=4个子集.共C(n,2)×2^2个...
我们只要枚举 s 的子集 x，那么 y 自然就是 s - x
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=20,M=1&amp;lt;&amp;lt;16;
char s[N];
int f[M];
bool st[M];
int n;

bool check(int x)
{
    char str[20];
    int tot=0;
    for(int i=0;i&amp;lt;n;i++)
        if(x&amp;gt;&amp;gt;i &amp;amp; 1) str[tot++]=s[i];
    
    for(int i=0;i&amp;lt;tot/2;i++)
        if(str[i] != str[tot-1-i])
            return 0;
    
    return 1;
}

void init()
{
    memset(st,0,sizeof st);
    for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;n;i++)
        if(check(i))
            st[i]=true;
}

int main()
{
    int T;
    cin&amp;gt;&amp;gt;T;
    while(T--)
    {
        scanf(&amp;quot;%s&amp;quot;,s);
        n=strlen(s);
        init();
        
        memset(f,0x3f,sizeof f);
        f[0]=0;
        for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;n;i++)
            for(int j=i;j;j=(j-1)&amp;amp;i)
                if(st[j]) f[i]=min(f[i],f[i-j]+1);
        
        printf(&amp;quot;%d\n&amp;quot;,f[(1&amp;lt;&amp;lt;n)-1]);
    }
    return 0;
}

hdu6149
给定一张 N 个点 M 条边的无向图，其中有 K 个点被标记为高点，剩下的 (N-K) 个点是低点。
图中的山谷定义为三元组 &amp;lt;X,Y,Z&amp;gt;，满足X和Y之间有边，Y与 Z之间也有边，同时X和Z是高点，Y是低点。
问这个图中最多有几个山谷（一个点只能出现在一个山谷中）N ≤ 30, K ≤ min(N,15)
高点最多只有 15 个。
可以考虑用状态压缩，s 表示高点的使用状态。
低点排成一个长度为 n-k 的序列。
f[i][s] 表示前 i 个低点，使用过的高点的状态为 s 的情况下，组成的山谷的最大可能值。
转移 f[i][s] 的时候，取出第 i+1 个低点。
枚举不在 s 中的两个高点 p 和 q.
检查 p 和 q 和第 i+1 个低点能否配对。
如果可以，那么就可以用 f[i][s] + 1 去更新
f[i + 1][s | (1 &amp;lt;&amp;lt; p) | (1 &amp;lt;&amp;lt; q)]
答案就是 max{ f[n-k][i] | 0 ≤ i &amp;lt; 2k2^k2k }
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
typedef pair&amp;lt;int,int&amp;gt; PII;
const int N=35,M=1&amp;lt;&amp;lt;15;
int f[N][M];
int g[N][N];
int n,m,k;
int high[N],low[N];
bool st[N];
vector&amp;lt;PII&amp;gt; trans[N];
int tot;

void init()
{
	for(int i=1;i&amp;lt;=n;i++)
		if(!st[i])
			low[++tot]=i;
	
	for(int i=1;i&amp;lt;=tot;i++)
	{
		trans[i].clear();
		for(int p=0;p&amp;lt;k;p++)
			if(g[low[i]][high[p]])
				for(int q=p+1;q&amp;lt;k;q++)
					if(g[low[i]][high[q]])
						trans[i].push_back(make_pair(p,q));							
	}
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		memset(g,0,sizeof g);
		memset(st,0,sizeof st);
		memset(f,0,sizeof f);
		tot=0;
		scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);
		for(int i=0;i&amp;lt;m;i++)
		{
			int x,y;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
			g[x][y]=g[y][x]=1;
		}
		
		for(int i=0;i&amp;lt;k;i++)
		{
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;high[i]);
			st[high[i]]=true;
		}
		
		init();
		
		for(int i=1;i&amp;lt;=tot;i++)
		{
			for(int s=0;s&amp;lt;1&amp;lt;&amp;lt;k;s++)
				f[i][s]=f[i-1][s];//不选第i个点
			
			for(int s=0;s&amp;lt;1&amp;lt;&amp;lt;k;s++)
			{
				for(int j=0;j&amp;lt;trans[i].size();j++)
				{
					int x=trans[i][j].first;
					int y=trans[i][j].second;
					if(s&amp;gt;&amp;gt;x &amp;amp; 1) continue;
					if(s&amp;gt;&amp;gt;y &amp;amp; 1) continue;
					f[i][s|(1&amp;lt;&amp;lt;x)|(1&amp;lt;&amp;lt;y)]=max(f[i][s|(1&amp;lt;&amp;lt;x)|(1&amp;lt;&amp;lt;y)],f[i-1][s]+1);//选第i个点
				}
			}
		}
			
		int ans=0;
		for(int i=0;i&amp;lt;1&amp;lt;&amp;lt;k;i++)
			ans=max(ans,f[tot][i]);
		
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

acwing524
数据范围非常小，可以考虑状态压缩DP。 设 f[s] 表示清除掉 s 集合中的猪花费的最小步数。
思考转移。
在已有的 s 集合基础上，再选择一条抛物线使得它经过 t集合的点。
那么就可以用 f[s] + 1 去更新 f[s | t]
三点确定一条抛物线。
而三点之中必须有一个原点，因此只要两个点就能确定一条抛物线。
因此我们可以枚举 s 集合以外的任意两个点，算出经过这两个点的抛物线，枚举所有的点看是否落在抛物线上，得到抛
物线经过的点集 t。
f[s | t] = min(f[s | t], f[s] + 1);
经过点 i 和 j 的抛物线经过的点集 t[i][j] 可以预处理。时间复杂度 O(n3n^3n3)
之后 DP 枚举每个集合，对每个集合都要枚举两个点。
时间复杂度 O(n2nn2^nn2n)
预处理：
ax[i]2+bx[i]=y[i]ax[i]^2 + bx[i] = y[i]ax[i]2+bx[i]=y[i]
ax[j]2+bx[j]=y[j]ax[j]^2 + bx[j] = y[j]ax[j]2+bx[j]=y[j]
解二元一次方程组，得到 a 和 b。
如果 a &amp;gt;= 0，不符合题意，t[i][j] = 0
否则对每个点判断一下是否落在这条抛物线上，如果第 k 个点落在抛物线上，
t[i][j] |= (1 &amp;lt;&amp;lt; (k - 1));
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int N=20,M=1&amp;lt;&amp;lt;18;
const double eps=1e-8;
double x[N],y[N];
int path[N][N];
int f[M];
int n,m;

int cmp(double a,double b)
{
	if(fabs(a-b) &amp;lt; eps) return 0;
	else return a&amp;lt;b? -1 : 1;
}

void init()
{
	for(int i=0;i&amp;lt;n;i++)
	{
	    path[i][i] |= 1&amp;lt;&amp;lt;i;
	    
		for(int j=i+1;j&amp;lt;n;j++)
		{
			if(!cmp(x[i],x[j])) continue;
			
			double a=(y[i]/x[i]-y[j]/x[j])/(x[i]-x[j]);
			if(cmp(a,0) &amp;gt;= 0) continue;
			double b=y[i]/x[i]-a*x[i];
			
			for(int k=0;k&amp;lt;n;k++)
				if(!cmp(a*x[k]*x[k]+b*x[k],y[k])) path[i][j]|=1&amp;lt;&amp;lt;k;
		}
	}
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
		for(int i=0;i&amp;lt;n;i++)
			scanf(&amp;quot;%lf%lf&amp;quot;,&amp;amp;x[i],&amp;amp;y[i]);
		memset(path,0,sizeof path);
		
		init();
		
		memset(f,0x3f,sizeof f);
		f[0]=0;
		for(int s=0;s&amp;lt;1&amp;lt;&amp;lt;n;s++)
			for(int i=0;i&amp;lt;n;i++)
				if(!(s&amp;gt;&amp;gt;i &amp;amp; 1))
				{
					for(int j=i;j&amp;lt;n;j++)//记得处理只射一只猪的情况(i == j)
					{
					    if(!(s&amp;gt;&amp;gt;j &amp;amp; 1))
							f[s|path[i][j]] = min(f[s|path[i][j]],f[s]+1);
					}
					break;
					//对于我们枚举的每一个状态i，我们找到它正数第一只没射掉的猪进行转移后break。
                    //因为如果我们转移了第一只后面的没射的猪，到时候还要回头来将第一只猪射掉。
                    //所以后面的没射的猪的转移其实是多余的，射完第一只猪后按顺序接着往后射就可以了。
				}
						
		printf(&amp;quot;%d\n&amp;quot;,f[(1&amp;lt;&amp;lt;n)-1]);
	}
	return 0;
}

acwing529
简化版题目：
给定一个 n 个点 m 条边的图，请你求出一个有根树，满足每个点的深度和它到父节点的边权乘积之和最小。
n ≤ 12，m ≤ 1000
考虑到点数只有12个，可以考虑状态压缩 DP。 用 s 表示当前加入的点集。
为了方便转移，我们不记录根是谁，而是直接去考虑深度。
也就是用 f[i][s] 表示当前的点集是 s，最深的点为 i。
然后我们去枚举 s 的补集的子集 t，把 t 都作为第 i+1 层加入 s。
我们不用去考虑 t 里的点在这颗树中是否真的是第 i+1层
因为如果不是的话只可能小于i+1层，答案会更小。
那么一定存在一种转移顺序，考虑到这种更优的情况，也就是先把这个点加入 s 集合。
例如，如果第j层中用到的某条边(a, b)应该在比j小的层，假设a是S中的点，b是第j层的点，则在枚举S + {b}时会得到更小的花费。
具体的操作是：
对于 s，枚举 t（s 的补集的子集），检查 t 里的点是否都和 s 里的点有连边，处理出每个点到 s 里的点的最短边。
设这些最短边边权之和为 v。
那么 f[i][s | t] = min(f[i][s | t], f[i - 1][s] + (i - 1) * v)
时间复杂度分析：
s 一共有 2n2^n2n 个，s 的补集的子集一共有 3n3^n3n 个。
处理 t 里的每个点到 s 里的点的最短边，预处理时间复杂度 O(n2n^2n2)
验证 t 是否可行，时间复杂度 O(n)。
转移时对每个深度都要更新一次，时间复杂度O(n)
总时间复杂度就是 O(n22n+n3nn^22^n + n3^nn22n+n3n)，即 O(n3nn3^nn3n)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;bitset&amp;gt;
using namespace std;
const int N=15,M=1&amp;lt;&amp;lt;12,INF=0x3f3f3f3f;
int f[M][N];
int g[N][N];
int dist[M][N];
int n,m;

void init()
{
    memset(dist,0x3f,sizeof dist);

    for(int s=0;s&amp;lt;1&amp;lt;&amp;lt;n;s++)//集合s 
        for(int i=0;i&amp;lt;n;i++)
            if(!(s&amp;gt;&amp;gt;i &amp;amp; 1))//枚举不在集合s中的点i 
                for(int j=0;j&amp;lt;n;j++)
                    if(s&amp;gt;&amp;gt;j &amp;amp; 1)//预处理出i到集合s的最短距离 
                        dist[s][i]=min(dist[s][i],g[i][j]);
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);

    memset(g,0x3f,sizeof g);
    while(m--)
    {
        int a,b,c;
        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);
        a--,b--;
        g[a][b]=g[b][a]=min(g[a][b],c);
    }

    init();

    memset(f,0x3f,sizeof f);
    for(int i=0;i&amp;lt;n;i++) f[1&amp;lt;&amp;lt;i][1]=0;

    for(int s=0;s&amp;lt;1&amp;lt;&amp;lt;n;s++)//集合s 
    {
        int c=(1&amp;lt;&amp;lt;n)-1-s;
        for(int t=c;t;t=(t-1)&amp;amp;c)//集合s的补集t 
        {
            int sum=0;
            for(int i=0;i&amp;lt;n;i++)
                if(t&amp;gt;&amp;gt;i &amp;amp; 1)
                {
                    sum+=dist[s][i];
                    if(sum &amp;gt;= INF) break;
                }   

            if(sum &amp;lt; INF)
                for(int i=1;i&amp;lt;=n;i++)
                    f[s|t][i]=min(f[s|t][i],f[s][i-1]+(i-1)*sum);
        }
    }

    int ans=INF;
    for(int i=1;i&amp;lt;=n;i++)
        ans=min(ans,f[(1&amp;lt;&amp;lt;n)-1][i]);

    printf(&amp;quot;%d\n&amp;quot;,ans);

    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/zhuang-ya-dp/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/wu-xiang-tu-you-xiang-tu-de-lian-tong-xing-fu-xi/">
                        无向图/有向图的连通性复习
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-01</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            相关概念
1.无向图


2.有向图


3.割点和桥










4.tarjan算法


4.1无向图的桥

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&amp;gt;dfn[u])
				cout&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;—&amp;quot;&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot;是桥&amp;quot;&amp;lt;&amp;lt;endl; 
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
				tarjan(1,0);
	}
	return 0;
}

4.2无向图的割点



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt,root;
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	int count=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&amp;gt;=dfn[u])
			{
				count++;
				if(u!=root||count&amp;gt;1)
					cout&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;是割点&amp;quot;&amp;lt;&amp;lt;endl; 
			}	
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i,0);
			 } 
	}
	return 0;
}

有向图的强连通分量（SCC）

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
stack&amp;lt;int&amp;gt;s;
bool ins[maxn];
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		cout&amp;lt;&amp;lt;&amp;quot;连通分量：&amp;quot;;
		do
		{
			v=s.top();
			s.pop();
			cout&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
			ins[v]=false;
		}while(v!=u);
		cout&amp;lt;&amp;lt;endl;
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(ins,0,sizeof(ins));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
	}
	return 0;
}

例题
poj1144
求割点数
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=105;
int n,root;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn*maxn];

int low[maxn],dfn[maxn],num;
bool cut[maxn];
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	dfn[u]=low[u]=++num;
	int flag=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]&amp;gt;=dfn[u])
			{
				flag++;
				if(u!=root||flag&amp;gt;1)//u不是根或者u是根但至少有两个子结点
					cut[u]=true; 			
			}
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(cut,false,sizeof(cut));
	cnt=num=0;
}

int main()
{ 
	while(cin&amp;gt;&amp;gt;n&amp;amp;&amp;amp;n)
	{
		init(); 
		int u,v;
		while(cin&amp;gt;&amp;gt;u&amp;amp;&amp;amp;u)
		{
			while(1)
			{
				char c=getchar();
				if(c==&#39;\n&#39;)
					break;
				cin&amp;gt;&amp;gt;v;
				add(u,v);
				add(v,u);
			}
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i);
			}
		int ans=0;
		for(int i=1;i&amp;lt;=n;i++)
			if(cut[i])
				ans++;
		cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj3352
最少加几条边，才能使无向图变成边双连通图。



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],degree[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(degree,0,sizeof(degree));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
			add(v,u);
		}
		tarjan(1,-1);
		for(int u=1;u&amp;lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(low[u]!=low[v])
					degree[low[u]]++;
			}
		int leaf=0;
		for(int i=1;i&amp;lt;=n;i++)
			if(degree[i]==1)
				leaf++;
		cout&amp;lt;&amp;lt;(leaf+1)/2&amp;lt;&amp;lt;endl;
	}
	return 0;
}

换种写法：(可求得所有点双连通分量)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=5010,M=200010;
int h[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
int d[N];
bool is_bridge[M];
int id[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u,int fa)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        if(!dfn[j])
        {
            tarjan(j,u);
            low[u]=min(low[u],low[j]);
            if(dfn[u] &amp;lt; low[j])
                is_bridge[i]=is_bridge[i^1]=true;
        }
        else
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++dcc_cnt;
        int y;
        do{
            y=stk[top--];
            id[y]=dcc_cnt;
        }while(y != u);
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        add(a,b);
        add(b,a);
    }
    
    tarjan(1,-1);
    
    for(int i=0;i&amp;lt;idx;i++)
        if(is_bridge[i])
            d[id[e[i]]]++;
            
    int cnt=0;
    for(int i=1;i&amp;lt;=dcc_cnt;i++)
        if(d[i] == 1)
            cnt++;
    cout&amp;lt;&amp;lt;(cnt+1)/2&amp;lt;&amp;lt;endl;
    return 0;
}



poj2553

求解强连通分量，缩点，计算缩点的出度，统计出度为0的顶点。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;
const int maxn=5050;
int n,m;
bool ins[maxn];//标记是否在栈内 
int head[maxn],id[maxn],dout[maxn];
int low[maxn],dfn[maxn];
stack&amp;lt;int&amp;gt; s;
int cnt,num,scc_cnt;
struct Egde
{
	int to,next;
}e[maxn*maxn];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(ins,false,sizeof(ins));
	memset(dout,0,sizeof(dout));
	memset(id,0,sizeof(id));
	cnt=num=0;
	scc_cnt=0;
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		++scc_cnt;
		do
		{
			v=s.top();
			s.pop();
			id[v]=scc_cnt;
			ins[v]=false;
		}while(v!=u);
	}
}

int main()
{
	while((cin&amp;gt;&amp;gt;n)&amp;amp;&amp;amp;n)
	{
		cin&amp;gt;&amp;gt;m;
		init();
		while(m--)
		{
			int u,v;
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
		for(int u=1;u&amp;lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(id[u]!=id[v])
					dout[id[u]]++; 
			}
		int flag=1;
		for(int i=1;i&amp;lt;=n;i++)
		{
			if(!dout[id[i]])
			{
				if(flag)
					flag=0;
				else
					cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
				cout&amp;lt;&amp;lt;i;
			}		
		}
		cout&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj1236/acwing367
至少添加几条边，使得有向图为强连通图



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=110,M=N*N;
int n;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N];
int stk[N],top;
bool in_stk[N];
int scc_cnt,timestamp;
int id[N];
int dout[N],din[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    in_stk[u]=true;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(in_stk[j])
            low[u]=min(low[u],dfn[j]);
    }   
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            //cout&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&#39; &#39;;
            in_stk[y]=false;
            id[y]=scc_cnt;
        }while(y != u);
        //cout&amp;lt;&amp;lt;endl;
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n;
    memset(h,-1,sizeof h);
    for(int i=1;i&amp;lt;=n;i++)
    {
        int x;
        while(cin&amp;gt;&amp;gt; x &amp;amp;&amp;amp; x)
            add(i,x);
    }
        
    
    for(int i=1;i&amp;lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
    
    // for(int i=1;i&amp;lt;=n;i++)
    // {
    //     cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;id[i]&amp;lt;&amp;lt;endl;
    // }
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                dout[a]++;
                din[b]++;
            }
        }
     
    int a=0,b=0;  
    for(int i=1;i&amp;lt;=scc_cnt;i++)
    {
        if(!din[i])
            a++;
        if(!dout[i])
            b++;
    }
    
    cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;
    if(scc_cnt == 1)
        cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl;
    else
        cout&amp;lt;&amp;lt;max(a,b)&amp;lt;&amp;lt;endl;
    return 0;
}

acwing1174
（1）若采用暴力求解，先建反图，判断从每个点出发能否到达所有点。时间复杂度：$O(n(n+m))
（2）若为拓扑图，则只需判断出度为0的点，若出度为0的点大于1个，则答案为0，若出度为0的点为1，则答案为1.
先求出所有强连通分量，然后缩点，判断出度为0的分量，答案为该分量里的点的数目。
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 10010, M = 50010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, cnt[N];//强连通分量编号，每个分量里点的数目
int dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            cnt[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
        add(a, b);
    }

    for (int i = 1; i &amp;lt;= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 1; i &amp;lt;= n; i ++ )
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b) dout[a] ++ ;
        }

    int zeros = 0, sum = 0;
    for (int i = 1; i &amp;lt;= scc_cnt; i ++ )
        if (!dout[i])
        {
            zeros ++ ;
            sum += cnt[i];
            if (zeros &amp;gt; 1)
            {
                sum = 0;
                break;
            }
        }

    printf(&amp;quot;%d\n&amp;quot;, sum);

    return 0;
}

acwing1175
求最大半连通子图的结点数和最大半连通子图数。
(1)对于任何一个强连通分量（tarjan），一定是半连通分量。
(2)缩点，建图得到一个有向无环图（拓扑图），求拓扑图上的最长链（最长链包含的结点数即为最大半连通子图的结点数）。缩完点之后的图中出现了重边怎么办,那就会使方案数莫名增多.所以对于缩完点后的图还要判重边
(3)最长链的条数即为最大半连通子图数。
求最长链采用dp，跑最长路,我们只需要找出一条点权最大的路径就行了，不限制点的个数。
所以首先对这个图进行tarjan缩点，并记录下每个连通块的大小，和每个点所在的连通块。
缩点之后，会发现这个图变成了一个dag（有向无环图），我们要对这个dag求出最长链的大小和个数。
因为这个图是无环的，所以我们可以按照拓扑序进行DP
Tarjan缩点后的点的标号顺序是逆拓扑序，所以不需要对新图进行拓扑排序
状态表示: f[i]表示到第i个连通块的最长链大小，g[i]表示个数。
很容易就想到了转移的方法：
1.{g[i]=g[i]+g[j]}(条件：f[j]+number[i]==f[i])
2.{g[i]=g[j],f[i]=f[j]+number[i]}(条件：f[j]+number[i]&amp;gt;f[i])。
按照这个转移状态就可以啦。
总结：强连通分量+缩点+去重+DAGdp
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;unordered_set&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=100010,M=2000010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m,mod;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N],g[N];
typedef pair&amp;lt;int,int&amp;gt; PII;
int stk[N],top;
bool ins[N];
typedef long long LL;

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]++;
        }while(y != u);
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;mod;
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&amp;lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    unordered_set&amp;lt;LL&amp;gt; S;//(u,v)-&amp;gt;u*1000000+v
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            LL hash=a*1000000ll+b;
            if(a != b &amp;amp;&amp;amp; !S.count(hash))
            {
                add(hs,a,b);
                S.insert(hash);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
        if (!f[i])//代表它是入度为0的点 
        {
            f[i] = Size[i];
            g[i] = 1;
        }
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&amp;lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
                g[k]=g[i];
            }
            else if(f[k] == f[i] + Size[k])
                g[k]=(g[k]+g[i])%mod;
        }
    }
    
    int maxf=0,sum=0;
    for(int i=1;i&amp;lt;=scc_cnt;i++)
        if(f[i]&amp;gt;maxf)
        {
            maxf=f[i];
            sum=g[i];
        }
        else if(f[i] == maxf)
            sum=(sum+g[i])%mod;
    
    cout&amp;lt;&amp;lt;maxf&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;
    return 0;
    
}

补一个缩点的模板缩点`
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=10010,M=200010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N];
int stk[N],top;
bool ins[N];
int p[N];//点权 

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]+=p[y];
        }while(y != u);
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    for(int i=1;i&amp;lt;=n;i++)
    	cin&amp;gt;&amp;gt;p[i];
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&amp;lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                add(hs,a,b);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
    	if(!f[i])
    	{
    		f[i]=Size[i];
		}
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&amp;lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
            }
        }
    }
    
    int maxf=0;
    for(int i=1;i&amp;lt;=scc_cnt;i++)
  		maxf=max(maxf,f[i]);
    cout&amp;lt;&amp;lt;maxf&amp;lt;&amp;lt;endl;
    return 0;
    
}

再补一个DAGdp的简单题P1137
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=100000+15;
int n,m,idx;
int head[maxn],din[maxn],dp[maxn];
struct EDGE
{
    int to;
	int next;
}edge[maxn&amp;lt;&amp;lt;2];
int q[maxn],hh,tt=-1;

void add(int x,int y)
{
    edge[++idx].next=head[x];
    edge[idx].to=y;
    head[x]=idx;
}

void topsort()
{
    
    for (int i=1;i&amp;lt;=n;i++)
	    if (din[i]==0) 
			q[++tt]=i;
			
    while (hh&amp;lt;=tt)
    {
        int t=q[hh++];
        for (int i=head[t];i;i=edge[i].next)
        {
            int v=edge[i].to;
            din[v]--;
            if (din[v]==0)
            	q[++tt]=v;
        }
    }
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
    for (int i=1;i&amp;lt;=m;i++)
    {
        int u,v;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;u,&amp;amp;v);
        add(u,v);
        din[v]++;
    }
    
    topsort();
    
    for (int i=1;i&amp;lt;=n;i++)
    {
        int u=q[i-1];
        if(!dp[u])
        	dp[u]=1;
        for (int j=head[u];j;j=edge[j].next)
        {
            int v=edge[j].to;
            dp[v]=max(dp[v],dp[u]+1);
        }
    }
    for (int i=1;i&amp;lt;=n;i++)
    	printf(&amp;quot;%d\n&amp;quot;,dp[i]);
    return 0;
}

acwing1183
题意：求删除一个点后，图中最多有多少个连通块。
/*
1.统计连通块数量
2.枚举每一个连通块删除割点后所得的最大连通块数ans
3.ans+cnt-1即为答案
*/
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=10010,M=30010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int ans;
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &amp;gt;= dfn[u])
            {
                cnt++;
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }

    if(u != root &amp;amp;&amp;amp; cnt)//不是根节点，还要加上父节点的那一块连通分量
        cnt++;
    ans=max(ans,cnt);//每一个连通块删除割点后所得的最大连通块数ans
}

int main()
{
    while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m &amp;amp;&amp;amp; n)
    {
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(low,0,sizeof low);
        idx=timestamp=0;
        ans=0;

        while(m--)
        {
            int a,b;
            cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
            add(a,b);
            add(b,a);
        }

        int cnt=0;
        for(root=0;root&amp;lt;n;root++)
            if(!dfn[root])
            {
                cnt++;//连通块数
                tarjan(root);
            }
        
        cout&amp;lt;&amp;lt;ans+cnt-1&amp;lt;&amp;lt;endl;
    }
    return 0;
}

acwing396
题意：
就是有很多个点，在某个时候一个点将会塌陷，你要建造一些点，使任意一点塌陷时其他点都能成功逃脱
情况一：当前连通块内没有一个割点
那么此时至少要建立两个点，使得在任意一点坍塌时能顺利逃脱，那么此时要建立的点的个数就是2，
而方案数则是Cn2=n(n−1)2C_n^2 = \frac{n(n−1)}{2}Cn2​=2n(n−1)​,n为点数

情况二：当前连通块中有一个割点
此时在当前点双连通分量中非割点位置任意选取一个顶点建立1个出口即可，方案数为；cnt-1（cnt为当前连通分量中点数）

情况三：当前连通块中中有一个割点以上，无需设置出口（一个割点时已设置出口，且各个v-dcc连通，无论删去任意一个出口or割点or普通点，都可保证剩下点可成功逃离）
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 1010, M = 1010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
vector&amp;lt;int&amp;gt; dcc[N];
bool cut[N];
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    if(u == root &amp;amp;&amp;amp; h[u] == -1)
    {
        dcc_cnt++;
        dcc[dcc_cnt].push_back(u);
        return;
    }
    
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &amp;gt;= dfn[u])
            {
                cnt++;
                if(u != root || cnt &amp;gt;1)
                    cut[u]=true;
                ++dcc_cnt;
                int y;
                do{
                    y=stk[top--];
                    dcc[dcc_cnt].push_back(y);
                }while(y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }
}

int main()
{
    int kase=1;
    while(cin&amp;gt;&amp;gt;m &amp;amp;&amp;amp; m)
    {
        for(int i=1;i&amp;lt;=dcc_cnt;i++)
            dcc[i].clear();
        idx=n=timestamp=top=dcc_cnt=0;
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(cut,0,sizeof cut);
        
        while(m--)
        {
            int a,b;
            cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
            n=max(n,a),n=max(n,b);
            add(a,b);
            add(b,a);
        }
        
        for(root = 1; root &amp;lt;= n; root ++)
        {
            if(!dfn[root])
                tarjan(root);
        }
        
        int res=0;
        ULL num=1;
        for(int i=1;i&amp;lt;=dcc_cnt;i++)
        {
            int cnt=0;//统计当前v-dcc中割点的数量
            for(int j=0;j&amp;lt;dcc[i].size();j++)
                if(cut[dcc[i][j]])
                    cnt++;
            
            if(cnt == 0)
            {
                if(dcc[i].size()&amp;gt;1)
                    res+=2,num*=dcc[i].size()*(dcc[i].size()-1)/2;
                else 
                    res++;//孤立点
            }
            else if (cnt == 1)
            {
                res++,num*=dcc[i].size()-1;
            }
        }
         printf(&amp;quot;Case %d: %d %llu\n&amp;quot;, kase++, res, num);
    }
    return 0;
}

acwing368
图片转自@xxh的题解


#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 600010;

int n, m;
int h[N], hs[N], e[M], ne[M], w[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, size[N];
int dist[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    for (int i = 1; i &amp;lt;= n; i ++ ) add(h, 0, i, 1);

    while (m -- )
    {
        int t, a, b;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;t, &amp;amp;a, &amp;amp;b);
        if (t == 1) add(h, b, a, 0), add(h, a, b, 0);
        else if (t == 2) add(h, a, b, 1);
        else if (t == 3) add(h, b, a, 0);
        else if (t == 4) add(h, b, a, 1);
        else add(h, a, b, 0);
    }

    tarjan(0);//从超级源点可到所有点

    bool success = true;
    for (int i = 0; i &amp;lt;= n; i ++ )
    {
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a == b)
            {
                if (w[j] &amp;gt; 0)//只要任意一个SCc里有边权大于0的边，则存在正环
                {
                    success = false;
                    break;
                }
            }
            else 
                add(hs, a, b, w[j]);
        }
        if (!success) 
            break;
    }

    if (!success) puts(&amp;quot;-1&amp;quot;);
    else
    {
        for (int i = scc_cnt; i; i -- )
        {
            //入度为0的点dist为0
            for (int j = hs[i]; ~j; j = ne[j])
            {
                int k = e[j];
                dist[k] = max(dist[k], dist[i] + w[j]);
            }
        }

        LL res = 0;
        for (int i = 1; i &amp;lt;= scc_cnt; i ++ ) 
            res += (LL)dist[i] * size[i];

        printf(&amp;quot;%lld\n&amp;quot;, res);
    }

    return 0;
}

P3627
题意：
在有向图中找一条路径，使得经过的点的点权和最大（每个点可以经过多次，但只有一次对答案的贡献
思路：
首先看见可以重复走路径，那么就想到其实这些路口可以构成一个个强连通分量（因为只要我们能到达一个强连通分量其中某一个点，那么我们就能到达这个强连通分量的其余所有点，根据贪心策略，这样得到的答案保证更优）。那就很容易想到缩点加最长路。
缩点+spfa最长路code
推荐博客：
https://blog.csdn.net/acmmmm/article/details/16361033
https://blog.csdn.net/sentimental_dog/article/details/53790582

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/wu-xiang-tu-you-xiang-tu-de-lian-tong-xing-fu-xi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/qiu-zu-he-shu/">
                        求组合数
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-28</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            组合数的计算
求组合数 I（杨辉三角递推法）
给定 n, m，计算CnmC_n^mCnm​对 109+7 取模的结果。
当 n，m 都比较小的时候且需要频繁地调用组合数的时候,采用 Pascal 公式预处理出所有对a，b对应的CabC_a^bCab​
若只要求一个组合数的话，也可以滚动一下这个数组，节约空间，但同时m这一维要倒着枚举，就像01背包一样。程序如下：
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=2010,mod=1e9+7;
int c[N][N];

int main()
{
    for(int i=0;i&amp;lt;N;i++)
        for(int j=0;j&amp;lt;=i;j++)
            if(!j)
                c[i][j]=1;
            else
                c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    
    int n;
    cin&amp;gt;&amp;gt;n;
    while(n--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        printf(&amp;quot;%d\n&amp;quot;,c[a][b]);
    }
    return 0;
}

滚动数组优化:
#include&amp;lt;iostream&amp;gt;
using namespace std;
int n,m;
long long c[10005];
int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    m=min(m,n-m);
    c[0]=1;
    for (int i=1;i&amp;lt;=n;i++)
    {
        for (int j=m;j&amp;gt;=1;j--)
        {
            c[j]=c[j]+c[j-1];
        }
    }
    cout&amp;lt;&amp;lt;c[m];
}

因为 Cnm=Cnn−mC_n^m=C_n^{n−m}Cnm​=Cnn−m​，所以m可以取m和n-m中小的那一个，以节省时间。但复杂度还是过高，约为O(n2)O(n^2)O(n2)。
求组合数 II（乘法逆元）
这种方法只适用于对答案模一个大质数的情况。
当 n, m &amp;gt; 10000的时候，就不能再使用 O(n^2) 的做法了。需要使用公式：
第一种做法：（费马小定理）
令 fact[n]=n!
fact[0] = 1;
for (int i = 1;i &amp;lt;= n;i ++)
    fact[i] =(LL) fact[i - 1] * i % p;

令分母 k =(LL)fact[m] * fact[n - m] % p
计算 k 模 p 的逆元，即 kp−2k^{p-2}kp−2 MOD p
答案就是(LL)fact[n] *  kp−2k^{p-2}kp−2 MOD p
这样需要一次快速幂，时间复杂度 O(nlog n)
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010,mod=1e9+7;
int fact[N],infact[N];
typedef long long LL;

int qmi(int a,int k,int p)
{
    int res=1;
    while(k)
    {
        if(k&amp;amp;1)
            res=(LL)res*a%p;
        a=(LL)a*a%p;
        k&amp;gt;&amp;gt;=1;
    }
    return res;
}

void init()
{
    fact[0]=infact[0]=1;
    for(int i=1;i&amp;lt;N;i++)
    {
        fact[i]=(LL)fact[i-1]*i%mod;
        infact[i]=qmi(fact[i],mod-2,mod);
    }
}

int main()
{
    init();
    
    int n;
    cin&amp;gt;&amp;gt;n;
    while(n--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        printf(&amp;quot;%d\n&amp;quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod);
    }
    return 0;
}

第二种做法：(递推)
我们先处理每个数关于 p 的逆元 inv[n]。
inv[1] = 1
现在假设我们要求 inv[i]，首先拿 p 除以 i，得到 k，余数是 r。
那么 p = ki + r (r &amp;lt; i, 1 &amp;lt; i &amp;lt; p)
两边都 MOD p，得到 ki + r = 0 (mod p)
ki + r = 0 (mod p)
两边同时乘上 i{-1}r{-1}
得到 kr^{-1} + i^{-1} = 0 (mod p)
i^{-1} = -kr^{-1} (mod p)
k = p / i, r = p % i
由于 r &amp;lt; i，所以算inv[i]的时候，inv[r]显然已经算好了
因此 inv[i] = (-p / i) * inv[p % i]
在处理出了每个数关于 p 的逆元。
for (int i = 2;i &amp;lt;= n;i ++)
    inv[i] = (LL)inv[i - 1] * inv[i] % p;

就可以得到 i! 关于 p 的逆元
此时答案就是
(LL)fact[n] * inv[m] % p * inv[n - m] % p
p一定要是大质数!，起码得大于m。为什么呢？若要求a在模p下的乘法逆元，必须要保证a与p互质。在此题中，要求m!的乘法逆元，那么p必须与m!互质，那么p就要大于m，且是个质数。
求组合数 III（Lucas定理）：
适用于对答案模一个质数的情况。
和上面的乘法逆元求组合数的条件对比一下，只相差了一个大字。也就是说这个质数不用很大，非常小也行。
给定 n, m，计算CnmC_n^mCnm​对 1000003 取模的结果。n, m &amp;lt;= 1e18

code

求组合数 IV（分解质因数）
乘法逆元只能处理模数为大质数的情况，卢卡斯定理只能处理模数为质数的情况，那有没有一种方法能处理模数不是质数的情况呢？显然是有的。而且不取模也是可以的。
我们可以把组合数中要乘或除的每一个数分解质因数，再把分母的质因数减掉，最后把剩下的质因数乘起来，边乘边模p就行了。 （如果需要取模的话）
对于n!包含质因子x个数：fac[x]=n/x+n/x2+……+n/xk(直到n/xk=0结束)。
code
总结
每种算法都有其优点与局限性。递推写起来快，思维简单，但时间复杂度高。乘法逆元用得比较普遍，因为一般都是模一个大质数，复杂度也几乎是线性的。卢卡斯定理只会在特定的题目里做到，但其实编程复杂度并不高，就是在乘法逆元的基础上加几句话。质因数分解的适用性最广，编程复杂度也最高，这就是完美的代价吧。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/qiu-zu-he-shu/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/bei-zeng-st-biao-rmq/">
                        倍增 ST表 RMQ
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-28</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            倍增





ST表


ST表创建



ST表查询


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;//使用log函数
/*log():以e为底的对数，exp(5)=e^5,log(exp(5))=5
  log10():以10为底的对数
  log2():以2为底的对数 
  任何一个其它的对数logm(n)=log(n)/log(m)*/
using namespace std;
const int maxn=105;
int n,a[maxn],F[maxn][maxn];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

void ST_create()
{
	for(int i=1;i&amp;lt;=n;i++)//初始化 
		F[i][0]=a[i];
	int k=log2(n);//log(n)/log(2);
	for(int j=1;j&amp;lt;=k;j++)
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)//n-2^j+1
			F[i][j]=max(F[i][j-1],F[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
}

int ST_query(int l,int r)//求区间[l..r]的最值 
{
	int k=log2(r-l+1);
	return max(F[l][k],F[r-(1&amp;lt;&amp;lt;k)+1][k]);//取两个区间最值 
}

int ST_print()
{
	int k=log2(n);
	for(int j=0;j&amp;lt;=k;j++)
	{	
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)//n-2^j+1,打印第一列 
			cout&amp;lt;&amp;lt;F[i][j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
		cout&amp;lt;&amp;lt;endl;
	}
}

int ST_print2()//按列打印 
{
	int k=log2(n);
	for(int i=1;i&amp;lt;=n;i++)
	{
		for(int j=0;j&amp;lt;=k;j++)
			cout&amp;lt;&amp;lt;F[i][j]&amp;lt;&amp;lt;&#39; &#39;;
		cout&amp;lt;&amp;lt;endl;
	}
}

int main()
{
	int l,r;
	int i,v;
	cin&amp;gt;&amp;gt;n;
	for(i=1;i&amp;lt;=n;i++)
		cin&amp;gt;&amp;gt;a[i];//5 3 7 2 12 1 6 4 8 15
	ST_create();//创建ST表
	ST_print();
	cout&amp;lt;&amp;lt;&amp;quot;输入查询最值的区间l r:&amp;quot;&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;
	cout&amp;lt;&amp;lt;ST_query(l,r)&amp;lt;&amp;lt;endl;//求区间[l..r]的最值
	return 0;
}

例题
poj3264

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;//min,max
#include&amp;lt;cmath&amp;gt;//log
using namespace std;
const int maxn=50010;
int h[maxn];
int Fmax[maxn][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j
int Fmin[maxn][20];
int N,Q;

void ST_create()
{
	for(int i=1;i&amp;lt;=N;i++)//初始化 
		Fmax[i][0]=Fmin[i][0]=h[i];
	int k=log2(N);//log(N)/log(2.0);
	for(int j=1;j&amp;lt;=k;j++)
		for(int i=1;i&amp;lt;=N-(1&amp;lt;&amp;lt;j)+1;i++)//N-2^j+1
		{
			Fmax[i][j]=max(Fmax[i][j-1],Fmax[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
			Fmin[i][j]=min(Fmin[i][j-1],Fmin[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
		}			
}

int RMQ(int l,int r)//求区间[l..r]的最值差 
{
	int k=log2(r-l+1);
	int m1=max(Fmax[l][k],Fmax[r-(1&amp;lt;&amp;lt;k)+1][k]);
	int m2=min(Fmin[l][k],Fmin[r-(1&amp;lt;&amp;lt;k)+1][k]);
	return m1-m2;//取两个区间最值差 
}

int main()
{
	int a,b;
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;Q))
	{
		for(int i=1;i&amp;lt;=N;i++)//下标从1开始 
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i]);
		ST_create();
		for(int j=1;j&amp;lt;=Q;j++)
		{
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
			printf(&amp;quot;%d\n&amp;quot;,RMQ(a,b));
		}
	}
	return 0;
}

poj3368



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int lb[N];		
int f[N][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

int n,Q;
int a[N];

void ST_create()
{	
	for(int j=1;j&amp;lt;=lb[n];j++)
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
			f[i][j]=max(f[i][j-1],f[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);	
}

int RMQ(int l,int r)
{
	if(l &amp;gt; r)
		return 0;
	int k=lb[r-l+1];
	return max(f[l][k],f[r-(1&amp;lt;&amp;lt;k)+1][k]);
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&amp;lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;amp;(i-1));
	while(~scanf(&amp;quot;%d%&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;Q);
		for(int i=1;i&amp;lt;=n;i++)
		{
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
			if(i == 1)
			{
				f[i][0]=1;
				continue;
			}
			if(a[i] == a[i-1])
				f[i][0]=f[i-1][0]+1;
			else 
				f[i][0]=1;
		}
		ST_create();
		for(int j=1;j&amp;lt;=Q;j++)
		{
			int l,r;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l,&amp;amp;r);
			int t=l;
			while(t&amp;lt;=r &amp;amp;&amp;amp; a[t] == a[t-1])
				t++;
			printf(&amp;quot;%d\n&amp;quot;,max(t-l,RMQ(t,r)));
		}
	}
	return 0;
}

hdu3468

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=200010;
int a[N];
int n,k;
int F[N][20],lb[N];

void Initlog()
{
	lb[0]=-1;
    for(int i=1;i&amp;lt;=N;i++)
        lb[i]=lb[i-1]+(i&amp;amp;(i-1)?0:1);
}

void ST()
{
    for(int i=1;i&amp;lt;=n;i++)
		F[i][0]=a[i];
    for(int j=1;j&amp;lt;=lb[n];j++)
        for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
            F[i][j]=max(F[i][j-1],F[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
}

int query(int l,int r)
{
    int k=lb[r-l+1];
    return max(F[l][k],F[r-(1&amp;lt;&amp;lt;k)+1][k]);
}

bool check(int mid)
{
    int t=n/mid,s=0;
    for(int i=0;i&amp;lt;mid;i++)
		s+=query(t*i+1,t*i+t);
    return s&amp;gt;k;
}

int main()
{
    lb[0]=-1;
	for(int i=1;i&amp;lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;amp;(i-1));
	while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k),n&amp;gt;=0||k&amp;gt;=0)
    {
        int sum=0;
        for(int i=1;i&amp;lt;=n;i++)
        {
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
            sum+=a[i];
        }
        if(sum&amp;lt;=k)
		{
			printf(&amp;quot;-1\n&amp;quot;);
			continue;
		}
		ST();
		int l=1,r=n;
		while(l&amp;lt;r)//二分找划分数 
    	{
	        int mid=(l+r)/2;
	        if(check(mid)) r=mid;
	        else l=mid+1;
    	}
		printf(&amp;quot;%d\n&amp;quot;,l);
    }
    return 0;
}

poj2019

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
const int maxn=260,INF=0x3f3f3f3f;
using namespace std;
int a[maxn][maxn],lb[maxn];
int Fmax[maxn][maxn][8],Fmin[maxn][maxn][8];
int n,m,k;

void ST()
{
	for(int k=1;k&amp;lt;=n;k++)//多一维 
        for(int i=1;i&amp;lt;=n;i++)
            Fmax[k][i][0]=Fmin[k][i][0]=a[k][i];	
	for(int k=1;k&amp;lt;=n;k++)
		for(int j=1;j&amp;lt;=lb[n];j++)
			for(int i=1;i+(1&amp;lt;&amp;lt;j)-1&amp;lt;=n;i++)
			{
				Fmax[k][i][j]=max(Fmax[k][i][j-1],Fmax[k][i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
				Fmin[k][i][j]=min(Fmin[k][i][j-1],Fmin[k][i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
			}
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&amp;lt;maxn;i++)
		lb[i]=(i&amp;amp;(i-1))?lb[i-1]:lb[i-1]+1;
	while(~scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k))
	{
		for(int i=1;i&amp;lt;=n;i++)
			for(int j=1;j&amp;lt;=n;j++)
				scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]);	
		ST();
		for(int i=0;i&amp;lt;k;i++)
		{
			int x,y;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
			int k=lb[m];
    		int maxx=-INF;
			int minx=INF;
    		int l=y,r=y+m-1;//从坐标为(x,y)的地方开始，右下扩展B长度 
    		for(int i=x;i&amp;lt;x+m;i++)//查询每一行的最值 
		    {
		        maxx=max(maxx,max(Fmax[i][l][k],Fmax[i][r-(1&amp;lt;&amp;lt;k)+1][k]));
		        minx=min(minx,min(Fmin[i][l][k],Fmin[i][r-(1&amp;lt;&amp;lt;k)+1][k]));
		    }
			printf(&amp;quot;%d\n&amp;quot;,maxx-minx);
		}
	}
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/bei-zeng-st-biao-rmq/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/shu-wei-dp/">
                        数位dp
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-28</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            问题的一般形式是这样的：
定义一个条件 A，比如：被 7 整除、数位中含有 3 等等。
询问区间 [L, R] 中有几个数满足条件 A L 和 R 的范围一般非常大，比如101810^{18}1018
通过数位 DP，我们会发现这些问题的规模实际上是 log10Rlog_{10} Rlog10​R
数位 DP 就是考虑数字的每一位。
问题的规模变为log10Rlog_{10} Rlog10​R
每一位作为不同的阶段，设计状态。
我们从高位往低位依次枚举。
每一位的数选择的范围是不同的，依据前面选的数决定。
acwing1085









#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
int dp[15][15];
int num[15];

void init(){//预处理 
    dp[0][0]=1;
    for(int i=1;i&amp;lt;=9;i++)
        for(int j=0;j&amp;lt;=9;j++){
            if(j==4)
                dp[i][j]=0;
            else
                for(int k=0;k&amp;lt;=9;k++){
                    if(j==6&amp;amp;&amp;amp;k==2)
                        continue;
                    dp[i][j]+=dp[i-1][k];
                }
        }
}

int solve(int x)//求解[1..x]之间满足条件的个数 
{
    int ans=0,cnt=0;
    while(x)
        num[++cnt]=x%10,x/=10;
    num[cnt+1]=0;
    for(int i=cnt;i&amp;gt;=1;i--){//高位向低位计算 
        for(int j=0;j&amp;lt;num[i];j++)
            if(j==4||(j==2&amp;amp;&amp;amp;num[i+1]==6))
            	continue;
            else
				ans+=dp[i][j];
        if(num[i]==4||(num[i]==2&amp;amp;&amp;amp;num[i+1]==6)){
			ans--;//减1，例如4，统计0，1 ，2，3共4个其实只有3个满足（不包括0） 
				 //例如3，统计0，1 ，2共3个满足，0相当于统计了3本身 
            break;
    	}
    }
    return ans;
}

void print(){//输出初始化处理后的dp数组 
	printf(&amp;quot;  j=\t&amp;quot;);
	for(int j=0;j&amp;lt;=9;j++)
		printf(&amp;quot;%-10d&amp;quot;,j);
	printf(&amp;quot;\n&amp;quot;);
	for(int i=1;i&amp;lt;=9;i++){
    	printf(&amp;quot;i=%d\t&amp;quot;,i);
		for(int j=0;j&amp;lt;=9;j++)
			printf(&amp;quot;%-10d&amp;quot;,dp[i][j]);	
		printf(&amp;quot;\n&amp;quot;);
	}
}

int main()
{
    int n,m;
    memset(dp,0,sizeof dp);
    init();//初始化处理 
    //print();//输出dp数组 
    while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;m,&amp;amp;n),n+m){//测试 1 24  62 386
    	//printf(&amp;quot;%d\n&amp;quot;,solve(n));
    	//printf(&amp;quot;%d\n&amp;quot;,solve(m));
        printf(&amp;quot;%d\n&amp;quot;,solve(n)-solve(m-1));
	}
    return 0;
}

记忆化递归












#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
int a[20];
int dp[20][2];
//dp[pos][sta]表示当前第pos位，sta状态下满足条件的个数，sta表示前一位是否是6，只有0和1两种状态
int dfs(int pos,bool sta,bool limit)
{
    if(pos==0) return 1;
    if(!limit&amp;amp;&amp;amp;dp[pos][sta]!=-1) return dp[pos][sta];
    int len=limit?a[pos]:9;
    int ans=0;
    for(int i=0;i&amp;lt;=len;i++)
    {
        if(sta&amp;amp;&amp;amp;i==2)continue;
        if(i==4) continue;//都是保证枚举合法性
        ans+=dfs(pos-1,i==6,limit&amp;amp;&amp;amp;i==len);
    }
    if(!limit) dp[pos][sta]=ans;
    return ans;
}

int solve(int x)//求解[0..x]之间满足条件的个数 
{
    int pos=0;
    while(x){
        a[++pos]=x%10;
        x/=10;
    }
    return dfs(pos,0,1);//如果不包括0，此处减1即可
}

void print(){//输出dp数组 
	printf(&amp;quot;  j=\t&amp;quot;);
	for(int j=0;j&amp;lt;=1;j++)
		printf(&amp;quot;%-10d&amp;quot;,j);
	printf(&amp;quot;\n&amp;quot;);
	for(int i=1;i&amp;lt;=9;i++){
    	printf(&amp;quot;i=%d\t&amp;quot;,i);
		for(int j=0;j&amp;lt;=1;j++)
			printf(&amp;quot;%-10d&amp;quot;,dp[i][j]);	
		printf(&amp;quot;\n&amp;quot;);
	}
}

int main()
{
    int a,b;
    memset(dp,-1,sizeof dp);
    while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b),a+b)//测试24 386 
    {
		//printf(&amp;quot;%d\n&amp;quot;,solve(a));
		//print();
    	//printf(&amp;quot;%d\n&amp;quot;,solve(b));
    	//print();
		printf(&amp;quot;%d\n&amp;quot;,solve(b)-solve(a-1));
    }
    return 0;
}

例题
hdu3555



正向做法
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=20;
LL f[N][2];
LL ten[N];
int num[N];
LL n;

LL dfs(int pos,bool sta,bool limit)
{
	if(pos == 0) return 0;
	if(!limit &amp;amp;&amp;amp; f[pos][sta] != -1)
		return f[pos][sta];
	
	int len=limit?num[pos]:9;
	LL ans=0;
	for(int i=0;i&amp;lt;=len;i++)
	{
		if(sta &amp;amp;&amp;amp; i==9)
			ans+=limit?n%ten[pos-1]+1:ten[pos-1];
		else
			ans+=dfs(pos-1,i==4,limit&amp;amp;&amp;amp;i==len);
	}
	if(!limit)
		f[pos][sta]=ans;
	return ans;
}

LL dp(LL n)//求解[1..x]之间满足条件的个数 
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,1);
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	memset(f,-1,sizeof f);
	ten[0]=1;
	for(int i=1;i&amp;lt;N;i++)
		ten[i]=ten[i-1]*10;
	while(T--)
	{
		scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n);
		printf(&amp;quot;%lld\n&amp;quot;,dp(n));
	}
	return 0;
}

反向做法
#include&amp;lt;cstdio&amp;gt;//求不包含49的个数ans(不包括0)，然后n-ans
#include&amp;lt;cstring&amp;gt;
using namespace std;
typedef long long LL;//注意！！本题数据类型为ll 
const int N=30;
int dig[N];
LL dp[N][2],n;
//dp[pos][sta]表示当前第pos位，sta状态下满足条件的个数，sta表示前一位是否是4，只有0和1两种状态
LL dfs(int pos,bool sta,bool limit)//求不包含49的个数
{
    if(!pos) return 1;//包括0 
    if(!limit&amp;amp;&amp;amp;dp[pos][sta]!=-1) return dp[pos][sta];
    int len=limit?dig[pos]:9;
    LL ans=0;
    for(int i=0;i&amp;lt;=len;i++)
    {
        if(sta&amp;amp;&amp;amp;i==9)
        	continue;
        ans+=dfs(pos-1,i==4,limit&amp;amp;&amp;amp;i==len);
    }
    if(!limit) dp[pos][sta]=ans;
    return ans;
}

LL solve(LL x)//求解[1..x]之间不包含49的个数 
{
    int pos=0;
    while(x){
        dig[++pos]=x%10;
        x/=10;
    }
    return dfs(pos,0,1)-1;//除去0 
}

int main()
{
    memset(dp,-1,sizeof(dp));
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--){
		scanf(&amp;quot;%I64d&amp;quot;,&amp;amp;n);
		printf(&amp;quot;%I64d\n&amp;quot;,n-solve(n));
	}
    return 0;
}

acwing338


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=10;
int f[N][10][N];
int num[N];
int ans1[N];
int ans2[N];

int dfs(int pos,int val,int cnt,bool lead,bool limit)
{
    if(pos == 0) return cnt;
    if(!limit &amp;amp;&amp;amp; !lead &amp;amp;&amp;amp; f[pos][val][cnt] != -1)
        return f[pos][val][cnt];

    int len=limit?num[pos]:9;
    int ans=0,t=0;
    for(int i=0;i&amp;lt;=len;i++)
    {
        if(val != i) t=cnt;
        else 
        {
            if(lead &amp;amp;&amp;amp; val==0)
                t=0;
            else  
                t=cnt+1;
        }
        ans+=dfs(pos-1,val,t,lead&amp;amp;&amp;amp;i==0,limit&amp;amp;&amp;amp;i==len);
    }
    if(!limit &amp;amp;&amp;amp; !lead) f[pos][val][cnt]=ans;
    return ans;
}

void dp(int n,int ans[])
{
    int pos=0;
    while(n)
    {
        num[++pos]=n%10;
        n/=10;
    }

    for(int i=0;i&amp;lt;=9;i++)
        ans[i]=dfs(pos,i,0,1,1);
}

int main()
{
    memset(f,-1,sizeof f);
    int a,b;
    while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b))
    {
        if(!a &amp;amp;&amp;amp; !b) break;
        if(a&amp;gt;b) swap(a,b);
        dp(b,ans1);
        dp(a-1,ans2);
        for(int i=0;i&amp;lt;10;i++)
            printf(&amp;quot;%d &amp;quot;,ans1[i]-ans2[i]);
    }
    return 0;
}

poj3252

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=35;
int f[N][N][N];
int num[N];

int dfs(int pos,int cnt0,int cnt1,bool lead,bool limit)
{
	if(pos == 0) return cnt0&amp;gt;=cnt1;
	if(!limit &amp;amp;&amp;amp; !lead &amp;amp;&amp;amp; f[pos][cnt0][cnt1] != -1)
		return f[pos][cnt0][cnt1];

	int len=limit?num[pos]:1;
	int ans=0;
	for(int i=0;i&amp;lt;=len;i++)
	{
		if(lead &amp;amp;&amp;amp; !i)
			ans+=dfs(pos-1,0,0,1,limit&amp;amp;&amp;amp;i==len);
		else 
			ans+=dfs(pos-1,cnt0+(i==0),cnt1+(i==1),0,limit&amp;amp;&amp;amp;i==len);
	}
	if(!limit &amp;amp;&amp;amp; !lead)
		f[pos][cnt0][cnt1]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%2;
		n/=2;
	}
	
	return dfs(pos,0,0,1,1);
}

int main()
{
	int a,b;
	memset(f,-1,sizeof f);
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b))
		printf(&amp;quot;%d\n&amp;quot;,dp(b)-dp(a-1));
	return 0;
}

hdu4734



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=10,M=4610;
int f[N][M];
int num[N];
int a,b;

int dfs(int pos,int val,bool limit)
{
	if(pos == 0) return val&amp;gt;=0;
	if(val &amp;lt; 0) return 0;
	if(!limit &amp;amp;&amp;amp; f[pos][val] != -1)
		return f[pos][val];
	
	int ans=0;
	int len=limit?num[pos]:9;
	for(int i=0;i&amp;lt;=len;i++)
		ans+=dfs(pos-1,val-i*(1&amp;lt;&amp;lt;pos-1),limit &amp;amp;&amp;amp; i==len);
	if(!limit) f[pos][val]=ans;
	return ans;

}


int F(int n)
{
	int ans=0,len=0;
	while(n)
	{
		ans+=(n%10)*(1&amp;lt;&amp;lt;len);
		len++;
		n/=10;
	}
	return ans;
}

int dp(int n)//求解小于等于f(a)的数的个数 
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,F(a),1);
}

int main()
{
	int T,kas=1;
	cin&amp;gt;&amp;gt;T;
	memset(f,-1,sizeof f);
	while(T--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
		printf(&amp;quot;Case #%d: %d\n&amp;quot;,kas++,dp(b));
	}
	return 0;
}

acwing1081
统计区间内一个数的B进制表示下恰好有k位为1的数的个数
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=35;
int f[N][N];
int num[N];
int k,b;

int dfs(int pos,int cnt,bool limit)
{
    if(cnt &amp;gt; k) return 0;
	if(pos == 0) return cnt==k;
	
	if(f[pos][cnt] != -1 &amp;amp;&amp;amp; !limit) 
		return f[pos][cnt];
	
	int len=limit?num[pos]:1;
	int ans=0;
	for(int i=0;i&amp;lt;=min(len,1);i++)
		if(i) ans+=dfs(pos-1,cnt+1,limit&amp;amp;&amp;amp;i==len);
		else ans+=dfs(pos-1,cnt,limit&amp;amp;&amp;amp;i==len);

	if(!limit) f[pos][cnt]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n) num[++pos]=n%b,n/=b;
	
	return dfs(pos,0,1);
}

int main()
{
	int l,r;
	memset(f,-1,sizeof f);
	scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;l,&amp;amp;r,&amp;amp;k,&amp;amp;b);
	
	printf(&amp;quot;%d\n&amp;quot;,dp(r)-dp(l-1));
	return 0;
}

acwing1082
统计区间内不下降数的个数
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=15;
int f[N][10];
int num[N];

int dfs(int pos,int last,bool limit)
{
	if(pos ==0) return 1;
	if(f[pos][last] != -1 &amp;amp;&amp;amp; !limit)
		return f[pos][last];

	int ans=0;
	int len=limit?num[pos]:9;
	for(int i=0;i&amp;lt;=len;i++)
	{
		if(i&amp;lt;last) continue;
		ans+=dfs(pos-1,i,limit&amp;amp;&amp;amp;i==len);
	}
	
	if(!limit) f[pos][last]=ans;
	return ans;
	
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,1);
}

int main()
{
	int a,b;
	memset(f,-1,sizeof f);
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b))
		printf(&amp;quot;%d\n&amp;quot;,dp(b)-dp(a-1));
	
	return 0;
}

P4127
询问 [L,R] 中各位数字之和能整除原数的个数。1 ≤ L ≤ R ≤ 1e18
思路
可以发现各位数之和最大只能是 9 * 18 = 162
我们可以枚举这个和 sum
然后去统计可以被 sum 整除，且数位和是 sum 的数。
我们把状态定义为 f[dep][cur][mod]
表示当前枚举第 dep 位，目前这个数的数位和是 cur，对
sum 取模是 mod.
cur = sum 且 mod = 0 的个数要统计进答案
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=20,M=170;
LL f[N][M][M];
int num[N];
LL a,b;
LL sum;

LL dfs(int pos,int val,int mod,bool limit)//val为当前各位数字之和 
{
	if(pos == 0) return val==sum &amp;amp;&amp;amp; mod==0;
	if(val &amp;gt; sum) return 0;
	
	if(!limit &amp;amp;&amp;amp; f[pos][val][mod] != -1)
		return f[pos][val][mod];
	
	int len=limit?num[pos]:9;
	LL ans=0;
	for(int i=0;i&amp;lt;=len;i++)
		ans+=dfs(pos-1,val+i,(mod*10+i)%sum,limit&amp;amp;&amp;amp;i==len);
	
	if(!limit) f[pos][val][mod]=ans;
	return ans;
}

LL dp(LL n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	LL res=0;
	for(int i=1;i&amp;lt;=pos*9;i++)//枚举各位之和
	{
		memset(f,-1,sizeof f);
		sum=i;
		res+=dfs(pos,0,0,1);
	}
	
	return res;
}

int main()
{
	cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	cout&amp;lt;&amp;lt;dp(b)-dp(a-1)&amp;lt;&amp;lt;endl;
	
	return 0;
}

acwing1083
求区间内任意相邻位上的数字之差的绝对值大于等于二的数的个数
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=11;
int f[N][10];
int num[N];

int dfs(int pos,int val,bool lead,bool limit)
{
	if(pos == 0) return 1;
	if(!limit &amp;amp;&amp;amp; !lead &amp;amp;&amp;amp; f[pos][val] != -1)
		return f[pos][val];
	
	int len=limit?num[pos]:9;
	int ans=0;
	for(int i=0;i&amp;lt;=len;i++)
	{
		if(lead || abs(i-val) &amp;gt;= 2)//如果包含前导零不能让i与之做差，直接让i成为下一位即可
			ans+=dfs(pos-1,i,lead&amp;amp;&amp;amp;i==0,limit&amp;amp;&amp;amp;i==len);
	}
	
	if(!limit &amp;amp;&amp;amp; !lead) f[pos][val]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,-2,1,1);
}

int main()
{
	memset(f,-1,sizeof f);
	int a,b;
	cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	cout&amp;lt;&amp;lt;dp(b)-dp(a-1)&amp;lt;&amp;lt;endl;
	return 0;
}

acwing1084
求区间内各位数字之和mod N为0的数的个数
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=11,M=110;
int f[N][M];
int num[N];
int a,b,mod;

int dfs(int pos,int val,bool limit)
{
	if(pos == 0) return val == 0;
	if(!limit &amp;amp;&amp;amp; f[pos][val] != -1)
		return f[pos][val];
	
	int len=limit?num[pos]:9;
	int ans=0;
	for(int i=0;i&amp;lt;=len;i++)
		ans+=dfs(pos-1,(val+i)%mod,limit&amp;amp;&amp;amp;i==len);
	
	if(!limit) f[pos][val]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,1);
}

int main()
{
	while(~scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;mod))
	{
		memset(f,-1,sizeof f);
		printf(&amp;quot;%d\n&amp;quot;,dp(b)-dp(a-1));
	}
	return 0;
}

hdu3709




#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
typedef long long LL;
using namespace std;
const int N=20,M=2000;
LL f[N][N][M];
int num[N];

LL dfs(int pos,int val,int sum,bool limit)
{
	if(pos == 0) return sum==0;
	if(sum&amp;lt;0) return 0;
	if(!limit &amp;amp;&amp;amp; f[pos][val][sum] != -1)
		return f[pos][val][sum];
	
	int len=limit?num[pos]:9;
	LL ans=0;
	for(int i=0;i&amp;lt;=len;i++)
		ans+=dfs(pos-1,val,sum+(pos-val)*i,limit&amp;amp;&amp;amp;i==len);
	
	if(!limit) f[pos][val][sum]=ans;
	return ans;
}

LL dp(LL n)
{
	if(n&amp;lt;0) return 0;
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	LL ans=0;
	for(int i=1;i&amp;lt;=pos;i++)
		ans+=dfs(pos,i,0,1);
	return ans-pos+1;//pos次循环统计了pos次0，应减去多算的pos-1个0的出现次数
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	memset(f,-1,sizeof f);
	while(T--)
	{
		LL a,b;
		scanf(&amp;quot;%lld%lld&amp;quot;,&amp;amp;a,&amp;amp;b);
		printf(&amp;quot;%lld\n&amp;quot;,dp(b)-dp(a-1));
	}
	return 0;
}

hdu4507
如果一个整数符合下面3个条件之一，那么我们说这个整数和7有关：
整数中某一位是7
整数的每一位加起来的和是7的整数倍
这个整数是7的整数倍
询问[L,R]中与7无关的数字的平方和，模1e9+7.1≤L≤R≤1e18
为了转移需要维护三个值：
cnt 和 7 有关的数的个数
sum 和 7 有关的数的和
sqr 和 7 有关的数的平方和

因此对于所有回溯上来的数x1,x2,x3..xn，你得知道与7无关的数的个数（对应n个d2d^2d2的和），
与7有关的数之和（对应2d(x1+x2+...+xn），与7有关的数的平方和（对应x12+x22+...+xn2x_1^2+x_2^2+...+x_n^2x12​+x22​+...+xn2​）
假设当前状态是 f，从 g 状态转移过来（dfs回溯上来）
f.cnt += g.cnt
f.sum += g.sum + d * g.cnt
f.sqr += d * d * g.cnt + 2 * d * g.sum + g.sqr
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
typedef long long LL;
using namespace std;
const int N=20,mod=1e9+7;
struct Node
{
	LL cnt;
	LL sum;
	LL sqr;
}f[N][7][7];//分别表示数位，各位和%7，数本身%7 
int num[N];
LL ten[N];

Node dfs(int pos,int val,int sum,bool limit)
{
	if(pos == 0)
	{
		Node t;
		t.cnt= val&amp;gt;0 &amp;amp;&amp;amp; sum&amp;gt;0;
		t.sum=0;
		t.sqr=0;
		return t;
	}
	if(!limit &amp;amp;&amp;amp; f[pos][val][sum].cnt != -1)
		return f[pos][val][sum];
	
	int len=limit?num[pos]:9;
	Node ans;
	ans.cnt=ans.sum=ans.sqr=0;
	for(int i=0;i&amp;lt;=len;i++)
	{
		if(i == 7) continue;
		LL d=i*ten[pos-1]%mod;
		Node t=dfs(pos-1,(val+i)%7,(sum*10+i)%7,limit&amp;amp;&amp;amp;i==len);
		ans.cnt=(ans.cnt+t.cnt)%mod;
		ans.sum=(ans.sum+t.sum+d*t.cnt%mod)%mod;
		ans.sqr=(ans.sqr+t.sqr+d*d%mod*t.cnt%mod+2*d%mod*t.sum%mod)%mod;
	}
	
	if(!limit) f[pos][val][sum]=ans;
	return ans;
}

int dp(LL n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,0,1).sqr;
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	memset(f,-1,sizeof f);
	ten[0]=1;
	for(int i=1;i&amp;lt;N;i++)
		ten[i]=ten[i-1]*10%mod;

	while(T--)
	{
		LL a,b;
		scanf(&amp;quot;%lld%lld&amp;quot;,&amp;amp;a,&amp;amp;b);
		printf(&amp;quot;%d\n&amp;quot;,((dp(b)-dp(a-1))%mod+mod)%mod);
	}
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/shu-wei-dp/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/">
                        字符串复习（二）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-27</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Manacher
回文串:对于一个长度为 n 的字符串 str，如果它正着读和反着读一样，即 str[i] = str[n - i + 1] (1 &amp;lt;= i &amp;lt; n - i + 1),如 aba，acbbca 就是回文串，abc，abab 就不是回文串。
Manacher 算法可以求出以每个位置为中心，向两边能扩展的最长回文子串长度 p[i]，它的时间复杂度是 O(n) 的。
注意到回文子串的长度可能是偶数， 如 abba，中心不是某个字符（中心是两个 b 之间的空隙），所以先要在相邻的
字符中插入一个标识符，例如 #,这样例如 #a#b#b#a# 的中心就是 # 了。
我们用 abbabcba 来举例。
先插入 # 得到 #a#b#b#a#b#c#b#a#。
然后用 Manacher 可以得到如下的 p 数组。
对于每个 p[i]，一定有 str[i + j] == str[i - j] (1 ≤ j &amp;lt; p[i])

类比 Z 算法，我们也维护一个 mx 和 id，表示对于当前计算的所有 i，i + p[i] 的最大值是 mx，mx 对应的 i 记为id。
当你现在开始计算 p[i] 时，默认 p[1..i-1] 都已经算出。

计算最长回文子串长度
以字符串&amp;quot;cabbaf&amp;quot;为例，将预处理后的新字符串&amp;quot;#c#a#b#b#a#f#&amp;quot;变成一个字符数组arr，定义一个辅助数组int[] p，p的长度与arr等长，p[i]表示以arr[i]字符为中心的最长回文半径，p[i]=1表示只有arr[i]字符本身是回文子串。
i       0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i]  # c # a # b # b # a #  f  #
p[i]    1 2 1 2 1 2 5 2 1 2 1  2  1

我们来比对分下一下最长回文半径和原字符串之间的关系。在上面例子中，最长回文子串是&amp;quot;#a#b#b#a#&amp;quot;，它以arr[6]为中心，半径是5，其代表的原始字符串是&amp;quot;abba&amp;quot;，而&amp;quot;abba&amp;quot;的长度为4，可以通过5减去1得到，是字符串&amp;quot;cabbaf&amp;quot;中的最长回文子串，那么我们是不是可以得出最长回文半径和最长回文子串长度之间的关系？
让我们再多看几个例子，如&amp;quot;aba&amp;quot;，转换后是&amp;quot;#a#b#a#&amp;quot;，以字符&#39;b&#39;为中心的回文，半径是4，减1得到3，3是原字符串的最长回文子串长度。
再例如&amp;quot;effe&amp;quot;，转换后是&amp;quot;#e#f#f#e#&amp;quot;，以最中间的&#39;#&#39;为中心的回文，半径是5，减1得到4，4是原字符串的最长回文子串长度。
因此，最后我们得到最长回文半径和最长回文子串长度之间的关系：int maxLength = p[i]-1。maxLength表示最长回文子串长度。
计算最长回文子串起始索引
知道了最长回文子串的长度，我们还需要知道它的起始索引值，这样才能截取出完整的最长回文子串。
继续以第三步中的字符串&amp;quot;cabbaf&amp;quot;为例，p[6]=5，是最长半径，用6(i)减去最长半径5(p[i])得到1，而1恰好是最长回文子串&amp;quot;abba&amp;quot;的起始索引。
我们再来看一个奇回文的例子。例如&amp;quot;aba&amp;quot;，转换后是&amp;quot;#a#b#a#&amp;quot;，p[3]=4，最长半径是4，i为3，用i减去4得到-1，数组下标越界了。
在偶回文的情况下，可以满足i减最长半径，而奇回文却会下标越界，我们需要在转换后的字符串前面再加一个字符，解决下标越界的问题，不能是&#39;#&#39;，那就加个&#39;$&#39;字符吧，但是加过一个字符后，字符串的长度不是奇数了，只能在尾部再加一个不会重复出现的字符，比如&#39;@&#39;(也可不加，因为字符串结尾为&#39;\0&#39;)，这样字符串的长度依旧是奇数了，满足前面第三部分的条件。
加多一个字符后，奇回文可以正常做减法了，偶回文呢？
i       0 1 2 3 4 5 6 7 8 9 10 11 12 13
arr[i]  $ # c # a # b # b # a  #  f  #
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1

在补上字符&#39;$&#39;后，p[7]=5，用i减去最长半径，7-5=2，而理想的结果应该是1，那就再除以2吧，这样就能得到1了。而奇回文&amp;quot;aba&amp;quot;在用i减去最长半径后得到的是0，除以2后还是0，可以完美解决下标越界的问题。
结论：最长回文子串的起始索引int index = (i - p[i])/2。
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=11000010;
char s[N];
charma[N&amp;lt;&amp;lt;1];
int p[N&amp;lt;&amp;lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i]&amp;gt;mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s))
	{
		int len=strlen(s);
		manacher(s,len);
		int ans=0;
		for(int i=0;i&amp;lt;2*len+2;i++)
			ans=max(ans,p[i]-1);
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

Codeforces 17E
给出一个字符串 s。 求 s 有多少对相交的回文子串。包含也算作相交。
如 babb 一共有 6 对相交的回文子串：
s[1..1] and s[1..3]
s[1..3] and s[2..2]
s[1..3] and s[3..3]
s[1..3] and s[3..4]
s[3..3] and s[3..4]
s[3..4] and s[4..4]
|s| ≤ 2·e6
正难则反
统计不相交的回文子串对数。
不相交的回文子串假设端点分别为 x1,y1,x2,y2
那么一定有 x1 &amp;lt;= y1 &amp;lt; x2 &amp;lt;= y2
我们只要统计出以 i 为起点的回文串个数 st[i]，和以 i为终点的回文串个数 ed[i]。
然后计算

在使用 manacher 算法的时候，对每个 i 都计算出了 p[i]
那么我们就要把[i-p[i], i+p[i]] 这个极大回文子串对 st和 ed 的贡献算进去。
对于 st: [i-p[i]+1, i] 这些点每个位置都要 +1
对于 ed：[i, i+p[i]-1] 这些点每个位置都要 +1
只需要通过差分转化为单点修改即可。
最后用总的回文子串对数减去不相交的回文子串对数即是答案
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=2e6+10,mod=51123987;
char s[N];
int p[N&amp;lt;&amp;lt;1];
int n;
char ma[N&amp;lt;&amp;lt;1];
int l[N&amp;lt;&amp;lt;1],r[N&amp;lt;&amp;lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,s);
	manacher(s,n);
	n=n*2+2;
	
	int ans=0;
	for(int i=0;i&amp;lt;n;i++)
	{
		l[i-p[i]+1]++,l[i+1]--;
		r[i]++,r[i+p[i]]--;
		ans=(ans+p[i]/2)%mod;
	}
	ans=(LL)ans*(ans-1)/2%mod;
	
	int sum=0;
	for(int i=1;i&amp;lt;n;i++)
	{
		l[i]+=l[i-1];r[i]+=r[i-1];
		if(i&amp;amp;1) continue;
		ans=(ans-(LL)sum*l[i]%mod+mod)%mod;
		sum=(sum+r[i])%mod;
	}
	printf(&amp;quot;%d&amp;quot;,ans);
}

BZOJ 2565
定义双回文串 T，满足存在 T = ab，其中 a 和 b 都是回文串。
给定字符串 S，求一个 S 的最长的双回文子串 T。
|S| ≤ 1e6

Lmax是一个点往左扩展，越靠右越可能长，所以做逆推；Rmax是一个点往右扩展，越靠左越可能长，所以做顺推。递推式子见代码。处理好之后扫一遍就出解了。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
int n;
int l[N*2],r[N*2],p[N*2];
char ma[N*2],a[N];

void manacher(char *s,int len)
{
    int k=0;
    ma[k++]=&#39;$&#39;;
    ma[k++]=&#39;#&#39;;
    for(int i=0;i&amp;lt;len;i++)
    {
        ma[k++]=s[i];
        ma[k++]=&#39;#&#39;;
    }
    ma[k]=0;
    int mx=0,id=0;
    for(int i=0;i&amp;lt;k;i++)
    {
        if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]] == ma[i-p[i]])
            p[i]++;
        if(i+p[i]&amp;gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
        l[i+p[i]-1]=max(l[i+p[i]-1],p[i]-1);
        //cout&amp;lt;&amp;lt;l[i+p[i]-1]&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;p[i]-1&amp;lt;&amp;lt;endl;
        r[i-p[i]+1]=max(r[i-p[i]+1],p[i]-1);
        //cout&amp;lt;&amp;lt;r[i-p[i]+1]&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;p[i]-1&amp;lt;&amp;lt;endl;
    }
}

 
int main()
{
	scanf(&amp;quot;%s&amp;quot;,a);
	
	int n=strlen(a);
	manacher(a,n);
	n=n*2+2;
	
	for(int i=1;i&amp;lt;n;i+=2) r[i]=max(r[i],r[i-2]-2);
	for(int i=n-1;i&amp;gt;=1;i-=2) l[i]=max(l[i],l[i+2]-2);
	
	int ans=0;
	for(int i=1;i&amp;lt;n;i++) 
		if(l[i] &amp;amp;&amp;amp; r[i])
			ans=max(ans,l[i]+r[i]);
	cout&amp;lt;&amp;lt;ans;
	
	return 0;
}

bzoj4755
有两个长度均为 N 的字符串 A 和 B。
扭动的字符串 S(i,j,k) 定义为 A[i..j]+B[j..k] 若 A=’xyz’, B=‘uvw’, 则 S(1,2,3)=‘xyvw’
定义扭动的回文串为如下情况中的一个；
A 中的一个回文串
B 中的一个回文串
某一个回文的扭动字符串S(i,j,k)
求最长的扭动回文串
1≤N≤100000，字符串只含大写字母

样例：
5
ABCDE
BAECB
答案：
5
最长的扭动回文串是 S(2,3,5) = BCECB
对于前两种情况，我们只需要用 manacher 算法求出每个位置的回文扩展半径，然后取一个最大值即可。
对于第三种情况，需要在两个字符串中各取一段拼起来。
我们可以把答案字符串分解为 STS’
其中 S’ 是 S 的反串，T 是回文串。
可以发现一定是 S 在一个串，TS’ 在另一个串；或者 ST 在一个串，S’在另一个串。
且T 一定是极大的回文子串。
那么我们只要枚举极大回文子串 T 即可。
假设中心在 A 中，枚举中心 i。
(1)假设A[i-p[i], i+p[i]] 是极大回文子串。
枚举 A[i+p[i]+1..n] 的前缀和 B[1..i-p[i]] 的后缀最长能匹配上多少。
(2)假设B[i-p[i], i+p[i]] 是极大回文子串。
枚举 A[1..i-p[i]-1] 的后缀 和 B[i + p[i]..n] 的前缀最长能匹配上多少。
这两部分的最大值 * 2 + 极大回文子串的长度就是答案了。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N=100010,M=N&amp;lt;&amp;lt;1,P=131;
char a[N],b[N];
char ma[M];
int pa[M],pb[M];
int n;
ULL ha[N],hb[N],p[N];
int ans;

ULL getha(int l,int r)
{
	return ha[r]-ha[l-1]*p[r-l+1];
}

ULL gethb(int l,int r)
{
	return hb[l]-hb[r+1]*p[r-l+1];
}

void manacher(char *s,int len,int p[])
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=1;i&amp;lt;=len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l++]=0;
	
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx &amp;gt; i) p[i]=min(p[2*id-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}	
}

int search(int L,int R)
{
	int l=0,r=min(L,n-R+1);
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(getha(L-mid+1,L) == gethb(R,R+mid-1))
			l=mid;
		else 
			r=mid-1;
	}
	return l;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,a+1);
	scanf(&amp;quot;%s&amp;quot;,b+1);
	
	p[0]=1;
	for(int i=1;i&amp;lt;=n;i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&amp;lt;=n;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=n;i&amp;gt;=1;i--)
		hb[i]=hb[i+1]*P+b[i];
	
	manacher(a,n,pa);
	manacher(b,n,pb);
	n=n*2+1;
	for(int i=1;i&amp;lt;=n;i++) ans=max(ans,pa[i]-1);
	for(int i=1;i&amp;lt;=n;i++) ans=max(ans,pb[i]-1);
	for(int i=1;i&amp;lt;=n;i++)
	{
		int l=(i-pa[i])/2+1,r=(i+pa[i])/2-1;//下标从1开始
		if(l&amp;lt;=r)
			ans=max(ans,pa[i]-1+search(l-1,r)*2);
	}
	for(int i=1;i&amp;lt;=n;i++)
	{
		int l=(i-pb[i])/2+1,r=(i+pb[i])/2-1;
		if(l&amp;lt;=r)
			ans=max(ans,pb[i]-1+search(l,r+1)*2);
	}
	printf(&amp;quot;%d&amp;quot;,ans);
	return 0;
}

SP7586
求一个串中包含几个回文串
用马拉车求出以每个字母为对称轴的回文串长度，因为一个回文串长度/2就是这个回文串包含的子回文串长度，所以最后统计一下即可
代码
BZOJ 2084 Antisymmetry
给定一个长度为 n 的01串，问有多少个子串满足翻转并取反后和原来一样。
比如0101翻转并取反后还是和原来一样。
只要定义 0 = 1， 0 ≠ 0，1 ≠ 1 即可。跑一遍 Manacher 即可。
以 0/1 扩展的 p[i] 一定是 0 （即没有奇数长度的合法子串）
以 # 扩展的累加起来即可
接下来我们来考虑如果我们确定了一个中心后，向外扩展出一个最大可能的反对称串，那么这个串中一定含有len/2个满足条件的串，其中len为串长，因为要想大的满足条件，则在里面的小串必须满足是反对称的
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=500010;
char s[N];
char ma[N&amp;lt;&amp;lt;1];
int p[N&amp;lt;&amp;lt;1];
int n;

void manacher(char *s,int len)
{
    int l=0;
    ma[l++]=&#39;$&#39;;
    ma[l++]=&#39;#&#39;;
    for(int i=0;i&amp;lt;len;i++)
    {
        ma[l++]=s[i];
        ma[l++]=&#39;#&#39;;
    }
    ma[l]=0;
    int mx=0,id=0;
    for(int i=1;i&amp;lt;l;i+=2)
    {
        if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]]-&#39;0&#39;+ma[i-p[i]]-&#39;0&#39;==1 || (ma[i+p[i]]==ma[i-p[i]] &amp;amp;&amp;amp; ma[i+p[i]]==&#39;#&#39;))
            p[i]++;
        if(i+p[i]&amp;gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
    }
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,s);
    manacher(s,n);
    long long ans=0;
    for(int i=1;i&amp;lt;n*2+2;i+=2)
    	ans+=p[i]/2;
	
    printf(&amp;quot;%lld\n&amp;quot;,ans);
    return 0;
}

BZOJ 3790
母亲节就要到了，小 H 准备送给她一个特殊的项链。这个项链可以看作一个用小写字母组成的字符串，每个小写字母表示一种颜色。为了制作这个项链，小 H 购买了两个机器。第一个机器可以生成所有形式的回文串，第二个机器可以把两个回文串连接起来，而且第二个机器还有一个特殊的性质：假如一个字符串的后缀和一个字符串的前缀是完全相同的，那么可以将这个重复部分重叠。
例如：aba和aca连接起来，可以生成串abaaca或 abaca。现在给出目标项链的样式，询问你需要使用第二个机器多少次才能生成这个特殊的项链。

样例：
abcdcba （答案：0）
abacada （答案：2）
abcdef （答案：5）
题目的意思就是用尽可能少的回文子串去覆盖原串。
我们可以先跑一遍 Manacher 算法得到每个位置的覆盖半径。
问题转化为了有许多个区间 [i-p[i], i+p[i]]，要选出尽可能少的区间来覆盖 [1, n] 区间
贪心即可。
对所有的区间按照左端点从小到大排序。
每次都选右端点最远的那个区间。
设当前覆盖到的右端点为 right。
每次找出左端点在[1, right] 中的右端点的最大的那个线段，再做一次覆盖。
时间复杂度 O(n log n)

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=50010,M=N&amp;lt;&amp;lt;1;
char s[N],ma[M];
int p[M];
struct Node
{
	int l,r;
	bool operator&amp;lt;(const Node &amp;amp;W) const
	{
		return l&amp;lt;W.l;
	}
}e[M];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
		e[i].l=i-p[i]+1,e[i].r=i+p[i]-1;
	}
}

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s))
	{
		int n=strlen(s);
		manacher(s,n);
		
		n=n*2+1;
		sort(e+1,e+n+1);
		
		int st=1,j=1,ed=n;
		int res=0;
		
		while(st &amp;lt; ed)
		{
			int r=0;
			while(j &amp;lt;= n &amp;amp;&amp;amp; e[j].l &amp;lt;= st)
				r=max(r,e[j].r),j++;
			
			st=r;
			res++;
		}
		printf(&amp;quot;%d\n&amp;quot;,res-1);
	}
}

trie





void insert(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-&#39;a&#39;;
        if(!trie[p][k])
            trie[p][k]=++idx;
        p=trie[p][k];
    }
    cnt[p]=true;
}


int query(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-&#39;a&#39;;
        p=trie[p][k];
        if(!p)
            return 0;
    }
    return cnt[p];
}

模板题





例题
poj2503
您刚从滑铁卢搬到大城市。 这里的人说的是一门不可理解的外语。 幸运的是，您有一本字典来帮助您理解它们。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;sstream&amp;gt;
using namespace std;
const int N=1000010,M=26;
int trie[N][M];
int cnt[N],idx=1;
char word[N][15];

void insert(string str,int k)
{
	int len=str.size(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=str[i]-&#39;a&#39;;
		if(!trie[p][ch])
			trie[p][ch]=++idx;
		p=trie[p][ch];
	}
	cnt[p]=k;
}

int query(string str)
{
	int len=str.size(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=str[i]-&#39;a&#39;;
		p=trie[p][k];
		if(!p)
			return 0;
	}
	return cnt[p];
}

int main()
{
	string s,str;
	int k=1;
	while(getline(cin,s))
	{
		if(s.empty())
			break;
		stringstream ss(s);
		ss&amp;gt;&amp;gt;word[k]&amp;gt;&amp;gt;str;
		insert(str,k);
		k++;
	}
	
	while(cin&amp;gt;&amp;gt;s)
	{
		int k=query(s);
		if(k)
			cout&amp;lt;&amp;lt;word[k]&amp;lt;&amp;lt;endl;
		else 
			cout&amp;lt;&amp;lt;&amp;quot;eh&amp;quot;&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj3630

给定一个电话号码列表，判断它是否一致，即没有号码是另一个号码的前缀。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;sstream&amp;gt;
using namespace std;
const int N=100010,M=10;
int trie[N][M];
bool cnt[N];
int idx;
int n;

bool insert(char *s)
{
	int p=1;
	int len=strlen(s);
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=s[i]-&#39;0&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		else if(i == len-1)//字符串处理完毕，仍不空，说明该串是其它串的前缀 
			return true;
		p=trie[p][k];
		if(cnt[p])//其他串是该串前缀 
			return true;
	}
	cnt[p]=true;
	return false;
}

int main()
{
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		idx=1;
		bool ans=false;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i=1;i&amp;lt;=n;i++)
		{
			char s[15];
			scanf(&amp;quot;%s&amp;quot;,s);
			if(ans)
				continue;
			if(insert(s))//不能立即结束，仍要读取n个串 
				ans=true;
		}
		if(ans)
			cout&amp;lt;&amp;lt;&amp;quot;NO&amp;quot;&amp;lt;&amp;lt;endl;//有前缀输出NO 
		else
			cout&amp;lt;&amp;lt;&amp;quot;YES&amp;quot;&amp;lt;&amp;lt;endl;
	}
	return 0;
}

hdu1251
Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=500005;
const int maxz=26;//不同字符个数，例如数字10，小写字母26
int trie[maxn][maxz];
int cnt[maxn];//计数器 
void insert(string s)//将字符串s插入到字典树中 
{
	int len=s.length(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=s[i]-&#39;a&#39;;//转换成数字
		if(!trie[p][ch]) 
			trie[p][ch]=++tot;//记录下标 
		p=trie[p][ch];
		cnt[p]++;//统计有多少个单词经过 
	}
}

int query(string s)
{
	int len=s.length(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=s[i]-&#39;a&#39;;//转换成数字
		p=trie[p][ch];
		if(!p)
			return 0;
	}
	return cnt[p];	
}

int main()
{	
	string s;
	memset(trie,0,sizeof(trie));
	memset(cnt,0,sizeof(cnt));
	tot=1;
	while(getline(cin,s))
	{
		if(!s.size())
			break;
		insert(s);
	}
	while(cin&amp;gt;&amp;gt;s)
		cout&amp;lt;&amp;lt;query(s)&amp;lt;&amp;lt;endl;
	return 0;
}

若反过来问，单词表中有多少单词是当前查询单词的前缀，只需统计查询时经过的end标记数量即可。
poj2513
给你一堆木棍。 每个棍子的每个端点都带有某种颜色。是否可以将操纵杆沿一条直线对齐，以使触摸的端点的颜色具有相同的颜色？


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=500010,M=26;
int trie[N][M];
int cnt[N];
int d[N];
int idx=1;
int color;
int p[N];

int find(int x)
{
	if(x != p[x])
		p[x]=find(p[x]);
	return p[x];
}

int insert(char *s)
{
	int len=strlen(s),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=s[i]-&#39;a&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	if(cnt[p])
		return cnt[p];
	else 
	{
	    cnt[p]=++color;
	    return cnt[p];
	}
}

int main()
{
	for(int i=1;i&amp;lt;N;i++)
		p[i]=i;
	char a[15],b[15];
	while(~scanf(&amp;quot;%s%s&amp;quot;,a,b))
	{
		int i=insert(a);
		int j=insert(b);
		d[i]++;
		d[j]++;
		//cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
		int pi=find(i);
		int pj=find(j);
		p[pi]=pj;
	}
	
	int s=find(1);
	int num=0;
	for(int i=1;i&amp;lt;=color;i++)
	{
		if(d[i] % 2 == 1)
			num++;
		if(num &amp;gt; 2 || find(i) != s)
 		{
 			puts(&amp;quot;Impossible&amp;quot;);
			return 0;
		}
 	}
	if(num == 0 || num == 2)
		puts(&amp;quot;Possible&amp;quot;);
	else 
		puts(&amp;quot;Impossible&amp;quot;);
	return 0;
}

poj3764
给出n个节点的树，每条边有边权w。 • 请你找一条路径，使得这条路径上所有边权的异或和最大。
• 数据范围
• n &amp;lt;= 100,000, 0 &amp;lt; w &amp;lt; 2^31
暴力的做法：
• 枚举每个点当根
• dfs整颗树，获得根到每个节点的路径异或和s[]
• 时间复杂度O(n^2)
异或的性质
x xor x = 0
• 一个数异或两次会抵消掉。
• x到y的路径异或和就等于s[x] xor s[y] !

这样只要任取一个点为根，dfs得到s[]数组后，枚举x， y即可，还是O(n^2)
现在的问题是，给定一个s[]数组，找两个元素，使得他
们的异或和最大。
• 给一个数x，在数组s中找一个数y使其和x的异或和最大。
• 涉及二进制的题，我们可以选择按位来考虑。
假设x的二进制有31位，我们把它的二进制写出来，最高位称为第30位，最低位称为第0位。
因为要让异或值最大，所以我们从高位开始考虑。
• 如果x的第30位是1 —— if (x &amp;gt;&amp;gt; 30 &amp;amp; 1)
• 那我们一定希望y的第30位是0，这样异或之后的第30位 是1.
• 否则就算第29～0位异或后都是1，也比2^30小。
• 同理，如果x的第30位是0，我们希望y的第30位是1.
运用贪心的思想，假设现在枚举到x的第i位
• if x第i位是1 我们要尽可能找第i位为0的y
• if x第i位是0 我们要尽可能找第i位为1的y
涉及前缀判断，采用trie
先把所有的数的二进制当作字符串，存进trie中。
• 从高往低枚举二进制位时，设置一个指针p，一开始指向trie的根节点。
• if x第i位是1 我们要尽可能找第i位为0的y 如果说明存在第i位为0的数，我们就让p往0节点走，答案中的第i位为1。
• 如果不存在第i位为0的数，我们只能退而求其次，让p往1节点走，答案中的第i位为0.
• if x第i位是0 我们要尽可能找第i位为1的y ， 同理
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010*31,M=N&amp;lt;&amp;lt;1;
int trie[N][2],tot=1;
int d[N];
int n;
int h[N],e[M],ne[M],w[M],idx;

void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j == fa)
			continue;
		d[j]=d[u]^w[i];
		dfs(j,u);
	}
}

void insert(int x)
{
	int p=1;
	for(int i=30;i&amp;gt;=0;i--)
	{
		int u=x&amp;gt;&amp;gt;i&amp;amp;1;
		if(!trie[p][u])
			trie[p][u]=++tot;
		p=trie[p][u];
	}
}

int query(int x)
{
	int p=1;
	int res=0;
	for(int i=30;i&amp;gt;=0;i--)
	{
		int k=x&amp;gt;&amp;gt;i&amp;amp;1;
		if(trie[p][!k])
		{
			res+=1&amp;lt;&amp;lt;i;
			p=trie[p][!k];
		}	
		else 
			p=trie[p][k];
	}
	return res;
}

int main()
{
	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n))
	{
		memset(h,-1,sizeof h);
		memset(d,0,sizeof d);
		memset(trie,0,sizeof trie);
		idx=0;
		tot=1;
		for(int i=0;i&amp;lt;n-1;i++)
		{
			int a,b,c;
			scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);
			a++,b++;
			add(a,b,c);add(b,a,c);
		}
		dfs(1,-1);
		int res=0;
//		for(int i=1;i&amp;lt;=n;i++)
//			cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&#39; &#39;;
		
		for(int i=1;i&amp;lt;=n;i++)
		{
			insert(d[i]);
			res=max(res,query(d[i]));
		}
		printf(&amp;quot;%d\n&amp;quot;,res);
	}
	return 0;
}

AC自动机











每个结点的26个指针都有指向
匹配时判断后缀是不是单词，若为单词则也需要统计上
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=5e5+10,M=1e6+10;
int trie[N][26],cnt[N],idx;
char s[M];
int q[N],ne[N];
int n;

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-&#39;a&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;26;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;26;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	int res=0;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-&#39;a&#39;;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			res+=cnt[p];
			cnt[p]=0;
			p=ne[p];
		}
	}
	return res;
}

void print()
{
	for(int i=0;i&amp;lt;idx;i++)
	{
		cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;ne[i]&amp;lt;&amp;lt;&amp;quot;: &amp;quot;;
		for(int j=0;j&amp;lt;26;j++)
			if(trie[i][j])
			    cout&amp;lt;&amp;lt;char(j+&#39;a&#39;)&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;trie[i][j]&amp;lt;&amp;lt;&amp;quot;  &amp;quot;;
		cout&amp;lt;&amp;lt;endl;
	}
	cout&amp;lt;&amp;lt;endl;
}

int main()
{
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		memset(ne,0,sizeof ne);
		idx=0;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		
		for(int i=0;i&amp;lt;n;i++)
		{
			char str[55];
			scanf(&amp;quot;%s&amp;quot;,str);
			insert(str);
		}
		
		build();
		//print();
		scanf(&amp;quot;%s&amp;quot;,s);
		printf(&amp;quot;%d\n&amp;quot;,query(s));
	}
	return 0;
}

hdu2896
小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1e5+10,M=10010;
int trie[N][128],idx;
char s[M];
int q[N],ne[N];
int n,m;
int ans[N],cnt;
int id[N];
int tot;

void insert(char *s,int i)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-32;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	id[p]=i;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;128;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;128;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	bool flag = false;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-32;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			if(id[p])
			{
				flag=true;
				ans[cnt++]=id[p];
				//cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;id[p]&amp;lt;&amp;lt;endl;
			}
			p=ne[p];
		}
	}
	return flag;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		char str[210];
		scanf(&amp;quot;%s&amp;quot;,str);
		insert(str,i);
	}
	
	build();

	scanf(&amp;quot;%d&amp;quot;,&amp;amp;m);
	for(int i=1;i&amp;lt;=m;i++)
	{
		scanf(&amp;quot;%s&amp;quot;,s);
		cnt=0;
		if(query(s))
		{
			tot++;
			printf(&amp;quot;web %d:&amp;quot;,i);
			cnt=unique(ans,ans+cnt)-ans;
			sort(ans,ans+cnt);
			for(int i=0;i&amp;lt;cnt;i++)
				printf(&amp;quot; %d&amp;quot;,ans[i]);
			puts(&amp;quot;&amp;quot;);
		}
	}
	
	printf(&amp;quot;total: %d\n&amp;quot;,tot);
	return 0;
}

1.本题不是计数，不需判重复，只需标记病毒编号为true，多次标记不影响最终答案
2.多个主串，字典树下一次还要再查询，不能改变字典树
附：ASCII表

poj2778






#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=110,mod=100000;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n,m;
int q[N];
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
	matrix(int c[][N])
	{
		memcpy(m,c,sizeof m);
	}
};

int get(char c)
{
	switch(c)
	{
		case &#39;A&#39; : return 0;
		case &#39;G&#39; : return 1;
		case &#39;C&#39; : return 2;
		case &#39;T&#39; : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;	
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&amp;lt;=idx;i++)
		for(int j=0;j&amp;lt;=idx;j++)
			for(int k=0;k&amp;lt;=idx;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&amp;lt;=idx;i++)
		res.m[i][i]=1;
	while(k)
	{
		if(k &amp;amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return res;
}

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	for(int i=0;i&amp;lt;n;i++)
	{
		char str[15];
		scanf(&amp;quot;%s&amp;quot;,str);
		insert(str);
	}
	
	build();
	
	matrix g;
	for(int i=0;i&amp;lt;=idx;i++)
	{
		if(cnt[i]) continue;
		for(int j=0;j&amp;lt;4;j++)
		{
			int p=trie[i][j];
			if(!cnt[p])
				g.m[i][p]=(g.m[i][p]+1)%mod;
		}
	}
	
//	for(int i=0;i&amp;lt;=idx;i++)
//	{
//		for(int j=0;j&amp;lt;=idx;j++)
//			cout&amp;lt;&amp;lt;g.m[i][j]&amp;lt;&amp;lt;&#39; &#39;;
//		cout&amp;lt;&amp;lt;endl;
//	}
	
	g=qmi(g,m);
	int res=0;
	for(int i=0;i&amp;lt;=idx;i++)
		res=(res+g.m[0][i])%mod;
	
	printf(&amp;quot;%d&amp;quot;,res);
	
	return 0;
}

最后的答案为什么是g.m[0][i]求和?
矩阵g的n次幂表示构造长度为n的DNA序列的方案数（g的i次幂表示构造长度为n的DNA序列的方案数），类似离散数学中二元关系的复合运算，二元关系&amp;lt;1,2&amp;gt; ,&amp;lt;2,3&amp;gt; 复合一次可得到关系&amp;lt;1,3&amp;gt;
由于从根结点出发构造序列，且根结点idx为0.g.m[0][i]表示从根结点走i步的方案数，即从根节点开始构造长度为i的序列的方案数。
poj3691
AC自动机+DP
为每个结点构造失败指针的同时，检查其失败指针所指向的节点是否为危险节点，如果是的话也需要把当前节点标记为危险节点。
所谓的危险节点，就是指以当前节点为结尾的字符串是某个病毒串，或者包含了某个病毒串。如果在bfs的同时进行这项操作的时候就非常方便，在构造完当前失败指针的同时检查其所指向的节点是否为危险节点。
根据危险DNA序列所建的字典树，我们用模拟的方式 ，从第一个字符开始构造， 依次递增，找到一个满足要求的字符串，在构造此字符串的同时，比较该字符串和输入要判断的序列S，若该位置i的字符和s[i]，相同，则表示，此位置的字符不需要改变，反则，需要把s[i]该为词字符，为一次改变操作.
状态表示：dp[i][j]，表示到达查找串第i个字符时，对应于AC自动机的j节点所需要的最小改变数。
状态转移为dp[i][son[j]] = min( dp[i][son[j]], dp[i-1][j] + s[i-1]!=k )
读到i个字符时，对应于j状态（DP的过程要两重循环i和j），要转移到son[j]（j的子节点状态，在这里用k在[0,3]一重循环遍历所有可以转字符），如果第i个字符跟所要转移到的字符相同，则代价为0，因为不需要改变；否则代价为1，因为需要改变。
如果当前状态不可达，则不需要对其进行后续运算。
如果子节点为危险节点，则不可以进行转移，即不可以使用上面的状态方程。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n;
char s[N];
int f[N][N];
int q[N];

int get(char c)
{
	switch(c)
	{
		case &#39;A&#39; : return 0;
		case &#39;G&#39; : return 1;
		case &#39;C&#39; : return 2;
		case &#39;T&#39; : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

void print()
{
    for(int i=0;i&amp;lt;=idx;i++)
    {
        cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;ne[i]&amp;lt;&amp;lt;&amp;quot;: &amp;quot;;
        for(int j=0;j&amp;lt;4;j++)
            if(trie[i][j])
                cout&amp;lt;&amp;lt;trie[i][j]&amp;lt;&amp;lt;&#39; &#39;;
        cout&amp;lt;&amp;lt;endl;
    }
}

int main()
{
	int kas=1;
	while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		memset(trie,0,sizeof trie);
		memset(ne,0,sizeof ne);
		memset(cnt,0,sizeof cnt);
		idx=0;
		for(int i=0;i&amp;lt;n;i++)
		{
			char str[25];
			scanf(&amp;quot;%s&amp;quot;,str);
			insert(str);
		}
		
		build();
		
		//print();
		
		scanf(&amp;quot;%s&amp;quot;,s+1);
		int len=strlen(s+1);
		
		memset(f,0x3f,sizeof f);
		f[0][0]=0;
		for(int i=1;i&amp;lt;=len;i++)
			for(int j=0;j&amp;lt;=idx;j++)
				for(int k=0;k&amp;lt;4;k++)
				{
					int t=get(s[i]) != k;
					int p=trie[j][k];
					if(!cnt[p])
						f[i][p]=min(f[i][p],f[i-1][j]+ t);
				}
				
		int res=INF;
		for(int i=0;i&amp;lt;=idx;i++)
			res=min(res,f[len][i]);
		
		if(res == INF)
			res=-1;
		printf(&amp;quot;Case %d: %d\n&amp;quot;,kas++,res);
	}
	return 0;
}

最后，循环dp[len][j]，即在读完最后一个字符后检查所有状态的最终值，取其最小。如果均不可达，则返回-1。
类似题：求主串至少包含一个模式串的方案数，正难则反。
代码
hdu2233
长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？
比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为
(2个) aa,ab,
(26个)aaa,aab,aac...aaz,
(26个)aba,abb,abc...abz,
(25个)baa,caa,daa...zaa,
(25个)bab,cab,dab...zab。







代码
若要求长度正好为L，原矩阵的L次幂即可
长度不超过L，需要累加
acwing1285
每次插入一个单词时把所有路径上的点都+1，每个单词的出现次数就是其结尾节点的fail树子树和。因为其fail指针指向的节点一定包含当前字符串。
统计贡献时要从下往上按照拓扑排序加，
代码
hdu3695
给出 n 个模式串，给出一个长串 S，找出 S 中出现了几种模式串。注意模式串在 S 中正着出现和反着出现都算出
现。S 可能有些段是压缩过的，格式为[tx]，t 是一个数字，x 是一个字母，代表有 t 个 x。把 a[3b]c 解压后会得到
abbbc。
n≤250，模式串的长度不超过1000，t≤5·1e6, 解压后的长串的长度不超过 5100000.

样例输入：
3
2
AB DCB
DACB
3
ABC CDE GHI
ABCCDEFIHG
4
ABB ACDEE BBB FEEE
A[2B]CD[4E]F
样例输出：
0
3
2
我们可以把这 n 个串插入 Trie 树，建成 AC 自动机。然后把解压后的 S 正着在 AC 自动机上跑一遍，再反着在
AC 自动机上跑一遍，对于覆盖过的模式串，打一个标记。最后统计标记的总数即可
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=250010,M=5100010;
int trie[N][26],idx;
char s[M],tmp[M];
int ne[N];
int dar[N];
int n;
int q[N];

void insert(char *s,int k)
{
    int p=0;
    for(int i=0;s[i];i++)
    {
        int k=s[i]-&#39;A&#39;;
        if(!trie[p][k])
        {
        	trie[p][k]=++idx;
        	memset(trie[idx],0,sizeof trie[idx]);
        	dar[idx]=0;
		}
        p=trie[p][k];
    }
   	dar[p]++;
}

void build()
{
    int hh=0,tt=-1;
    for(int i=0;i&amp;lt;26;i++)
        if(trie[0][i])
        {
        	int t=trie[0][i];
        	q[++tt]=t;
        	ne[t]=0;
		}
    
    while(hh &amp;lt;= tt)
    {
        int t=q[hh++];
        for(int i=0;i&amp;lt;26;i++)
        {
            int p=trie[t][i];
            if(!p) trie[t][i]=trie[ne[t]][i];
            else 
            {
                ne[p]=trie[ne[t]][i];
                q[++tt]=p;
            }
        }
    }
}

int query(char *s,int type)
{
    int len=strlen(s);
    if(type)
        reverse(s,s+len);
    //cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;
    int res=0;
    for(int i=0,j=0;s[i];i++)
    {
        int k=s[i]-&#39;A&#39;;
        j=trie[j][k];
        int p=j;
        while(p)
        {
        	if(dar[p])
        	{
        		res+=dar[p];
        		dar[p]=0;
			}
			else 
				break;
            p=ne[p];
        }
    }
    return res;
}

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    while(T--)
    {
    	memset(trie[0],0,sizeof trie[0]);
    	ne[0]=0;
    	dar[0]=0;
        idx=0;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        for(int i=1;i&amp;lt;=n;i++)
        {
            char str[1010];
            scanf(&amp;quot;%s&amp;quot;,str);
            insert(str,i);
        }
        
        build();
        
        scanf(&amp;quot;%s&amp;quot;,s);
        int l=0;
        for(int i=0;s[i];i++)
        {
            if(s[i] !=&#39;[&#39;)
                tmp[l++]=s[i];
            else
            {
                i++;
                int len=0;
                while(s[i] &amp;gt;=&#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;=&#39;9&#39;)
                {
                    len=len*10+s[i]-&#39;0&#39;;
                    i++;
                }
                for(int k=0;k&amp;lt;len;k++)
                    tmp[l++]=s[i];
                i++;
            }
        }
        tmp[l]=0;
        
        printf(&amp;quot;%d\n&amp;quot;,query(tmp,0)+query(tmp,1));
    }
}

hdu4763
给你一个字符串 S。
请你把这个 S 划分成 EAEBE 的形式。
其中 A 和 B 可以包含任意个（可以是0个）字符。
求 E 的最大长度。字符串的长度之和不会超过1e6

Sample Input
5
xy
abc
aaa
aaaaba
aaxoaaaaa

Sample Output
0
0
1
1
2
观察 EAEBE。
首先要保证 E 既是 S 的前缀又是 S 的后缀。
且去除掉前缀 E 和后缀 E 之后，中间剩下的还要出现一次 E。 对 S 跑一次扩展 KMP 中的 Z 算法。
如果 i+Z[i]-1 == n ，就说明 S[i..n] 可以作为 E。
那么就要求在 S[Z[i]+1..i-Z[i]] 中，还得存在一个 j 满足 Z[j] ≥ Z[i]
问题变成了先找 i+Z[i]-1 = n 的 符合条件的i
然后在[Z[i]+1..i-Z[i]] 中，查询 Z 的最大值，如果比Z[i] 大，那么就可以把 Z[i] 作为答案。最后取最大值即可。
查询区间最大值我们可以用线段树 / ST 表来维护。
最后的时间复杂度都是 O(n log n)

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/dan-diao-dui-lie-you-hua-dp/">
                        单调队列优化dp
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-27</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            acwing1088



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=2e6+10;
typedef long long LL;
int p[N],d[N];
LL s[N];
int q[N];
bool ans[N];
int n;

int main()
{
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    for(int i=1;i&amp;lt;=n;i++)
    {
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;p[i],&amp;amp;d[i]);
        p[i+n]=p[i];
        d[i+n]=d[i];
    }

    for(int i=1;i&amp;lt;=n*2;i++) s[i]=s[i-1]+p[i]-d[i];

    int hh=0,tt=-1;
    for(int i=1;i&amp;lt;=n*2;i++)//顺时针求长度为n的窗口内前缀和的最小值
    {
        if(hh &amp;lt;= tt &amp;amp;&amp;amp; i - q[hh] &amp;gt;= n) hh++;

        while(hh &amp;lt;= tt &amp;amp;&amp;amp; s[q[tt]] &amp;gt;= s[i])
            tt--;
        q[++tt]=i;
        if(i &amp;gt;= n &amp;amp;&amp;amp; s[q[hh]] &amp;gt;= s[i-n])
            ans[i-n+1]=true;
    }

    d[0]=d[n];
    for(int i=n*2;i&amp;gt;=1;i--) s[i]=s[i+1]+p[i]-d[i-1];

    hh=0,tt=-1;
    for(int i=n*2;i&amp;gt;=1;i--)//逆时针求长度为n的窗口内后缀和的最小值
    {
        if(hh &amp;lt;= tt &amp;amp;&amp;amp; q[hh]-i &amp;gt;= n) hh++;

        while(hh &amp;lt;= tt &amp;amp;&amp;amp; s[q[tt]] &amp;gt;= s[i])
            tt--;
        q[++tt]=i;
        if(i&amp;lt;=n+1 &amp;amp;&amp;amp; s[q[hh]] &amp;gt;= s[i+n])
            ans[i-1]=true;
    }

    for(int i=1;i&amp;lt;=n;i++)
        if(ans[i]) puts(&amp;quot;TAK&amp;quot;);
        else puts(&amp;quot;NIE&amp;quot;);
    return 0;   
}

acwing1089

#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int N = 2e5 + 10, INF = 0x3f3f3f3f;
int n, m;
int w[N], q[N];
int f[N];

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i ++ ) scanf(&amp;quot;%d&amp;quot;, &amp;amp;w[i]);

    int hh = 0, tt = 0;
    q[0]=0;
    for (int i = 1; i &amp;lt;= n; i ++ )
    {
        if (i - q[hh] &amp;gt; m) hh ++ ;
        f[i] = f[q[hh]] + w[i];
        while (hh &amp;lt;= tt &amp;amp;&amp;amp; f[q[tt]] &amp;gt;= f[i]) tt -- ;
        q[ ++ tt] = i;
    }

    int res = INF;
    for (int i = n - m + 1; i &amp;lt;= n; i ++ ) res = min(res, f[i]);
    printf(&amp;quot;%d\n&amp;quot;, res);

    return 0;
}

acwing1090

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=50010,INF=0x3f3f3f3f;
int n,t;
int a[N];
int f[N];
int q[N];

bool check(int mid)
{
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&amp;lt;=n;i++)
    {
        if(hh &amp;lt;= tt &amp;amp;&amp;amp; i - q[hh] &amp;gt; mid+1) hh++;
        f[i]=f[q[hh]]+a[i];
        while(hh &amp;lt;= tt &amp;amp;&amp;amp; f[q[tt]] &amp;gt;= f[i])
            tt--;
        q[++tt]=i;
    }
    
    int res=INF;
    for(int i=n-mid;i&amp;lt;=n;i++)
        res=min(res,f[i]);
    
    return res&amp;lt;=t;
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;t;
    for(int i=1;i&amp;lt;=n;i++)
        cin&amp;gt;&amp;gt;a[i];

    int l=0,r=n;
    while(l &amp;lt; r)
    {
        int mid=l+r&amp;gt;&amp;gt;1;
        if(check(mid))
            r=mid;
        else
            l=mid+1;
    }
    
    cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;endl;
    return 0;
}

acwing1087

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
LL f[N][2];
int n,k;
int e[N];
LL s[N];
int q[N];

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k;
    
    for(int i=1;i&amp;lt;=n;i++)
        cin&amp;gt;&amp;gt;e[i];
        
    for(int i=1;i&amp;lt;=n;i++)
    	s[i]=s[i-1]+e[i];
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&amp;lt;=n;i++)
    {
    	f[i][0]=max(f[i-1][0],f[i-1][1]);
    	if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-q[hh] &amp;gt; k) hh++;
    	
    	f[i][1]=f[q[hh]][0]-s[q[hh]]+s[i];
    	while(hh &amp;lt;= tt &amp;amp;&amp;amp; f[i][0]-s[i] &amp;gt;= f[q[tt]][0] -s[q[tt]])
    		tt--;
    	q[++tt]=i;
	}
	
	cout&amp;lt;&amp;lt;max(f[n][0],f[n][1])&amp;lt;&amp;lt;endl;
	return 0;
}


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010,INF=0x3f3f3f3f;
LL f[N];
int n,k;
int e[N];
LL s[N];
int q[N];

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k;
    
    for(int i=1;i&amp;lt;=n;i++)
        cin&amp;gt;&amp;gt;e[i];
        
    for(int i=1;i&amp;lt;=n;i++)
    	s[i]=s[i-1]+e[i];
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&amp;lt;=n;i++)
    {
    	if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-q[hh] &amp;gt; k) hh++;
    	
    	f[i]=f[q[hh]-1]-s[q[hh]]+s[i];
    	while(hh &amp;lt;= tt &amp;amp;&amp;amp; f[i-1]-s[i] &amp;gt;= f[q[tt]-1] -s[q[tt]])
    		tt--;
    	q[++tt]=i;
	}
	
	LL res=-1e18;
	for(int i=n-k;i&amp;lt;=n;i++)
	    res=max(res,f[i]);
	cout&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl;
	return 0;
}

acwing1091
先用滑动窗口+单调队列求出每一行长度为k的连续序列中的最大值、最小值，
存到rmin[i][j],rmax[i][j]两个数组里，
再用相同的方法求这两个数组中每一列长度为k的连续序列的最大值、最小值存到cmin[i],cmax[i]中。
遍历cmin,cmax得出答案。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int n,m,k;
int a[N][N];
int rmax[N][N],rmin[N][N];
int cmax[N],cmin[N];
int tmp[N];
int q[N];

void get(int a[],int b[],int len,int type)//0:最小值，1：最大值 
{
    int hh=0,tt=-1;
    for(int i=1;i&amp;lt;=len;i++)
    {
        if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-q[hh] &amp;gt;=k) hh++;
        while(hh &amp;lt;= tt &amp;amp;&amp;amp;(type?a[q[tt]]&amp;lt;=a[i]:a[q[tt]]&amp;gt;=a[i]))
            tt--;
        q[++tt]=i;
        b[i]=a[q[hh]];
    }
}

int main()
{
    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);

    for(int i=1;i&amp;lt;=n;i++)
        for(int j=1;j&amp;lt;=m;j++)
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]);

    for(int i=1;i&amp;lt;=n;i++)
    {
        get(a[i],rmin[i],m,0);
        get(a[i],rmax[i],m,1);
    }

    int ans=INF;
    for(int i=k;i&amp;lt;=m;i++)
    {
        for(int j=1;j&amp;lt;=n;j++) tmp[j]=rmin[j][i];
        get(tmp,cmin,n,0);

        for(int j=1;j&amp;lt;=n;j++) tmp[j]=rmax[j][i];
        get(tmp,cmax,n,1);

        for(int j=k;j&amp;lt;=n;j++)
            ans=min(ans,cmax[j]-cmin[j]);
    }

    printf(&amp;quot;%d\n&amp;quot;,ans);

    return 0;   
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/dan-diao-dui-lie-you-hua-dp/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/shu-zhuang-shu-zu/">
                        树状数组
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-27</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            树状数组




sum[9]=c[9]+c[8];












#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=10000;
int n,a[maxn],c[maxn],s[maxn];

int lowbit(int i)//c[i]的区间长度 
{
	return (-i)&amp;amp;i;
}

void add(int i,int z)//a[i]加上z
{
	for(;i&amp;lt;=n;i+=lowbit(i))//直接后继，即父亲i+=lowbit(i)
		c[i]+=z;	
} 

int sum(int i)//求前缀和a[1]..a[i] 
{
	int s=0;
	for(;i&amp;gt;0;i-=lowbit(i))//直接前驱 i-=lowbit(i);
		s+=c[i];
	return s; 
}

int sum(int i,int j)//求区间和a[i]..a[j] 
{
	return sum(j)-sum(i-1); 
}

int main()
{
	memset(c,0,sizeof(c));
	cin&amp;gt;&amp;gt;n;
	for(int i=1;i&amp;lt;=n;i++)
	{
		cin&amp;gt;&amp;gt;a[i];
		add(i,a[i]);//加入树状数组 
	} 
	int x1,x2;
	cin&amp;gt;&amp;gt;x1;
	cout&amp;lt;&amp;lt;sum(x1)&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;x1&amp;gt;&amp;gt;x2;
	cout&amp;lt;&amp;lt;sum(x1,x2)&amp;lt;&amp;lt;endl;
	return 0;
}






#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=10000;
int n,a[maxn][maxn],c[maxn][maxn];//二维树状数组 

int lowbit(int i)//区间长度 
{
	return (-i)&amp;amp;i;
}

void add(int x,int y,int z)//a[x][y]加上z
{
	for(int i=x;i&amp;lt;=n;i+=lowbit(i))
		for(int j=y;j&amp;lt;=n;j+=lowbit(j))
			c[i][j]+=z;
} 

int sum(int x,int y)//求左上角(1,1)到右下角(x,y)矩阵区间和 
{
	int s=0;
	for(int i=x;i&amp;gt;0;i-=lowbit(i))
		for(int j=y;j&amp;gt;0;j-=lowbit(j))
			s+=c[i][j];
	return s; 
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1); 
}

int main()
{
	for(int i=1;i&amp;lt;=n;i++)
		memset(c[i],0,sizeof(c[i]));
	cin&amp;gt;&amp;gt;n;
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
		{
			cin&amp;gt;&amp;gt;a[i][j];
			add(i,j,a[i][j]);//加入树状数组 
		} 
	int x1,y1,x2,y2;
	cin&amp;gt;&amp;gt;x1&amp;gt;&amp;gt;y1;
	cout&amp;lt;&amp;lt;sum(x1,y1)&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;x1&amp;gt;&amp;gt;y1&amp;gt;&amp;gt;x2&amp;gt;&amp;gt;y2;
	cout&amp;lt;&amp;lt;sum(x1,y1,x2,y2)&amp;lt;&amp;lt;endl;
	return 0;
}

poj2352
统计x前面比它小的星星的个数。注意的是：给的点的坐标是从0开始的，树状数组下标为0的位置不可用，所以我们需要在输入x坐标时+1。
因为本题给出的数据就是已经按照y从小到大排好序的,也就是说，当前读到一个点的时候，当前点的y坐标肯定比已经读入的大，或者等于。就算是等于的话，也是x坐标比我当前点的x坐标小，所以我们每次只要算x坐标比我们小的就行了 。


#include&amp;lt;cstdio&amp;gt;
using namespace std;
#define maxn 32010
int ans[maxn],tr[maxn];//等级统计，每个值的数量 
int n;

int lowbit(int x)
{
	return x&amp;amp;-x;
}

void add(int x,int c)//将第i个元素增加val，其后继也要增加
{
	for(int i=x;i&amp;lt;=maxn;i+=lowbit(i))//是x点的范围，注意不是星星的个数n 
		tr[i]+=c;//i的后继（父结点） 
}

int sum(int x)//前缀和 
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];//i的前驱
	return res;
}

int main()
{
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    int x,y;
    for(int i=0;i&amp;lt;n;i++)
    {
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
        x++;
        ans[sum(x)]++;
        add(x,1);//x的数量c[x]增1,若是统计小于等于x的数量，则先执行add操作再查询 
    }
    for(int i=0;i&amp;lt;n;i++)
        printf(&amp;quot;%d\n&amp;quot;,ans[i]);
	return 0;
}

树状数组求逆序对
1）逆序数问题定义
给一个1~n的排列，求满足i&amp;lt;j且a[i]&amp;gt;a[j]的二元组对数，比如[4,2,1,5,3]这个序列，满足条件的二元组为{&amp;lt;4,2&amp;gt;, &amp;lt;4,1&amp;gt;, &amp;lt;4,3&amp;gt;, &amp;lt;2,1&amp;gt;, &amp;lt;5,3&amp;gt;}，故逆序数是5
2）树状数组求逆序数的原理
首先明确树状数组在此问题中维护信息是某个区间中数字出现的个数，sum(a[i])可求得[1, a[i]]的区间和，这恰好代表第i个数字前小于它的个数，，那么大于它的显然就有sum(n)-sum(a[i])个,然后将源数据按其原本顺序插入树状数组，第i个数字插入的方式为将树状数组的第a[i]位设为1，同时更新覆盖到它的父区间。
for (int i = 1; i &amp;lt;= n; i++) 
{
    ans += sum(n) - sum(a[i]);
    add(a[i], 1);
}

累加每步的结果后可得逆序数为5，用树状数组的好处在于add操作和sum的操作时间复杂度都为O(logn)，非常的巧妙
poj3067
由于x是从小到大排序的，假设当前我们在处理第k条边，那么第1~k-1条边的x必然是小于（等于时候暂且不讨论）第k条边的 x 的，那么前k-1条边中，与第k条边相交的边的y值必然大于yk的，所以此时我们只需要求出在前k-1条边中有多少条边的y值在区间[yk, M]即可,也就是求yk的逆序数，M为西岸城市个数，即y的最大值。
所以就将问题转化成区间求和的问题，树状数组解决。当两条边的x相同时，我们记这两条边的y值分别为ya，yb（ya&amp;lt;yb),我们先处理（x，ya），再处理（x，yb），原因很明显，因为当x相同时，这两条边是认为没有交点的，若先处理（x，yb），那么下次处理（x，ya）时，（x，ya）就会给（x，yb）增加一个逆序，也就是将这两条边做相交处理了。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1010,M=1000010;
int tr[N];
int n,m,k;
struct Edge 
{
    int x, y;
    bool operator&amp;lt; (const Edge &amp;amp;W) const 
    {
    	if(x == W.x)
    		return y&amp;lt;W.y;
    	else
    		return x&amp;lt;W.x;
	}
}e[M];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;amp;-x;
}

void add(int x)//加1操作，参数省略
{
	for(int i=x;i&amp;lt;=m;i+=lowbit(i))//y点有m个
		tr[i]++;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))
    	res+=tr[i];
    return res;
}

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    for(int kase=1;kase&amp;lt;=T;kase++)
	{
		memset(tr,0,sizeof tr);
	    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);
	    for(int i=1;i&amp;lt;=k;i++)
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;e[i].x,&amp;amp;e[i].y);
	    sort(e+1,e+k+1);
	    LL ans=0;
	    for(int i=1;i&amp;lt;=k;i++)
		{
			ans+=sum(m)-sum(e[i].y);
			add(e[i].y);
	    }
	    printf(&amp;quot;Test case %d: %lld\n&amp;quot;,kase,ans);
	}
    return 0;
}

acwing241

#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N = 200010;
int n;
int a[N];
int tr[N];
int bigger[N], lower[N];

int lowbit(int x)
{
    return x &amp;amp; -x;
}

void add(int x, int c)
{
    for (int i = x; i &amp;lt;= n; i += lowbit(i)) tr[i] += c;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);

    for (int i = 1; i &amp;lt;= n; i ++ ) scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i]);

    for (int i = 1; i &amp;lt;= n; i ++ )//从左向右扫
    {
        bigger[i] = sum(n) - sum(a[i]);//1~i-1有多少数大于y（y+1~n）
        lower[i] = sum(a[i]);//1~i-1有多少数小于y（1~y-1）
        add(a[i], 1);
    }

    memset(tr, 0, sizeof tr);
    LL res1 = 0, res2 = 0;
    for (int i = n; i; i -- )//从右向左扫
    {
        res1 += bigger[i] * (LL)(sum(n) - sum(a[i]));//i+1~n有多少数大于y
        res2 += lower[i] * (LL)(sum(a[i]));//i+1~n有多少数小于y
        add(a[i], 1);
    }

    printf(&amp;quot;%lld %lld\n&amp;quot;, res1, res2);

    return 0;
}

拓展应用
1.树状数组基本应用. 单点修改 + 区间查询
2.区间修改 + 单点查询

acwing242
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
int a[N];
int n,m;
int tr[N];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;amp;-x;
}

void add(int x,int c)
{
	for(int i=x;i&amp;lt;=n;i+=lowbit(i))
		tr[i]+=c;
}

int sum(int x)
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];
	return res;
}

int main()
{
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		add(i,a[i]-a[i-1]);
	}
	
	while(m--)
	{
		char op[2];
		scanf(&amp;quot;%s&amp;quot;,op);
		if(*op == &#39;C&#39;)
		{
		    int l,r,d;
			scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;l,&amp;amp;r,&amp;amp;d);
			add(l,d);
			add(r+1,-d);
		}
		else
		{
		    int x;
		    scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
			printf(&amp;quot;%d\n&amp;quot;,sum(x));
		}
	}
	return 0;
 } 

3.区间修改 + 区间查询
acwing243


//区间加
//区间和
#include&amp;lt;iostream&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
int n,m;
int a[N];
LL tr1[N];//维护b[i]的前缀和
LL tr2[N];//维护b[i]*i的前缀和

int lowbit(int x)
{
    return x&amp;amp;-x;
}

void add(LL tr[],int x,LL c)
{
    for(int i=x;i&amp;lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

LL sum(LL tr[],int x)
{
    LL res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=tr[i];
    return res;
}

LL prefix_sum(int x)
{
    return sum(tr1,x)*(x+1)-sum(tr2,x);
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1;i&amp;lt;=n;i++)
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
    for(int i=1;i&amp;lt;=n;i++)
    {
        int b=a[i]-a[i-1];//最大为1e9
        add(tr1,i,b);
        add(tr2,i,(LL)i*b);
    }
    
    while(m--)
    {
        char op[2];
        int l,r,d;
        scanf(&amp;quot;%s%d%d&amp;quot;,op,&amp;amp;l,&amp;amp;r);
        if(*op == &#39;Q&#39;)
            printf(&amp;quot;%lld\n&amp;quot;,prefix_sum(r)-prefix_sum(l-1));
        else
        {
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;d);
            add(tr1,l,d);
            add(tr1,r+1,-d);
            add(tr2,l,l*d);
            add(tr2,r+1,(r+1)*-d);
        }
    }
    return 0;
}

acwing244
我们发现,如果说第K头牛的前面有Ak头牛比它矮,那么它的身高Hk就是数值1 n中第Ak+1小的没有在Hk+1,Hk+2,…,HnH_{k+1},H_{k+2},…,H_{n}Hk+1​,Hk+2​,…,Hn​中出现过的数
所以说,我们需要建立一个长度为n的01序列b,刚开始都是1,然后n到1倒序扫描每一个AiA_iAi​,对于每个AiA_iAi​
执行查询和修改操作.
也就是说这道题目的题意就是让我们,动态维护一个01序列,支持查询第k个1所在的位置,以及修改序列中的一个数值
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
int h[N];
int n;
int tr[N];
int ans[N];

int lowbit(int x)
{
    return x&amp;amp;-x;
}

void add(int x,int c)
{
    for(int i=x;i&amp;lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))  
        res+=tr[i];
    return res;
}

int main()
{
    cin&amp;gt;&amp;gt;n;
    for(int i=2;i&amp;lt;=n;i++)
        cin&amp;gt;&amp;gt;h[i];
        
    for(int i=1;i&amp;lt;=n;i++)   
        tr[i]=lowbit(i);//相当于add(i,1);
    
    for(int i=n;i;i--)
    {
        int k=h[i]+1;
        int l=1,r=n;
        while(l&amp;lt;r)
        {
            int mid=l+r&amp;gt;&amp;gt;1;
            if(sum(mid) &amp;gt;= k)
                r=mid;
            else
                l=mid+1;
        }
        ans[i]=l;
        add(l,-1);
    }
    
    for(int i=1;i&amp;lt;=n;i++)
        cout&amp;lt;&amp;lt;ans[i]&amp;lt;&amp;lt;endl;
    return 0;
}

poj1195

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#define maxn 1050
#define lowbit(x) (x)&amp;amp;(-x)
int c[maxn][maxn],n;

void add(int x,int y,int z)//单点更新 
{
    for(int i=x;i&amp;lt;=n;i+=lowbit(i))
        for(int j=y;j&amp;lt;=n;j+=lowbit(j))
            c[i][j]+=z;
}

int sum(int x,int y)//区间和：左上角(1,1)到右下角(x,y)矩阵区间和 
{
    int s=0;
    for(int i=x;i&amp;gt;0;i-=lowbit(i))
        for(int j=y;j&amp;gt;0;j-=lowbit(j))
            s+=c[i][j];
    return s;
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1);
}

int main()
{
    int opt,x,y,a,l,b,r,t;
	while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;opt)!=EOF)
	{
		if(opt==3) break;
		if(opt==0)
		{
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    		memset(c,0,sizeof(c));
		}
		else if(opt==1)
		{
            scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;a);
            ++x;++y;
            add(x,y,a);
        }
        else
		{
            scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;l,&amp;amp;b,&amp;amp;r,&amp;amp;t);
            ++l,++b,++r,++t;
            printf(&amp;quot;%d\n&amp;quot;,sum(l,b,r,t));
        }
	}
    return 0;
}

poj3321




#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int maxn=1e5+10;
int n,q;
int c[maxn];
int a[maxn];
int L[maxn],R[maxn];
int head[maxn];
int cnt;
int dfn;
struct edge{
    int u,v;
    int next;
}E[2*maxn];

void adde(int u,int v)
{
    E[++cnt].u=u;
    E[cnt].v=v;
    E[cnt].next=head[u];
    head[u]=cnt;
}

int lowbit(int x)
{
    return x&amp;amp;(-x);
}

void add(int x,int v)
{
    for(int i=x;i&amp;lt;=n;i+=lowbit(i))
        c[i]+=v;
}

int sum(int x)
{
    int ans=0;
    for(int i=x;i;i-=lowbit(i))
    {
        ans+=c[i];
    }
    return ans;
}


void dfs(int u,int fa)
{
    L[u]=++dfn;
    for(int i=head[u];i;i=E[i].next)
    {
        int v=E[i].v;
        if(v==fa) continue;
        dfs(v,u);
    }
    R[u]=dfn;
}

int main()
{
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    int u,v;
    for(int i=1;i&amp;lt;=n;i++)
    {
        c[i]=lowbit(i);
        a[i]=1;
    }
    for(int i=1;i&amp;lt;n;i++)
    {
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;u,&amp;amp;v);
        adde(u,v);
    }
    dfs(1,-1);
//	for(int i=1;i&amp;lt;=n;i++)//测试dfs序列 
//    	printf(&amp;quot;--%d %d\n&amp;quot;,L[i],R[i]);
//  	printf(&amp;quot;\n&amp;quot;);	
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;q);
    char op[10];
    for(int i=1;i&amp;lt;=q;i++)
    {
        scanf(&amp;quot;%s%d&amp;quot;,op,&amp;amp;v);
        if(op[0]==&#39;C&#39;)
        {
        	int j=L[v];
            if(a[j])//由于每个节点的dfn编号就是它的左值，所以直接修改左节点
                add(j,-1);
            else
                add(j,1);
            a[j]^=1;
        }
        else
        {
            int s1=sum(R[v]);
            int s2=sum(L[v]-1);
            printf(&amp;quot;%d\n&amp;quot;,s1-s2);
        }
    }
    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/shu-zhuang-shu-zu/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/shu-lun/">
                        数论
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-26</time>
                    
                        <a href="https://caifxh.github.io/tag/14SoYNkfD/" class="post-tag i-tag
                            i-tag-error">
            #数学
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            数论
除法和模运算
计算机中整数和整数的除法是整数除法，即 a ÷ b = ⌊ ab ⌋.
模运算即是两数相除的余数，在 c++ 的代码中用 a%b 来计算这
个数字，通过一些小学知识我们容易得到
a % b = a − ⌊a/b⌋ × b
整除性和约数
整除是数论中的一个中心概念。
如果两个数字 a, b, 满足 a % b = 0 , 那么我们就说 a 是 b 的倍数，同时也说 b 是 a 的约数，计做 b | a 。
在通常情况下，我们考虑一个数字的约数和倍数，都只考虑他的正约数和正倍数。
• 记号 d | a 意味着对某个整数 k，有 a = kd。
• 0 可被任何整数整除。0=0*d,d|0
• 如果 d | a 我们称 a 是 d 的倍数，d 是 a 的约数。
• 一个整数 a 的约数最小为 1， 最大为 |a|。 • 例如：12 的约数有 1, 2, 3, 4, 6, 12
求约数
如何才能求出一个数字 n 的所有约数呢？
一个非常朴素的方法, 从 1 到 n 枚举，复杂度 O(n)
注意到约数总是成对出现的，即如果有 a ÷ b = c 就一定会有a ÷ c = b
我们以 ⌊√n⌋ 作为一个限度，只枚举到 √n(注意 n 是完全平方数的情况)
vector&amp;lt;int&amp;gt; get_div(int x)
{
    vector&amp;lt;int&amp;gt; res;
    for (int i = 1; i &amp;lt;= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}

int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;

    while (n -- )
    {
        int x;
        cin &amp;gt;&amp;gt; x;
        auto res = get_div(x);

        for (auto x : res) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}

求倍数
一个数字的倍数有无穷多个，所以很难求出所有的倍数，我们通常只求出 n 以内 a 的所有倍数。
和求约数相同，我们同样可以想到一个 O(n) 的简单方法，即枚举
对于一个数字 a , 他的所有倍数一定是 a, 2a, 3a, 4a, . . . , ⌊n/a⌋a, 每个倍数都比前一个倍数多 a, 所以我们可以从 a 开始每次加 a 枚举他的下一个倍数
复杂度分析：考虑一种极限情况，a = 1 , 此时枚举相当于从 1枚举到 n , 所以复杂度其实还是 O(n)
然而我们后面会看到，如果对于每个数字都枚举倍数的话，复杂度会有所下降。
素数和合数
对于某个整数 a &amp;gt; 1，如果它仅有约数 1 和 a，则称 a 为素数（或质数）
前 10 个素数: 2, 3, 5, 11, 13, 17, 19, 23, 29, 31
不是素数的整数 a &amp;gt; 1 称为合数。
例如，因为 2 | 10，所以 10 是合数。
整数 1 既不是素数也不是合数
如何判断一个数字是否是质数呢？定义判断即可
bool is_prime(int x)
{
    if(x&amp;lt;2)
        return false;
    for(int i=2;i&amp;lt;=x/i;i++)
    {
        if(x%i==0)
            return false;
    }
    return true;
}

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    while(n--)
    {
        int x;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
        if(is_prime(x))
            puts(&amp;quot;Yes&amp;quot;);
        else
            puts(&amp;quot;No&amp;quot;);
    }
    return 0;
}

埃拉托斯特尼筛法
埃氏筛法的原理是：每个合数都是多个质数的积；那么从最小的质数2开始，用每一个质数去筛比它大的数，就能筛掉合数。埃氏筛法低效的原因是，一个合数会被它的多个质因子重复筛。
我们考虑这样一个事实，如果一个数字是另外一个数字的倍数，那么这个数字一定不是素数，既然这样我们每枚举到一个数字 i，就可以把他所有的倍数全都设置成不是质数，这样从来没被标记过的数字就是质数了。
算法思想：每个质数都可以把它的倍数筛掉
时间复杂度：O(nloglogn)
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i &amp;lt;= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j &amp;lt;= n; j += i)
            st[j] = true;
    }
}

例题
bzoj1607
题意：给定 n 个数，对于其中的每一个数字，询问有多少个数是他的约数。

代码
线性筛（欧拉筛）
再次把眼光放回如何判断 [1, n]中哪些数字是质数这个问题上来。考虑之前的做法为什么会运行的比较缓慢呢？事实上我们在确认一个数字不是质数的时候，要用很多数字来筛选他才可以，比如数字 6, 我们在枚举 2的倍数的时候筛了他一次，在枚举 3 的倍数的时候筛了他一次，有没有什么办法能够让他只被筛选一次呢？
考虑这样一种想法，如果每个数字都只被他最小的质约数筛一次，那么复杂度就可以达到 O(n)。可是如何才能实现呢？这是一个类似构造的想法
$i=p_1^{k_1} * p_2^{k_2} * ... * p_s^{k_s} 
i * primes[j]=primes[j] * p_1^{k_1} * p_2^{k_2} * ... * p_s^{k_s}当i当i
当i%primes[j]不为0时，i*primes[j]的最小质因数为primes[j];
当i%primes[j]为0之后，i*primes[j]的最小质因数为当i当ip_1$而不是primes[j],此时不能再用primes[j]筛去，否则违背只用最小质因数筛的方法。

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i &amp;lt;= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] &amp;lt;= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

线性筛欧拉函数
回顾一下，我们在求逆元的时候介绍了一个函数，欧拉函数φ(n), 并介绍了一种 √n求一个欧拉函数的方法，现在我们考虑能不能 O(n) 时间内求出 [1, n] 每个数字的欧拉函数函数值呢？
考虑在线性筛的同时能不能把欧拉函数值也更新一下，注意到线性筛的时候每个数字只会被筛到一次，我们能否在这个时候顺便求出欧拉函数的函数值呢？
考虑他在被筛的时候函数的取值应该是多少
i. I是个质数,phi(p)=p-1
2.如果i % primes[j] = 0, 那么phi(i * primes[j])=primes[j] * phi(i)
原因：iprimes[j]的质因数构成和i相同，但primes[j]的次数多1
3.如果 i%prime[j] 不为 0，即primes[j]小于i的最小质因子p1p_1p1​,
phi(i * primes[j]) = phi(i) * primes[j](1-1/primes[j]) = phi(i)*(primes[j]-1)
也可根据欧拉函数的积性， i mod primes[j] 不为0且primes[j]为质数,所以i与primes[j]互质,
phi(i * primes[j])=phi(i) * phi(primes[j]) 其中phi(primes[j])=primes[j]-1即第一条性质
int primes[N],cnt;
int eulers[N];
bool st[N];

void get_eulers(int n)
{
    eulers[1]=1;
    for(int i=2;i&amp;lt;=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            eulers[i]=i-1;
        }
        for(int j=0;primes[j]&amp;lt;=n/i;j++)
        {
            int t=i*primes[j];
            st[t]=true;
            if(i%primes[j]==0)
            {
                eulers[t]=eulers[i]*primes[j];
                break;
            }
            eulers[t]=eulers[i]*(primes[j]-1);
        }
    }
}

积性函数都可以用欧拉筛来求
整除分块（数论分块）



证明细节见：
https://blog.csdn.net/qq_41021816/article/details/84842956
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main(){
    long long n,ans=0;
    cin &amp;gt;&amp;gt; n;
    for(long long l=1,r;l&amp;lt;=n;l=r+1){
        r = n/(n/l);            //计算r，让分块右移
        ans += (r-l+1)*(n/l);   //求和
        cout &amp;lt;&amp;lt; l &amp;lt;&amp;lt;&amp;quot;&amp;quot;&amp;lt;&amp;lt; r &amp;lt;&amp;lt;&amp;quot;: &amp;quot;&amp;lt;&amp;lt; n/r &amp;lt;&amp;lt; endl;  //打印分块
    }
    cout &amp;lt;&amp;lt; ans;               //打印和
}

积性函数

常见的积性函数

积性函数性质



p为质数
积性函数的基本问题

狄利克雷卷积


线性筛求莫比乌斯函数

int primes[N],cnt;
int miu[N];
bool st[N];

void get_eulers(int n)
{
	memset(st,0,sizeof st);
    miu[1]=1;
    for(int i=2;i&amp;lt;=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            miu[i]=-1;
        }
        for(int j=0;i*primes[j]&amp;lt;=n;j++)
        {
            int t=i*primes[j];
            st[t]=true;
            if(i%primes[j]==0)
            {
                miu[t]=0;
                break;
            }
            miu[t]=-miu[i];//积性函数性质，miu[i]*miu[primes[j]]
        }
    }
}

莫比乌斯函数性质


莫比乌斯函数的由来


杜教筛


经典的杜教筛题目，例如洛谷P4213，求数论函数的前缀和。


杜教筛公式推导



唯一的因子分解

约数倍数的特征

求质约数
注意到一个数字 n 最多只有一个 &amp;gt; √n 的质约数，所以我们仍然只需要枚举到 √n
一个非常朴素的方法是枚举每个数字，判断是否是约数并判断是否是素数，但是这个方法的复杂度接近 O(n)，并不是一个非常明智的选择

void divide(int x)
{
    for (int i = 2; i &amp;lt;= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
        }
    if (x &amp;gt; 1) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; endl;
}

int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;
    while (n -- )
    {
        int x;
        cin &amp;gt;&amp;gt; x;
        divide(x);
    }

    return 0;
}

快速分解质因数
我们来考虑求出的 prime 数组的一个应用
如何能够在线性筛之后快速的分解一个数字的质约数呢？考虑在筛掉一个数字的时候记录一下他是被哪个质数筛掉的也即他的最小的质约数是谁。这样我们只要每次除掉一个最小的质约数就可以了。
for(int j = 1; prime[j] * i &amp;lt;= Max; ++ j) {
	from[i*prime[j]] = prime[j];
	...
}

查询时只需递归查询from[x],from[x/from[x]]...,一次查询的时间复杂度是O(logn)
约数个数 约数和
对于一个大于1正整数n可以分解质因数：n=p1a1*p2a2*p3a3*…*pkak,
则由约数个数定理可知n的正约数有(a₁+1)(a₂+1)(a₃+1)…(ak+1)个，
int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;

    unordered_map&amp;lt;int, int&amp;gt; primes;

    while (n -- )
    {
        int x;
        cin &amp;gt;&amp;gt; x;

        for (int i = 2; i &amp;lt;= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x &amp;gt; 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes) res = res * (p.second + 1) % mod;

    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    return 0;
}

n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为
f(n)=(p10+p11+p12+…p1a1)(p20+p21+p22+…p2a2)…(pk0+pk1+pk2+…pkak）
LL res = 1;
for (auto p : primes)
{
    LL a = p.first, b = p.second;
    LL t = 1;
    while (b -- ) t = (t * a + 1) % mod;
    res = res * t % mod;
}
cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

除法定理
对任意整数 a 和任意正整数 n， 存在唯一的整数 q 和 r，
满足 0 &amp;lt;= r &amp;lt; n，并且 a = qn + r.
值 q = a / n称为除法的商
值 r = a mod n 称为除法的余数。
n | a 当且仅当 a mod n = 0。
模 n 等价类
包含整数 a 的模 n 等价类为：[𝒂]𝒏[𝒂]_𝒏[a]n​= {𝒂 + 𝒌𝒏: 𝒌𝝐𝒁}
例如，[𝟑]𝟕[𝟑]_𝟕[3]7​= {… , −11, −𝟒, 𝟑, 10, 17, … }
𝒃𝝐[𝒂]𝒏[𝒂]_𝒏[a]n​ 等同于b = a (mod n)
-1 = n – 1 (mod n)
公约数与最大公约数
如果 d 是 a 的约数并且也是 b 的约数，则 d 是 a 与 b 的公约数。
例如，12 的约数是 1, 2, 3, 4, 6, 12，因此 8 与 12 的公约数为 1, 2, 4。 1 是任意两个整数的公约数。
公约数的重要性质为：
d | a 且 d | b 蕴含着 d | (a + b) 且 d | (a–b)
更一般的，对任意整数 x 和 y，有
d | a 且 d | b 蕴含着 d | (ax + by)
两个不同时为 0 的整数 a 与 b 的最大公约数表示成gcd(a, b)。
例如 gcd(12, 8) = 4，gcd(5, 9) = 1, gcd(0, 4) = 4.
定义 gcd(0, 0) = 0
gcd 函数的基本性质：
• gcd(a, b) = gcd(b, a)
• gcd(a, b) = gcd(-a, b)
• gcd(a, b) = gcd(|a|, |b|)
• gcd(a, 0) = |a|
• gcd(a, ka) = |a|
gcd 的其他性质
如果 a 和 b 是不都为 0 的任意整数，则 gcd(a, b) 是a 与 b 的线性组合集合 {ax + by: x, y ∈ Z}中的最小正元素。

裴蜀定理
对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。
它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.
上述裴蜀定理针对的是两个变量。那么我们很自然的就想到这样的定理能否推广到多个变量呢？显然可以，证明方法同上
模板题
我们只需要对这所有的数字求一个gcd，值得注意的是不要忘记数据中有负数，要将其变为正数再求gcd,因为系数的最终答案没有影响。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
int n;

int gcd(int a,int b)
{
	return b?gcd(b,a%b) : a;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	int ans=0;
	for(int i=0;i&amp;lt;n;i++)
	{
		int x;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
		if(x&amp;lt;0)	
			x=-x;
		ans=gcd(ans,x);
	}
	printf(&amp;quot;%d\n&amp;quot;,ans);
	return 0;
}

gcd 的其他性质
• 对于任意整数 a 和 b，如果 d | a 并且 d | b，则d | gcd(a, b)
证明：gcd(a,b)|a,gcd(a,b)|b,则gcd为最大的约数，则d | gcd(a, b)
• 对所有正整数 n, a 和 b，如果 n | ab 且 gcd(a, n)=1，则 n | b
互质数
如果两个整数 a 和 b 仅有公因数 1，即如果 gcd(a, b) = 1，则 a 与 b 称为互质数。
例如，5 和 9 是互质数。
对任意整数 p, a 和 b，如果 gcd(a, p) = gcd(b, p) = 1， 则 gcd(ab, p) = 1
证明：由线性组合的定理可知，存在整数x,y,x’ ，y’, 满足ax+py=1,bx’+py’=1
把上面两个等式两边相乘，整理得
ab(x x’)+p(ybx’+y’ax+pyy’)=1
因为1是ab与p的一个正线性组合，所以可以证明所需结论
欧几里得算法
欧几里得算法求最大公约数
利用性质：gcd(a, b) = gcd(b, a % b)
int gcd(int a, int b)
{
    return b?gcd(b,a%b):a;
}

因为每次取模，a 至少会变成原来的二分之一。
整个算法是 O(log n) 的。
求出了 gcd，就可以求出 lcm。
int lcm(int a, int b)
{
    return a / gcd(a, b) * b;
}


例题
hdu2503
给定 a, b, c, d (0 &amp;lt; a,b,c,d &amp;lt; 1000)。 求 a/b + c/d 的最简形式 e/f。

样例输入：
1 2 1 3
样例输出：
5 6
先通分，求b和d的最小公倍数。
分子相加后，再约掉分子和分母的最大公约数就是答案。
代码
扩展欧几里得算法与二元一次方程的整数解
给出整数a,b,n,问方程ax+by=n什么时候有整数解？如何求出所有的整数解?
有解的充分必要条件是gcd(a,b)可以整除n
证明：令a=gcd(a,b)a&#39;,b=gcd(a,b)b&#39;,有ax+by=gcd(a,b)(a&#39;x+b&#39;y)=n;如果x,y,a&#39;,b&#39;都是整数，那么n必须是gcd(a,b)的倍数才有解.
例如，4x+6y=8,2x+3y=4有整数解，4x+6y=7没有整数解。
如果有解，一种解题方法是先找到一个解（x0,y0）,那么通解公式如下：
x=x0+bt,y=y0-at,t是任意整数。
扩展欧几里得算法能计算出满足下列条件的整系数 x 和 y：gcd(a, b) = ax + by
我们来直接推倒一下：
ax + by = gcd(a, b)
注意到由欧几里得算法得：
gcd(a, b) = gcd(b, a % b)
因此：
ax + by = bx&#39; + (a % b)y&#39;
= bx&#39; + (a - int(a / b)b)y&#39;
= ay&#39; + b(x - int(a / b)y&#39;)
ax + by = ay&#39; + b(x&#39; - int(a / b)y&#39;)
每次求gcd的递归过程中同时将系数x，y计算出来，令x=y&#39;,y=x&#39;-a/b*y&#39;
例：求 9x + 7y = 1 的一组整数解

int exgcd(int a, int b, int &amp;amp;x, int &amp;amp;y) {
	if (!b) {
		x = 1, y = 0;
		return a;
	}
	int d = exgcd(b, a % b, x, y);
	int t = x;
	x = y;
	y = t - a / b * y;
	return d;
}

拓展欧几里得算法的应用
更一般的，求解 ax + by = c
只要 gcd(a, b) | c 就有无数解，否则无解

逆元
乘法逆元：对于一个数字 a, 在模 p 意义下如果存在一个数字 b,
满足 a × b ≡ 1 (mod p), 我们就称 b 是模 p 意义下 a 的乘法逆元，记做 a−1a^{-1}a−1 。
容易发现

现在我们可以对分子分母取模了！所以进行模运算的重点变成了求逆元。
欧拉函数
欧拉函数 φ(n), 定义为 1 到 n 中与 n 互质的数字的个数。

通过定义容易得到欧拉函数的前几项 1, 1, 2, 2, 4, 2, 6, · · ·
通过定义我们也很容易得到一个质数 p 的欧拉函数 φ(p) = p-1
我们也很容易写出一个求欧拉函数的简易做法，枚举

注意相同的质约数都是相同的 pi
有了这个公式我们就可以快速的求出一个数字 n 的欧拉函数φ(n) 了。
所以，欧拉函数ϕ(n)的求解，归结到了分解质因子这个问题。试除法：求n的质因子时，逐个检查从2到√n的所有质数，如果它能整除n，就是一个因子。试除法的复杂度是O(√n)
#include&amp;lt;iostream&amp;gt;
using namespace std;

int phi(int x)
{
    int res=x;
    for(int i=2;i&amp;lt;=x/i;i++)
    {
        if(x%i==0)
            res=res/i*(i-1);
        while(x%i==0)
            x/=i;
    }
    if(x&amp;gt;1)
        res=res/x*(x-1);
    return res;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    while(n--)
    {
        int x;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
        cout&amp;lt;&amp;lt;phi(x)&amp;lt;&amp;lt;endl;
    }
    return 0;
}

数论中的欧拉定理
如果 gcd(a, p) = 1 , 即 a, p 互质则有 aφ(p)a^{φ(p)}aφ(p) ≡ 1 (mod p)
注意这个定理的强制性要求是 a, p 互质，如果 a, p 不互质直接用这个做法是做不了的，我们还需要拓展欧拉定理才能处理这个问题
由此可以得到求 a 模 m 的逆的方法。
aφ(m)a^{φ(m)}aφ(m)≡ 1 (mod m)
a∗aφ(m)−1a * a^{φ(m)-1}a∗aφ(m)−1 ≡ 1 (mod m)
aφ(m)−1a^{φ(m)-1}aφ(m)−1 就是 a 模 m 的逆。
欧拉定理求逆元
有了这个定理我们要怎么求逆元呢？考虑逆元的定义，对于一个数字 a , 我所要寻找的 a−1a^{−1}a−1 需要满足 a × a−1a^{−1}a−1 ≡ 1 (mod p), 而 aφ(p)a^{φ(p)}aφ(p) ≡ 1 (mod p), 这对于我们是否有一些启示呢？
我们将 aφ(p)a^{φ(p)}aφ(p)写成 a × aφ(p)−1a^{φ(p)-1}aφ(p)−1 我们惊喜的发现原来 a−1a^{−1}a−1 启示就是 aφ(p)−1a^{φ(p)-1}aφ(p)−1 !
所以在求出欧拉函数之后我们只需要快速幂就能得到一个数字的逆元了。
int get_inv(int a) {
    return Pow(a,phi(p)-1);
}

有很多题目中给定的 p 是个质数，就是费马小定理。
如果 a, p 不互质怎么求逆元呢？事实上在后面我们会看到，a, p 不互质的情况下是不存在模 p 意义下 a的逆元的。
欧拉定理求同余方程
对于同余方程 ax ≡ b (mod m)
两边同乘 a 的逆 aφ(m)−1a^{φ(m)-1}aφ(m)−1 ax ≡ aφ(m)−1a^{φ(m)-1}aφ(m)−1 b (mod m)
就可以得到 x ≡ aφ(m)−1a^{φ(m)-1}aφ(m)−1 b (mod m)
比如：由φ(10) = 4，对于同余方程 3x ≡ 7 (mod 10)
解为 x ≡ aφ(m)−1a^{φ(m)-1}aφ(m)−1 b ≡ 333^333 * 7 ≡ 9 (mod 10)
扩展欧拉定理



模板题
代码
欧拉函数的性质



φ(36)=φ(4)φ(9)
第二行和第四行，每个元素都不和 4 互素。
剩下的两行，每个元素都和 4 互素，但各有 6 个数和 9 互素


同余
一个便于理解的定义：如果对于两个数字 a, b , 对于一个数字 m的余数相等，我们认为他们对于 m 同余
在数学上的标准定义：设 m 是给定的一个正整数，a, b 是整数，
若满足 m|(a - b) , 则称 a 与 b 对模 m 同余，记做 a ≡ b (mod m)

(a + b)%c 是否等于 ((a%c) + (b%c))%c
a ∗ b%c 是否等于 ((a%c) ∗ (b%c))%c
a/b%c 是否等于 (a%c)/(b%c)
对于 1，2 两个式子来说，是正确的，而对于第三个式子来说，是错误的

线性同余方程
设 x 是未知整数，形如ax ≡ b (mod m)的同余式成为一元线性同余方程
ax ≡ b (mod m)，即ax除以m,b除以m,两者余数相同，这里a,b,m都是整数，求解x的值。
方程也可以这样理解，ax-b是m的整数倍。设y是倍数，那么ax-b=my,移项得到ax-my=b.因为y可以是负数，改写为ax+my=b，这就是在扩展欧几里得算法中提到的二元一次不定方程。
当且仅当gcd(a,m)能整除b时有整数解。
ax ≡ 1 (mod m) 的解称为 a 模 m 的逆。
如 7x ≡ 1 (mod 31) 的解满足 x ≡ 9 (mod 31)
设a 模 m 的一个逆为 k，即 ak ≡ 1 (mod m)
对于 ax ≡ b (mod m)，两边同乘以 k，得到 akx ≡ bk(mod m)
也即 x ≡ bk (mod m)
定理：设 p 是素数，正整数 a 是其自身模 p 的逆，当且仅当 a ≡ 1 (mod p) 或 a ≡ -1 (mod p)
证明：若a ≡ 1 (mod p) 或 a ≡ -1 (mod p),则a² ≡ 1 (mod p) ,所以a其自身模p的逆。反过来，若a是其自身模p
的逆，则a²=a·a ≡ 1 (mod p) 。因此，p |(a² -1)。又因为a² -1=（a-1）（a+1），所以p |（a-1）或p |（a+1）。
因此，或者a ≡ 1 (mod p) ，或者a ≡ -1 (mod p)
#include&amp;lt;iostream&amp;gt;
using namespace std;

int exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    
    int d=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return d;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    while(n--)
    {
        int a,b,m;
        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;m);
        int x,y;
        int d=exgcd(a,m,x,y);
        if(b%d)
            puts(&amp;quot;impossible&amp;quot;);
        else
            printf(&amp;quot;%d\n&amp;quot;,((long long)b/d*x%m+m)%m);
    }
    return 0;
}

扩展欧几里得求乘法逆元
ax = 1 (mod m)
ax + my = 1
也就是 a, m 是已知数，现在要求出一组 x, y , 使得上面的式子成立。
这也就印证了上面欧拉定理中的一句话，如果想要存在 a 对 m 的逆元，必须要 gcd(a, m) = 1 (1%gcd(a,m) = 0)才可以
当然如果 gcd(a, m) != 1，就无解
注意到 x 的解是 x0 + km （k是任意整数）
我们只要求出一个 k 使得 x0 + km 是最小的正整数即可。
另外需要注意的是我们求出的 x 有可能是负数，这时候我们可以让 x 加上若个个 p, 这样显然是不会影响方程的，例如我在 x 上加了一个 p, 那么在 y 上减去 a 就能保证方程依然成立。

费马小定理
假如 p 是质数，且 (a, p)=1，那么ap−1a^{p-1}ap−1 ≡ 1 (mod p)
因此可以得到，a∗ap−2a * a^{p-2}a∗ap−2 ≡ 1 (mod p)
所以 ap−2a^{p-2}ap−2 是 a 模 p 的一个逆。
可以用快速幂加速计算。
#include&amp;lt;iostream&amp;gt;
using namespace std;
typedef long long LL;
int qml(int a,int b,int p)
{
    int res=1;
    while(b)
    {
        if(b&amp;amp;1)
            res=(LL)res*a%p;
        a=(LL)a*a%p;
        b&amp;gt;&amp;gt;=1;
    }
    return res;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    while(n--)
    {
        int b,p;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;b,&amp;amp;p);
        if(b%p==0)
            puts(&amp;quot;impossible&amp;quot;);
        else
            printf(&amp;quot;%d\n&amp;quot;,qml(b,p-2,p));
    }
    return 0;
}

线性求逆元
给定 n, p 求 [1, n] 中所有整数在模 p 意义下的乘法逆元，n ≤ 2 × 1e6, p ≤ 2 × 1e7。
我们考虑从 1 到 n 依此求出每个数字的逆元，枚举变量 i, 1 → n,
默认 [1, i - 1] 每个数字对于 p 的逆元都已经求完,现在我们考虑 i 对 p 的逆元要怎么求。
不妨把 p 写成 ki + b 的形式也即


模板题
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=3e6+10;
int inv[N];
int main()
{
    int n,p;
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;p);
    inv[1]=1;
    for(int i=2;i&amp;lt;=n;i++)
        inv[i]=(LL)(p-p/i)*inv[p%i]%p;
    for(int i=1;i&amp;lt;=n;i++)
    	printf(&amp;quot;%d\n&amp;quot;,inv[i]);
    return 0;
}

阶乘的逆元
这里特别列出阶乘的逆元，因为后面有组合数学和组合数取模相关的问题，所以这里特别列出了阶乘如何求逆元。
有很多同学会认为先求出 [1, n] 每个数字对p的逆元就可以了。这样处理确实可以，但是过于繁琐，我们考虑一共更简单的做法。

int ifac[N], fac = 1, mod;
for(int i = 2; i &amp;lt;= n; ++ i) 
	fac = (long long) fac * i % mod;
ifac[n] = get_inv(fac, mod);
for(int i = n - 1; i &amp;gt;= 0; -- i) 
	ifac[i] = (long long)ifac[i + 1] * (i + 1) % mod;

线性同余方程组
第一种：有两个以上的不同模的一元线性同余方程；
第二种：变元数大于 1，方程数大于 1，但是方程的模相同
中国剩余定理
下面取自成书于公元 3 世纪晚期的《孙子算经》的问题。
求一个数，它被 3 除余 1，被 5 除余 2，被 7 除余 3。
这也就等价于如下方程组：
x ≡ 1 (mod 3)
x ≡ 2 (mod 5)
x ≡ 3 (mod 7)


正确性显然，代入即可。还需要证明唯一性。

x ≡ 1 (mod 3)
x ≡ 2 (mod 5)
x ≡ 3 (mod 7)
现在回到开头的那个方程组，首先有 M = 105
M1 = 35，M2 = 21，M3 = 15
y1 = 2, y2 = 1, y3 = 1
因此 x ≡ 1 * 35 * 2 + 2 * 21 * 1 + 3 * 15 * 1 ≡ 157≡ 52 (mod 105)
中国剩余定理给出了模数两两互质的线性同余方程组的一个特殊解。方程组的通解可以表示为x+kM（k∈Z）。有些题目要求我们求出最小的非负整数解，只需把x对M取模，并让x落在0~M-1的范围内即可。
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=15;
int n;
int a[N],b[N];

void exgcd(LL a,LL b,LL &amp;amp;x,LL &amp;amp;y)
{
	if(!b)
	{
		x=1,y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	LL t=x;
	x=y;
	y=t-a/b*y;
}

LL crt()
{
	LL M=1,res=0;
	for(int i=1;i&amp;lt;=n;i++)
		M*=a[i];
	for(int i=1;i&amp;lt;=n;i++)
	{
		LL m,x,y;
		m=M/a[i];
		exgcd(m,a[i],x,y);
		res=(res+m*x*b[i])%M;
	}
	return (res%M+M)%M;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a[i],&amp;amp;b[i]);
	printf(&amp;quot;%lld\n&amp;quot;,crt());
	return 0;
}

扩展中国剩余定理

证明：




模板题
code

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/shu-lun/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/kuai-su-mi-andju-zhen-kuai-su-mi/">
                        快速幂&amp;矩阵快速幂
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-26</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            快速幂
给出 a，b, c，求出 aba^bab mod c.a, b, c &amp;lt;= 1e9
枚举 b，连续乘 b 次 a，每乘一次对 c 取模一次。
时间复杂度关于 b 线性。
每次都乘的是 a，重复运算太多，考虑分治
比如计算出 a,a2,a4,a8,a16a, a^2, a^4, a^8, a^{16}a,a2,a4,a8,a16, …
对 b 进行二进制转换，比如 b = 11 = 8 + 2 + 1
故 ab=a11=a8∗a2∗aa^b = a^{11} = a^8 * a^2 * aab=a11=a8∗a2∗a
因此，只要预处理出 log2109log_2 10^9log2​109 个 a 的幂次
计算的时候分解成 log2 b 个乘积即可
模板题
int qmi(int a,int b,int p)
{
    int res=1%p;
    while(b)
    {
        if(b&amp;amp;1)
            res=(long long)res*a%p;
        a=(long long)a*a%p;
        b&amp;gt;&amp;gt;=1;
    }
    return res;
}

快速乘
给出 a，b, c，求出 a∗ba * ba∗b mod c.a, b, c &amp;lt;= 1e18
沿用之前的做法，但是注意这里的模数是 1e18。如果两个小于 1e18 的数相乘，long long也存不下。
考虑到幂次可以转化为连乘，乘法也可以转化为连加。
同样的我们可以得到一个“快速”乘
比如计算出 a, 2a, 4a, 8a, 16a, …
对 b 进行二进制转换，比如 b = 11 = 8 + 2 + 1
故 ba = 11a = 8a + 2a + a
因此，只要预处理出 log21018log_2 10^{18}log2​1018 个 a 的乘积
计算的时候分解成 log2 b 个加法即可。
因为每次两个小于 1e18 的数相加，long long是可以存的。
模板题
long long mul(long long a, long long b, long long c)
{
    long long ans = 0;
    while (b) 
    {
        if (b &amp;amp; 1) ans = (ans + a) % c;
        b &amp;gt;&amp;gt;= 1;
        a = (a + a) % c;
    }
    return ans; 
}

例题
luoguP1965
答案显然就是 (x + m * 10^k) % n
根据模运算的的分配率可以得到 (x%n+m%n*10k%n)%n,只需用快速幂求出10k就可以了
代码
矩阵乘法
给定一个大小为 n × m 的矩阵 A[n][m]
和一个大小为 m × r 的矩阵 B[m][r]
    for (int i = 1;i &amp;lt;= n;i ++)
        for (int j = 1;j &amp;lt;= r;j ++)
            for (int k = 1;k &amp;lt;= m;k ++)
                C[i][j] += A[i][k] * B[k][j];
时间复杂度: O(n^3)

矩阵快速幂
poj3233
给定一个 n × n 的矩阵 A，和一个正整数 k。 求 S=A+A2+…+AkS = A + A^2 + … + A^kS=A+A2+…+Ak，对 m 取模,n ≤ 30，k ≤ 1e9

样例输入：
2 2 4
0 1
1 1
样例输出：
1 2
2 3
注意到，矩阵乘法也是具有结合律和乘法分配律的。
因此：(I为单位阵)
A+A2=A(I+A)A + A^2 = A(I + A)A+A2=A(I+A)
A+A2+A3+A4=(A+A2)(I+A2)A + A^2 + A^3 + A^4 = (A + A^2)(I + A^2)A+A2+A3+A4=(A+A2)(I+A2)
我们记 sum(n)=A+A2+…+Ansum(n) = A + A^2 + … + A^nsum(n)=A+A2+…+An
如果 n 是偶数:
sum(n)=sum(n/2)(I+An/2)sum(n) = sum(n / 2)(I + A^{n/2})sum(n)=sum(n/2)(I+An/2)
如果 n 是奇数：
sum(n)=sum(n−1)+An=sum((n−1)/2)(I+A(n−1)/2）+Ansum(n) = sum(n - 1) + A^n = sum((n - 1) / 2)(I + A^{(n-1)/2}）+ A^nsum(n)=sum(n−1)+An=sum((n−1)/2)(I+A(n−1)/2）+An
只需要解决如何快速求 A^n
对于整数的幂次，我们可以用快速幂来求。
对于矩阵的幂次，我们也可以用快速幂来求。
注意的是，初始值要设置为单位矩阵 I。也就是 A0A^0A0.
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=35;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
}a;
int n,k,mod;

matrix add(matrix a,matrix b)
{
	matrix res;
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
			res.m[i][j]=(a.m[i][j]+b.m[i][j])%mod;
	return res;
}

matrix mul(matrix a,matrix b)
{
	matrix c;
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
			for(int k=1;k&amp;lt;=n;k++)
				c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return c;
}

matrix qmi(matrix a,int k)
{
	matrix c;
	for(int i=1;i&amp;lt;=n;i++)
		c.m[i][i]=1;
	while(k)
	{
		if(k &amp;amp; 1)
			c=mul(c,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return c;
}

matrix get_sum(matrix a,int k)
{
	if(k == 1)
		return a;
	matrix c;
	for(int i=1;i&amp;lt;=n;i++)
		c.m[i][i]=1;
	
	c=add(c,qmi(a,k&amp;gt;&amp;gt;1));
	c=mul(c,get_sum(a,k&amp;gt;&amp;gt;1));
	if(k &amp;amp; 1)
		c=add(c,qmi(a,k));
	return c;
 } 

int main()
{
	scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;mod);
	
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a.m[i][j]);
	
	a=get_sum(a,k);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		for(int j=1;j&amp;lt;=n;j++)
			printf(&amp;quot;%d &amp;quot;,a.m[i][j]);
		puts(&amp;quot;&amp;quot;);
	}
		
	return 0;
}

矩阵乘法优化递推
poj3070


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=2,mod=10000;
int n;
struct matrix
{
    int m[N][N];
    matrix()
    {
    	memset(m,0,sizeof m);
	}
    matrix(int a[][N])
    {
        memcpy(m,a,sizeof m);
    }
};

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&amp;lt;2;i++)
		for(int j=0;j&amp;lt;2;j++)
			for(int k=0;k&amp;lt;2;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&amp;lt;2;i++)
		res.m[i][i]=1;
	
	while(k)
	{
		if(k &amp;amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return res;
}

int main()
{
	while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; ~n)
	{
		int f[N][N]={{1,0}};
		int c[N][N]={{1,1},{1,0}};
		matrix a=c;
		matrix b=f;
		if(n)
		{
			a=qmi(a,n-1);
			b=mul(b,a);
			printf(&amp;quot;%d\n&amp;quot;,b.m[0][0]);
		}
		else 
			printf(&amp;quot;0\n&amp;quot;);	
	}
}


acwing1303

代码

数列f[n]=f[n-1]+f[n-2]+1,f[1]=f[2]=1的第n项的快速求法（不考虑高精度）
仿照前例，考虑1×3的矩阵[f[n-2],f[n-1],1]，希望求得某3×3的矩阵A，使得此1×3的矩阵乘以A得到矩阵：
[f[n-1],f[n],1]
即：[]f[n-2],f[n-1],1]* A ＝[f[n-1],f[n],1] =[f[n-1],f[n-1]+f[n-2]+1,1]
容易构造出这个3×3的矩阵A，即：
０ １ ０
１ １ ０
０ １ １

数列f[n]=f[n-1]+f[n-2]+n+1,f[1]=f[2]=1的第n项的快速求法（不考虑高精度）.
解法：
仿照前例，考虑1×4的矩阵[f[n-2],f[n-1],n,1]，希望求得某4×4的矩阵A，使得此1×4的矩阵乘以A得到矩阵：[f[n-1],f[n],n+1,1]
即：[f[n-2],f[n-1],n,1]* A  = [f[n-1],f[n],n+1,1]＝[f[n-1],f[n-1]+f[n-2]+n+1,n+1,1]
容易构造出这个4×4的矩阵A，即：
０ １ ０ ０
１ １ ０ ０
０ １ １ ０
０ １ １ １

例题
poj3735
有 n 只小猫，要执行一些操作序列。
g i：给第 i 只小猫一棵花生
e i：让第 i 只小猫吃掉它的所有花生
s i j：让第 i 只小猫和第 j 只小猫交换他们手里的花生。
现在给你一个长度为 k 的序列，让你反复执行这个序列 m
次。问最后每只小猫手里的花生数。n≤100，k≤100，m≤1e9
联系矩阵优化递推。
如果我们也能求出一个序列对应的矩阵。
只要求矩阵的 m 次幂即可。
先考虑如何设计状态：
把刚才那3只猫看做一个矩阵{a,b,c},分别代表他们有的花生个数，显然初始是{0,0,0}
当进行s操作的时候，我们将初始矩阵乘上一个矩阵，得到的那个矩阵最好也是1行3列的。
那肯定我们要构造的那个矩阵是3*3的矩阵
s 1 2交换操作就是{a,b,c}*x={b,a,c}
x=  0 1 0
    1 0 0
    0 0 1

S操作是这样的，首先将X看做一个单位矩阵，要交换哪两个，只需要交换他们的列就可以了
对于e操作近似于s操作，将e 2举例：{a,b,c}*x={a,0,c}
x=  1 0 0
    0 0 0
    0 0 1

即将某列置于0
现在问题来了，怎么构造g操作的矩阵。使下面这个等式成立
g 1操作  {a,b,c}*X={a+1,b,c}
g 2操作  {a,b,c}*X={a,b+1,c}
g 3操作  {a,b,c}*X={a,b,c+1}
我们不妨再{a,b,c}矩阵多加一个1，这样我们就能实现我们的+1操作了
要使g 1操作实现{a,b,c,1}*x={a+1,b,c,1}
那么
x=  1 0 0 0
    0 1 0 0
    0 0 1 0
    1 0 0 1

当然这样构造矩阵，这样并不影响我们前面的s与e操作
这样一系列操作之后：

得到这个矩阵后，求它的 m 次幂，然后乘上初始状态对应
的向量，得到的就是答案。
时间复杂度: O(n^3log m)
代码
poj3150
有 n 个数排成一个环。定义一次变换为：把这个数变成距离它不超过 d 的位置上的数之和对 m 取模的值。
问这样变换 k 次后，每个位置上的数是多少。
n &amp;lt;= 500, m &amp;lt;= 109, k &amp;lt;= 1e9
对于每一次变换，其实可以写成一个矩阵：
比如题中 d = 2



因此一个矩阵只要存下第一行就可以得到整个矩阵。
计算矩阵乘法的时候，只要枚举 n^2 次。
时间复杂度变成了 O(n^2 log k)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=510;
int n,mod,d,k;
struct matrix 
{
	int m[N];
	matrix()
	{
		for(int i=0;i&amp;lt;N;i++)
			m[i]=0;
	}
	matrix(int a[])
	{
		memcpy(m,a,sizeof m);
	}
};

matrix mul(matrix a,matrix b)
{
	matrix res;
	
	for(int i=0;i&amp;lt;n;i++)//只计算res的第一行 
		for(int k=0;k&amp;lt;n;k++)
			res.m[i]=(res.m[i]+(LL)a.m[k]*b.m[(i-k+n)%n])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	res.m[0]=1;
		
	while(k)
	{
		if(k&amp;amp;1) res=mul(res,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return res;
}

int main()
{
	scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;mod,&amp;amp;d,&amp;amp;k);
	matrix b;
	for(int i=0;i&amp;lt;n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;b.m[i]);
	matrix a;
	for(int i=0;i&amp;lt;n;i++)
		if(i&amp;lt;=d || (i+d)%n == 0)
			a.m[i]=1;
	a=qmi(a,k);	
//	for(int i=0;i&amp;lt;n;i++)
//		printf(&amp;quot;%d &amp;quot;,a.m[i]);
	b=mul(b,a);
	for(int i=0;i&amp;lt;n;i++)
		printf(&amp;quot;%d &amp;quot;,b.m[i]);
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/kuai-su-mi-andju-zhen-kuai-su-mi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
                
                    <a href="https://caifxh.github.io/page/2" class="page-btn btn">下一页</a>
                    
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://caifxh.github.io/images/avatar.png?v=1585732375323)">
        </div>
        <h1 class="id_card-title">
            fxh
        </h1>
        <h2 class="id_card-description">
            菜
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>