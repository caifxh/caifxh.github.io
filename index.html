<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1585231131035">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1585231131035" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/shu-lun/">
                        数论
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-26</time>
                    
                        <a href="https://caifxh.github.io/tag/14SoYNkfD/" class="post-tag i-tag
                            i-tag-info">
            #数学
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            数论
除法和模运算
计算机中整数和整数的除法是整数除法，即 a ÷ b = ⌊ ab ⌋.
模运算即是两数相除的余数，在 c++ 的代码中用 a%b 来计算这
个数字，通过一些小学知识我们容易得到
a % b = a − ⌊a/b⌋ × b
整除性和约数
整除是数论中的一个中心概念。
如果两个数字 a, b, 满足 a % b = 0 , 那么我们就说 a 是 b 的倍数，同时也说 b 是 a 的约数，计做 b | a 。
在通常情况下，我们考虑一个数字的约数和倍数，都只考虑他的正约数和正倍数。
• 记号 d | a 意味着对某个整数 k，有 a = kd。
• 0 可被任何整数整除。0=0*d,d|0
• 如果 d | a 我们称 a 是 d 的倍数，d 是 a 的约数。
• 一个整数 a 的约数最小为 1， 最大为 |a|。 • 例如：12 的约数有 1, 2, 3, 4, 6, 12
求约数
如何才能求出一个数字 n 的所有约数呢？
一个非常朴素的方法, 从 1 到 n 枚举，复杂度 O(n)
注意到约数总是成对出现的，即如果有 a ÷ b = c 就一定会有a ÷ c = b
我们以 ⌊√n⌋ 作为一个限度，只枚举到 √n(注意 n 是完全平方数的情况)
vector&amp;lt;int&amp;gt; get_div(int x)
{
    vector&amp;lt;int&amp;gt; res;
    for (int i = 1; i &amp;lt;= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}

int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;

    while (n -- )
    {
        int x;
        cin &amp;gt;&amp;gt; x;
        auto res = get_div(x);

        for (auto x : res) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}

求倍数
一个数字的倍数有无穷多个，所以很难求出所有的倍数，我们通常只求出 n 以内 a 的所有倍数。
和求约数相同，我们同样可以想到一个 O(n) 的简单方法，即枚举
对于一个数字 a , 他的所有倍数一定是 a, 2a, 3a, 4a, . . . , ⌊n/a⌋a, 每个倍数都比前一个倍数多 a, 所以我们可以从 a 开始每次加 a 枚举他的下一个倍数
复杂度分析：考虑一种极限情况，a = 1 , 此时枚举相当于从 1枚举到 n , 所以复杂度其实还是 O(n)
然而我们后面会看到，如果对于每个数字都枚举倍数的话，复杂度会有所下降。
素数和合数
对于某个整数 a &amp;gt; 1，如果它仅有约数 1 和 a，则称 a 为素数（或质数）
前 10 个素数: 2, 3, 5, 11, 13, 17, 19, 23, 29, 31
不是素数的整数 a &amp;gt; 1 称为合数。
例如，因为 2 | 10，所以 10 是合数。
整数 1 既不是素数也不是合数
如何判断一个数字是否是质数呢？定义判断即可
bool is_prime(int x)
{
    if(x&amp;lt;2)
        return false;
    for(int i=2;i&amp;lt;=x/i;i++)
    {
        if(x%i==0)
            return false;
    }
    return true;
}

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    while(n--)
    {
        int x;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
        if(is_prime(x))
            puts(&amp;quot;Yes&amp;quot;);
        else
            puts(&amp;quot;No&amp;quot;);
    }
    return 0;
}

埃拉托斯特尼筛法
埃氏筛法的原理是：每个合数都是多个质数的积；那么从最小的质数2开始，用每一个质数去筛比它大的数，就能筛掉合数。埃氏筛法低效的原因是，一个合数会被它的多个质因子重复筛。
我们考虑这样一个事实，如果一个数字是另外一个数字的倍数，那么这个数字一定不是素数，既然这样我们每枚举到一个数字 i，就可以把他所有的倍数全都设置成不是质数，这样从来没被标记过的数字就是质数了。
算法思想：每个质数都可以把它的倍数筛掉
时间复杂度：O(nloglogn)
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i &amp;lt;= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j &amp;lt;= n; j += i)
            st[j] = true;
    }
}

例题
bzoj1607
题意：给定 n 个数，对于其中的每一个数字，询问有多少个数是他的约数。

代码
线性筛（欧拉筛）
再次把眼光放回如何判断 [1, n]中哪些数字是质数这个问题上来。考虑之前的做法为什么会运行的比较缓慢呢？事实上我们在确认一个数字不是质数的时候，要用很多数字来筛选他才可以，比如数字 6, 我们在枚举 2的倍数的时候筛了他一次，在枚举 3 的倍数的时候筛了他一次，有没有什么办法能够让他只被筛选一次呢？
考虑这样一种想法，如果每个数字都只被他最小的质约数筛一次，那么复杂度就可以达到 O(n)。可是如何才能实现呢？这是一个类似构造的想法
$i=p_1^{k_1} * p_2^{k_2} * ... * p_s^{k_s} 
i * primes[j]=primes[j] * p_1^{k_1} * p_2^{k_2} * ... * p_s^{k_s}当i当i
当i%primes[j]不为0时，i*primes[j]的最小质因数为primes[j];
当i%primes[j]为0之后，i*primes[j]的最小质因数为当i当ip_1$而不是primes[j],此时不能再用primes[j]筛去，否则违背只用最小质因数筛的方法。

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i &amp;lt;= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] &amp;lt;= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

线性筛欧拉函数
回顾一下，我们在求逆元的时候介绍了一个函数，欧拉函数φ(n), 并介绍了一种 √n求一个欧拉函数的方法，现在我们考虑能不能 O(n) 时间内求出 [1, n] 每个数字的欧拉函数函数值呢？
考虑在线性筛的同时能不能把欧拉函数值也更新一下，注意到线性筛的时候每个数字只会被筛到一次，我们能否在这个时候顺便求出欧拉函数的函数值呢？
考虑他在被筛的时候函数的取值应该是多少
i. I是个质数,phi(p)=p-1
2.如果i % primes[j] = 0, 那么phi(i * primes[j])=primes[j] * phi(i)
原因：iprimes[j]的质因数构成和i相同，但primes[j]的次数多1
3.如果 i%prime[j] 不为 0，即primes[j]小于i的最小质因子p1p_1p1​,
phi(i * primes[j]) = phi(i) * primes[j](1-1/primes[j]) = phi(i)*(primes[j]-1)
也可根据欧拉函数的积性， i mod primes[j] 不为0且primes[j]为质数,所以i与primes[j]互质,
phi(i * primes[j])=phi(i) * phi(primes[j]) 其中phi(primes[j])=primes[j]-1即第一条性质
int primes[N],cnt;
int eulers[N];
bool st[N];

void get_eulers(int n)
{
    eulers[1]=1;
    for(int i=2;i&amp;lt;=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            eulers[i]=i-1;
        }
        for(int j=0;primes[j]&amp;lt;=n/i;j++)
        {
            int t=i*primes[j];
            st[t]=true;
            if(i%primes[j]==0)
            {
                eulers[t]=eulers[i]*primes[j];
                break;
            }
            eulers[t]=eulers[i]*(primes[j]-1);
        }
    }
}

积性函数都可以用欧拉筛来求
整除分块（数论分块）



证明细节见：
https://blog.csdn.net/qq_41021816/article/details/84842956
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main(){
    long long n,ans=0;
    cin &amp;gt;&amp;gt; n;
    for(long long l=1,r;l&amp;lt;=n;l=r+1){
        r = n/(n/l);            //计算r，让分块右移
        ans += (r-l+1)*(n/l);   //求和
        cout &amp;lt;&amp;lt; l &amp;lt;&amp;lt;&amp;quot;&amp;quot;&amp;lt;&amp;lt; r &amp;lt;&amp;lt;&amp;quot;: &amp;quot;&amp;lt;&amp;lt; n/r &amp;lt;&amp;lt; endl;  //打印分块
    }
    cout &amp;lt;&amp;lt; ans;               //打印和
}

积性函数

常见的积性函数

积性函数性质



p为质数
积性函数的基本问题

狄利克雷卷积


线性筛求莫比乌斯函数

int primes[N],cnt;
int miu[N];
bool st[N];

void get_eulers(int n)
{
	memset(st,0,sizeof st);
    miu[1]=1;
    for(int i=2;i&amp;lt;=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            miu[i]=-1;
        }
        for(int j=0;i*primes[j]&amp;lt;=n;j++)
        {
            int t=i*primes[j];
            st[t]=true;
            if(i%primes[j]==0)
            {
                miu[t]=0;
                break;
            }
            miu[t]=-miu[i];//积性函数性质，miu[i]*miu[primes[j]]
        }
    }
}

莫比乌斯函数性质


莫比乌斯函数的由来


杜教筛


经典的杜教筛题目，例如洛谷P4213，求数论函数的前缀和。


杜教筛公式推导



唯一的因子分解

约数倍数的特征

求质约数
注意到一个数字 n 最多只有一个 &amp;gt; √n 的质约数，所以我们仍然只需要枚举到 √n
一个非常朴素的方法是枚举每个数字，判断是否是约数并判断是否是素数，但是这个方法的复杂度接近 O(n)，并不是一个非常明智的选择

void divide(int x)
{
    for (int i = 2; i &amp;lt;= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
        }
    if (x &amp;gt; 1) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; endl;
}

int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;
    while (n -- )
    {
        int x;
        cin &amp;gt;&amp;gt; x;
        divide(x);
    }

    return 0;
}

快速分解质因数
我们来考虑求出的 prime 数组的一个应用
如何能够在线性筛之后快速的分解一个数字的质约数呢？考虑在筛掉一个数字的时候记录一下他是被哪个质数筛掉的也即他的最小的质约数是谁。这样我们只要每次除掉一个最小的质约数就可以了。
for(int j = 1; prime[j] * i &amp;lt;= Max; ++ j) {
	from[i*prime[j]] = prime[j];
	...
}

查询时只需递归查询from[x],from[x/from[x]]...,一次查询的时间复杂度是O(logn)
约数个数 约数和
对于一个大于1正整数n可以分解质因数：n=p1a1*p2a2*p3a3*…*pkak,
则由约数个数定理可知n的正约数有(a₁+1)(a₂+1)(a₃+1)…(ak+1)个，
int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;

    unordered_map&amp;lt;int, int&amp;gt; primes;

    while (n -- )
    {
        int x;
        cin &amp;gt;&amp;gt; x;

        for (int i = 2; i &amp;lt;= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x &amp;gt; 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes) res = res * (p.second + 1) % mod;

    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    return 0;
}

n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为
f(n)=(p10+p11+p12+…p1a1)(p20+p21+p22+…p2a2)…(pk0+pk1+pk2+…pkak）
LL res = 1;
for (auto p : primes)
{
    LL a = p.first, b = p.second;
    LL t = 1;
    while (b -- ) t = (t * a + 1) % mod;
    res = res * t % mod;
}
cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

除法定理
对任意整数 a 和任意正整数 n， 存在唯一的整数 q 和 r，
满足 0 &amp;lt;= r &amp;lt; n，并且 a = qn + r.
值 q = a / n称为除法的商
值 r = a mod n 称为除法的余数。
n | a 当且仅当 a mod n = 0。
模 n 等价类
包含整数 a 的模 n 等价类为：[𝒂]𝒏[𝒂]_𝒏[a]n​= {𝒂 + 𝒌𝒏: 𝒌𝝐𝒁}
例如，[𝟑]𝟕[𝟑]_𝟕[3]7​= {… , −11, −𝟒, 𝟑, 10, 17, … }
𝒃𝝐[𝒂]𝒏[𝒂]_𝒏[a]n​ 等同于b = a (mod n)
-1 = n – 1 (mod n)
公约数与最大公约数
如果 d 是 a 的约数并且也是 b 的约数，则 d 是 a 与 b 的公约数。
例如，12 的约数是 1, 2, 3, 4, 6, 12，因此 8 与 12 的公约数为 1, 2, 4。 1 是任意两个整数的公约数。
公约数的重要性质为：
d | a 且 d | b 蕴含着 d | (a + b) 且 d | (a–b)
更一般的，对任意整数 x 和 y，有
d | a 且 d | b 蕴含着 d | (ax + by)
两个不同时为 0 的整数 a 与 b 的最大公约数表示成gcd(a, b)。
例如 gcd(12, 8) = 4，gcd(5, 9) = 1, gcd(0, 4) = 4.
定义 gcd(0, 0) = 0
gcd 函数的基本性质：
• gcd(a, b) = gcd(b, a)
• gcd(a, b) = gcd(-a, b)
• gcd(a, b) = gcd(|a|, |b|)
• gcd(a, 0) = |a|
• gcd(a, ka) = |a|
gcd 的其他性质
如果 a 和 b 是不都为 0 的任意整数，则 gcd(a, b) 是a 与 b 的线性组合集合 {ax + by: x, y ∈ Z}中的最小正元素。

裴蜀定理
对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。
它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.
上述裴蜀定理针对的是两个变量。那么我们很自然的就想到这样的定理能否推广到多个变量呢？显然可以，证明方法同上
模板题
我们只需要对这所有的数字求一个gcd，值得注意的是不要忘记数据中有负数，要将其变为正数再求gcd,因为系数的最终答案没有影响。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
int n;

int gcd(int a,int b)
{
	return b?gcd(b,a%b) : a;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	int ans=0;
	for(int i=0;i&amp;lt;n;i++)
	{
		int x;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
		if(x&amp;lt;0)	
			x=-x;
		ans=gcd(ans,x);
	}
	printf(&amp;quot;%d\n&amp;quot;,ans);
	return 0;
}

gcd 的其他性质
• 对于任意整数 a 和 b，如果 d | a 并且 d | b，则d | gcd(a, b)
证明：gcd(a,b)|a,gcd(a,b)|b,则gcd为最大的约数，则d | gcd(a, b)
• 对所有正整数 n, a 和 b，如果 n | ab 且 gcd(a, n)=1，则 n | b
互质数
如果两个整数 a 和 b 仅有公因数 1，即如果 gcd(a, b) = 1，则 a 与 b 称为互质数。
例如，5 和 9 是互质数。
对任意整数 p, a 和 b，如果 gcd(a, p) = gcd(b, p) = 1， 则 gcd(ab, p) = 1
证明：由线性组合的定理可知，存在整数x,y,x’ ，y’, 满足ax+py=1,bx’+py’=1
把上面两个等式两边相乘，整理得
ab(x x’)+p(ybx’+y’ax+pyy’)=1
因为1是ab与p的一个正线性组合，所以可以证明所需结论
欧几里得算法
欧几里得算法求最大公约数
利用性质：gcd(a, b) = gcd(b, a % b)
int gcd(int a, int b)
{
    return b?gcd(b,a%b):a;
}

因为每次取模，a 至少会变成原来的二分之一。
整个算法是 O(log n) 的。
求出了 gcd，就可以求出 lcm。
int lcm(int a, int b)
{
    return a / gcd(a, b) * b;
}


例题
hdu2503
给定 a, b, c, d (0 &amp;lt; a,b,c,d &amp;lt; 1000)。 求 a/b + c/d 的最简形式 e/f。

样例输入：
1 2 1 3
样例输出：
5 6
先通分，求b和d的最小公倍数。
分子相加后，再约掉分子和分母的最大公约数就是答案。
代码
扩展欧几里得算法与二元一次方程的整数解
给出整数a,b,n,问方程ax+by=n什么时候有整数解？如何求出所有的整数解?
有解的充分必要条件是gcd(a,b)可以整除n
证明：令a=gcd(a,b)a&#39;,b=gcd(a,b)b&#39;,有ax+by=gcd(a,b)(a&#39;x+b&#39;y)=n;如果x,y,a&#39;,b&#39;都是整数，那么n必须是gcd(a,b)的倍数才有解.
例如，4x+6y=8,2x+3y=4有整数解，4x+6y=7没有整数解。
如果有解，一种解题方法是先找到一个解（x0,y0）,那么通解公式如下：
x=x0+bt,y=y0-at,t是任意整数。
扩展欧几里得算法能计算出满足下列条件的整系数 x 和 y：gcd(a, b) = ax + by
我们来直接推倒一下：
ax + by = gcd(a, b)
注意到由欧几里得算法得：
gcd(a, b) = gcd(b, a % b)
因此：
ax + by = bx&#39; + (a % b)y&#39;
= bx&#39; + (a - int(a / b)b)y&#39;
= ay&#39; + b(x - int(a / b)y&#39;)
ax + by = ay&#39; + b(x&#39; - int(a / b)y&#39;)
每次求gcd的递归过程中同时将系数x，y计算出来，令x=y&#39;,y=x&#39;-a/b*y&#39;
例：求 9x + 7y = 1 的一组整数解

int exgcd(int a, int b, int &amp;amp;x, int &amp;amp;y) {
	if (!b) {
		x = 1, y = 0;
		return a;
	}
	int d = exgcd(b, a % b, x, y);
	int t = x;
	x = y;
	y = t - a / b * y;
	return d;
}

拓展欧几里得算法的应用
更一般的，求解 ax + by = c
只要 gcd(a, b) | c 就有无数解，否则无解

逆元
乘法逆元：对于一个数字 a, 在模 p 意义下如果存在一个数字 b,
满足 a × b ≡ 1 (mod p), 我们就称 b 是模 p 意义下 a 的乘法逆元，记做 a−1a^{-1}a−1 。
容易发现

现在我们可以对分子分母取模了！所以进行模运算的重点变成了求逆元。
欧拉函数
欧拉函数 φ(n), 定义为 1 到 n 中与 n 互质的数字的个数。

通过定义容易得到欧拉函数的前几项 1, 1, 2, 2, 4, 2, 6, · · ·
通过定义我们也很容易得到一个质数 p 的欧拉函数 φ(p) = p-1
我们也很容易写出一个求欧拉函数的简易做法，枚举

注意相同的质约数都是相同的 pi
有了这个公式我们就可以快速的求出一个数字 n 的欧拉函数φ(n) 了。
所以，欧拉函数ϕ(n)的求解，归结到了分解质因子这个问题。试除法：求n的质因子时，逐个检查从2到√n的所有质数，如果它能整除n，就是一个因子。试除法的复杂度是O(√n)
#include&amp;lt;iostream&amp;gt;
using namespace std;

int phi(int x)
{
    int res=x;
    for(int i=2;i&amp;lt;=x/i;i++)
    {
        if(x%i==0)
            res=res/i*(i-1);
        while(x%i==0)
            x/=i;
    }
    if(x&amp;gt;1)
        res=res/x*(x-1);
    return res;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    while(n--)
    {
        int x;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
        cout&amp;lt;&amp;lt;phi(x)&amp;lt;&amp;lt;endl;
    }
    return 0;
}

数论中的欧拉定理
如果 gcd(a, p) = 1 , 即 a, p 互质则有 aφ(p)a^{φ(p)}aφ(p) ≡ 1 (mod p)
注意这个定理的强制性要求是 a, p 互质，如果 a, p 不互质直接用这个做法是做不了的，我们还需要拓展欧拉定理才能处理这个问题
由此可以得到求 a 模 m 的逆的方法。
aφ(m)a^{φ(m)}aφ(m)≡ 1 (mod m)
a∗aφ(m)−1a * a^{φ(m)-1}a∗aφ(m)−1 ≡ 1 (mod m)
aφ(m)−1a^{φ(m)-1}aφ(m)−1 就是 a 模 m 的逆。
欧拉定理求逆元
有了这个定理我们要怎么求逆元呢？考虑逆元的定义，对于一个数字 a , 我所要寻找的 a−1a^{−1}a−1 需要满足 a × a−1a^{−1}a−1 ≡ 1 (mod p), 而 aφ(p)a^{φ(p)}aφ(p) ≡ 1 (mod p), 这对于我们是否有一些启示呢？
我们将 aφ(p)a^{φ(p)}aφ(p)写成 a × aφ(p)−1a^{φ(p)-1}aφ(p)−1 我们惊喜的发现原来 a−1a^{−1}a−1 启示就是 aφ(p)−1a^{φ(p)-1}aφ(p)−1 !
所以在求出欧拉函数之后我们只需要快速幂就能得到一个数字的逆元了。
int get_inv(int a) {
    return Pow(a,phi(p)-1);
}

有很多题目中给定的 p 是个质数，就是费马小定理。
如果 a, p 不互质怎么求逆元呢？事实上在后面我们会看到，a, p 不互质的情况下是不存在模 p 意义下 a的逆元的。
欧拉定理求同余方程
对于同余方程 ax ≡ b (mod m)
两边同乘 a 的逆 aφ(m)−1a^{φ(m)-1}aφ(m)−1 ax ≡ aφ(m)−1a^{φ(m)-1}aφ(m)−1 b (mod m)
就可以得到 x ≡ aφ(m)−1a^{φ(m)-1}aφ(m)−1 b (mod m)
比如：由φ(10) = 4，对于同余方程 3x ≡ 7 (mod 10)
解为 x ≡ aφ(m)−1a^{φ(m)-1}aφ(m)−1 b ≡ 333^333 * 7 ≡ 9 (mod 10)
扩展欧拉定理



模板题
代码
欧拉函数的性质



φ(36)=φ(4)φ(9)
第二行和第四行，每个元素都不和 4 互素。
剩下的两行，每个元素都和 4 互素，但各有 6 个数和 9 互素


同余
一个便于理解的定义：如果对于两个数字 a, b , 对于一个数字 m的余数相等，我们认为他们对于 m 同余
在数学上的标准定义：设 m 是给定的一个正整数，a, b 是整数，
若满足 m|(a - b) , 则称 a 与 b 对模 m 同余，记做 a ≡ b (mod m)

(a + b)%c 是否等于 ((a%c) + (b%c))%c
a ∗ b%c 是否等于 ((a%c) ∗ (b%c))%c
a/b%c 是否等于 (a%c)/(b%c)
对于 1，2 两个式子来说，是正确的，而对于第三个式子来说，是错误的

线性同余方程
设 x 是未知整数，形如ax ≡ b (mod m)的同余式成为一元线性同余方程
ax ≡ b (mod m)，即ax除以m,b除以m,两者余数相同，这里a,b,m都是整数，求解x的值。
方程也可以这样理解，ax-b是m的整数倍。设y是倍数，那么ax-b=my,移项得到ax-my=b.因为y可以是负数，改写为ax+my=b，这就是在扩展欧几里得算法中提到的二元一次不定方程。
当且仅当gcd(a,m)能整除b时有整数解。
ax ≡ 1 (mod m) 的解称为 a 模 m 的逆。
如 7x ≡ 1 (mod 31) 的解满足 x ≡ 9 (mod 31)
设a 模 m 的一个逆为 k，即 ak ≡ 1 (mod m)
对于 ax ≡ b (mod m)，两边同乘以 k，得到 akx ≡ bk(mod m)
也即 x ≡ bk (mod m)
定理：设 p 是素数，正整数 a 是其自身模 p 的逆，当且仅当 a ≡ 1 (mod p) 或 a ≡ -1 (mod p)
证明：若a ≡ 1 (mod p) 或 a ≡ -1 (mod p),则a² ≡ 1 (mod p) ,所以a其自身模p的逆。反过来，若a是其自身模p
的逆，则a²=a·a ≡ 1 (mod p) 。因此，p |(a² -1)。又因为a² -1=（a-1）（a+1），所以p |（a-1）或p |（a+1）。
因此，或者a ≡ 1 (mod p) ，或者a ≡ -1 (mod p)
#include&amp;lt;iostream&amp;gt;
using namespace std;

int exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    
    int d=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return d;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    while(n--)
    {
        int a,b,m;
        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;m);
        int x,y;
        int d=exgcd(a,m,x,y);
        if(b%d)
            puts(&amp;quot;impossible&amp;quot;);
        else
            printf(&amp;quot;%d\n&amp;quot;,((long long)b/d*x%m+m)%m);
    }
    return 0;
}

扩展欧几里得求乘法逆元
ax = 1 (mod m)
ax + my = 1
也就是 a, m 是已知数，现在要求出一组 x, y , 使得上面的式子成立。
这也就印证了上面欧拉定理中的一句话，如果想要存在 a 对 m 的逆元，必须要 gcd(a, m) = 1 (1%gcd(a,m) = 0)才可以
当然如果 gcd(a, m) != 1，就无解
注意到 x 的解是 x0 + km （k是任意整数）
我们只要求出一个 k 使得 x0 + km 是最小的正整数即可。
另外需要注意的是我们求出的 x 有可能是负数，这时候我们可以让 x 加上若个个 p, 这样显然是不会影响方程的，例如我在 x 上加了一个 p, 那么在 y 上减去 a 就能保证方程依然成立。

费马小定理
假如 p 是质数，且 (a, p)=1，那么ap−1a^{p-1}ap−1 ≡ 1 (mod p)
因此可以得到，a∗ap−2a * a^{p-2}a∗ap−2 ≡ 1 (mod p)
所以 ap−2a^{p-2}ap−2 是 a 模 p 的一个逆。
可以用快速幂加速计算。
#include&amp;lt;iostream&amp;gt;
using namespace std;
typedef long long LL;
int qml(int a,int b,int p)
{
    int res=1;
    while(b)
    {
        if(b&amp;amp;1)
            res=(LL)res*a%p;
        a=(LL)a*a%p;
        b&amp;gt;&amp;gt;=1;
    }
    return res;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    while(n--)
    {
        int b,p;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;b,&amp;amp;p);
        if(b%p==0)
            puts(&amp;quot;impossible&amp;quot;);
        else
            printf(&amp;quot;%d\n&amp;quot;,qml(b,p-2,p));
    }
    return 0;
}

线性求逆元
给定 n, p 求 [1, n] 中所有整数在模 p 意义下的乘法逆元，n ≤ 2 × 1e6, p ≤ 2 × 1e7。
我们考虑从 1 到 n 依此求出每个数字的逆元，枚举变量 i, 1 → n,
默认 [1, i - 1] 每个数字对于 p 的逆元都已经求完,现在我们考虑 i 对 p 的逆元要怎么求。
不妨把 p 写成 ki + b 的形式也即


模板题
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=3e6+10;
int inv[N];
int main()
{
    int n,p;
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;p);
    inv[1]=1;
    for(int i=2;i&amp;lt;=n;i++)
        inv[i]=(LL)(p-p/i)*inv[p%i]%p;
    for(int i=1;i&amp;lt;=n;i++)
    	printf(&amp;quot;%d\n&amp;quot;,inv[i]);
    return 0;
}

阶乘的逆元
这里特别列出阶乘的逆元，因为后面有组合数学和组合数取模相关的问题，所以这里特别列出了阶乘如何求逆元。
有很多同学会认为先求出 [1, n] 每个数字对p的逆元就可以了。这样处理确实可以，但是过于繁琐，我们考虑一共更简单的做法。

int ifac[N], fac = 1, mod;
for(int i = 2; i &amp;lt;= n; ++ i) 
	fac = (long long) fac * i % mod;
ifac[n] = get_inv(fac, mod);
for(int i = n - 1; i &amp;gt;= 0; -- i) 
	ifac[i] = (long long)ifac[i + 1] * (i + 1) % mod;

线性同余方程组
第一种：有两个以上的不同模的一元线性同余方程；
第二种：变元数大于 1，方程数大于 1，但是方程的模相同
中国剩余定理
下面取自成书于公元 3 世纪晚期的《孙子算经》的问题。
求一个数，它被 3 除余 1，被 5 除余 2，被 7 除余 3。
这也就等价于如下方程组：
x ≡ 1 (mod 3)
x ≡ 2 (mod 5)
x ≡ 3 (mod 7)


正确性显然，代入即可。还需要证明唯一性。

x ≡ 1 (mod 3)
x ≡ 2 (mod 5)
x ≡ 3 (mod 7)
现在回到开头的那个方程组，首先有 M = 105
M1 = 35，M2 = 21，M3 = 15
y1 = 2, y2 = 1, y3 = 1
因此 x ≡ 1 * 35 * 2 + 2 * 21 * 1 + 3 * 15 * 1 ≡ 157≡ 52 (mod 105)
中国剩余定理给出了模数两两互质的线性同余方程组的一个特殊解。方程组的通解可以表示为x+kM（k∈Z）。有些题目要求我们求出最小的非负整数解，只需把x对M取模，并让x落在0~M-1的范围内即可。
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=15;
int n;
int a[N],b[N];

void exgcd(LL a,LL b,LL &amp;amp;x,LL &amp;amp;y)
{
	if(!b)
	{
		x=1,y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	LL t=x;
	x=y;
	y=t-a/b*y;
}

LL crt()
{
	LL M=1,res=0;
	for(int i=1;i&amp;lt;=n;i++)
		M*=a[i];
	for(int i=1;i&amp;lt;=n;i++)
	{
		LL m,x,y;
		m=M/a[i];
		exgcd(m,a[i],x,y);
		res=(res+m*x*b[i])%M;
	}
	return (res%M+M)%M;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a[i],&amp;amp;b[i]);
	printf(&amp;quot;%lld\n&amp;quot;,crt());
	return 0;
}

扩展中国剩余定理

证明：




模板题
code

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/shu-lun/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/kuai-su-mi-andju-zhen-kuai-su-mi/">
                        快速幂&amp;矩阵快速幂
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-26</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            快速幂
给出 a，b, c，求出 aba^bab mod c.a, b, c &amp;lt;= 1e9
枚举 b，连续乘 b 次 a，每乘一次对 c 取模一次。
时间复杂度关于 b 线性。
每次都乘的是 a，重复运算太多，考虑分治
比如计算出 a,a2,a4,a8,a16a, a^2, a^4, a^8, a^{16}a,a2,a4,a8,a16, …
对 b 进行二进制转换，比如 b = 11 = 8 + 2 + 1
故 ab=a11=a8∗a2∗aa^b = a^{11} = a^8 * a^2 * aab=a11=a8∗a2∗a
因此，只要预处理出 log2109log_2 10^9log2​109 个 a 的幂次
计算的时候分解成 log2 b 个乘积即可
模板题
int qmi(int a,int b,int p)
{
    int res=1%p;
    while(b)
    {
        if(b&amp;amp;1)
            res=(long long)res*a%p;
        a=(long long)a*a%p;
        b&amp;gt;&amp;gt;=1;
    }
    return res;
}

快速乘
给出 a，b, c，求出 a∗ba * ba∗b mod c.a, b, c &amp;lt;= 1e18
沿用之前的做法，但是注意这里的模数是 1e18。如果两个小于 1e18 的数相乘，long long也存不下。
考虑到幂次可以转化为连乘，乘法也可以转化为连加。
同样的我们可以得到一个“快速”乘
比如计算出 a, 2a, 4a, 8a, 16a, …
对 b 进行二进制转换，比如 b = 11 = 8 + 2 + 1
故 ba = 11a = 8a + 2a + a
因此，只要预处理出 log21018log_2 10^{18}log2​1018 个 a 的乘积
计算的时候分解成 log2 b 个加法即可。
因为每次两个小于 1e18 的数相加，long long是可以存的。
模板题
long long mul(long long a, long long b, long long c)
{
    long long ans = 0;
    while (b) 
    {
        if (b &amp;amp; 1) ans = (ans + a) % c;
        b &amp;gt;&amp;gt;= 1;
        a = (a + a) % c;
    }
    return ans; 
}

例题
luoguP1965
答案显然就是 (x + m * 10^k) % n
根据模运算的的分配率可以得到 (x%n+m%n*10k%n)%n,只需用快速幂求出10k就可以了
代码
矩阵乘法
给定一个大小为 n × m 的矩阵 A[n][m]
和一个大小为 m × r 的矩阵 B[m][r]
    for (int i = 1;i &amp;lt;= n;i ++)
        for (int j = 1;j &amp;lt;= r;j ++)
            for (int k = 1;k &amp;lt;= m;k ++)
                C[i][j] += A[i][k] * B[k][j];
时间复杂度: O(n^3)

矩阵快速幂
poj3233
给定一个 n × n 的矩阵 A，和一个正整数 k。 求 S=A+A2+…+AkS = A + A^2 + … + A^kS=A+A2+…+Ak，对 m 取模,n ≤ 30，k ≤ 1e9

样例输入：
2 2 4
0 1
1 1
样例输出：
1 2
2 3
注意到，矩阵乘法也是具有结合律和乘法分配律的。
因此：(I为单位阵)
A+A2=A(I+A)A + A^2 = A(I + A)A+A2=A(I+A)
A+A2+A3+A4=(A+A2)(I+A2)A + A^2 + A^3 + A^4 = (A + A^2)(I + A^2)A+A2+A3+A4=(A+A2)(I+A2)
我们记 sum(n)=A+A2+…+Ansum(n) = A + A^2 + … + A^nsum(n)=A+A2+…+An
如果 n 是偶数:
sum(n)=sum(n/2)(I+An/2)sum(n) = sum(n / 2)(I + A^{n/2})sum(n)=sum(n/2)(I+An/2)
如果 n 是奇数：
sum(n)=sum(n−1)+An=sum((n−1)/2)(I+A(n−1)/2）+Ansum(n) = sum(n - 1) + A^n = sum((n - 1) / 2)(I + A^{(n-1)/2}）+ A^nsum(n)=sum(n−1)+An=sum((n−1)/2)(I+A(n−1)/2）+An
只需要解决如何快速求 A^n
对于整数的幂次，我们可以用快速幂来求。
对于矩阵的幂次，我们也可以用快速幂来求。
注意的是，初始值要设置为单位矩阵 I。也就是 A0A^0A0.
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=35;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
}a;
int n,k,mod;

matrix add(matrix a,matrix b)
{
	matrix res;
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
			res.m[i][j]=(a.m[i][j]+b.m[i][j])%mod;
	return res;
}

matrix mul(matrix a,matrix b)
{
	matrix c;
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
			for(int k=1;k&amp;lt;=n;k++)
				c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return c;
}

matrix qmi(matrix a,int k)
{
	matrix c;
	for(int i=1;i&amp;lt;=n;i++)
		c.m[i][i]=1;
	while(k)
	{
		if(k &amp;amp; 1)
			c=mul(c,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return c;
}

matrix get_sum(matrix a,int k)
{
	if(k == 1)
		return a;
	matrix c;
	for(int i=1;i&amp;lt;=n;i++)
		c.m[i][i]=1;
	
	c=add(c,qmi(a,k&amp;gt;&amp;gt;1));
	c=mul(c,get_sum(a,k&amp;gt;&amp;gt;1));
	if(k &amp;amp; 1)
		c=add(c,qmi(a,k));
	return c;
 } 

int main()
{
	scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;mod);
	
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a.m[i][j]);
	
	a=get_sum(a,k);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		for(int j=1;j&amp;lt;=n;j++)
			printf(&amp;quot;%d &amp;quot;,a.m[i][j]);
		puts(&amp;quot;&amp;quot;);
	}
		
	return 0;
}

矩阵乘法优化递推
poj3070


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=2,mod=10000;
int n;
struct matrix
{
    int m[N][N];
    matrix()
    {
    	memset(m,0,sizeof m);
	}
    matrix(int a[][N])
    {
        memcpy(m,a,sizeof m);
    }
};

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&amp;lt;2;i++)
		for(int j=0;j&amp;lt;2;j++)
			for(int k=0;k&amp;lt;2;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&amp;lt;2;i++)
		res.m[i][i]=1;
	
	while(k)
	{
		if(k &amp;amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return res;
}

int main()
{
	while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; ~n)
	{
		int f[N][N]={{1,0}};
		int c[N][N]={{1,1},{1,0}};
		matrix a=c;
		matrix b=f;
		if(n)
		{
			a=qmi(a,n-1);
			b=mul(b,a);
			printf(&amp;quot;%d\n&amp;quot;,b.m[0][0]);
		}
		else 
			printf(&amp;quot;0\n&amp;quot;);	
	}
}


acwing1303

代码

数列f[n]=f[n-1]+f[n-2]+1,f[1]=f[2]=1的第n项的快速求法（不考虑高精度）
仿照前例，考虑1×3的矩阵[f[n-2],f[n-1],1]，希望求得某3×3的矩阵A，使得此1×3的矩阵乘以A得到矩阵：
[f[n-1],f[n],1]
即：[]f[n-2],f[n-1],1]* A ＝[f[n-1],f[n],1] =[f[n-1],f[n-1]+f[n-2]+1,1]
容易构造出这个3×3的矩阵A，即：
０ １ ０
１ １ ０
０ １ １

数列f[n]=f[n-1]+f[n-2]+n+1,f[1]=f[2]=1的第n项的快速求法（不考虑高精度）.
解法：
仿照前例，考虑1×4的矩阵[f[n-2],f[n-1],n,1]，希望求得某4×4的矩阵A，使得此1×4的矩阵乘以A得到矩阵：[f[n-1],f[n],n+1,1]
即：[f[n-2],f[n-1],n,1]* A  = [f[n-1],f[n],n+1,1]＝[f[n-1],f[n-1]+f[n-2]+n+1,n+1,1]
容易构造出这个4×4的矩阵A，即：
０ １ ０ ０
１ １ ０ ０
０ １ １ ０
０ １ １ １

例题
poj3735
有 n 只小猫，要执行一些操作序列。
g i：给第 i 只小猫一棵花生
e i：让第 i 只小猫吃掉它的所有花生
s i j：让第 i 只小猫和第 j 只小猫交换他们手里的花生。
现在给你一个长度为 k 的序列，让你反复执行这个序列 m
次。问最后每只小猫手里的花生数。n≤100，k≤100，m≤1e9
联系矩阵优化递推。
如果我们也能求出一个序列对应的矩阵。
只要求矩阵的 m 次幂即可。
先考虑如何设计状态：
把刚才那3只猫看做一个矩阵{a,b,c},分别代表他们有的花生个数，显然初始是{0,0,0}
当进行s操作的时候，我们将初始矩阵乘上一个矩阵，得到的那个矩阵最好也是1行3列的。
那肯定我们要构造的那个矩阵是3*3的矩阵
s 1 2交换操作就是{a,b,c}*x={b,a,c}
x=  0 1 0
    1 0 0
    0 0 1

S操作是这样的，首先将X看做一个单位矩阵，要交换哪两个，只需要交换他们的列就可以了
对于e操作近似于s操作，将e 2举例：{a,b,c}*x={a,0,c}
x=  1 0 0
    0 0 0
    0 0 1

即将某列置于0
现在问题来了，怎么构造g操作的矩阵。使下面这个等式成立
g 1操作  {a,b,c}*X={a+1,b,c}
g 2操作  {a,b,c}*X={a,b+1,c}
g 3操作  {a,b,c}*X={a,b,c+1}
我们不妨再{a,b,c}矩阵多加一个1，这样我们就能实现我们的+1操作了
要使g 1操作实现{a,b,c,1}*x={a+1,b,c,1}
那么
x=  1 0 0 0
    0 1 0 0
    0 0 1 0
    1 0 0 1

当然这样构造矩阵，这样并不影响我们前面的s与e操作
这样一系列操作之后：

得到这个矩阵后，求它的 m 次幂，然后乘上初始状态对应
的向量，得到的就是答案。
时间复杂度: O(n^3log m)
代码
poj3150
有 n 个数排成一个环。定义一次变换为：把这个数变成距离它不超过 d 的位置上的数之和对 m 取模的值。
问这样变换 k 次后，每个位置上的数是多少。
n &amp;lt;= 500, m &amp;lt;= 109, k &amp;lt;= 1e9
对于每一次变换，其实可以写成一个矩阵：
比如题中 d = 2



因此一个矩阵只要存下第一行就可以得到整个矩阵。
计算矩阵乘法的时候，只要枚举 n^2 次。
时间复杂度变成了 O(n^2 log k)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=510;
int n,mod,d,k;
struct matrix 
{
	int m[N];
	matrix()
	{
		for(int i=0;i&amp;lt;N;i++)
			m[i]=0;
	}
	matrix(int a[])
	{
		memcpy(m,a,sizeof m);
	}
};

matrix mul(matrix a,matrix b)
{
	matrix res;
	
	for(int i=0;i&amp;lt;n;i++)//只计算res的第一行 
		for(int k=0;k&amp;lt;n;k++)
			res.m[i]=(res.m[i]+(LL)a.m[k]*b.m[(i-k+n)%n])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	res.m[0]=1;
		
	while(k)
	{
		if(k&amp;amp;1) res=mul(res,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return res;
}

int main()
{
	scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;mod,&amp;amp;d,&amp;amp;k);
	matrix b;
	for(int i=0;i&amp;lt;n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;b.m[i]);
	matrix a;
	for(int i=0;i&amp;lt;n;i++)
		if(i&amp;lt;=d || (i+d)%n == 0)
			a.m[i]=1;
	a=qmi(a,k);	
//	for(int i=0;i&amp;lt;n;i++)
//		printf(&amp;quot;%d &amp;quot;,a.m[i]);
	b=mul(b,a);
	for(int i=0;i&amp;lt;n;i++)
		printf(&amp;quot;%d &amp;quot;,b.m[i]);
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/kuai-su-mi-andju-zhen-kuai-su-mi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/xian-xing-dp/">
                        线性dp
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-26</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
多阶段决策问题
有一类活动的过程，可以分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效。
当然，各个阶段的决策的选取不是任意确定的，它依赖于当前的状态，又会影响以后的发展。
当各个阶段决策决定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。
这种把一个问题看做是一个前后关联、具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为多阶段决策问题。
各个阶段采取的决策， 一般来说是与阶段有关的。
决策依赖于当前的状态，又随即引起状态的转移。
一个决策序列就是在变化的状态中产生出来的。
称这种解决多阶段决策最优化的过程为动态规划（DP）。
动态规划（Dynamic Programming）程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。
由于各种问题的性质不同，确定最优解的条件也互不相同，因此不存在一种万能的动态规划算法可以解决各类最优化问题。
常见的 DP 类型有：
线性模型
区间 DP
背包 DP
数位 DP
状态压缩 DP
树状 DP
常见的 DP 优化方法有：
滚动数组优化
矩阵乘法优化
斜率优化
四边形不等式优化
决策单调性优化
数据结构优化
动态规划的基本概念
1.阶段和阶段变量
将问题的全过程恰当地分成若干个相互联系的阶段。
阶段的划分一般根据时间和空间的自然特征去划分。
阶段的划分要便于把问题转化成多阶段决策问题。
2.状态和状态变量
通常一个阶段包含若干状态。
状态可由变量来描述。
3.决策、决策变量和决策允许集合。
在对问题的处理中作出的每种选择性的行动就是决策。
即从该阶段的每一个状态出发， 通过一次选择性的行动转移至下一阶段的相应状态。
一个实际问题可能需要有多次决策和多个决策点，在每一个阶段的每一个状态中都需要有一次决策，
决策也可以用变量来描述，称这种变量为决策变量。
在实际问题中，决策变量的取值往往限制在某一个范围之内，此范围就称为决策允许集合。
4.策略和最优策略
所有阶段一次排列构成问题的全过程。
全过程中各阶段决策变量所组成的有序总体称为策略。
在实际问题中，从决策允许集合中找出最优效果的策略称为最优策略。
5.状态转移方程
前一阶段的终点就是后一阶段的起点，对前一阶段的状态做出某种决策，产生后一种阶段的状态，这种关系描述了从 i
阶段到 i+1 阶段状态的演变规律，称为状态转移方程。
从 n 个数中取出 k 个数，使得他们的和最大。
f[i][j] 表示现在考虑到了第 i 个数，已经选出了 j 个数。
阶段：枚举到第i个数
状态：已经选出了 j 个数。
决策：第i个数选或不选
策略：和最大
状态转移方程：f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[i])
动态规划的性质
什么样的“多阶段决策问题”才可以用动态规划的方法来求解呢？


对于不能划分阶段的题，不能用动态规划来解。
不符合最优化原理，不能用动态规划来解。
不具备无后效性原则的，不能用动态规划来解。
误用动态规划解决问题会得到错误的结果
动态规划设计方法
正推：从初始状态开始，通过对中间阶段的决策的选择，达到结束状态。我们也称递推。
倒推：从结束状态开始，通过对中间阶段的决策的选择，达到开始状态。我们可以把这种方法看成记忆化搜索。
动态规划设计方法的一般模式

划分阶段
确定状态和状态变量
确定决策并写出状态转移方程
寻找边界条件
设计并实现程序

动态规划与记忆化搜索
实现一个函数，用“搜索”的方法实现 DP 的更新。
通常用于解决转移顺序不方便人为确定的 DP。
数字三角形
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
设 f[i][j] 表示走到了第 i 行第 j 列的最大值。
正常 DP：
f[i][j] = max(f[i – 1][j], f[i – 1][j – 1]) + a[i][j]
搜索：
int dp(int i, int j)
{
if (i == 0) return 0;
    return a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
}

这样有很多状态其实会重复计算。
对于计算过的 dp(i, j)，我们用 f[i][j] 来存。
f 初始化为 -1
记忆化搜索：
int dp(int i, int j){
    if (i == 0) return 0;
    if (f[i][j] &amp;gt;= 0) return f[i][j];
    f[i][j] = a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
    return f[i][j];
}

acwing901
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=310;
int h[N][N];
int f[N][N];
int n,m;
int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};

int dp(int x,int y)
{
    if(f[x][y]!=-1)
        return f[x][y];
    
    f[x][y]=1;
    for(int i=0;i&amp;lt;4;i++)
    {
        int a=x+dx[i],b=y+dy[i];
        if(a&amp;gt;=1 &amp;amp;&amp;amp; a&amp;lt;=n &amp;amp;&amp;amp; b&amp;gt;=1 &amp;amp;&amp;amp; b&amp;lt;=m &amp;amp;&amp;amp; h[x][y]&amp;gt;h[a][b])
            f[x][y]=max(f[x][y],dp(a,b)+1);
    }
    return f[x][y];
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=1;j&amp;lt;=m;j++)
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i][j]);
    memset(f,-1,sizeof f);
    
    int res=0;    
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=1;j&amp;lt;=m;j++)
            res=max(res,dp(i,j));
    printf(&amp;quot;%d\n&amp;quot;,res);
    return 0;
}

线性模型
这里的线性指的是状态的排布是呈线性的。

最长上升子序列问题。
f[i] 表示以 a[i] 结尾的最长上升子序列问题。
计算 f[i] 的时候，只需要去考虑 f[1], f[2], …, f[i-1] 看是否能够转移即可。
f[i] = max{ f[j] + 1 | 1≤j&amp;lt;i, a[j]&amp;lt;a[i] }

贪心思想，数越小形成的最长上升子序列长度可能越大。
#include&amp;lt;cstdio&amp;gt;//最长上升子序列，优化算法，时间复杂度O(nlogn)
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int maxn=100010;
int d[maxn];//d[]表示从最长上升序列的元素
int a[maxn];

int main()
{
    int n;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
    int len=1;
    d[1]=a[1];
    for(int i=2;i&amp;lt;=n;i++)
	{
		if(a[i] &amp;gt; d[len])
            d[++len]=a[i];
        else//a[i]覆盖d[]中第一个大于a[i]的数 
        	*lower_bound(d+1,d+len+1,a[i])=a[i];
    }
    printf(&amp;quot;%d\n&amp;quot;,len);
    return 0;
}

如果题目要求严格递增，则必须用lower_bound，因为要替换掉相同的元素而不是增长序列。
如果题目要求最长不下降子序列，则必须用 upper_bound。
poj3486
你想保证 n 年中你都有一台电脑，一开始你有一台。
如果你在第 y (1≤y≤n) 年购买了一台电脑，那么你需要花费 c的代价。
如果你这台电脑一直用到了第 z 年，在第 z 年又买了一台新的，您需要在您拥有该计算机的每一年中支付维护成本m（y，z）
给定 n，c，数组 m。求最小花费
首先划分阶段。
每一年可以划分为一个阶段。
f[i] 表示直到第 i 年f[0], f[1],…,f[i-1]你手里都有一台电脑的最小花费。
f[i] 需要从 转移过来。
如何转移？
枚举上一次买电脑是哪一年
假设上一次买电脑是第 j 年。
那么1~j-1年就是一个子问题，我们已经算出了 f[j-1] 是满足
这个子问题的最优解，后面我们就不用考虑前 j-1年的情况，
且它也不会影响我们后面的决策。
第 j 年到第 i 年的维修费用是 m(j, i)，花费是 c
因此可以用 f[j-1]+m(j,i)+c 来更新 f[i]
f[i] = min{ f[j-1]+m(j,i) + c | 1≤j≤i }
边界条件：
f[0] = 0
f[1], f[2], …, f[n] 一开始都应该初始化为 +∞
code
acwing278

hdu1003

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=100005;
int a[maxn],dp[maxn];//dp[i]表示从start开始到第i个元素的最大子段和 
int main()
{
	int t,n,cas=0;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
	while(t--)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i=1;i&amp;lt;=n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);//也可以省略原数组，直接用dp[] 
		int l=1,r=1;//记录区间
		int start=1;//记录起点
		dp[1]=a[1];
		
		int ans=dp[1];
		for(int i=2;i&amp;lt;=n;i++)
		{
            if(dp[i-1]&amp;gt;=0)//dp[i-1]大于等于0，则累加，否则重新开始 
                dp[i]=dp[i-1]+a[i];
            else
            {
            	dp[i]=a[i];
            	start=i;//重新开始
			}	
            if(dp[i]&amp;gt;ans)//更新最值
            {
            	ans=dp[i];
				l=start;
         	    r=i;
            }
		}
		if(cas)
			printf(&amp;quot;\n&amp;quot;);
		printf(&amp;quot;Case %d:\n&amp;quot;,++cas);
		printf(&amp;quot;%d %d %d\n&amp;quot;,ans,l,r);
	}
	return 0;
}

poj2479




因为我们会从左到右枚举每一个lt[i],当然更新一遍lt[i]也没有错。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int maxn=50010;
const int inf=0x3f3f3f3f;
int lt[maxn],rt[maxn];//lt[i]表示从左端开始，以i结尾的子段和最大值 
int a[maxn];
 
int main()
{
	int t,n;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
	while(t--)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i=1;i&amp;lt;=n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		lt[1]=a[1];
		for(int i=2;i&amp;lt;=n;i++)//从左向右 
			lt[i]=max(a[i],lt[i-1]+a[i]);
		rt[n]=a[n];
		for(int i=n-1;i&amp;gt;=1;i--)//从右向左
			rt[i]=max(a[i],rt[i+1]+a[i]); 
		for(int i=n-1;i&amp;gt;=1;i--)//更新为从右端开始n..i个元素之中最大连续子段和 
			rt[i]=max(rt[i+1],rt[i]);
		int ans=-inf;
		for(int i=2;i&amp;lt;=n;i++)
			ans=max(ans,lt[i-1]+rt[i]);
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

poj2250

code

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/xian-xing-dp/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/">
                        字符串复习（一）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-26</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            哈希表
如果要储存和使用线性表（1，75，324，43，1353，90，46）一般情况下我们会使用一个数组 A[1..7] 来顺序存储这些数。
但是这样的存储结构会给查询算法带来 O(n) 的时间开销。
对 A 排序，使用二分查询法，时间复杂度变为 O(log n)也可以用空间换时间的做法，用数组 A[1..1353] 来表示每个数是否出现，查找的时间复杂度变为 O(1)，但是空间上的开销变得巨大。
优化上一种做法，建立一个哈希函数 h(key) = key % 23.(1, 75, 324, 43, 1353, 90) -&amp;gt; (1, 6, 2, 20, 19, 21, 0)
我们只要用一个 A[0..22] 数组就可以快速的查询每个数是否出现。
这种线性表的结构就称为哈希表（Hash Table）。
可以看出，哈希表的基本原理是用一个下标范围比较大的数组 A 来存储元素。
设计一个函数 h，对于要存储的线性表的每个元素 node，取一个关键字 key，算出函数值 h(key) 然后把这个值作为下标，用 A[h(key)] 来存储 node。
最常见的 h 就是模函数，也就是选定一个 m，令 h(key) =key % m.
但是有一个问题，可能存在两个 key: k1, k2 使得h(k1)=h(k2)，这时也称产生了“冲突”。
解决冲突有很多种办法：
1.开放寻址法
2.拉链法：可以让 A 的每个元素都存一个链表，对于
h(k1)=h(k2)，我们可以让这两个 node 都接在 A[h(k1)]
的链表上
假设我们使用第二种方法解决冲突。
对于插入元素(node, key)：

计算 h(key)，把 node 插入 A[h(key)] 链表。

对于查询元素(node, key)：

计算 h(key)，如果 A[h(key)] 为空，说明 node 不存在。
否则遍历 A[h(key)] 链表，寻找 node。

模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=100003;
int h[N],e[N],ne[N],idx;

void insert(int x)
{
    int k=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}

bool find(int x)
{
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i])
    {
        if(e[i]==x)
            return true;
    }
    return false;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    memset(h,-1,sizeof(h));
    while(n--)
    {
        char op[2];
        int x;
        scanf(&amp;quot;%s%d&amp;quot;,op,&amp;amp;x);

        if(*op==&#39;I&#39;)
            insert(x);
        else
        {
            if(find(x))
                puts(&amp;quot;Yes&amp;quot;);
            else
                puts(&amp;quot;No&amp;quot;);
        }
    }
    return 0;
}

例题
已知 X[1..4] 是 [-T, T] 中的整数，求出满足方程AX[1]+BX[2]+CX[3]+DX[4] = P的解有多少组？
|P|≤1e9，|A|,|B|,|C|,|D|≤1e4，T≤500
最直观的方法枚举 X[1..4], 时间复杂度 O(n4n^4n4)
适当优化，枚举了X[1..3] 之后，实际上 X[4] 已经确定了，时间复杂度 O(n3n^3n3)
继续优化，采用 meet in the middle 策略：
一边枚举 X[1], X[2]
一边枚举 X[4], X[3]
然后看有哪些方案可以组成方程的解
枚举 X[1], X[2], 然后算出 P-AX[1]-BX[2],把这个值存入一个哈希表，注意要统计次数。
这一步时间复杂度 O(n2n^2n2)
然后枚举 X[3], X[4], 算出 CX[3]+DX[4],去哈希表里查找这个值出现了几次。
把次数加进答案，这一步时间复杂度 O(n2n^2n2)
因此总的时间复杂度是 O(n2n^2n2)
字符串哈希
假设有 n 个长度为 L 的字符串，问其中最多有几个字符串是相等的。
直接比较两个长度为 L 的字符串是否相等时间复杂度是O(L) 的。
因此需要枚举 O(n2) 对字符串进行比较，时间复杂度 O(n2Ln^2Ln2L)
如果我们把每个字符串都用一个哈希函数映射成一个整数。
问题就变成了查找一个序列的众数。
时间复杂度变为了 O(nL)
一个设计良好的字符串哈希函数可以让我们先用 O(L) 的时间复杂度预处理，之后每次获取这个字符串的一个子串的哈希值都只要 O(1) 的时间。
BKDRHash 的基本思想就是把一个字符串当做一个 k 进制数来处理
假设字符串 s 的下标从 1 开始，长度为 n
ha[0] = 0;
    for (int i = 1;i &amp;lt;= n;i ++)
        ha[i] = (ha[i - 1] * P + str[i]) % M;

我们知道 ha[i] 就是 s[1..i] 的 BKDRHash
那么现在询问 s[x..y] 的 BKDRHash ，

因此我们预处理出 ha 数组和 k 的幂次，每次询问 s[x..y]的哈希值，只要 O(1) 的时间。
经验值，k=131，M=2642^{64}264
模板题
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 100010, P = 131;
int n, m;
char str[N];
ULL h[N], p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    scanf(&amp;quot;%s&amp;quot;, str + 1);

    p[0] = 1;
    for (int i = 1; i &amp;lt;= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf(&amp;quot;%d%d%d%d&amp;quot;, &amp;amp;l1, &amp;amp;r1, &amp;amp;l2, &amp;amp;r2);

        if (get(l1, r1) == get(l2, r2)) puts(&amp;quot;Yes&amp;quot;);
        else puts(&amp;quot;No&amp;quot;);
    }

    return 0;
}

例题
acwing160
核心问题就是：
给定两个字符串 A，B。求出 A 的每个后缀子串和 B 的最长公共前缀。
标准做法是扩展 KMP，时间复杂度线性。
我们来用 Hash 试试看
前面已经提到，我们可以用 O(n)预处理 O(1)处理出一个子串的哈希值。
求字符串 A[i..n] 与字符串 B[1..m] 的最长公共前缀？
二分长度 mid
计算出 A[i..i+mid-1] 和 B[1..mid] 的哈希值，比较是否相等。
因此时间复杂度是 O(nlog n) 的
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 200010, P = 131;
int n, m,q;
char a[N];
char b[N];
ULL ha[N],hb[N],p[N];
int cnt[N];

ULL get(ULL h[],int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m,&amp;amp;q);
    scanf(&amp;quot;%s&amp;quot;, a + 1);
    scanf(&amp;quot;%s&amp;quot;,b+1);

    p[0] = 1;
    for(int i=1;i&amp;lt;=max(n,m);i++)
        p[i]=p[i-1]*P;
    for(int i=1;i&amp;lt;=n;i++)
        ha[i]=ha[i-1]*P+a[i];
    for(int i=1;i&amp;lt;=m;i++)
        hb[i]=hb[i-1]*P+b[i];
    
    for(int i=1;i&amp;lt;=n;i++)
    {
        int l=0,r=min(m,n-i+1);

        while(l&amp;lt;r)
        {
            int mid=l+r+1&amp;gt;&amp;gt;1;
            if(get(ha,i,i+mid-1) == get(hb,1,mid))
                l=mid;
            else
                r=mid-1;
        }
        cnt[l]++;
    }
    while(q--)
    {
        int x;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
        printf(&amp;quot;%d\n&amp;quot;,cnt[x]);
    }

    return 0;
}

poj2774
给出两个字符串 S 和 T，求它们的最长公共子串。|S|, |T| ≤ 1e5
思路
原始的 DP 做法（最长公共子序列），时间复杂度 O(n^2)
我们可以二分答案 len。然后计算 S 和 T 中所有长度为 len 的子串的哈希值。
这一步是 O(n) 的。
然后比较 S 的哈希值集合中和 T 的哈希值集合中有没有相同的元素。
可以再通过一步哈希找相同的值。这样总共仍然是 O(n)。
总的时间复杂度就是 O(n log n)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010,P=131;
char a[N],b[N];
typedef unsigned long long ULL;
ULL ha[N],hb[N],p[N];
vector&amp;lt;ULL&amp;gt; v;
int la,lb;

ULL get(ULL h[],int l,int r)
{
	return h[r]-h[l-1]*p[r-l+1];
}

bool check(int mid)
{
	v.clear();
	for(int i=mid;i&amp;lt;=la;i++)
		v.push_back(get(ha,i-mid+1,i));
	
	sort(v.begin(),v.end());
	for(int i=mid;i&amp;lt;=lb;i++)
	{
		ULL t=get(hb,i-mid+1,i);
		if(binary_search(v.begin(),v.end(),t))
			return true;
	}
	return false;
}

int main()
{
	scanf(&amp;quot;%s%s&amp;quot;,a+1,b+1);
	la=strlen(a+1);
	lb=strlen(b+1);
	
	p[0]=1;
	for(int i=1;i&amp;lt;=max(la,lb);i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&amp;lt;=la;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=1;i&amp;lt;=lb;i++)
		hb[i]=hb[i-1]*P+b[i];
		
	int l=0,r=1e5;
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(check(mid))
			l=mid;
		else
			r=mid-1;
	}
	printf(&amp;quot;%d\n&amp;quot;,l);
	return 0;
}

也可手写哈希表：代码
Codeforces 580E
给出一个数字串，现在有两种操作：
1: l r d: 将[l,r] 中的所有数字都改为 d
2: l r d：询问[l,r]这个子串的周期是否为 d。 1 &amp;lt;= n &amp;lt;= 1e5
首先思考对于一个字符串 S，如何判断它的周期是不是 d？
比如串 ababab 的周期是 2 串 abcabc 的周期是 3 串 abcde 的周期是 5
假设 S 的长度为 n。
只要判断 S[1..n-d+1] 和 S[d+1..n]是否相等即可。


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
#define lc u&amp;lt;&amp;lt;1
#define rc u&amp;lt;&amp;lt;1|1
int n,m,k;
const int N=100010,P=131,mod=1e9+7;
char s[N];
typedef long long LL;
struct Node
{
	int l,r;
	int tag;
	LL key;
}tr[N&amp;lt;&amp;lt;2];
LL h[N],p[N];//p[i]表示p的i次方，h[i]表示连续i个1的字符串的hash值

void pushup(int u,int k)
{
	tr[u].key=((tr[lc].key*p[k])%mod+tr[rc].key)%mod;
}

void pushdown(int u)
{
	if(tr[u].tag)
	{
		int mid=tr[u].l+tr[u].r&amp;gt;&amp;gt;1,l=tr[u].l,r=tr[u].r;
		tr[lc].key=(tr[u].tag*h[mid-l+1])%mod;
		tr[lc].tag=tr[u].tag;
		tr[rc].key=(tr[u].tag*h[r-mid])%mod;
		tr[rc].tag=tr[u].tag;
		tr[u].tag=0;
	}
}

void build(int u,int l,int r)
{
	if(l == r)
	{
		tr[u]={l,r,0,s[l]-&#39;0&#39;+1};
		return;
	}
	tr[u]={l,r};
	int mid=l+r&amp;gt;&amp;gt;1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u,r-mid);
}

void modify(int u,int l,int r,int d)
{
	if(l &amp;lt;= tr[u].l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r)
	{
		tr[u].key=(d*h[tr[u].r-tr[u].l+1])%mod;
		//cout&amp;lt;&amp;lt;&amp;quot;-----&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].key&amp;lt;&amp;lt;endl;
		tr[u].tag=d;
		return;
	}
	pushdown(u);
	int mid=tr[u].l+tr[u].r&amp;gt;&amp;gt;1;
	if(l &amp;lt;= mid)
		modify(lc,l,r,d);
	if(r &amp;gt; mid)
		modify(rc,l,r,d);
	pushup(u,tr[u].r-mid);
}

int query(int u,int l,int r)
{
	if(tr[u].l == l &amp;amp;&amp;amp; tr[u].r == r)
		return tr[u].key;
	pushdown(u);
	int mid=tr[u].l+tr[u].r&amp;gt;&amp;gt;1;
	if(r&amp;lt;=mid)
		return query(lc,l,r);
	else if(l&amp;gt;mid)
		return query(rc,l,r);
	else 
		return (query(lc,l,mid)*p[r-mid]%mod+query(rc,mid+1,r))%mod;
}

void print(int u)
{
	if(tr[u].key)
	{
		cout&amp;lt;&amp;lt;&amp;quot;--&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].l&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].r&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].key&amp;lt;&amp;lt;endl;
		print(lc);
		print(rc);
	}
}

int main()
{
	scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);
	scanf(&amp;quot;%s&amp;quot;,s+1);
	
	p[0]=1;
	for(int i=1;i&amp;lt;=n;i++)
	{
		h[i]=(h[i-1]*P%mod+1)%mod;
		p[i]=p[i-1]*P%mod;
	}

	build(1,1,n);
	
	m+=k;
	while(m--)
	{
		int t,l,r,d;
		scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;t,&amp;amp;l,&amp;amp;r,&amp;amp;d);
		if(t == 1)
			modify(1,l,r,d+1);//加一处理，防止d为0
		else
		{
			if(d == r - l + 1)
			{
                printf(&amp;quot;YES\n&amp;quot;);
                continue;
            }
			if(query(1,l,r-d) == query(1,l+d,r))
				puts(&amp;quot;YES&amp;quot;);
			else
				puts(&amp;quot;NO&amp;quot;);
		}
		//print(1);
	}
	return 0;
}

坑：第75组数组卡无符号64位自动溢出的hash,防ull溢出的解决方法是取模
Codeforces 955D
给出两个字符串 S 和 T。你需要在 S 中选出两个不相交的长度为 k 的子串，使得他们拼起来之后包含 T。
|T| ≤ 2k ≤ |S| ≤ 5·1e5

样例： （答案：Yes 1 5）
7 4 3
baabaab
aaaa
KMP


我们用形式化的语言来进行描述。
假设现在 T[s+1..s+k] 和 P[1..k] 匹配上了。
此时 T[s+k+1] != P[k+1]。
朴素的做法是：回到 T[s + 2] 和 P[1] 重新开始比较。
KMP算法：找到一个最大的 x，使得 T[s+1..s+k] 的后 x个字符，和 P 的前 x 个字符相同。
这部分就是能匹配上的，我们可以不用逐个判断。
又注意到 T[s+1..s+k] = P[1..k]
那么我们要求的就是一个最大的 x，满足 P[1..k] 的前 x个字符等于它的后 x 个字符。当然 x 要小于 k。
这个 x 记为 next[k]
对于 P = ababaca
我们可以计算出next数组：

有了 next 数组，现在如何匹配两个字符串呢？
for (int i = 1, j = 0; i &amp;lt;= m; i ++ )
{
    while (j &amp;amp;&amp;amp; s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == n)
    {
        printf(&amp;quot;%d &amp;quot;, i - n);
        j = ne[j];
    }
}


讲过如何匹配之后，我们还要会高效计算 next 数组。
计算 next 数组的过程就是拿 P 和 P 自己匹配的过程。
只不过要在匹配的过程中，记录每个位置下指针指向的位置，作为 next 数组。
for (int i = 2, j = 0; i &amp;lt;= n; i ++ )
{
    while (j &amp;amp;&amp;amp; p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

KMP算法复杂度
时间复杂度：O(n)
空间复杂度：O(n)
例题
poj2406
给一个字符串 S，求 S 的一个最短的循环节 e，使得 S 可以写成 eee…eee （共|S|/|e|个 e）
输出 |S|/|e| 的最大值。|S| ≤ 1e6

样例：
abcd （答案：1）
aaaa （答案：4）
ababab （答案：3）
假设这个字符串的长度为 len
如果 len 可以被 len-next[len] 整除，那么我们就可以说len-next[len] 是那个循环节的长度。
因为 next[len] 就表示: S[1..next[len]] = S[next[len] + 1..len]
可以证明满足这一条性质的字符串具有长度为 len-next[len] 的循环周期
否则答案就是 1 了。
因为如果存在一个长度为 d 的循环节，那一定满足：
S[1..len-d+1] == S[d + 1 .. len]
但是现在循环节的长度只能是 len-next[len],如果它不是 len 的因子，那就没有可能了。
时间复杂度 O(n)

定理：假设S的长度为len，则S存在最小循环节，循环节的长度L为len-next[len]，子串为S[0…len-next[len]-1]。
（1）如果len可以被len - next[len]整除，则表明字符串S可以完全由循环节循环组成，循环周期T=len/L。
（2）如果不能，说明还需要再添加几个字母才能补全。需要补的个数是循环个数L-len%L=L-(len-L)%L=L-next[len]%L，L=len-next[len]。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1e6+10;
char s[N];
int ne[N];
int n;

int main()
{
	while(scanf(&amp;quot;%s&amp;quot;,s+1))
	{
		if(s[1] == &#39;.&#39;)
			break;
		
		n=strlen(s+1);
		for(int i=2,j=0;i&amp;lt;=n;i++)
		{
			while(j &amp;amp;&amp;amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		int t=n-ne[n];
		if(n%t == 0)
			cout&amp;lt;&amp;lt;n/t&amp;lt;&amp;lt;endl;
		else
			cout&amp;lt;&amp;lt;1&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj2752
给定一个字符串 S，求出 S 中所有的既是前缀又是后缀的子串。输出 i 代表 S[1..i]|S| ≤ 400000

样例：
ababcababababcabab（答案：2 4 9 18）
aaaaa（答案：1 2 3 4 5）
求出 next 数组。
答案就是 len, next[len], next[next[len]], …

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=4e5+10;
char s[N];
int ne[N];
int ans[N];

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s+1))
	{
		int n=strlen(s+1);
		for(int i=2,j=0;i&amp;lt;=n;i++)
		{
			while(j &amp;amp;&amp;amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
	
		int t=ne[n],cnt=0;
		while(t)
		{
			ans[cnt++]=t;
			t=ne[t];
		}
		
		for(int i=cnt-1;i&amp;gt;=0;i--)
			printf(&amp;quot;%d &amp;quot;,ans[i]);
		printf(&amp;quot;%d\n&amp;quot;,n);

	}
	return 0;
}

hdu2594
求出最长的既是 s1 的前缀又是 s2 的后缀的子串。

样例：
riemann
marjorie
答案：rie
只要把两个串拼起来，中间用一个分隔符,s1,s1,s1s2,令len=strlen(s1$s2),则next[len]即为答案
也可不加分隔符，枚举 len, next[len], next[next[len]] ......找到小于 min(|s1|, |s2|) 的最大值即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=50010*2;//数组开两倍!
char s1[N],s2[N];
int ne[N];

int main()
{
	while(~scanf(&amp;quot;%s%s&amp;quot;,s1+1,s2+1))
	{
		strcat(s1+1,&amp;quot;$&amp;quot;);
		strcat(s1+1,s2+1);
		int n=strlen(s1+1);
		for(int i=2,j=0;i&amp;lt;=n;i++)
		{
			while(j &amp;amp;&amp;amp; s1[i] != s1[j+1])
				j=ne[j];
			if(s1[i] == s1[j+1])
				j++;
			ne[i]=j;
		}
		
		int ans=ne[n];
		s1[ans+1]=&#39;\0&#39;;
		if(ans == 0)
			printf(&amp;quot;0\n&amp;quot;);
		else 
			printf(&amp;quot;%s %d\n&amp;quot;,s1+1,ans);
	}
}

Codeforces 526D
给出一个字符串 s，判断其每个前缀是否可以表示成ABAB…ABA 的形式（A 和 B 都可以为空， 但是必须满足 A 有 k+1 个，B 有 k 个）
|s|, k ≤ 1e6

输入
7 2
bcabcab
输出
0000011
长度为 6 的前缀，可以取 A=“”,B=“bca”
长度为 7 的前缀，可以取 A=“b”, B=“ca”
对于前缀 P，我们可以把 P 拆成 SSSS…ST，其中 T 是 S的前缀。
这样就可以用 KMP 来做了。
首先 i-next[i] 就是S[1..i] 这一段的最小循环节的长度，
记为 e。
可以发现 e 的倍数 je 也是循环节。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=1e6+10;
char s[N];
int n,k;
int ne[N];

bool check(int i,int cir)
{
	int up=i/k/cir;
	int down=ceil((i/(k+1)+1)/(1.0*cir));
	return up&amp;gt;=down || (i % (k+1) == 0 &amp;amp;&amp;amp; (i / (k+1)) % cir == 0);
}

int main()
{
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k))
	{
		scanf(&amp;quot;%s&amp;quot;,s+1);
		
		int len=strlen(s+1);
		for(int i=2,j=0;i&amp;lt;=len;i++)
		{
			while(j &amp;amp;&amp;amp; s[i] != s[j+1])
				j=ne[j];
			
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		for(int i=1;i&amp;lt;=n;i++)
		{
			int cir=i-ne[i];
			printf(&amp;quot;%d&amp;quot;,check(i,cir));
		}
	}
}

acwing
首先我们用KMP求出 T 的 next数组。
利用 next数组在长文本中匹配模板串 T的过程：如果下一个字母不匹配，需要一直沿着next指针找：j = next[j]，直到下一个字符匹配或者next指针指向开头为止。
然后我们会发现，假设我们已经匹配完长文本的前个字母，则剩下部分的匹配过程，只跟next指针的位置有关，因此我们可以用二维数组来表示当前状态的方案数：
f[i][j]表示匹配完前 i 个字母时，next指针在 j 时的方案总数。
状态转移：对于每个状态f[i][j]，我们从&#39;a&#39;-&#39;z&#39;枚举下一个字母，然后求出对应的next指针，假设是，则将f[i][j]的方案总数累加到f[i+1][u]。
转移过程中需要注意，因为密码中不能存在 T，所以next指针要避免转移到 T的最后一个字母。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt; 
using namespace std;
const int N=55,mod=1e9+7;
int f[N][N];
int edge[N][26];
char p[N];
int ne[N];
int n;


int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;p+1;
    int m=strlen(p+1);
    
    for(int i=2,j=0;i&amp;lt;=m;i++)
    {
        while(j &amp;amp;&amp;amp; p[i] != p[j+1])
            j=ne[j];
        if(p[i] == p[j+1])
            j++;
        ne[i]=j;
    }
    
    for(int i=0;i&amp;lt;m;i++)
        for(char k=&#39;a&#39;;k&amp;lt;=&#39;z&#39;;k++)
        {
            int j=i;//已匹配了前i个字母
            while(j &amp;amp;&amp;amp; p[j+1] != k)
                j=ne[j];
            if(p[j+1] == k)
                j++;
            edge[i][k-&#39;a&#39;]=j;
        }
        
    f[0][0]=1;
    for(int i=0;i&amp;lt;n;i++)
        for(int j=0;j&amp;lt;m;j++)
            for(char k=&#39;a&#39;;k&amp;lt;=&#39;z&#39;;k++)
            {
                int u=edge[j][k-&#39;a&#39;];
                f[i+1][u]=(f[i+1][u]+f[i][j])%mod;
            }
            
    int res = 0;
    for (int i = 0; i &amp;lt; m; i ++ ) res = (res + f[n][i]) % mod;

    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    return 0;
}

luoguP3193
设f(i,j)表示以准考证号为基准递推，准考证号匹配到第i位，不吉利数字匹配到第j位时（即准考证的后j位等于不吉利数字的前j位），不出现不吉利数字的字符串数量。。
那怎么转移？
既然要以考号为基准递推，就要考虑一位考号对下一位的影响。
而考号是可以随便写的，那我们就要考虑10种数字了。
对于一个新数字new，有以下几种情况：
1.new
与不吉利数字的j+1位匹配，dp(i+1,j+1)的答案数+dp(i,j)
2.上述两者不匹配。
不匹配怎么办？这个不匹配的new一定没有贡献了？
当然不一定。
怎么讲呢，举个例子吧，不吉利数字是12212112。然后你的准考证号枚举到第9位时，前面8位已经枚举成了11112212。可以发现已经匹配了不吉利数字的前5位，现在要匹配第6位。
如果第9位枚举1，那它就匹配了，dp(9,6)+=dp(8,5)。如果第9位枚举2，那它就不匹配。但是会发现，存在 与当前已匹配的不吉利数字的后缀相同 的前缀，可以匹配上这个2！
上一个位置就是不吉利数字的第2位。
它的下一位，第3位2，刚好可以匹配枚举的第9位！
所以此时最多能匹配不吉利数字的前3位，有转移dp(9,3)+=dp(8,5)。
我们只需要沿着不吉利数字的失配指针往前走，找到第一个下一位与new匹配的位置就可以了。
为什么不用考虑再往前的下一位可以匹配new的位置？
因为这是递推，从前往后每一种状态都会被考虑，所以在考虑匹配后面的位之前，前面的位已经匹配好更前面的情况了。
比如不吉利数字1221221211。你目前枚举的准考证号前8位是12212212，现在你要枚举第9
位。很明显当枚举2时，通过找不吉利数字中 后缀相同的前缀，可知dp(8,8)可以转移到dp(9,6)。
但是我们发现也可以转移到dp(9,3)诶！
事实上，在这之前dp(8,5)已经转移到dp(9,3)过了。而dp(8,5)表示什么？它表示准考证号枚举8位，后5位与不吉利数字的前5位匹配上。
dp(8,8)同理，表示准考证号枚举前8位，后8位与不吉利数字的前8位匹配上。
这样直观看起来没什么答案关联。但是仔细考虑以下，不吉利数字的第8位的失配指针指向第5位。
这说明什么？
不吉利数字的前8位中，前5位等于后5位！
匹配5位的情况包含匹配8位的情况！（因为你匹配了8位，根据上推论可知也算在匹配了5位的情况中）
这就是别人博客中此题题解经常提到的计数方案会包含的问题。
其实按照AC自动机的构造方式，如果一个点没有字符为new的儿子边的话，它会建出一条对应的虚拟儿子边和点，儿子点上存的是沿着失配指针往回走的上一个实际存在这条字符边所指向的儿子。
当然这题m很小，不吉利数字串自己匹配自己的复杂度很小，可以直接暴力跑失配指针找第一个。

其中g(i,j)表示当前匹配到i个字符，添加一个字符变成匹配为j个字符的方案数。
不吉利数字已经知道了，g数组可以预处理出来（KMP）。
然后我们惊奇地发现n≤1e9，不让你循环推，直接就想到矩阵快速幂优化了。
观察一下转移方程，发现dp[i+1][?]总是由dp[i][?]推来，而且i还是n这个级别的。
又发现每次实际上都是乘一个固定的矩阵g，也就是说整个dp数组的某一位的值其实都是通过一些g数组乘过来的。
所以可以把dp数组直接当成g数组自己乘自己。
比如说，g(4,2)=4。
表示有4种转移情况可以让 与不吉利数字的前4位匹配的情况 在准考证号增加1位后 与不吉利数字的前2位匹配。
所以dp(x+1,2)=dp(x,4)∗g(4,2)=dp(x,4)∗4
而dp(x,4)又是哪来的？
它是通过∑i=1m\sum_{i=1}^m∑i=1m​dp(x−1,i)∗g(i,4)转移过来的。
所以一直往前推到x=0，发现dp值的n次转移都只跟转移矩阵g有关，是否与不吉利数字完全匹配等情况可以在弄g数组时就处理掉，即g数组只考虑不吉利数字被匹配0~m−1位的情况，不让它转移到j位都被匹配的情况。
所以就是对g矩阵做快速幂，求它的n次方。
时间复杂度O(log(n)∗m^3)
为什么答案是g(0,i)，for i 0~m-1
考虑g(i,j)的意义。如果g矩阵自己对自己连续进行k次转移（不进行快速幂而循环推），g(i,j)就表示：在进行k次转移前 准考证号匹配不吉利数字的前i位时，准考证号增加k个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。这是矩阵转移的基本概念。
所以进行n次转移后，g(i,j)就表示一开始准考证号匹配不吉利数字的前i位时，准考证号增加n个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。
我们需要取全局情况的答案，而这是很显然的。开始时准考证号匹配不吉利数字的前0位（准考证号还一位都没枚举），所以i为0；而由于已经定义过g数组只考虑不吉利数字被匹配 0~m−1位的情况，所以j在这个区间取任意值，g(0,j)都是答案的一部分。把它们都算上就是答案。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=25;
char p[N];
int n,m,mod;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
};
int ne[N];

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&amp;lt;m;i++)
		for(int j=0;j&amp;lt;m;j++)
			for(int k=0;k&amp;lt;m;k++)
				res.m[i][j]=(res.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return res;
}

int main() 
{
	scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;mod);
	scanf(&amp;quot;%s&amp;quot;, p+1);
	
	matrix g;
	for(int i=2,j=0;i&amp;lt;=m;i++)
	{
		while(j &amp;amp;&amp;amp; p[i] != p[j+1])
			j=ne[j];
		if(p[i] == p[j+1])
			j++;
		ne[i]=j;
	}
	
	for(int i=0;i&amp;lt;m;i++)
		for(int k=0;k&amp;lt;10;k++)
		{
			int j=i;
			while(j &amp;amp;&amp;amp; p[j+1]-&#39;0&#39; != k)
				j=ne[j];
			if(p[j+1]-&#39;0&#39; == k)
				j++;
			if(j&amp;lt;m)	g.m[i][j]=(g.m[i][j]+1)%mod;
		}
	
	matrix a;
	for(int i=0;i&amp;lt;m;i++)
		a.m[i][i]=1;
	
	while(n)
	{
		if(n &amp;amp; 1) a=mul(a,g);
		g=mul(g,g);
		n&amp;gt;&amp;gt;=1;
	}
//	
//	for(int i=0;i&amp;lt;m;i++)
//	{
//		for(int j=0;j&amp;lt;m;j++)
//			cout&amp;lt;&amp;lt;a.m[i][j]&amp;lt;&amp;lt;&#39; &#39;;
//		cout&amp;lt;&amp;lt;endl;
//	}
	
	int ans = 0;
	for(int i = 0; i &amp;lt; m; ++i)
		ans = (ans + a.m[0][i]) % mod;
	
	printf(&amp;quot;%d\n&amp;quot;, ans);
	return 0;
}



Z算法




r[5] = 7
r[6] = 7
l[5] = 5
l[6] = 5

对于 Z[2] 我们需要暴力计算。
也就是暴力计算 S[1..|S|] 和 S[2..|S|] 的最长公共前缀。
如果 Z[2] &amp;gt; 0, 那么 r = r[2], l = l[2] = 2
如果 Z[2] = 0, 那么 r = r[2] = 0, l = l[2] = 0
我们的目标就是用已有的 Z[2], Z[3], ..., Z[k-1]，来推
出 Z[k].
假设 k = 121, Z[2..120] 已经知道了
r[120] = 130, l[120] = 100

划分成[l,i-1],[i,r]





蓝色部分一定不相等，否则说明z-box可以右移
第一步：
初始化 Z[]，暴力计算 Z[2]
for(int i = 1;i &amp;lt;= n;i ++) z[i] = 0;
int l, r;
while(str[1 + z[2]] == str[2 + z[2]]) z[2] ++; 
l = 2, r = 2+ z[2]-1;

第二步：
枚举 i，分三种情况依次计算 Z[i]
for(int i = 3;i &amp;lt;= n;i ++)
{
    if(i &amp;gt; r)
    {
        while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
        l = i, r = i + z[i] - 1;
    }
    else
    {
        if(z[i - l + 1] &amp;lt; r - i + 1) z[i] = z[i - l + 1];
        else
        {
            z[i] = r - i;
            while(str[1 + z[i]] == str[i + z[i]]) z[i] ++; 
            l = i, r = i + z[i] - 1; 
        }
    } 
}

时间复杂度是 O(n) 的
扩展KMP
给定两个字符串 S 和 T（长度分别为 n 和 m）
定义 extend[i] 为 S[i..n] 与 T 的最长公共前缀的长度。
求出 extend 数组

如果 S = T，那么 extend 数组就是 Z 数组。

假设现在遍历到了 S[i]，且 S[1], S[2],…, S[i-1]都已经算出
与 Z 算法类似，设置两个变量 l 和 r，r 表示能和 T 匹
配到的最右边的位置，l 为 r 对应的起始位置。
也就是 S[l .. r] = T[1.. r-l+1]

S[i] 对应的是 T[i-l+1]
现在要计算的是 S[i..n] 与 T 的最长公共前缀
注意到此时 S[i..r] = T[i-l+1 .. r-l+1]
所以我们可以先对 T 求一遍 Z 数组，然后考察一下 Z[i-l+1]



void calc_Z(char *str) 
{
	int n = strlen(str + 1);
	for(int i = 1; i &amp;lt;= n; i ++) z[i] = 0;
	z[1] = n;
	int l, r = 0;
	for(int i = 2; i &amp;lt;= n; i ++) 
	{
		if(i &amp;gt; r) 
		{
			while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
			l = i, r = i + z[i] - 1;
		} else 
		{
			if(z[i - l + 1] &amp;lt; r - i + 1) z[i] = z[i - l + 1];
			else 
			{
				z[i] = r - i + 1;
				while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
				l = i, r = i + z[i] - 1;
			}
		}
	}
}

void calc_extend(char *S, char *T) 
{
	calc_Z(T);
	int l, r = 0;
	int n = strlen(S + 1);
	int m = strlen(T + 1);
	for (int i = 1; i &amp;lt;= n; i ++) 
	{
		if (i &amp;gt; r) 
		{
			while (i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp;
			        S[i + ext[i]] == T[1 + ext[i]]) ext[i] ++;
			l = i, r = i + ext[i] - 1;
		}
		else 
		{
			if (i + z[i - l + 1] - 1 &amp;lt; r) ext[i] = z[i - l + 1];
			else 
			{
				ext[i] = r - i + 1;
				while (i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp; S[i +ext[i]] == T[1 + ext[i]]) 
					ext[i] ++;
				l = i, r = i + ext[i] - 1;
			}
		}
	}
}

例题
题意：给你n个字符串，求这n个字符串的最长公共子串
hdu4333
给一个 L 位数的正整数 N，每次可以把这个数的最后一位移到最前面来，得到一个新的数。
总共最多可以得到 n 个数，重复的只算一次。
问这些数中，等于 n 的，小于 n的，大于 n 的数分别有几个。
L ≤ 1e5

样例：
341 （答案： 1 1 1）
我们只需要把这个数复制两遍，然后只考虑长度为 n 的子串。这些子串就是移动过程中产生的数。
如何和原数 N 做比较呢
假设现在的数是 S[i .. i+L-1], N 是 S[1..L]
我们只要求出他们的最长公共前缀 x，如果 x = n 说明这两个数相等。
否则，比较 S[x] 和 S[i+x-1] 的大小，就可以确定他们的大小关系。
求 x ，就是扩展 KMP 中的 Z 算法。x = min(n, Z[i])
最后一步去重。对 N 跑一次 KMP
如果 L-next[L] 是 L 的约数，那么 L-next[L] 是 N 的最小循环节。否则 N 的 最小循环节是 L。
对循环节内的情况枚举一遍即可,或除以最小循环节个数。
时间复杂度 O(L)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=200010;
char str[N];
int ne[N];
int z[N];

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    for(int kas=1;kas&amp;lt;=T;kas++)
    {
        scanf(&amp;quot;%s&amp;quot;,str+1);
        
        int len=strlen(str+1);
        for(int i=2,j=0;i&amp;lt;=len;i++)
        {
            while(j &amp;amp;&amp;amp; str[i] != str[j+1])
                j=ne[j];
            if(str[i] == str[j+1])
                j++;
            ne[i]=j;
        }
        
        for(int i=1;i&amp;lt;=len;i++)
            str[i+len]=str[i];
        str[len*2+1]=&#39;\0&#39;;
        memset(z,0,sizeof z);
        z[1]=len*2;
        int l,r=0;
        
        for(int i=2;i&amp;lt;=len*2;i++)
        {
            if(i&amp;gt;r)
            {
                while(str[1+z[i]] == str[i+z[i]])
                    z[i]++;
                l=i,r=i+z[i]-1;
            }
            else 
            {
                if(z[i-l+1] &amp;lt; r-i+1)
                    z[i]=z[i-l+1];
                else 
                {
                    z[i]=r-i;
                    while(str[1+z[i]] == str[i+z[i]])
                        z[i]++;
                    l=i,r=i+z[i]-1;
                }
            }
        }
        
        int gre=0,eql=0,les=0;
        for(int i=1;i&amp;lt;=len;i++)
        {
            if(z[i] &amp;gt;= len)
                eql++;
            else if(str[1+z[i]] &amp;gt; str[i+z[i]])
                les++;
            else gre++;
        }
        
        int t;
        if(len%(len-ne[len]) == 0)
            t=len/(len-ne[len]);//循环节个数 
        else 
            t=1;
        printf(&amp;quot;Case %d: %d %d %d\n&amp;quot;,kas,les/t,eql/t,gre/t);
    }
}

对循环节内的情况枚举代码
poj3376
给你 n 个字符串 m[1], m[2], …, m[n]。 求 S = m[i]m[j] （1 &amp;lt;= i,j &amp;lt;= n）是回文串的数量。
n 个字符串的长度之和不超过 2·1e6

样例输入：
3a
ab
ba
答案：5（aa,aba,aba,abba,baab)
考虑什么情况下 i 和 j 拼起来会是回文串。


i的长度小于j，那么i一定是j的反串的前缀，且j的反串剩下的后缀是回文串


i的长度等于j，那么i等于j的反串


i的长度大于j，那么j的反串一定是i的前缀，且i串剩下的后缀是回文串


我们可以将这n个字符串插入trie，每个节点要维护两个值：
value1. 到当前节点的字符串个数；value2.当前节点后面的回文子串个数
我们用每个字符串的反串去trie上查找，要构成回文串有以下情况：


1.此反串是其他串的前缀，那么组合回文串的数量就要加上value2


2.此反串的前缀是某些字符串，且反串剩下的后缀是回文串，那么组合回文串的数量要加上value1


3.2的特例：此反串的前缀是某些字符串，且反串剩下的后缀为空，同样要加上value1，这种情况可以和2一起处理


留下的问题就是一个字符串的所有后缀中，哪些是回文串。
对于串 S，我们先求出正串 S 对反串 T 的 extend[i]
那么对于每个 i，如果 S[i..n] 和 T 的最长公共前缀等于
S[i..n] 的长度，说明 S[i..n] 是一个回文串。
因此整道题就在线性的时间复杂度内解决了。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=2e6+10;
int trie[N][26],tot=1;
int n;
char s[N],t[N];
int len[N];
int slen;
int z[N],ext[N];
bool flag[2][N];
int bg[N],ed[N];
typedef long long LL;
struct Node
{
	int v1,v2;
}cnt[N];

void get_z(char *s)
{
	int n=strlen(s+1);
	for(int i=1;i&amp;lt;=n;i++) z[i]=0;
	z[1]=n;
	int l,r=0;
	for(int i=2;i&amp;lt;=n;i++)
	{
		if(i&amp;gt;r)
		{
			while(s[1+z[i]] == s[i+z[i]])
				z[i]++;
			l=i,r=i+z[i]-1;
		}
		else
		{
			if(z[i-l+1] &amp;lt; r-i+1)
				z[i]=z[i-l+1];
			else
			{
				z[i]=r-i;
				while(s[1+z[i]] == s[i+z[i]])
					z[i]++;
				l=i,r=i+z[i]-1;
			}
		}
	}
}

void exkmp(int type,char *s,char *t)
{
	get_z(t);
	int n=strlen(s+1);
	int m=strlen(t+1);
	for(int i=1;i&amp;lt;=n;i++)
		ext[i]=0;
	int l,r=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		if(i&amp;gt;r)
		{
			while(i+ext[i] &amp;lt;=n &amp;amp;&amp;amp; 1+ext[i] &amp;lt;=m &amp;amp;&amp;amp;
			s[i+ext[i]] == t[1+ext[i]])
				ext[i]++;
			l=i,r=i+ext[i]-1;
		}
		else
		{
			if(z[i-l+1] &amp;lt; r-i+1)
				ext[i]=z[i-l+1];
			else
			{
				ext[i]=r-i+1;
				while(i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp; 
				s[i+ext[i]] == t[1+ext[i]])
					ext[i]++;
				l=i,r=i+ext[i]-1;
			}
		}
	}

	for(int i=1;i&amp;lt;=n;i++)
	{
		//cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;ext[i]&amp;lt;&amp;lt;endl;
		if(ext[i] == n-i+1)
			flag[type][i+slen]=true;//s[i...n]为回文串
	}
}

void insert(int k)
{
	int p=1;
	for(int i=bg[k];i&amp;lt;=ed[k];i++)
	{
		cnt[p].v2+=flag[0][i];
		int ch=s[i]-&#39;a&#39;;
		if(!trie[p][ch])
			trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	cnt[p].v1++;
}

void print(int k)
{
	int p=1;
	for(int i=bg[k];i&amp;lt;=ed[k];i++)
	{
		int ch=s[i]-&#39;a&#39;;
		p=trie[p][ch];
		cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;cnt[p].v2&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;cnt[p].v1&amp;lt;&amp;lt;endl;
	}
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;len[i]);
		scanf(&amp;quot;%s&amp;quot;,s+1+slen);
		for(int j=1;j&amp;lt;=len[i];j++)
			t[slen+j]=s[slen+len[i]+1-j];
		t[slen+len[i]+1]=&#39;\0&#39;;
		exkmp(0,s+slen,t+slen);
		exkmp(1,t+slen,s+slen);

		bg[i]=slen+1;
		slen+=len[i];
		ed[i]=slen;

		insert(i);
		//print(i);
	}

	LL ans=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		int p=1;
		bool f=true;
		for(int j=ed[i];j&amp;gt;=bg[i];j--)//用反串去trie上匹配
		{
			int k=s[j]-&#39;a&#39;;
			if(!trie[p][k])
			{
				f=false;
				break;
			}
			else
				p=trie[p][k];
			if(flag[1][bg[i]+ed[i]-j+1] || j == bg[i])
				ans+=cnt[p].v1;
		}
		if(f)
			ans+=cnt[p].v2;
	}

	printf(&amp;quot;%lld\n&amp;quot;,ans);
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://caifxh.github.io/images/avatar.png?v=1585231131035)">
        </div>
        <h1 class="id_card-title">
            fxh
        </h1>
        <h2 class="id_card-description">
            菜
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>