<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caifxh.github.io</id>
    <title>fxh</title>
    <updated>2020-04-10T05:01:24.893Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caifxh.github.io"/>
    <link rel="self" href="https://caifxh.github.io/atom.xml"/>
    <subtitle>菜</subtitle>
    <logo>https://caifxh.github.io/images/avatar.png</logo>
    <icon>https://caifxh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, fxh</rights>
    <entry>
        <title type="html"><![CDATA[尺取法]]></title>
        <id>https://caifxh.github.io/post/chi-qu-fa/</id>
        <link href="https://caifxh.github.io/post/chi-qu-fa/">
        </link>
        <updated>2020-04-09T16:19:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="尺取法">尺取法</h4>
<p>尺取法（又称为：双指针、twopointers），是算法竞赛中一个常用的优化技巧，用来解决序列的区间问题，操作简单、容易编程。</p>
<p>如果区间是单调的，也常常用二分法来求解，所以很多问题用尺取法和二分法都行。</p>
<p>尺取法：顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。之所以需要掌握这个技巧，是因为尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以尺取法是一种高效的枚举区间的方法，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案。</p>
<p>使用尺取法时应清楚以下四点：</p>
<p>1、  什么情况下能使用尺取法?<br>
2、何时推进区间的端点？<br>
3、如何推进区间的端点？<br>
4、何时结束区间的枚举？</p>
<p>尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。</p>
<h4 id="尺取法的概念">尺取法的概念</h4>
<p>什么是尺取法？为什么尺取法能优化呢？<br>
考虑下面的应用背景：<br>
（1）给定一个序列。有时候需要它是有序的，先排序。<br>
（2）问题和序列的区间有关，且需要操作2个变量，可以用两个下标（指针）i、j扫描区间。<br>
对于上面的应用，一般的做法，是用i、j分别扫描区间，有两重循环，复杂度O(n2)。以反向扫描（即i、j方向相反，后文有解释）为例，代码是：</p>
<pre><code>for(int i = 0; i &lt; n; i++)           //i从头扫到尾
	for(int j = n-1; j &gt;= 0; j--){   //j从尾扫到头
        ......
    }
</code></pre>
<p>下面用尺取法来优化上面的算法。<br>
实际上，尺取法就是把两重循环变成了一个循环，在这个循环中一起处理i和j。复杂度也就从O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)变成了O(n)。仍以上面的反向扫描为例，代码是：</p>
<pre><code>//用while实现：
int i = 0, j = n - 1;
while (i &lt; j) {      //i和j在中间相遇。这样做还能防止i、j越界
        ......       //满足题意的操作
        i++;         //i从头扫到尾
        j--;         //j从尾扫到头
}
//用for实现：
for (int i = 0, j = n - 1; i &lt; j; i++, j--) {
    ......
}
</code></pre>
<p>在尺取法中，这两个指针i、j，有两种扫描方向：<br>
（a）反向扫描。i、j方向相反，i从头到尾，j从尾到头，在中间相会。<br>
（b）同向扫描。i、j方向相同，都从头到尾，可以让j跑在i前面。<br>
把同向扫描的i、j指针称为“快慢指针”，把反向扫描的i、j指针称为“左右指针”，更加形象。快慢指针在序列上产生了一个大小可变的“滑动窗口”，有灵活的应用</p>
<h4 id="反向扫描">反向扫描</h4>
<p>1.找指定和的整数对<br>
这个问题是尺取法最经典，也最简单直接的应用。</p>
<p>输入n ( n≤100,000)个整数，放在数组a[]中。找出其中的两个数，它们之和等于整数m(假定肯定有解)。题中所有整数都是int型。<br>
样例输入：<br>
21 4 5 6 13 65 32 9 23<br>
28<br>
样例输出：<br>
5 23<br>
说明：样例输入的第一行是数组a[]，第2行是m = 28。样例输出5和23，相加得28。</p>
<p>为了说明尺取法的优势，下面给出四种方法：<br>
（1）用两重循环暴力搜，枚举所有的取数方法，复杂度O(n2)，超时。暴力法不需要排序。<br>
（2）二分法。首先对数组从小到大排序，复杂度O(nlogn)；然后，从头到尾处理数组中的每个元素a[i]，在大于a[i]的数中二分查找是否存在一个等于 m - a[i]的数，复杂度也是O(nlogn)。两部分相加，总复杂度仍然是O(nlogn)。<br>
（3）Hash。分配一个hash空间s，把n个数放进去。逐个检查a[]中的n个数，例如a[i]，检查m - a[i]在s中是否有值，如果有，那么存在一个答案。复杂度是O(n)。<br>
hash方法很快，但是需要一个额外的、可能很大的hash空间。<br>
（4）尺取法。这是标准解法。首先对数组从小到大排序；然后，设置两个变量i和j，分别指向头和尾，i初值是0，j初值是n-1，然后让i和j逐渐向中间移动，检查a[i]+a[j]，如果大于m，就让j减1，如果小于m，就让i加1，直至a[i]+a[j] = m。排序复杂度O(nlogn)，检查的复杂度O(n)，合起来总复杂度O(nlogn)。</p>
<pre><code>void find_sum(int a[], int n, int m){ 
     sort(a, a + n - 1);      //先排序，复杂度O(nlogn)
     int i = 0, j = n - 1;    //i指向头，j指向尾
     while (i &lt; j){           //复杂度O(n)
		    int sum = a[i] + a[j];
		    if (sum &gt; m)   j--;
		    if (sum &lt; m)   i++;
		    if (sum == m){     
			    cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; a[j] &lt;&lt; endl;  //打印一种情况
                i++;          //可能有多个答案，继续
		    }
	  }
}
</code></pre>
<h4 id="判断回文串">判断回文串</h4>
<p>2.给一个字符串，判断它是不是回文串。</p>
<p>“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”就是回文串。写一个程序判断读入的字符串是否是“回文”。如果是，输出“yes”，否则输出“no”。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    int n;
    cin &gt;&gt; n;                         //n是测试用例个数
    while(n--){
        string s;  cin &gt;&gt; s;          //读一个字符串
        bool ans = true;
        int i = 0, j = s.size() - 1;  //双指针
        while(i &lt; j){ 
            if(s[i] != s[j]){
                ans = false;
                break;
            }
            i++;   j--;               //移动双指针
        }
        if(ans)   cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        else      cout &lt;&lt; &quot;no&quot;  &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<p>允许删除（或插入，本题只考虑删除）最多1个字符，判断是否能构成回文字符串。</p>
<p>设反向扫描双指针为i、j。如果 s[i]和s[j]相同，i++、j–；如果s[i]和s[j]不同，那么，或者删除s[i]，或者删除s[j]，看剩下的字符串是否是回文串即可。</p>
<h4 id="同向扫描">同向扫描</h4>
<p>1.寻找区间和<br>
这是用尺取法产生“滑动窗口”的典型例子。</p>
<p>给定一个长度为n的数组a[]和一个数s，在这个数组中找一个区间，使得这个区间之和等于s。输出区间的起点和终点位置。<br>
样例输入：<br>
15<br>
6 1 2 3 4 6 4 2 8 9 10 11 12 13 14<br>
6<br>
样例输出：<br>
0 0<br>
1 3<br>
5 5<br>
6 7<br>
说明：样例输入的第1行是n=15，第2行是数组a[]，第3行是区间和s=6。样例输出，共有4个情况。</p>
<p>题解<br>
指针i和j，i&lt;=j，都从头向尾扫描，判断区间[i,j]的和是否等于s。<br>
如何寻找区间和等于s的区间？如果简单地对i和j做二重循环，复杂度是O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)。用尺取法，复杂度O(n)，操作步骤是：<br>
（1）初始值i=0、j=0，即开始都指向第一个元素a[0]。定义sum是区间[i, j]的和，初始值sum = a[0]。<br>
（2）如果sum等于s，输出一个解。继续，把sum减掉元素a[i]，并把i往后移动一位。<br>
（3）如果sum大于s，让sum减掉元素a[i]，并把i往后移动一位。<br>
（4）如果sum小于s，把j往后挪一位，并把sum的值加上这个新元素。<br>
在上面的步骤中，有2个关键技巧：<br>
（1）滑动窗口的实现。窗口就是区间[i,j]，随着i和j从头到尾移动，窗口就“滑动”扫描了整个序列，检索了所有的数据。i和j并不是同步增加的，窗口像一只蚯蚓伸缩前进，它的长度是变化的，这个变化，正对应了对区间和的计算。<br>
（2）sum的使用。如何计算区间和？暴力的方法是从a[i]到a[j]累加，但是，这个累加的复杂度是O(n)的，会超时。如果利用sum，每次移动i或j的时候，只需要把sum加或减一次，就得到了区间和，复杂度是O(1)。这是“前缀和”递推思想的应用。</p>
<p>以下是几个经典的使用尺取法的例题，都是从挑战书上引用的。（尺取法通常会需要对某些量进行预处理，以便能在使用时快速地判断。</p>
<p><a href="https://vjudge.net/problem/POJ-3061">poj3061</a><br>
题意：给定一个序列，找出最短的子序列长度，使得其和大于或等于S。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/09/9969_60ea20507a-37.PNG" alt="37.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/09/9969_7e2f255c7a-38.PNG" alt="38.PNG" loading="lazy"></p>
<p>分析：首先，序列都是正数，如果一个区间其和大于等于S了，那么不需要在向后推进右端点了，因为其和也肯定大于等于S但长度更长，<strong>所以，当区间和小于S时右端点向右移动，和大于等于S时，左端点向右移动以进一步找到最短的区间，如果右端点移动到区间末尾其和还不大于等于S，结束区间的枚举。</strong></p>
<p>Input：<br>
10 15<br>
5 1 3 5 10 7 4 9 2 8<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_7ec42c2e79-16.png" alt="16.png" loading="lazy"><br>
二分+前缀和：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010;
int s[N];
int n,m;

bool check(int mid)
{
	for(int i=1;i&lt;=n-mid+1;i++)
		if(s[i+mid-1]-s[i-1] &gt;= m)
			return 1;
	return 0;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;s[i]),s[i]+=s[i-1];
			
		if(s[n] &lt; m) 
		{
			cout&lt;&lt;0&lt;&lt;endl;
			continue;
		}
		
		int l=1,r=n;
		while(l&lt;r)
		{
			int mid=l+r&gt;&gt;1;
			if(check(mid))
				r=mid;
			else 
				l=mid+1;
		}
		
		printf(&quot;%d\n&quot;,l);
	}
	return 0;
}
</code></pre>
<p>尺取法：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010;
int a[N];
int n,m;

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for(int i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);
		int ans=n+1;
		int sum=0;
		int l=0,r=0;
		while(1)
		{
			while(r&lt;n &amp;&amp; sum&lt;m)
				sum+=a[r],r++;
			
			if(sum &lt; m) break;
			
			ans=min(ans,r-l);
			sum-=a[l++];//左端点向右移动以进一步找到最短的区间
		}
		
		if(ans == n+1) ans=0;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3320">poj3320</a><br>
题意：一本书有P页，每一页都一个知识点，求去最少的连续页数覆盖所有的知识点。</p>
<p>和上面的题一样的思路，如果一个区间的子区间满足条件，那么在区间推进到该处时，右端点会固定，左端点会向右移动到其子区间，且其子区间会是更短的，只是需要存储所选取的区间的知识点的数量，那么使用map进行映射以快速判断是否所选取的页数是否覆盖了所有的知识点。</p>
<ul>
<li>当前区间若可行，则需在保证可行的前提下，缩小区间范围，将l指针右移</li>
<li>当前区间若不可行，则需要扩大区间范围，将r指针右移</li>
<li>当r已到末尾且l已经最优时，结束枚举</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;
const int N=1000010;
int a[N],cnt[N];
map&lt;int,int&gt; m;
int tot;
int n;

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(!m[a[i]]) m[a[i]]=++tot;
		a[i]=m[a[i]];
	}
	
	int ans=n;
	int l=1,r=1;
	int sum=0;
	
	while(1)
	{
		while(r&lt;=n &amp;&amp; sum&lt;tot)
			if(cnt[a[r++]]++ == 0)
				sum++;
			
		if(sum &lt; tot) break;
		ans=min(ans,r-l);
		if(--cnt[a[l++]] == 0) sum--;
	}
	
	printf(&quot;%d\n&quot;,ans);
	
	return 0;
}
</code></pre>
<p><a href="">poj2566</a><br>
题意：给你n个数字，这些数字可正可负，再给你个数字t,求在这个数列中一个连续的子序列，和的绝对值与t相差最小</p>
<p>一般来说，我们必须要保证数列单调性，才能使用尺取法。<br>
预处理出前i个数的前缀和，和编号i一起放入pair中，然而根据前缀和大小进行排序。由于<br>
abs(sum[i]-sum[j]) =  abs(sum[j]-sum[i])<br>
可以忽视数列前缀和的前后关系。此时，sum[r]-sum[l]有单调性。</p>
<p>因此我们可以先比较当前sum[r]-sum[l]与t的差，并更新答案。</p>
<p>如果当前sum[r]-sum[l]&lt;t,说明和还可以更大，r++。</p>
<p>同理，如果sum[r]-sum[l]&gt;t，说明和还可以更小，l++。</p>
<p>如果sum[r]-sum[l]=t，必定是最小答案。</p>
<ul>
<li>尺取的前提是一个有序的，可判定的序列，由于题目说的是连续序列和的绝对值，也就是说我们只需要知道两个端点</li>
<li>利用前缀和来进行判定，我们来枚举前缀和的两个端点，从而可以找到一个最接近询问值的数，</li>
<li>我们在存前缀和的同时还得把相应的坐标给存上，</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define x first
#define y second
typedef pair&lt;int,int&gt; PII;
const int N=100010,INF=0x3f3f3f3f;
PII s[N];
int n,m;
int ans,st,ed;

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		if(!n &amp;&amp; !m) break;
		s[0]=make_pair(0,0);
		for(int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;s[i].x);
			s[i].y=i;
			s[i].x+=s[i-1].x;
		}
		
		sort(s,s+n+1);
		
		while(m--)
		{
			int t;
			scanf(&quot;%d&quot;,&amp;t);
			int l=0,r=1;
			int mi=INF;
			while(r&lt;=n)                                            
			{
				int val=s[r].x-s[l].x;
				if(abs(val-t) &lt; mi)
				{                              
					mi=abs(val-t);
					ans=val;
					st=s[l].y;
					ed=s[r].y;
				}
				
				if(val &lt; t) r++;
				else if(val &gt; t) l++;
				else break;
				
				if(l == r) r++;
			}
			
			if(st &gt; ed) swap(st,ed);
			
			printf(&quot;%d %d %d\n&quot;,ans,st+1,ed);
		}
	}
	return 0;
}
</code></pre>
<ul>
<li>由于序列不能为空，如果l==r,则r++。</li>
<li>我们更新答案的时候左右区间端点为乱序，输出的时候调整一下。</li>
</ul>
<p><a href="https://vjudge.net/problem/POJ-2739">poj2739</a><br>
题意：找到某一个区间使得区间内的数的和等于某一给定值k。</p>
<p>设输入为x，只要判断x是否可以表示为x=y(i)+y(i+1)+y(i+2)+...+y(i+m)，即可，其中y为某一个素数。只要设置两个变量i，j，分别指向这个连续素数串的头和尾，不停的移动寻找解即可。不过首先需要得到10000以内的所有素数，如果每次输入都计算这些素数，没有必要而且可能会超时，所以先把所有素数计算出来并存储在一个数组中。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=10010;
int primes[N],cnt;
int n;

bool isprime(int x)
{
	for(int i=2;i*i&lt;=x;i++)
		if(x%i == 0) 
			return false;
	return true;
}

void init(int n)
{
	for(int i=2;i&lt;=n;i++)
		if(isprime(i))
			primes[cnt++]=i;
}

int main()
{
	init(N-1);

	while(~scanf(&quot;%d&quot;,&amp;n))
	{
	    if(!n) break;
	    int l=0,r=0;
    	int ans=0;
    	int sum=0;
    	
    	while(1)
	    {
    		while(r&lt;cnt &amp;&amp; sum&lt;n)
    			sum+=primes[r++];
    		if(sum &lt;n) break;
    		
    		if(sum == n)
    			ans++;
    		sum-=primes[l++];
	    }
	    
	    printf(&quot;%d\n&quot;,ans);
	}

	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2100">poj2100</a><br>
题意:给你一个数，询问有多少种连续自然数的平方和等于这个数，输出所有可能</p>
<p>题解:尺取法遍历所有符合条件的区间，满足的话记录左边界以及右边界，计数器+1。<br>
尺取法过程:</p>
<ul>
<li>
<p>1.初始化左右端点</p>
</li>
<li>
<p>2.不断扩大右端点，直到满足条件</p>
</li>
<li>
<p>3.如果第二步中无法满足条件，则终止，否则更新结果</p>
</li>
<li>
<p>4.将左端点扩大1，然后回到第二步</p>
</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define x first 
#define y second
typedef long long LL;
typedef pair&lt;int,int&gt; PII;
const int N=1e7+10;
vector&lt;PII&gt; ans;
LL n;

int main()
{
	while(~scanf(&quot;%lld&quot;,&amp;n))
	{
		ans.clear();
		
		LL l=1,r=1;
		LL sum=0;
		
		while(1)
		{
			while(r*r &lt;= n &amp;&amp; sum &lt; n)
				sum+=r*r,r++;
			
			if(sum &lt; n) break;
			
			if(sum == n) ans.push_back(make_pair(l,r-1));
			
			sum-=l*l,l++;
		}
		
		printf(&quot;%d\n&quot;,ans.size());
		for(int i=0;i&lt;ans.size();i++)
		{
			printf(&quot;%d &quot;,ans[i].y-ans[i].x+1);
			for(int j=ans[i].x;j&lt;ans[i].y;j++)
				printf(&quot;%d &quot;,j);
			printf(&quot;%d\n&quot;,ans[i].y);
		}	
	}
	
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5672">hdu5672</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/09/9969_81340f2e7a-34.PNG" alt="34.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1e6+10;
char s[N];
int cnt[30];
int k;

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		memset(cnt,0,sizeof cnt);
		scanf(&quot;%s&quot;,s);
		scanf(&quot;%d&quot;,&amp;k);
		int n=strlen(s);
		int l=0,r=0;
		LL ans=0;
		int sum=0;
		
		while(1)
		{
			while(r&lt;n &amp;&amp; sum&lt;k)
				if(cnt[s[r++]-'a']++ == 0)
					sum++;
			
			if(sum &lt; k) break;
			
			ans+=n-r+1;
			
			if(--cnt[s[l++]-'a'] == 0) sum--;
		}
		
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1638">P1638</a><br>
博览馆正在展出由世上最佳的 M 位画家所画的图画。<br>
wangjy想到博览馆去看这几位大师的作品。<br>
可是，那里的博览馆有一个很奇怪的规定，就是在购买门票时必须说明两个数字，a和b，代表他要看展览中的第 a 幅至第 b 幅画(包含 a 和 b)之间的所有图画，而门票的价钱就是一张图画一元。<br>
为了看到更多名师的画，wangjy希望入场后可以看到所有名师的图画(至少各一张)。<br>
可是他又想节省金钱。。。<br>
作为wangjy的朋友，他请你写一个程序决定他购买门票时的 a 值和 b 值。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1e6+10,M=2010;
int a[N],cnt[M];
int n,m;

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
		
	int l=1,r=1;
	int sum=0;
	int ans=n;
	int al=1,ar=n;//初始化
	
	while(1)
	{
		while(r&lt;=n &amp;&amp; sum&lt;m)
			if(cnt[a[r++]]++ == 0)
				sum++;
		
		if(sum &lt; m) break;
		
		if(ans &gt; r-l) ans=r-l,al=l,ar=r-1;
		
		if(--cnt[a[l++]] == 0) sum--;
	}
	
	printf(&quot;%d %d\n&quot;,al,ar);
	
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5056">hdu5056</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/09/9969_cb35afd87a-35.PNG" alt="35.PNG" loading="lazy"><br>
如果有一段字符刚刚好满足条件，那么后面的包含这个串的子串全部满足，我们可以尺取l和r，对于一个r满足的话，后面len  -  r + 1个子串也满足，然后更新l就可以了，因为l和r是分开更新的，所以复杂度是O(n)。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010;
char s[N];
int cnt[30];
int k;

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        memset(cnt,0,sizeof cnt);
        scanf(&quot;%s&quot;,s);
        scanf(&quot;%d&quot;,&amp;k);
        int n=strlen(s);
        int l=0,r=0;
        LL ans=0;
        
        while(l&lt;n)
        {
            while(r&lt;n)
            {
                cnt[s[r]-'a']++;
                if(cnt[s[r]-'a'] &lt;= k)
                    ans+=r-l+1,r++;
                else 
                {
                    cnt[s[r]-'a']--;
                    break;
                }
            }
                
            cnt[s[l]-'a']--,l++;
        }
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>
<p><a href="">hdu5358</a><br>
log2(f(i,j))表示f(i,j)转换为2进制的长度，然后我们经过分析log2(f(i,j))+1的值域为[1,34]然后我们枚举log2(f(i,j))+1的值，例如我们枚举其值为k，对于一个k我们找到所有满足条件的区间(i,j),这个条件的代数表达为<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>+</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^{k-1}+1&lt;= f(i,j)+1 &lt;=2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>;</p>
<p>因此我们需要再枚举一个区间的左端点，对于一个给定的左端点，因为f(i,j)在给定i的情况下单调，我们可以用尺取法求得一个区间[l,r]，使得区间内的j (l&lt;=j&lt;=r)都瞒住<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">log_2sum(i,j)+1=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>;</p>
<p>区间(i+j)的和可以表示为 i*(r-l+1) + (r+l)*(r-l+1)/2</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
const int N=100010;
LL s[N];
int n;

int main()
{
	//cout&lt;&lt;log2(1e10)&lt;&lt;endl;
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		
		for(int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%lld&quot;,&amp;s[i]);
			s[i]+=s[i-1];
		}
		
		LL ans=0;
		for(LL k=1;k&lt;=34;k++)
		{
			LL l=1,r=1;
			LL lmax=1ll&lt;&lt;(k-1),rmax=1ll&lt;&lt;k;
			if(k == 1) lmax=0;
			for(LL i=1;i&lt;=n;i++)
			{
				l=max(l,i),r=max(r,i);
				while(l&lt;=n &amp;&amp; s[l]-s[i-1] &lt; lmax)
					l++;
				while(r&lt;=n &amp;&amp; s[r]-s[i-1] &lt; rmax)
					r++;
				r--;
				ans+=k*(i*(r-l+1)+(l+r)*(r-l+1)/2);
			}
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1102">P1102</a><br>
我们考虑题目要求求出所有A-B=C的数对，我们可以先将原数组排序，然后就会发现每个数A，对应的数B一定是一段连续的区间。<br>
然后我们再考虑如何去找到这个区间。<br>
我们显然是要找到这个连续区间的左端点和右端点。</p>
<p>考虑到排序之后序列的有序性，我们枚举每个数，他们的左端点和右端点都是单调不降的，因此我们可以用双指针来维护这个东西。</p>
<p>具体的实现就是，我们维护两个右端点r1 , r2，每次r1右移到a[r1] - a[l] &lt;c的最后位置的下一位，r2右移到满足a[r2] - a[l] &lt;= c最后一位.</p>
<p>也就是说， 此时如果a[r2-1] - a[l] == c &amp;&amp; a[r1] - a[l] == c，中间的那一段一定都是满足条件的，我们让ans += r2 - r1即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=200010;
int a[N];

int main()
{
	int n,c;
	cin&gt;&gt;n&gt;&gt;c;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	
	sort(a,a+n);
	
	int l=0,r1=0,r2=0;
	LL ans=0;
	
	while(l&lt;n)
	{
		while(r1&lt;n &amp;&amp; a[r1]-a[l] &lt; c) r1++;
		while(r2&lt;n &amp;&amp; a[r2]-a[l] &lt;= c) r2++;
		if(a[r2-1] - a[l] == c &amp;&amp; a[r1]-a[l] == c)
			ans+=r2-r1;
		l++;
	}
	printf(&quot;%lld\n&quot;,ans);
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/UVA11572">uva11572</a><br>
给出 n个数，找尽量长的一个子序列，使得该子序列中没有重复的元素。</p>
<p>右指针往右跳到不重复的最远位置,更新答案,然后左指针往右跳一位,左右指针都只跳了n次,所以查询的复杂度是O(n)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
const int N=1e6+10;
int a[N],b[N],cnt[N];
int n;

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i];
			
		sort(b,b+n);
		
		int tot=unique(b,b+n)-b;
		
		for(int i=0;i&lt;n;i++)
			a[i]=lower_bound(b,b+tot,a[i])-b;

		int l=0,r=0;
		int ans=0;
		
		for(int i=0;i&lt;tot;i++) cnt[i]=0;
		
		while(r&lt;n)
		{
			while(r&lt;n &amp;&amp; cnt[a[r]] == 0)
				cnt[a[r++]]++;
			
			ans=max(ans,r-l);
			
			cnt[a[l++]]--;
		}
		
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://codeforces.com/contest/660/problem/C">cf660C</a><br>
大意：给定一个包含nn个元素的数组aa。数组a的每个元素不是00就是11。<br>
现在，让我们用f(a)表示a中连续元素序列中最长子段的长度，它只包含数字1。并且你最多可以将k个0更改为1来得到最大的f(a)。</p>
<p>贪心：对于一个含0的区间，我们让区间中的0都填满是最优的<br>
于是维护一段区间，保证区间中的0的个数≤k就可以<br>
于是就可以对于0的个数≤k时右移右端点，增添新的位置，扩大区间；<br>
当[l,r]中0的个数＞k时右移l，到[l,r]中0的个数≤k时为止</p>
<p>注意边界和初始化</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=3e5+10;
int a[N];
int n,k;

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for(int i=1;i&lt;=n;i++)	
		scanf(&quot;%d&quot;,&amp;a[i]);
		
	int l=1,r=1;
	int ans=0;
	int sum=0;
	int al=0,ar=0;
	
	while(r&lt;=n)
	{
		while(r&lt;=n &amp;&amp; sum&lt;=k)
		{
			if(!a[r])
			{
				if(sum == k) break;//注意点！
				else sum++;
			}
			r++;
		}
		
		if(ans &lt; r-l) ans=r-l,al=l,ar=r-1;
		
		if(!a[l++]) sum--;
	}
	
	printf(&quot;%d\n&quot;,ans);
	for(int i=1;i&lt;=n;i++)
		if(i&gt;=al &amp;&amp; i&lt;=ar)
			printf(&quot;1 &quot;);
		else 
			printf(&quot;%d &quot;,a[i]);
		
	return 0;
}
</code></pre>
<p>尺取法的模型便是这样：根据区间的特征交替推进左右端点求解问题，其高效的原因在于避免了大量的无效枚举，其区间枚举都是根据区间特征有方向的枚举。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[四边形不等式]]></title>
        <id>https://caifxh.github.io/post/si-bian-xing-bu-deng-shi/</id>
        <link href="https://caifxh.github.io/post/si-bian-xing-bu-deng-shi/">
        </link>
        <updated>2020-04-09T04:05:10.000Z</updated>
        <content type="html"><![CDATA[<p>四边形不等式优化主要针对区间DP模型。<br>
转移方程形如：<br>
f[i][j] = min(f[i][k] + f[k + 1][j] + w(i, j))<br>
对于每个区间都要枚举 k<br>
时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)<br>
状态数已经定好了是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)，我们能想办法优化的部分就是把 O(n) 的转移优化到 O(1)<br>
这里就要用到四边形不等式优化。</p>
<p>对于 a &lt; b &lt; c &lt; d：<br>
如果有 f(a, c) + f(b, d) &lt;= f(b, c) + f(a, d) <strong>交叉 &lt;= 包含</strong><br>
我们就称 f 满足四边形不等式。</p>
<p>如果代价函数 w(i,j) 满足单调性和四边形不等式，那么 dp 函数 f(i,j) 也满足四边形不等式。<br>
定义 s(i,j) 为 f(i,j) 取得最优值对应的转移（即 k）<br>
如果 f(i,j) 满足四边形不等式，那么 s(i,j) 单调<br>
即s(i,j)≤s(i,j+1)≤s(i+1,j+1)</p>
<h4 id="应用背景">应用背景</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_a72071bc79-20.PNG" alt="20.PNG" loading="lazy"></figure>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_9d82d0e079-21.PNG" alt="21.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_c982acc479-22.PNG" alt="22.PNG" loading="lazy"></p>
<h4 id="四边形不等式定义和单调性定义">四边形不等式定义和单调性定义</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_22f1d33479-23.PNG" alt="23.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_70a44cae79-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_9708b8d079-25.PNG" alt="25.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=310,INF=0x3f3f3f3f;
int f[N][N];
int sum[N];
int s[N][N];
int n;

int main()
{
    cin&gt;&gt;n;

    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;sum[i];
        sum[i]+=sum[i-1];
        s[i][i]=i;
    }

    for(int len=2;len&lt;=n;len++)
    {
        for(int i=1;i+len-1&lt;=n;i++)
        {
            int j=i+len-1;
            f[i][j]=INF;
            for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)
                if(f[i][j] &gt; f[i][k]+f[k+1][j]+sum[j]-sum[i-1])
                {
                    f[i][j] = f[i][k]+f[k+1][j]+sum[j]-sum[i-1];
                    s[i][j]=k;
                }
        }
    }

    cout&lt;&lt;f[1][n]&lt;&lt;endl;

    return 0;
}

</code></pre>
<p><a href="https://www.acwing.com/problem/content/1070/">acwing1068</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_1733cf0c79-29.png" alt="29.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=210,INF=0x3f3f3f3f;
int f[N][N];
int g[N][N];
int w[N];
int sum[N];
int s[N][N];
int n;

int main()
{
    cin&gt;&gt;n;
    
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;w[i];
        w[n+i]=w[i];
    }
    
    for(int i=1;i&lt;=n*2;i++)
    {
        sum[i]=sum[i-1]+w[i];
        s[i][i]=i;
    }
    
    for(int len=2;len&lt;=n*2;len++)
    {
        for(int i=1;i+len-1&lt;=n*2;i++)
        {
            int j=i+len-1;
            f[i][j]=INF;
            for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)
                if(f[i][j] &gt; f[i][k]+f[k+1][j]+sum[j]-sum[i-1])
                {
                    f[i][j] = f[i][k]+f[k+1][j]+sum[j]-sum[i-1];
                    s[i][j]=k;
                }
                
            g[i][j]=max(g[i+1][j],g[i][j-1])+sum[j]-sum[i-1];
        }
    }
    
    int maxv=0;
    int minv=INF;
    for(int i=1;i&lt;=n;i++)
    {
        maxv=max(maxv,g[i][n+i-1]);
        minv=min(minv,f[i][n+i-1]);
    }
    
    cout&lt;&lt;minv&lt;&lt;endl&lt;&lt;maxv&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<h4 id="四边形不等式定理">四边形不等式定理</h4>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_ffe53f3c79-27.PNG" alt="27.PNG" loading="lazy"></figure>
<h4 id="一维线性dp的四边形不等式优化">一维线性DP的四边形不等式优化</h4>
<figure data-type="image" tabindex="3"><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_0a2e13bc79-28.PNG" alt="28.PNG" loading="lazy"></figure>
<p>比赛时，我们只要先写出暴力的 DP 然后打出 cost、dp、和决策数组，验证 cost、dp函数是否满足四边形不等式，<br>
以及决策是否具有单调性。</p>
<ul>
<li>拿到题目后，先判断w是否单调、是否满足四边形不等式，再使用四边形不等式优化DP。</li>
</ul>
<h4 id="最优二叉搜索树">最优二叉搜索树</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_f95a567879-31.PNG" alt="31.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_e9d4e4fc79-30.PNG" alt="30.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_13099f6679-32.PNG" alt="32.PNG" loading="lazy"><br>
题目给出的数列(val)是有序的，假设我们以i为根，1<sub>i-1就是左子树，i+1</sub>n就是右子树</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=260;
int w[N];
int sum[N];
int s[N][N];
int f[N][N];
int n;

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		for(int i=1;i&lt;=n;i++)
		{
			cin&gt;&gt;w[i];
			sum[i]=sum[i-1]+w[i];
			s[i][i]=i;
		}
		
		for(int len=1;len&lt;=n;len++)
		{
			for(int i=1;i+len-1&lt;=n;i++)
			{
				int j=i+len-1;
				f[i][j]=1e9;
				if(len == 1) f[i][j]=0;
				
				for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)
					if(f[i][j] &gt; f[i][k-1]+f[k+1][j]+sum[j]-sum[i-1]-w[k])
					{
						f[i][j] = f[i][k-1]+f[k+1][j]+sum[j]-sum[i-1]-w[k];
						s[i][j]=k;
					}
			}
		}
		
		cout&lt;&lt;f[1][n]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2829">hdu2829</a><br>
有 n 个火车站，第 i 个火车站有一个重要度 a[i]。<br>
你现在可以炸掉 m 条铁轨。这样铁轨就断成了 m + 1 段，每一段都有一个战略值，它等于这一段铁轨上的火车站两两的重要度乘积之和。请你最小化总的战略值之和。<br>
0 ≤ m &lt; n ≤ 1000</p>
<p>斜率优化：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_e9dadca879-33.PNG" alt="33.PNG" loading="lazy"><br>
那么，就有：dp[i][j] = min( dp[k][j-1] + w[k+1][i] )，j≤k&lt;i；<br>
方程的意义是：炸毁仓库k和仓库k+1之间的那段铁路（即第k段铁路），算出总价值，枚举k找到最小的。</p>
<p>那么如何计算w[k+1][i]呢？假设sum[i]=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mi>v</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{k=1}^{i}v[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.264274em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> ，那么就有：w[1][i] = w[1][k] + w[k+1][i] + (v[1]+v[2]+…+v[k]) × (v[k+1]+v[k+2]+…+v[i])= w[1][k] + w[k+1][i] + sum[k] × (sum[i]-sum[k])<br>
即w[k+1][i] = w[1][i] - w[1][k] - sum[k] × (sum[i]-sum[k])</p>
<p>我们把w[k+1][i]的计算式带入状态转移方程得到：<br>
dp[i][j] = min{ dp[k][j-1] + w[1][i] - w[1][k] - sum[k] × (sum[i]-sum[k]) }</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1010;
int f[N][N];
int s[N],w[N];
int q[N];
int n,m;

int getY(int i,int j,int k)
{
	return f[i-1][j]-w[j]+s[j]*s[j]-f[i-1][k]+w[k]-s[k]*s[k];
}

int getX(int i,int j)
{
	return s[i]-s[j];
}

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		if(!n &amp;&amp; !m) break;
		
		for(int i=1;i&lt;=n;i++)
		{
			int x;
			scanf(&quot;%d&quot;,&amp;x);
			s[i]=s[i-1]+x;
			w[i]=w[i-1]+s[i-1]*x;
			f[0][i]=w[i];
		}
		
		for(int i=1;i&lt;=m;i++)
		{
			int hh=0,tt=-1;
			q[++tt]=0;
			for(int j=1;j&lt;=n;j++)
			{
				while(hh &lt; tt &amp;&amp; getY(i,q[hh+1],q[hh]) &lt;= s[j]*getX(q[hh+1],q[hh]))
					hh++;
				int k=q[hh];
				f[i][j]=f[i-1][k]+w[j]-w[k]-s[k]*(s[j]-s[k]);
				
				while(hh &lt; tt &amp;&amp; getY(i,q[tt],q[tt-1])*getX(j,q[tt]) &gt;= getY(i,j,q[tt])*getX(q[tt],q[tt-1]))
					tt--;
				q[++tt]=j;
			}			
		}
		
		printf(&quot;%d\n&quot;,f[m][n]);
	}
	return 0;
}
</code></pre>
<p>四边形不等式：<br>
用 f[i][j] 来表示在前 j 个火车站中用了 i 个炸弹得到的最小的战略值总和。<br>
枚举上一次使用炸弹的位置 k，得到<br>
f[i][j] = min(f[i - 1][k] + w[k + 1][j])(i-1 &lt; k &lt; j)</p>
<p>w[i][j] = [i, j] 中两两乘积之和= [(a[i] + a[i + 1] + … + a[j])2 - (a[i]2 + a[i + 1]2 + … + a[j]2)] / 2<br>
可以验证它是满足单调性和四边形不等式的。<br>
因此这题可以用四边形不等式来优化。<br>
f[i][j] = min(f[i - 1][k] + w[k + 1][j])<br>
(s[i-1][j] &lt; k &lt; s[i+1][j])</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1010;
int f[N][N];
int a[N];
int w[N][N];
int p[N][N];
int n,m;

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		if(!n &amp;&amp; !m) break;
		
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		
		for(int i=1;i&lt;=n;i++)
		{
			int sum=0;
			w[i][i]=0;
			for(int j=i+1;j&lt;=n;j++)
			{
				sum+=a[j-1];
				w[i][j]=w[i][j-1]+sum*a[j];
			}
		}
		
		//      打表
// 		for(int i=1;i&lt;=n;i++) 
// 		{
// 		    for(int j=1;j&lt;=n;j++)
// 		        cout&lt;&lt;w[i][j]&lt;&lt;' ';
// 		    cout&lt;&lt;endl;
// 		}
		
		for(int i=0;i&lt;=n;i++)
		{
			f[0][i]=w[1][i];
			p[0][i]=0;
			p[i][n+1]=n;
		}
	
		
		for(int i=1;i&lt;=m;i++)
			for(int j=n;j&gt;=1;j--)
			{
				f[i][j]=1e9;
				for(int k=p[i-1][j];k&lt;=p[i][j+1];k++)
					if(f[i][j] &gt; f[i-1][k] + w[k+1][j])
					{
						f[i][j] = f[i-1][k] + w[k+1][j];
						p[i][j]=k;
					}
			}
		
		printf(&quot;%d\n&quot;,f[m][n]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斜率优化]]></title>
        <id>https://caifxh.github.io/post/xie-lu-you-hua/</id>
        <link href="https://caifxh.github.io/post/xie-lu-you-hua/">
        </link>
        <updated>2020-04-08T09:24:30.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_52e5180078-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_55ff749078-2.png" alt="2.png" loading="lazy"></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507">hdu3507</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_98db0db078-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_3be50fce78-4.PNG" alt="4.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_3db0a1a678-5.PNG" alt="5.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_6b0c654078-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_80a51b8678-7.PNG" alt="7.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_afd9578278-8.PNG" alt="8.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_d2b42cb478-9.PNG" alt="9.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e1bc29be78-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e3da236678-11.PNG" alt="11.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e70434fa78-12.PNG" alt="12.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e8f70a9e78-13.PNG" alt="13.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=500010;
int f[N];
int s[N];
int q[N];
int n,m;

int getY(int i,int j)
{
	return f[i]+s[i]*s[i]-f[j]-s[j]*s[j];
}

int getX(int i,int j)
{
	return s[i]-s[j];
}

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		for(int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;s[i]);
			s[i]+=s[i-1];
		}
		
		int hh=0,tt=-1;
		q[++tt]=0;
		
		for(int i=1;i&lt;=n;i++)
		{
			while(hh&lt;tt &amp;&amp; getY(q[hh+1],q[hh]) &lt;= 2*s[i]*getX(q[hh+1],q[hh]))
				hh++;
			int j=q[hh];
			f[i]=f[j]+(s[i]-s[j])*(s[i]-s[j])+m;
			while(hh&lt;tt &amp;&amp; getY(q[tt],q[tt-1])*getX(i,q[tt]) &gt;= getY(i,q[tt])*getX(q[tt],q[tt-1]))
				tt--;
			q[++tt]=i;
		}
		
		printf(&quot;%d\n&quot;,f[n]);
	}
	return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_b435e00678-14.png" alt="14.png" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/description/304/">acwing302</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int N=300010;
LL st[N],sc[N];
LL f[N];
int q[N];
int n,s;

LL getY(int i,int j)
{
    return f[i]-f[j];
}

LL getX(int i,int j)
{
    return sc[i]-sc[j];
}

int main()
{
    cin&gt;&gt;n&gt;&gt;s;
    
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lld%lld&quot;,&amp;st[i],&amp;sc[i]);
        st[i]+=st[i-1];
        sc[i]+=sc[i-1];
    }
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
        int l=hh,r=tt;
        while(l&lt;r)
        {
            int mid=l+r&gt;&gt;1;
            if(getY(q[mid+1],q[mid]) &gt;= (s+st[i])*getX(q[mid+1],q[mid])) r=mid;
            else l=mid+1;
        }
        
        int j=q[l];
        f[i]=f[j]-(s+st[i])*sc[j]+s*sc[n]+st[i]*sc[i];
        while(hh&lt;tt &amp;&amp; getY(q[tt],q[tt-1])*getX(i,q[tt]) &gt;= getY(i,q[tt])*getX(q[tt],q[tt-1]))
            tt--;
        q[++tt]=i;
    }
    
    cout&lt;&lt;f[n]&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/305/">acwing303</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_1bbe8e4e78-15.png" alt="15.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010,M=100010,P=110;
LL f[P][M];
LL d[N];
int t[M],a[M];
LL s[M];
int q[M];
int n,m,p;

LL getY(int i,int j,int k)
{
    return f[i-1][j]+s[j]-f[i-1][k]-s[k];
}

int getX(int i,int j)
{
    return i-j;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;
    
    for(int i=2;i&lt;=n;i++)
        cin&gt;&gt;d[i],d[i]+=d[i-1];
        
    for(int i=1;i&lt;=m;i++)
    {
        int h;
        cin&gt;&gt;h&gt;&gt;t[i];
        a[i]=t[i]-d[h];
    }
    
    sort(a+1,a+m+1);
    
    
    for(int i=1;i&lt;=m;i++) s[i]=s[i-1]+a[i];
    
    memset(f,0x3f,sizeof f);
    for(int i=0;i&lt;=p;i++) f[i][0]=0;
    
    for(int i=1;i&lt;=p;i++)
    {
        
        int hh=0,tt=-1;
        q[++tt]=0;
        
        for(int j=1;j&lt;=m;j++)
        {
            while(hh &lt; tt &amp;&amp; getY(i,q[hh+1],q[hh]) &lt;= (LL)a[j]*getX(q[hh+1],q[hh]))
                hh++;
            int k=q[hh];
            f[i][j]=f[i-1][k]+(LL)a[j]*(j-k)-(s[j]-s[k]);
            while(hh &lt; tt &amp;&amp; getY(i,q[tt],q[tt-1])*getX(j,q[tt]) &gt;= getY(i,j,q[tt])*getX(q[tt],q[tt-1]))
                tt--;
            q[++tt]=j;
        }
    }

    cout&lt;&lt;f[p][m]&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P2120">P2120</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_cc43d24e79-17.PNG" alt="17.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_e7b6cfb879-18.PNG" alt="18.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_ea64c32879-19.PNG" alt="19.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1000010;
LL f[N];
LL x[N],c[N],p[N];
LL sp[N],sxp[N];
int q[N];
int n;

LL getY(int i,int j)
{
	return f[i]+sxp[i]-f[j]-sxp[j];
}

LL getX(int i,int j)
{
	return sp[i]-sp[j];
}

int main()
{
	cin&gt;&gt;n;
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;x[i],&amp;p[i],&amp;c[i]);
		sp[i]=sp[i-1]+p[i];
		sxp[i]=sxp[i-1]+x[i]*p[i];
	}
	
	int hh=0,tt=-1;
	q[++tt]=0;
	
	for(int i=1;i&lt;=n;i++)
	{
		while(hh &lt; tt &amp;&amp; getY(q[hh+1],q[hh]) &lt;= x[i]*getX(q[hh+1],q[hh]))
			hh++;
		int j=q[hh];
		f[i]=f[j]+x[i]*(sp[i]-sp[j])-(sxp[i]-sxp[j])+c[i];
		while(hh &lt; tt &amp;&amp; getY(q[tt],q[tt-1])*getX(i,q[tt]) &gt;= getY(i,q[tt])*getX(q[tt],q[tt-1]))
			tt--;
		q[++tt]=i;
	}
	
	printf(&quot;%lld\n&quot;,f[n]);
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前缀和 差分]]></title>
        <id>https://caifxh.github.io/post/qian-zhui-he-chai-fen/</id>
        <link href="https://caifxh.github.io/post/qian-zhui-he-chai-fen/">
        </link>
        <updated>2020-04-07T16:42:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前缀和"><a href="https://www.acwing.com/problem/content/797/">前缀和</a></h3>
<p>给定一个序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>1</mn><mo>−</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[1-n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>。<br>
有很多次询问，每个询问形如:l r  询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的区间和。<br>
<code>每次询问的复杂度要求 O(1)</code><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/08/9969_9251f5104a-1.PNG" alt="1.PNG" loading="lazy"></p>
<h4 id="预处理时间复杂度on">预处理时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4>
<pre><code>for(int i=1;i&lt;=n;i++)
{
    scanf(&quot;%d&quot;,&amp;a[i]);
    s[i]=s[i-1]+a[i];
}
</code></pre>
<h4 id="alr的区间和-sr-sl-1"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的区间和: s[r]-s[l-1]</h4>
<h4 id="查询时间复杂度o1">查询时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4>
<pre><code>while(m--)
{
    int l,r;
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    printf(&quot;%d\n&quot;,s[r]-s[l-1]);
}
</code></pre>
<h2 id="ps前缀和下标从1开始"><code>PS:前缀和下标从1开始</code></h2>
<h3 id="区间加差分"><a href="https://www.acwing.com/problem/content/799/">区间加/差分</a></h3>
<p>给定一个序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>1</mn><mo>−</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[1-n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>(初值全为0)。<br>
有很多次操作，每个操作形如:l r  将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的每个值加上k。<br>
最后输出整个数组。复杂度要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/08/9969_bd972e544a-2.PNG" alt="2.PNG" loading="lazy"><br>
区间加[l,r]，实际上是发生了这两件事：<br>
a[l]比前一个元素多了k;<br>
a[r+1]比前一个元素少了k.<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/08/9969_065512be4a-4.PNG" alt="4.PNG" loading="lazy"><br>
我们用数组b表示刚刚的差值，<strong>b[i]=a[i]-a[i-1]</strong>.<br>
那么：区间加[𝒍,𝒓]，可以化为这两个操作： <strong>b[l]+=k; b[r+1]-=k;</strong></p>
<pre><code>void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}
</code></pre>
<p>因此，一次区间加只修改这两个元素； 最后利用b数组求出a数组(a数组为b数组的前缀和)，对b数组求一遍前缀和即为答案。</p>
<pre><code>for(int i=1;i&lt;=n;i++)
{
    b[i]+=b[i-1];
    printf(&quot;%d &quot;,b[i]);
}
</code></pre>
<p><code>PS:数组a初值为0，进行n次插入操作可得到数组a。</code></p>
<pre><code>for(int i=1;i&lt;=n;i++)
    scanf(&quot;%d&quot;,&amp;a[i]);
for(int i=1;i&lt;=n;i++)
    insert(i,i,a[i]);
</code></pre>
<h4 id="总结差分无需构造前缀和需构造">总结：差分无需构造，前缀和需构造</h4>
<p>通过上述的两个方法，我们能轻易地处理这两类问题：</p>
<ul>
<li>数组固定，然后大量询问；</li>
<li>大量做区间加，最后要你给出这个数组。</li>
</ul>
<h3 id="例题">例题</h3>
<p><a href="https://www.luogu.com.cn/problem/P2879">Luogu2879</a><br>
有好几头牛从１到n线性排列，每头牛的高度为h[i]现在告诉你这里面的牛的最大高 度为maxH,而且有r组关系，每组关系输入两个数字，假设为a和b,表示第a头牛能看到第b头牛，能看到的条件是a, b之间的其它牛的高度都严格小于min(h[a], h[b]),而 h[b] &gt;= h[a] 最后求所有牛的可能最高身高输出</p>
<h4 id="思路">思路：</h4>
<p>首先假设所有牛都是最高身高。 读入的约束信息需要去重，这个利用排序或者set可以解决。 可以发现对于每个位置h[i],假设它被覆盖了x次，最后答案就是h[i]-x. 如果出现了一对[l,r]，把区间(l,r)的数都-1就可以了。（注意区间开闭）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt; 
using namespace std;
const int N=10010;
int height[N];
set&lt;pair&lt;int,int&gt; &gt; S;

int main()
{
	int n,i,h,r;
	cin&gt;&gt;n&gt;&gt;i&gt;&gt;h&gt;&gt;r;
	height[1]=h;//差分数组 
	
	while(r--)
	{
		int a,b;
		cin&gt;&gt;a&gt;&gt;b;
		if(a&gt;b)
			swap(a,b);
		if(!S.count({a,b}))
		{
			S.insert({a,b});
			height[a+1]--;
			height[b]++;
		}
	}
	
	for(int i=1;i&lt;=n;i++)
	{
		height[i]+=height[i-1];
		cout&lt;&lt;height[i]&lt;&lt;endl;
	}
	return 0;
 } 
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3406">Luogu3406</a><br>
该铁路经过N个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好 ，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车 票。第i段铁路连接了城市i和城市i+1(1&lt;=i&lt;N)。如果搭乘的比较远，需要购买多张 车票。第i段铁路购买纸质单程票需要Ai博艾元。 虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了IC卡。对于第i段 铁路，需要花Ci博艾元的工本费购买一张IC卡，然后乘坐这段铁路一次就只要扣 Bi(Bi&lt;Ai)元。IC卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应 的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于 第i段铁路的IC卡，无法乘坐别的铁路的车。 Uim现在需要出差，要去M个城市，从城市P1出发分别按照P1,P2,P3...PM的顺序访 问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且 不会是同一个城市。 现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和 充值的总费用。</p>
<p>直接模拟每段铁路的覆盖即可</p>
<pre><code> #include&lt;iostream&gt;
using namespace std;
const int N=100010;
 int a[N];
 int b[N];//差分数组 
 typedef long long LL;
 
 int main()
 {
 	int n,m;
 	cin&gt;&gt;n&gt;&gt;m;
 	for(int i=1;i&lt;=m;i++)
 		cin&gt;&gt;a[i];
 	for(int i=1;i&lt;m;i++)
 	{
 		b[min(a[i],a[i+1])]++;
 		b[max(a[i],a[i+1])]--;
	 }
	 
	 for(int i=1;i&lt;=n;i++)
	 	b[i]+=b[i-1];
	
//	for(int i=1;i&lt;=n;i++)
//		cout&lt;&lt;&quot;--&quot;&lt;&lt;b[i]&lt;&lt;' ';
	
	LL sum=0;
	for(int i=1;i&lt;n;i++)
	{
		LL ai,bi,ci;
		cin&gt;&gt;ai&gt;&gt;bi&gt;&gt;ci;
		sum+=min(ai*b[i],ci+bi*b[i]);
	}
	
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
 }
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1083">Luogu1083</a></p>
<h4 id="思路1">思路1：</h4>
<p>利用差分数组存每天的教室使用情况，然后求前缀和，如果发现不符合要求，就从后往前撤回订单，直到每天都符合要求，那么我们撤回的最后一个（也就是最靠前的一个）即为ans</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int l[N],r[N],d[N];
int res=INF;

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;d[i],&amp;l[i],&amp;r[i]);
		b[l[i]]+=d[i];
		b[r[i]+1]-=d[i];
	}
	
	int j=m;//从后往前撤回订单，直至满足要求 
	int sum=0;
	for(int i=1;i&lt;=n;i++)
	{
		sum+=b[i];
		//cout&lt;&lt;sum&lt;&lt;' ';
		if(sum&gt;a[i])
		{
			//从后往前撤回 
			while(sum&gt;a[i])
			{
				b[l[j]]-=d[j];
				b[r[j]+1]+=d[j];
				if(i&gt;=l[j] &amp;&amp; i&lt;=r[j])
					sum-=d[j];
				j--;
			}
			res=min(res,j);
		}	
	}
	
	if(res==INF)
		cout&lt;&lt;&quot;0&quot;;
    else 
		cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl&lt;&lt;res+1&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="思路2">思路2：</h4>
<p>在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int s[N],t[N],d[N];

bool check(int x)//判断前x份订单能否全部满足 
{
	memset(b,0,sizeof b);
	for(int i=1;i&lt;=x;i++)
	{
		b[s[i]]+=d[i];
		b[t[i]+1]-=d[i];
	}

	for(int i=1;i&lt;=n;i++)
	{
		b[i]+=b[i-1];
		if(b[i]&gt;a[i])
			return false;
	}
	return true;
}

int main()
{
//	freopen(&quot;test.in.txt&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;d[i],&amp;s[i],&amp;t[i]);
	}
	if(check(m))
	{
		puts(&quot;0&quot;);
		return 0;
	}
	int l=0,r=m;//l取成0，防止无解情况 
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(check(mid))
			l=mid;
		else	
			r=mid-1;
	}
	cout&lt;&lt;-1&lt;&lt;endl;
	cout&lt;&lt;l+1&lt;&lt;endl;

    return 0;
}
</code></pre>
<h4 id="前缀和差分">前缀和+差分</h4>
<p><a href="https://www.luogu.com.cn/problem/P3948">luoguP3948</a></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=80010;
typedef long long LL;
LL b[N];
int sum[N];
int n,opt,minn,maxx,l,r,x,f;
LL mod;
char ch[5];

int main()
{
    scanf(&quot;%d%d%lld%d%d&quot;,&amp;n,&amp;opt,&amp;mod,&amp;minn,&amp;maxx);
    for(int j=1;j&lt;=opt;j++){
        scanf(&quot;%s%d%d%&quot;,&amp;ch,&amp;l,&amp;r);
        if(ch[0]=='A'){
            scanf(&quot;%d&quot;,&amp;x);
            b[l]+=x;
            b[r+1]-=x;
        }
        else{
            int ans=0;
			LL now=0;
            for(int i=1;i&lt;=r;i++){
                now+=b[i];
                if(i&gt;=l&amp;&amp;(now*i)%mod&gt;=minn&amp;&amp;(now*i)%mod&lt;=maxx)ans++;
            }
            printf(&quot;%d\n&quot;,ans);
        }
    }
    scanf(&quot;%d&quot;,&amp;f);
    for(int i=1;i&lt;=n;i++){
        b[i]+=b[i-1];
        if((b[i]*i)%mod&gt;=minn&amp;&amp;(b[i]*i)%mod&lt;=maxx)sum[i]=sum[i-1]+1;
        else sum[i]=sum[i-1];
    }
    for(int j=1;j&lt;=f;j++){
        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
        printf(&quot;%d\n&quot;,sum[r]-sum[l-1]);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单调数据结构]]></title>
        <id>https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/</id>
        <link href="https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/">
        </link>
        <updated>2020-04-07T16:41:48.000Z</updated>
        <content type="html"><![CDATA[<h4 id="单调栈">单调栈</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_93bac9686e-28.PNG" alt="28.PNG" loading="lazy"><br>
给定一个序列。对序列中的每个元素，求出它左侧的第一个小于它 的元素的位置。若没有这样的元素，输出0。</p>
<blockquote></blockquote>
<p>样例输入：<br>
4<br>
5 3 7 4<br>
样例输出：<br>
0 0 2 2</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_d560c46c6e-29.PNG" alt="29.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/832/">模板题1</a></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int stk[N],top;

int main()
{
    int n;
    cin&gt;&gt;n;
    while(n--)
    {
        int x;
        cin&gt;&gt;x;
        while(top&amp;&amp;stk[top]&gt;=x)
            top--;
        if(top)  
            cout&lt;&lt;stk[top]&lt;&lt;&quot; &quot;;
        else 
            cout&lt;&lt;-1&lt;&lt;&quot; &quot;;
        stk[++top]=x;
    }
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P5788">模板题2</a><br>
找出第 i 个元素之后第一个大于 ai的元素的下标<br>
分析：<br>
从后往前枚举，对于i&lt;j,若a[i]&gt;=a[j],则j不可能成为下标小于i的元素的答案。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=3e6+10;
int stk[N],top;
int n;
int a[N];
int ans[N];

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	
	for(int i=n;i&gt;=1;i--)
	{
		while(top &amp;&amp; a[stk[top]] &lt;= a[i]) top--;
		
		if(top) ans[i]=stk[top];
		else ans[i]=0;
		
		stk[++top]=i;
		
	}
	
	for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]);
	return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="https://vjudge.net/problem/POJ-2559">poj2559</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_b64b4e746e-30.PNG" alt="30.PNG" loading="lazy"><br>
首先考虑最大面积的矩形X的左右边界的性质：</p>
<p>设其左边界为L，右边界为R，则其高H = min{h[i] | L &lt;= i &lt;= R}</p>
<p>此时最大面积为 (R - L + 1) * H</p>
<p>若此时左边界的左边那个矩形的高度 h[L-1] &gt;= H<br>
则左边界可以向左拓展，则新的面积为：</p>
<p>(R - (L-1) + 1) * H &gt; 原面积</p>
<p>则与原假设条件冲突</p>
<p>故左边界左边的那个矩形的高度 :h[L-1] &lt; H<br>
同理右边界右边的那个矩形的高度： h[R+1] &lt; H</p>
<p>设H = h[i]</p>
<p>所以左边界L是满足h[j-1] &lt; h[i]的最大的j，即从i点向左遍历的第一个高度比i小的点的右边一个点</p>
<p>而右边界R是满足 h[j+1] &lt; h[i]的最小的j，即从i点向右遍历第一个高度比i小的点的左边一个点</p>
<p>所以我们可以利用单调栈的性质得到每个确定点，即确定高度的最大面积矩形的左右边界，然后枚举取最大即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010;
int h[N];
int l[N],r[N];
int stk[N],top;
int n;

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)
	{
		top=0;
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;h[i]);
		
		for(int i=1;i&lt;=n;i++)//找出h[i]左边第一个小于h[i]的位置 
		{
			while(top &amp;&amp; h[stk[top]] &gt;= h[i]) 
				top--;
			
			if(top) l[i]=stk[top]+1;
			else l[i]=1;//表示左边没有比h[i]小的位置 
			
			stk[++top]=i;
		}
		
		top=0;
		for(int i=n;i&gt;=1;i--)//找出h[i]右边第一个小于h[i]的位置 
		{
			while(top &amp;&amp; h[stk[top]] &gt;= h[i])
				top--;
			if(top) r[i]=stk[top]-1;
			else r[i]=n;//表示右边没有比h[i]大的位置 
				
			stk[++top]=i; 
		}
		
		LL ans=0;
		for(int i=1;i&lt;=n;i++)
			ans=max(ans,(LL)h[i]*(r[i]-l[i]+1));
	
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1901">P1901</a><br>
对于一个新的信号塔:</p>
<ul>
<li>当他加入栈中时,会挡住之前比它低的塔的传播,同时 , 也会接受到比它低的塔的信号</li>
<li>所以将栈顶所有比它低的塔删除,(因为他们已经不能再传播给其他塔信号了),同时 , 新的塔接收到的能量加上 删掉的塔传播的能量</li>
<li>对于原有的高度比它高的信号塔,离此新的信号塔最近的(当前栈顶元素),会接受到新的塔的信号</li>
<li>再将此新的信号塔加入栈中,最后O(n)扫一遍后,输出最大值即可</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1e6+10;
int stk[N],top;
int sum[N];
int h[N],w[N];
int n;

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;h[i]&gt;&gt;w[i];
		
		while(top &amp;&amp; h[stk[top]] &lt;= h[i])
			sum[i]+=w[stk[top--]];
		sum[stk[top]]+=w[i];
		
		stk[++top]=i;
	}
	
	int ans=0;
	for(int i=1;i&lt;=n;i++)
		ans=max(ans,sum[i]);
	
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
<p><a href="">P1823</a><br>
先假设每个人身高不同，脑补一下走过整个队列。</p>
<ul>
<li>观察队伍中的一个人A。如果我们他后面找到了一个比他不知道高到哪里去了的B，A就不能与B后面的人谈笑风生了。</li>
<li>因此我们可以维护一个单调栈，记录我们已经找到过的高人，显然栈上的高人们按高度的降序排列，栈顶的人最矮。</li>
<li>当我们找到一个新的高人时，他可以向栈里比他矮的人传授人生经验，并让他们出栈。如果出栈之后栈非空，他还可以与栈顶的高人谈笑风生。然后我们再另请这位高明进栈。</li>
<li>我们还要考虑两个人身高相同的情况。我们可以在栈里存pair&lt;身高，人数&gt;并维护它。</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; PII;
#define x first
#define y second
typedef long long LL;
const int N=500010;
int h[N];
PII stk[N];
int top;
int n;

int main()
{
	cin&gt;&gt;n;
	LL ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;h[i]);
		
		PII p=make_pair(h[i],1);
		while(top &amp;&amp; stk[top].x &lt;= h[i])
		{
			if(stk[top].x == h[i]) 
				p.y+=stk[top].y;
			ans+=stk[top].y;
			top--;
		}
		
		if(top) ans++;
		stk[++top]=p;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
<h4 id="单调队列">单调队列</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_5111bd346e-31.PNG" alt="31.PNG" loading="lazy"></figure>
<p><a href="https://www.luogu.com.cn/problem/P1886">模板题</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_55f2d4966e-32.PNG" alt="32.PNG" loading="lazy"><br>
单调队列与普通队列不一样的地方就在于单调队列既可以从队首出队，也可以从队尾出队。<br>
那么我们应该怎样实现单调队列呢?<br>
就拿样例来谈谈，设以最小的为标准。</p>
<blockquote></blockquote>
<p>8 3<br>
1 3 -1 -3 5 3 6 7</p>
<p>下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。</p>
<ul>
<li>
<p>由于此时队中没有一个元素，我们直接令1进队。此时，q={1},p={1}。</p>
</li>
<li>
<p>现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q={1,3},p={1,2}</p>
</li>
<li>
<p>下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从队尾出队。同理，1从队尾出队。最后-1进队，此时q={-1},p={3}</p>
</li>
<li>
<p>出现-3，同上面分析，-1&gt;-3，-1从队尾出队,-3从队尾进队。q={-3}，p={4}。</p>
</li>
<li>
<p>出现5，因为5&gt;-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q={-3,5},p={4,5}</p>
</li>
<li>
<p>出现3。3先与队尾的5比较，3&lt;5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q={-3,3},p={4,6}</p>
</li>
<li>
<p>出现6。6与3比较，因为3&lt;6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从队首出队。此时，q={3,6},p={6,7}</p>
</li>
<li>
<p>出现7。队尾元素6小于7，7进队。此时，q={3,6,7},p={6,7,8}。</p>
</li>
</ul>
<p>那么，我们对单调队列的基本操作已经分析完毕。因为单调队列中元素大小单调递(增/减/自定义比较)，因此，队首元素必定是最值。按题意输出即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1000010;
int a[N];
int q[N];
int n,k;

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	
	int hh=0,tt=-1;
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
		
	for(int i=1;i&lt;=n;i++)//求滑动窗口最小值 
	{
		if(hh &lt;= tt &amp;&amp; i-k&gt;= q[hh]) hh++;
		while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &gt;= k)
			printf(&quot;%d &quot;,a[q[hh]]);
	}
	puts(&quot;&quot;);
	
	hh=0,tt=-1;
	for(int i=1;i&lt;=n;i++)
	{
		if(hh &lt;= tt &amp;&amp; i-k&gt;=q[hh]) hh++;
		while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &gt;= k)
			printf(&quot;%d &quot;,a[q[hh]]);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/137/">acwing135</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_1ff2c8586e-33.PNG" alt="33.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 300010, INF = 0x3f3f3f3f;
int n, m;
int s[N];
int q[N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;s[i]), s[i] += s[i - 1];

    int res = -INF;
    int hh = 0, tt = -1;
    q[++tt]=0;//将s[0]入队
    for (int i = 1; i &lt;= n; i ++ )
    {
        if(hh&lt;=tt &amp;&amp; i-m &gt; q[hh]) hh++;
        res=max(res,s[i]-s[q[hh]]);
        while (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt -- ;
        q[ ++ tt] = i;
    }

    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度]]></title>
        <id>https://caifxh.github.io/post/gao-jing-du/</id>
        <link href="https://caifxh.github.io/post/gao-jing-du/">
        </link>
        <updated>2020-04-07T16:40:47.000Z</updated>
        <content type="html"><![CDATA[<h4 id="高精度加法">高精度加法</h4>
<p>当进行加法运算的数字较大时，受存储范围限制，无法使用int或longlong型变量进行存储。<br>
考虑到加法运算的本质，不妨将数字拆开来存储。<br>
对于一个超过变量存储数据范围的数字，可以将这个数字拆开，拆成一位一位的，或者是几位几位的存储到一个数组中， 用一个数组去表示一个数字</p>
<p>采用用顺序存储数据方式，会有一个问题：最高位进位变得很困难。<br>
最高位在num[0]，所以一旦有进位，需要将num[]数组中每一位都往后移，时间复杂度O(len)<br>
·倒序存储·：num[]数组从0到len-1依次存储整数个位到最高位。则最高位进位时，只需要num[len++]=t，t为最高位数字</p>
<p>进位：<br>
方法一：设一个变量t，记录当前进位<br>
边计算边进位和逐位相加不进位最后再统一进位效果是一样的如下，先进行一遍逐位相加。<br>
然后，从0开始遍历一遍ans.num[]，将本位大于9的部分进位给更高位。<br>
最后判断是否最高位有进位，有则ans.len++</p>
<p><a href="https://www.luogu.com.cn/problem/P1601">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=510;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum add(bignum a,bignum b)
{
	bignum c;
	c.len=max(a.len , b.len);
	for(int i=0;i&lt;c.len;i++) c.m[i]=a.m[i]+b.m[i];
	for(int i=0;i&lt;c.len;i++)
		if(c.m[i] &gt; 9)
		{
			c.m[i+1]+=1;
			c.m[i]-=10;
		}
	if(c.m[c.len]) c.len++;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	scanf(&quot;%s&quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&lt;len;i++)
		b.m[len-i-1]=s[i]-'0';
	bignum c=add(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="高精度减法">高精度减法</h4>
<ul>
<li>判断正负</li>
<li>基本和加法一模一样，只不过从进位变成退位</li>
<li>退位后更新结果长度<br>
<a href="https://www.luogu.com.cn/problem/P2142">模板题</a></li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=10100;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

int judge(bignum a,bignum b)
{
	if(a.len &gt; b.len) return 1;
	if(a.len &lt; b.len) return -1;
	for(int i=a.len-1;i&gt;=0;i--)
	{
		if(a.m[i] &gt; b.m[i]) return 1;
		if(a.m[i] &lt; b.m[i]) return -1;
	}
	return 0;
}

bignum Minus(bignum a,bignum b)
{
	if(judge(a,b) == -1)
	{
		printf(&quot;-&quot;);
		return Minus(b,a);
	}

	bignum c;
	c.len=a.len;
	for(int i=0;i&lt;c.len;i++) c.m[i]=a.m[i]-b.m[i];
	for(int i=0;i&lt;c.len;i++)
		if(c.m[i] &lt; 0)
		{
			c.m[i+1]-=1;
			c.m[i]+=10;
		}
	while(c.len &gt; 1 &amp;&amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	scanf(&quot;%s&quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&lt;len;i++)
		b.m[len-i-1]=s[i]-'0';
	bignum c=Minus(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="高精度乘法">高精度乘法</h4>
<h4 id="1高精低精">1.高精*低精</h4>
<p>将加法运算改为乘法运算即可。<br>
注意：</p>
<ul>
<li>进位的运算</li>
<li>最高位进位的处理，可能不止进一位<br>
<a href="https://www.acwing.com/problem/content/description/795/">模板题</a></li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	for(int i=0;i&lt;c.len;i++) c.m[i]=a.m[i]*b;
	for(int i=0;i&lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
		if(i == c.len-1 &amp;&amp; c.m[i+1]) c.len++;
	}

	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	int b;
	scanf(&quot;%d&quot;,&amp;b);

	bignum c=mul(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="2高精高精">2.高精*高精</h4>
<p>乘法竖式中，a.num[i]和b.num[j]相乘的结果，放在了ans.num[i+j]的位置。<br>
a,b都为正整数时，长度为a.len和b.len的数字相乘得到ans，则<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/17/9969_ff4d713467-43.PNG" alt="43.PNG" loading="lazy"><br>
模拟上例竖式运算过程即可<br>
{模板题](https://www.luogu.com.cn/problem/P1303}</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=4010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,bignum b)
{
	bignum c;
	c.len=a.len+b.len;
	for(int i=0;i&lt;a.len;i++)
		for(int j=0;j&lt;b.len;j++)
			c.m[i+j]+=a.m[i]*b.m[j];
	for(int i=0;i&lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
	}
	while(c.len &gt; 1 &amp;&amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	scanf(&quot;%s&quot;,s);
	b.len=len=strlen(s);
	for(int i=0;i&lt;len;i++)
		b.m[len-i-1]=s[i]-'0';
	bignum c=mul(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="高精度除法">高精度除法</h4>
<h4 id="1高精低精-2">1.高精/低精</h4>
<p>除法是从高位到低位进行运算的。使用一个临时变量来记录余数，注意细节<br>
<a href="https://www.acwing.com/problem/content/description/796/">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};
int t;

bignum Div(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	t=0;
	for(int i=c.len-1;i&gt;=0;i--)
	{
		t=t*10+a.m[i];
		c.m[i]=t/b;
		t%=b;
	}
	while(c.len &gt; 1 &amp;&amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	int b;
	scanf(&quot;%d&quot;,&amp;b);
	bignum c=Div(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	printf(&quot;%d\n&quot;,t);

	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1255">数楼梯</a><br>
斐波那契递推<br>
<a href="https://paste.ubuntu.com/p/JKWpDTPXrj/">code</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树形dp]]></title>
        <id>https://caifxh.github.io/post/shu-xing-dp/</id>
        <link href="https://caifxh.github.io/post/shu-xing-dp/">
        </link>
        <updated>2020-04-06T03:53:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="树的重心">树的重心</h4>
<p>对于一棵 n 个节点的无根树，找到一个点 A，使得把树变成以<br>
该点为根的有根树时，最大子树的结点树最小。A 叫做重心。<br>
给定一棵树，找重心。<br>
求一下每个点子树的点数，然后对于每个点考虑一下他作为重心<br>
时候最大子树的大小是多少，和当前的重心进行比对就可以了。<br>
代码非常简单易懂。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace  std;
const int N=100010,M=N*2;
int h[N],e[M],ne[M],idx;
int ans=N;
bool st[N];
int cnt[N];
int n;
int poi;

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void dfs(int u,int fa)
{
    cnt[u]=1;
    int res=0;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        dfs(j,u);
        cnt[u]+=cnt[j];
        res=max(res,cnt[j]);
    }
    res=max(res,n-cnt[u]);

    if(res &lt; ans)
    {
        ans=res;
        poi=u;
    }
}

int main()
{
    
    memset(h,-1,sizeof h);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n-1;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
        add(b,a);
    }
    
    dfs(1,-1);
    
    cout&lt;&lt;ans&lt;&lt;endl;
    //cout&lt;&lt;poi&lt;&lt;endl;重心
    return 0;
}
</code></pre>
<h3 id="树的最长路径"><a href="https://www.acwing.com/problem/content/description/1074/">树的最长路径</a></h3>
<p>妨枚举直径在树上转弯的点。所以我们维护出到一个节点<br>
时向下的最长链和次长链，然后用二者加和来更新答案，同时更<br>
新父亲节点的最长链和次长链。<br>
f[i][0]表示根节点为i，向下所能到达的最长路径长度<br>
f[i][1]表示根节点为i，向下所能到达的次长路径长度</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=10010,M=N*2;
int h[N],e[M],ne[M],w[M],idx;
int n,m;
int ans;
int f[N][2];//0表示最长路径， 1表示次长路径

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v == fa)
            continue;
        dfs(v,u);
        if(f[v][0] + w[i] &gt; f[u][0])
        {
            f[u][1]=f[u][0];
            f[u][0]=f[v][0]+w[i];
        }
        else if(f[v][0] + w[i] &gt; f[u][1])
            f[u][1]=f[v][0]+w[i];
    }
    
    ans=max(ans,f[u][0]+f[u][1]);
}

int main()
{
    cin&gt;&gt;n;
    memset(h,-1,sizeof h);
    for(int i=0;i&lt;n-1;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
        add(b,a,c);
    }

    dfs(1,-1);

    cout&lt;&lt;ans&lt;&lt;endl;

    return 0;
}
</code></pre>
<h3 id="hdu2196"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2196">hdu2196</a></h3>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_8fd00bd859-5.png" alt="5.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_97f5be6659-6.png" alt="6.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9a64697c59-7.png" alt="7.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9cf7fd0c59-8.png" alt="8.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_a95f556859-9.png" alt="9.png" loading="lazy"><br>
f[i][0]表示根节点为i，向下所能到达的最长路径长度<br>
f[i][1]表示根节点为i，向下所能到达的次长路径长度<br>
f[i][2]表示根节点为i，向上所能到达的最长路径长度</p>
<p>（1）f[i][0]，f[i][1]的求法同树的直径<br>
（2）f[i][2]的求法分两种情况：<br>
①从父结点向上走的最长路径长度<br>
②从父节点向下走其他子树的最长路径长度（若父节点向下走的最长路径经过当前点，则向下走其他子树的最长路径长度为父节点向下走的次长路径长度；若不经过，则取父节点向下走的最长路径）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=10010,M=N*2;
int h[N],e[M],ne[M],w[M],idx;
int n;
int f[N][3]; // 0表示向下走的最大长度，1表示次大长度，2表示向上走的最大长度

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs_d(int u,int fa)
{
    int one=0,two=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        dfs_d(j,u);
        //cout&lt;&lt;u&lt;&lt;&quot;:&quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;
        int d=f[j][0]+w[i];
        if(d &gt; one) 
            two=one,one=d;
        else if(d &gt; two)
            two=d;
    }
    f[u][0]=one;
    f[u][1]=two;
}

void dfs_u(int u,int fa)//先更新后递归
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa) 
            continue;
        if(f[j][0] + w[i] == f[u][0])//父节点向下走的最长路径经过当前点
            f[j][2]=max(f[u][2],f[u][1])+w[i];
        else 
            f[j][2]=max(f[u][2],f[u][0])+w[i];//父节点向下走的最长路径不经过当前点
        dfs_u(j,u);
    }
}

int main()
{
    while(~scanf(&quot;%d&quot;,&amp;n))
    {
        memset(h,-1,sizeof h);
        memset(f,0,sizeof f);
        idx=0;
        
        for(int i=2;i&lt;=n;i++)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            add(i,a,b);
            add(a,i,b);
        }
        
        dfs_d(1,-1);//子节点更新父节点
        
        dfs_u(1,-1);//父节点更新子节点
        
        for(int i=1;i&lt;=n;i++)
            cout&lt;&lt;max(f[i][0],f[i][2])&lt;&lt;endl;
    }
    
    return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_87cfb6ac54-azdp.png" alt="azdp.png" loading="lazy"><br>
我们通常认为，树形DP的写法有两种：<br>
a.根到叶子: 不过这种动态规划在实际的问题中运用的不多。<br>
b.叶子到根: 既根的子节点传递有用的信息给根，完后根得出最优解的过程。这类的习题比较的多。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_9c10e58c54-1.png" alt="1.png" loading="lazy"><br>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1520">hdu1520</a></p>
<h4 id="最大独立集">最大独立集</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_cc54b78254-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_d8be803454-3.png" alt="3.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int N=6000+10;
int val[N],dp[N][2],fa[N],n;
vector&lt;int&gt;E[N];

void dfs(int u){
	dp[u][0]=0;
	dp[u][1]=val[u];
	for(int i=0;i&lt;E[u].size();i++){
		int v=E[u][i];
		dfs(v);
		dp[u][0]+=max(dp[v][1],dp[v][0]);
		dp[u][1]+=dp[v][0];
	}
}

int main(){
	while(~scanf(&quot;%d&quot;,&amp;n)){
		for(int i=1;i&lt;=n;i++){
			scanf(&quot;%d&quot;,&amp;val[i]);
			E[i].clear();
			fa[i]=-1;
		}
		while(1){
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
	        if(a==0&amp;&amp;b==0) break;
	        E[b].push_back(a);
	        fa[a]=b;
		}
	    int rt=1;
	    while(fa[rt]!=-1) rt=fa[rt];
	    dfs(rt);
	    printf(&quot;%d\n&quot;,max(dp[rt][1],dp[rt][0]));
    }
    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=3398">poj3398</a></p>
<h4 id="最小支配集">最小支配集</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_0583dd4659-1.png" alt="1.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9030541459-2.png" alt="2.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_a03cff4259-3.png" alt="3.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_b3418f3659-4.png" alt="4.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int n;
vector&lt;int&gt; E[maxn];
int dp[maxn][3];

void dfs(int u,int fa)
{
    dp[u][0]=1; //加上自身为服务器,选择当前结点 
    dp[u][1]=0;//不选当前结点，选其父节点 
    dp[u][2]=maxn;//选一个子节点 
    int k=E[u].size();
    for(int i=0;i&lt;k;i++)
    {
        int v=E[u][i];
        if(v==fa) continue;
        dfs(v,u);
        dp[u][0]+=min(dp[v][0],dp[v][1]);
        dp[u][1]+=dp[v][2];
    }
    for(int i=0;i&lt;k;i++)
    {
        int v=E[u][i];
        if(v==fa)  continue;
        dp[u][2]=min(dp[u][2],dp[u][1]-dp[v][2]+dp[v][0]);
    }
}

int main()
{
    int u,v;
    while(scanf(&quot;%d&quot;,&amp;n))
    {
        for(int i=1;i&lt;=n;i++)
            E[i].clear();
        for(int i=1;i&lt;n;i++)
        {
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            E[u].push_back(v);
            E[v].push_back(u);
        }
        dfs(1,0);
		printf(&quot;%d\n&quot;,min(dp[1][0],dp[1][2])); 
		int t;
		scanf(&quot;%d&quot;,&amp;t);
		if(t == -1)
			break;
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1079/#">acwing1077</a><br>
题目说的很清楚，用最少的点覆盖所有的点。题目给出的是个树,所以可以用动态规划来解决。<br>
给出如下定义：<br>
f[u][0]表示 u不放看守 ,且u点被父节点监视,<br>
易得在这类情况下子节点可以自己放守卫或者在子节点上放守卫。<br>
由于有多个子节点，为使得所有子节点都被看守，<br>
所以每个节点的最小值累加求和<br>
f[u][0] = ∑(min(f[j][1] , f[j][2]))</p>
<p>f[u][2]表示u放看守,<br>
既然u已经放上了看守，说明子节点必然已经被看到，<br>
因此对于所有子节点可自己放守卫，可被父节点监视，可被子节点监视<br>
f[u][2] = ∑min(min(f[j][0],f[j][1]),f[j][2])+w[u]</p>
<p>f[u][1]表示 u不放看守 ,且u点被一个儿子监视,<br>
首先我们可以枚举当前哪一颗子结点监视u，其余节点可自己放守卫或在子节点放守卫，<br>
f[u][1]=min(f[u][1],f[j][2]+∑min(f[k][2],f[k][1])),j为当前监视u的结点，k为除了j之外u其他的子节点<br>
而f[u][0]=∑(min(f[j][1] , f[j][2]))<br>
则f[u][1]=min(f[u][1],f[j][2]+f[u][0] - min(f[j][2],f[j][1]))</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1510;

int n;
int h[N], w[N], e[N], ne[N], idx;
int f[N][3];
int fa[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    f[u][2] = w[u];

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        f[u][0] += min(f[j][1], f[j][2]);
        f[u][2] += min(min(f[j][0], f[j][1]), f[j][2]);
    }

    f[u][1] = 1e9;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        f[u][1] = min(f[u][1], f[u][0] + f[j][2] - min(f[j][1], f[j][2]));
    }
}

int main()
{
    cin &gt;&gt; n;

    memset(h, -1, sizeof h);
    memset(fa,-1,sizeof fa);
    for (int i = 1; i &lt;= n; i ++ )
    {
        int id, cost, cnt;
        cin &gt;&gt; id &gt;&gt; cost &gt;&gt; cnt;
        w[id] = cost;
        while (cnt -- )
        {
            int ver;
            cin &gt;&gt; ver;
            add(id, ver);
            fa[ver]=id;
        }
    }

    int root = 1;
    while (fa[root] != -1) root =fa[root] ;

    dfs(root);

    cout &lt;&lt; min(f[root][1], f[root][2]) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2412">hdu2412</a></p>
<h4 id="最大独立集唯一性判断">最大独立集+唯一性判断</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_2ff74c5054-4.png" alt="4.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_3ad95a6454-5.png" alt="5.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_5315ab5054-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_6272ec5c54-7.png" alt="7.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int N=200+10;
int dp[N][2],f[N][2],n;
vector&lt;int&gt;E[N];

void dfs(int u){
   	dp[u][0]=0;
	dp[u][1]=1;
	for(int i=0;i&lt;E[u].size();i++){
		int v=E[u][i];
		dfs(v);
		if(dp[v][0]==dp[v][1]){
			dp[u][0]+=dp[v][0];
			f[u][0]=0;
		}else if(dp[v][0]&gt;dp[v][1]){
			dp[u][0]+=dp[v][0];
			if(!f[v][0]) f[u][0]=0;
		}
		else{
			dp[u][0]+=dp[v][1];
			if(!f[v][1]) f[u][0]=0;
		}
		dp[u][1]+=dp[v][0];
		if(!f[v][0]) f[u][1]=0;
	}
}

int main(){
	int n,k;
	string s1,s2;
	map&lt;string,int&gt;mp;
	while(cin&gt;&gt;n&amp;&amp;n){//n为0时结束 
		mp.clear();
		for(int i=0;i&lt;=n;i++)//尽量不要使用memset清0的办法，尽管也可以用 
			E[i].clear();
		memset(f,1,sizeof(f));
		k=1;
		cin&gt;&gt;s1;
		mp[s1]=k++;
		E[0].push_back(mp[s1]);//增加超根 
		for(int i=1;i&lt;=n-1;i++){
			cin&gt;&gt;s1&gt;&gt;s2;
			if(mp[s1]==0)
				mp[s1]=k++;
			if(mp[s2]==0)
				mp[s2]=k++;
			E[mp[s2]].push_back(mp[s1]);
		}
	    dfs(0);
	    printf(&quot;%d &quot;,dp[0][0]);
	    if(f[0][0])
	    	printf(&quot;Yes\n&quot;);
		else
			printf(&quot;No\n&quot;);	
    }
    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=1463">poj1463</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_06bf19b654-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_2d62973254-9.png" alt="9.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int N=1500+10;
int val[N],dp[N][2],fa[N],n;
vector&lt;int&gt;E[N];

void dfs(int u){
	dp[u][0]=0;
	dp[u][1]=1;
	for(int i=0;i&lt;E[u].size();i++){
		int v=E[u][i];
		dfs(v);
		dp[u][1]+=min(dp[v][1],dp[v][0]);
		dp[u][0]+=dp[v][1];
	}
}

int main(){
	while(~scanf(&quot;%d&quot;,&amp;n)){
		for(int i=0;i&lt;n;i++)//编号从0开始 
			E[i].clear();
		memset(fa,-1,sizeof(fa));
		memset(dp,0,sizeof(dp));
		for(int i=0;i&lt;n;i++){
			int a,b,m;
			scanf(&quot;%d:(%d)&quot;,&amp;a,&amp;m);//注意读入 
	        while(m--)
	        {
	        	scanf(&quot;%d&quot;,&amp;b);
	        	E[a].push_back(b);
	        	fa[b]=a;
			}
		}
	    int rt=0;//编号从0开始
	    while(fa[rt]!=-1) rt=fa[rt];
	    dfs(rt);
	    printf(&quot;%d\n&quot;,min(dp[rt][1],dp[rt][0]));
    }
    return 0;
}
</code></pre>
<h4 id="背包类树形dp">背包类树形dp</h4>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1561">hdu1561</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_e427e85a54-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_e76dea7854-12.png" alt="12.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/26/9969_8e4c463458-19.PNG" alt="19.PNG" loading="lazy"><br>
加上虚根一共m+1个结点</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 210,M=N*2;
int n, m;
int w[N];
int h[N], e[M], ne[M], idx;
int f[N][N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int son=e[i];
        dfs(son);
        for (int j = m ; j &gt;= 0; j -- )
            for (int k = 0; k &lt;= j; k ++ )
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }

    for (int j = m+1; j &gt;= 1; j -- ) f[u][j] = f[u][j - 1] + w[u];
    for (int j = 0; j &lt; 1; j ++ ) f[u][j] = 0;
}

int main()
{
    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n)
    {
    	memset(h, -1, sizeof h);
    	memset(f,0,sizeof f);
    	idx=0;
	    for (int i = 1; i &lt;= n; i ++ )
	    {
	    	int a,b;
	    	cin&gt;&gt;a&gt;&gt;b;
	    	if(!a)
	    		add(0,i);
	    	else 
	    		add(a,i);
	    	w[i]=b;
	    }
	
	    dfs(0);
	
	    cout &lt;&lt; f[0][m+1]&lt;&lt; endl;
	}

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/288/">acwing286</a><br>
同背包类树形dp</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 310;

int n, m;
int h[N], e[N], ne[N], idx;
int w[N];
int f[N][N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int son = e[i];
        dfs(son);

        for (int j = m - 1; j &gt;= 0; j -- )
            for (int k = 0; k &lt;= j; k ++ )
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }

    for (int i = m; i&gt;=1; i -- ) f[u][i] = f[u][i - 1] + w[u];
    for(int i=0;i&lt;1;i++) f[u][i]=0;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;

    memset(h, -1, sizeof h);
    for (int i = 1; i &lt;= n; i ++ )
    {
        int p;
        cin &gt;&gt; p &gt;&gt; w[i];
        add(p, i);
    }

    m ++ ;
    dfs(0);

    cout &lt;&lt; f[0][m] &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1077/">acwing1075</a><br>
如果x和y可以互相转化，就连接一条无向边，最后得到的图其实是一个森林，每棵树都是无根树，其实就是要求，整个森林中两个连通的点的最远距离（这里边权都是1），和在无根树中求两点最远距离是一样的，不过这题的特殊性，可以更方便点<br>
对于任意一条边，必有x&lt;y，在树中，x就应该为y的双亲（因为y的约数和是唯一的，但x可能是很多个数的约数和，这正好对应树的关系，双亲唯一，孩子不定）。而dp思想照样是找出每个节点到叶子的最大值m1和次大值m2，再两者相加的dp[rt]，而整个树中的最大值，就是扫描全部节点，找到最大的dp[rt]<br>
由于这题，每个节点的双亲是可以记录下来的，所以dp的时候不用递归，而写成递推式，直接从叶往上递推，<br>
还有一个重要的时候就是怎么找出约数和，数据比较大，应该尽量避免多余的判断，用筛法求约数和则是一个不错的方法</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int N=50010;
int f[N][2];
int sum[N];
 
int main()
{
   cin&gt;&gt;n;
   
   for(int i=1;i&lt;=n;i++)
		for(int j=2*i;j&lt;=n;j+=i)//求约数和 
			sum[j]+=i;
	
	for(int i=n;i&gt;=1;i--)
	{
		if(sum[i]&lt;i)//判断是否符合条件，注意审题。
		{
			if(f[i][0]+1&gt;f[sum[i]][0])
			{
				f[sum[i]][1]=f[sum[i]][0];
				f[sum[i]][0]=f[i][0]+1;
			}
			else if(f[i][0]+1&gt;f[sum[i]][1])
				f[sum[i]][1]=f[i][0]+1;
		} 
	}
	int ans=0;
	for(int i=1;i&lt;=n;i++)
		ans=max(f[i][0]+f[i][1],ans);
	cout&lt;&lt;ans&lt;&lt;endl;
	
   return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1076/">acwing1074</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/26/9969_ab1a78b058-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/26/9969_b31a9ed258-21.PNG" alt="21.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110, M = N * 2;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int f[N][N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int father)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        if (e[i] == father) continue;
        dfs(e[i], u);
        for (int j = m; j&gt;=0; j -- )
            for (int k = 0; k &lt; j; k ++ )
                f[u][j] = max(f[u][j], f[u][j - k - 1] + f[e[i]][k] + w[i]);
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; n - 1; i ++ )
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        add(a, b, c), add(b, a, c);
    }

    dfs(1, -1);

    printf(&quot;%d\n&quot;, f[1][m]);

    return 0;
}
</code></pre>
<h4 id="左儿子右兄弟">左儿子右兄弟</h4>
<p><a href="http://poj.org/problem?id=2486">POJ2486</a><br>
题目大意：一个叫Wshxzt的可爱的女孩子被HX大叔带到了一棵苹果树边。众所周知，苹<br>
果树是一个树形的结构，在节点处长有苹果）。现在我们知道Wshxzt是个苹果控，她只要访问到一个节点，就一定会吃光这个节点所有的苹果。当然一个节点的苹果只能吃一次。HX大叔为了防止Wshxzt长胖，限制她只能走K（1 ≤ K ≤ 200）步，从一个节点走到另<br>
一个相邻的节点是所谓走一步。Wshxzt从节点1开始。树上的节点有N（1 ≤ N ≤ 100）<br>
个，你需要计算Wshxzt最多能吃到多少苹果。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_166db48459-001.png" alt="001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_2201b2aa59-002.png" alt="002.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_367c7b2059-003.png" alt="003.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_3952b18e59-004.png" alt="004.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=110,M=N*2;
int n,m,cnt;
//dp[u][j][0]表示以u为根的树经过j步没有回到点u得到的最值
//dp[u][j][1]表示以u为根的树经过j步回到点u得到的最值 
int dp[N][M][2],val[N],head[N];
 
struct edge{
	int v,next;
}e[M];
 
void init(){
	memset(head,-1,sizeof(head));
	memset(dp,0,sizeof(dp));
	cnt=0;
}
 
void add(int u,int v){
	e[cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt++;
}
 
void dfs(int u,int fa){
	for(int i=0;i&lt;=m;i++)//不论走多少步，均初始化为 
		dp[u][i][0]=dp[u][i][1]=val[u];
	for(int i=head[u];~i;i=e[i].next){
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		for(int j=m;j&gt;=1;j--){//树形背包 
			for(int k=1;k&lt;=j;k++){
				dp[u][j][0]=max(dp[u][j][0],dp[u][j-k][1]+dp[v][k-1][0]);
				if(k&gt;=2) dp[u][j][0]=max(dp[u][j][0],dp[u][j-k][0]+dp[v][k-2][1]);
				if(k&gt;=2) dp[u][j][1]=max(dp[u][j][1],dp[u][j-k][1]+dp[v][k-2][1]);
			}
		}
	}
}
 
int main(){
	int u,v;
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){
		init();
		for(int i=1;i&lt;=n;++i)
			scanf(&quot;%d&quot;,&amp;val[i]);
		for(int i=1;i&lt;n;++i){
			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
			add(u,v);
			add(v,u);
		}
		dfs(1,-1);
		printf(&quot;%d\n&quot;,max(dp[1][m][0],dp[1][m][1]));
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/UVA12186">uva12186</a><br>
一个老板和n个员工组成树状结构，每个员工都有自己的唯一上司，老板的编号为0，员工1~n，工人们打算签署一个志愿书给老板，但无法跨级，当一个中级员工（非是工人的员工）的直属下属中不小于T%的人签字时，他也会签字并且递给他的直属上司，问：要让老板收到请愿书至少需要多少个工人签字。<br>
注意：这里要求的是最底层工人（即叶子结点）的最少个数。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9266e0c059-0001.png" alt="0001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_73948b9259-0002.png" alt="0002.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;

using namespace std;
const int N=100010;
vector&lt;int&gt; E[N];
int n,T;

int dfs(int u)
{
	if(E[u].size() == 0)
		return 1;
	vector&lt;int&gt; res;
    for(int i=0;i&lt;E[u].size();i++)
    {
    	int j=E[u][i];
    	int t=dfs(j);
    	res.push_back(t);
	}
	
	sort(res.begin(),res.end());
	int k=E[u].size();
	int c=(k*T-1)/100+1;
	int ans=0;
	for(int i=0;i&lt;c;i++)
		ans+=res[i];

	return ans;
}

int main()
{
    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;T)&amp;&amp;n){
        for(int i=0;i&lt;=n;i++)
			E[i].clear();
        for(int i=1;i&lt;=n;i++)
        {
            int u;
            scanf(&quot;%d&quot;,&amp;u);
            E[u].push_back(i);
        }
        printf(&quot;%d\n&quot;,dfs(0));
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LCA]]></title>
        <id>https://caifxh.github.io/post/lca/</id>
        <link href="https://caifxh.github.io/post/lca/">
        </link>
        <updated>2020-04-06T03:50:22.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ebac8e3a56-0001.png" alt="0001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_f3642cbe56-0002.png" alt="0002.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_01286f7256-0003.png" alt="0003.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_0e8b262856-0004.png" alt="0004.png" loading="lazy"></p>
<h4 id="暴力">暴力</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_25639d9456-0005.png" alt="0005.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_285eb8e456-0006.png" alt="0006.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_3b0b44da56-0007.png" alt="0007.png" loading="lazy"><br>
<a href="http://poj.org/problem?id=1330">poj1330</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_634786a256-01.png" alt="01.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
const int maxn=10010;
int fa[maxn];
bool flag[maxn];

int LCA(int u,int v)
{
    if(u==v)
    	return u;
	flag[u]=1;
	while(fa[u]!=u)//u向上走到根 
	{
		u=fa[u];
		flag[u]=1;
	}
	if(flag[v]) 
		return v;
	while(fa[v]!=v)//v向上走
	{
		v=fa[v];
		if(flag[v])
			return v;
	}
	return 0;   	
}

int main()
{
	int n,u,v,T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
		{
			fa[i]=i;
			flag[i]=0;
		} 
		for(int i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
			fa[v]=u;
		}
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		printf(&quot;%d\n&quot;,LCA(u,v));
	}
	return 0;
}
</code></pre>
<h4 id="树上倍增">树上倍增</h4>
<p>用树上倍增法求LCA的时间复杂度为O((n+m)logn)。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_e1ee9b0856-02.png" alt="02.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_040ed6bc56-04.png" alt="04.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_073739f656-05.png" alt="05.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_0c3d228a56-06.png" alt="06.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_21a1fd3a56-07.png" alt="07.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_2e88049056-08.png" alt="08.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_3e3f101856-09.png" alt="09.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_4e5cc82856-10.png" alt="10.png" loading="lazy"></p>
<h4 id="步骤">步骤</h4>
<p>1.建立一个空队列，并将根节点入队，同时存储根节点的深度<br>
2.取出队头，遍历其所有出边。由于存储的时候是按照无向图存储，因此要进行深度判定，对于连接到它父亲节点的边，直接continue即可。记当前路径的另一端节点为y，处理出y的d、f两个数组的值，然后将y入队。<br>
3.重复第2步，直到队列为空<br>
以上部分是树上倍增法的预处理，也是比较通用的对于树上倍增的预处理，时间复杂度O(nlogn)<br>
。接下来是求LCA的核心部分。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_182d302457-00000.PNG" alt="00000.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/1174/">acwing1172</a></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 40010, M = N * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][16];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k &lt;= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 15; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 15; k &gt;= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    int root = 0;
    memset(h, -1, sizeof h);

    for (int i = 0; i &lt; n; i ++ )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        if (b == -1) root = a;
        else add(a, b), add(b, a);
    }

    bfs(root);

    scanf(&quot;%d&quot;, &amp;m);
    while (m -- )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        int p = lca(a, b);
        if (p == a) puts(&quot;1&quot;);
        else if (p == b) puts(&quot;2&quot;);
        else puts(&quot;0&quot;);
    }

    return 0;
}
</code></pre>
<h4 id="离线tarjan">离线tarjan</h4>
<p>Tarjan算法求LCA的本质是用并查集对向上标记法进行优化，是一种离线算法，时间复杂度O(n+m)。<br>
在深度优先遍历的任意时刻，树中结点分为三类：<br>
1.已经访问完毕并且回溯的结点，在这些结点上标记一个整数2.<br>
2，已经开始递归，但尚未回溯的点。这些结点就是当前正在访问的结点，x以及x的祖先。在这些结点上标记一个整数1.<br>
3.尚未访问的绩点。这些结点没有标记。<br>
对于正在访问的结点x，它到根节点的路劲已经标记为1.若y是已经访问完毕并且回溯的节点，则LCA（x，y）就是从y向上走到根，第一个遇到的标记为1的节点。<br>
可以利用并查集进行优化，当一个结点获得整数2的标记时，把它所在的集合合并到它的父节点所在的集合中（合并时它的父节点标记一定为1，且单独构成一个集合）。<br>
此时扫描与x相关的所有询问，若询问的另一个点y的标记为2，就知道l该孙文的回答应该是y所在并查集中的代表元素。<br>
这样，Tarjan算法求LCA的步骤就很明了了：</p>
<p>1.从根节点开始进行dfs<br>
2.将当前节点标记为1<br>
3.遍历当前节点的所有出边；若当前边的终点还没有访问过，则访问它，访问过后将该节点合并到当前节点的集合中；<br>
4.遍历与当前节点相关的所有询问；若当前询问的另一个节点的标记为2，则该询问的答案即为另一个节点所在集合的代表元素<br>
5.将当前节点标记为2</p>
<p><a href="https://www.acwing.com/problem/content/1173/">acwing1171</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
const int N=10010,M=N*2;
int h[N],e[M],ne[M],w[M],idx;
int n,m;
typedef pair&lt;int,int&gt; PII;
#define x firsst
#define y second
vector&lt;PII&gt; query[N];//first存储查询的另外一个点，second存查询编号
int res[M];
int st[N];
int p[N];
int dist[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}


void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        dist[j]=dist[u]+w[i];
        dfs(j,u);
    }
}

void tarjan(int u)
{
    st[u]=1;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])
        {
            tarjan(j);
            p[j]=u;
        }
    }
    
    for(int i=0;i&lt;query[u].size();i++)
    {
        int y=query[u][i].first,id=query[u][i].second;
        if(st[y] == 2)
        {
            int anc=find(y);
            res[id]=dist[u]+dist[y]-dist[anc]*2;
        }
    }
    st[u]=2;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    
    for(int i=0;i&lt;n-1;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
        add(b,a,c);
    }
    
    for(int i=0;i&lt;m;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(a != b)
        {
            query[a].push_back({b,i});
            query[b].push_back({a,i});
        }
    }
    
    for(int i=1;i&lt;=n;i++)
        p[i]=i;
    
    dfs(1,-1);
    
    tarjan(1);
    
    for(int i=0;i&lt;m;i++)
        cout&lt;&lt;res[i]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="lca求次小生成树">lca求次小生成树</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ee11055656-13.PNG" alt="13.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_0fa2ff0856-2.png" alt="2.png" loading="lazy"><br>
我们假设一条路径是由三段构造而成.是三段,不是就三个点.a-&gt;c,c-&gt;b,b-&gt;a(转自秦同学题解)<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_a07e83ee56-14.PNG" alt="14.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_a8d7c74856-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_cb3cbf6e56-16.PNG" alt="16.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ceafad0056-17.PNG" alt="17.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 300010, INF = 0x3f3f3f3f;

int n, m;
struct Edge
{
    int a, b, w;
    bool used;
    bool operator&lt; (const Edge &amp;t) const
    {
        return w &lt; t.w;
    }
}edge[M];
int p[N];
int h[N], e[M], w[M], ne[M], idx;
int depth[N], fa[N][17], d1[N][17], d2[N][17];
int q[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

LL kruskal()
{
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;
    sort(edge, edge + m);
    LL res = 0;
    for (int i = 0; i &lt; m; i ++ )
    {
        int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w;
        if (a != b)
        {
            p[a] = b;
            res += w;
            add(edge[i].a, edge[i].b, w), add(edge[i].b, edge[i].a, w);
            edge[i].used=true;
        }
    }

    return res;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    q[0] = 1;
    int hh = 0, tt = 0;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                d1[j][0] = w[i], d2[j][0] = -INF;
                for (int k = 1; k &lt;= 16; k ++ )
                {
                    int anc = fa[j][k - 1];
                    fa[j][k] = fa[anc][k - 1];
                    int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]};
                    d1[j][k] = d2[j][k] = -INF;
                    for (int u = 0; u &lt; 4; u ++ )
                    {
                        int d = distance[u];
                        if (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;
                        else if (d &lt; d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;
                    }
                }
            }
        }
    }
}

int lca(int a, int b, int w)
{
    static int distance[N * 2];
    int cnt = 0;
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 16; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
        {
            distance[cnt ++ ] = d1[a][k];
            distance[cnt ++ ] = d2[a][k];
            a = fa[a][k];
        }
    if (a != b)
    {
        for (int k = 16; k &gt;= 0; k -- )
            if (fa[a][k] != fa[b][k])
            {
                distance[cnt ++ ] = d1[a][k];
                distance[cnt ++ ] = d2[a][k];
                distance[cnt ++ ] = d1[b][k];
                distance[cnt ++ ] = d2[b][k];
                a = fa[a][k], b = fa[b][k];
            }
        distance[cnt ++ ] = d1[a][0];
        distance[cnt ++ ] = d1[b][0];
    }

    int dist1 = -INF, dist2 = -INF;
    for (int i = 0; i &lt; cnt; i ++ )
    {
        int d = distance[i];
        if (d &gt; dist1) dist2 = dist1, dist1 = d;
        else if (d &lt; dist1 &amp;&amp; d &gt; dist2) dist2 = d;
    }

    if (w != dist1) 
        return w - dist1;
    return w - dist2;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; m; i ++ )
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        edge[i] = {a, b, c};
    }

    LL sum = kruskal();
    
    bfs();

    LL res = 1e18;
    for (int i = 0; i &lt; m; i ++ )
        if (!edge[i].used)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            res = min(res, sum + lca(a, b, w));
        }
    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[状态机]]></title>
        <id>https://caifxh.github.io/post/zhuang-tai-ji/</id>
        <link href="https://caifxh.github.io/post/zhuang-tai-ji/">
        </link>
        <updated>2020-04-05T04:04:31.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/1051/">acwing1049</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_6f0c7d4276-33.PNG" alt="33.PNG" loading="lazy"><br>
不合法状态按照问题的性质初始化为INF(求最小值)/-(求最大值)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100010,INF=0x3f3f3f3f;
int w[N];
int f[N][2];

int main()
{
    int t;
    cin&gt;&gt;t;
    while(t--)
    {
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;w[i]);
        
        f[0][0]=0,f[0][1]=-INF;
        for(int i=1;i&lt;=n;i++)
        {
            f[i][0]=max(f[i-1][0],f[i-1][1]);
            f[i][1]=f[i-1][0]+w[i];
        }
        printf(&quot;%d\n&quot;,max(f[n][0],f[n][1]));
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1059/">acwing1057</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/04/9969_1479fc8076-29.PNG" alt="29.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_f409bd6e76-31.PNG" alt="31.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100010,M=110;
int w[N];
int f[N][M][2];

int main()
{
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;w[i];
    memset(f,-0x3f,sizeof f);
    for(int i=0;i&lt;=n;i++) f[i][0][0]=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=k;j++)
        {
            f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i]);
            f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0]-w[i]);
        }
    int res=0;
    for(int i=0;i&lt;=k;i++)
        res=max(res,f[n][i][0]);
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1060/">acwing1058</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_0cd946fa76-32.PNG" alt="32.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100010, INF = 0x3f3f3f3f;

int n;
int w[N];
int f[N][3];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);

    f[0][0] = f[0][1] = -INF, f[0][2] = 0;
    for (int i = 1; i &lt;= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]);
        f[i][1] = f[i - 1][0] + w[i];
        f[i][2] = max(f[i - 1][2], f[i - 1][1]);
    }

    printf(&quot;%d\n&quot;, max(f[n][1], f[n][2]));

    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3401">poj3401</a><br>
最近，lxhgww沉迷于股票，经过几天的研究，他发现了一些规律的模式。<br>
他预测未来T天的股票市场。 在第i天，您可以以APi的价格购买一只股票或卖出一只股票以获得BPi。<br>
还有其他一些限制，即在第一天就可以购买最多ASi股票，最多可以卖出BSi股票。两个交易日的间隔应大于W天。 也就是说，假设您在第i天进行了交易（<strong>任何买卖股票都被视为一项交易</strong>），那么下一个交易日必须在第（i + W + 1）天或更晚的时间进行。而且，任何时候最多只能拥有MaxP股票。<br>
在第一天之前，lxhgww已经拥有无限的资金，但是没有股票，当然，他希望从股市中赚到尽可能多的钱。 所以问题来了，他最多只能赚多少钱？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_d66ad1ba76-34.png" alt="34.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_f1520dcc76-35.PNG" alt="35.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_4584aa0276-36.png" alt="36.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_79e2bd3476-37.png" alt="37.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_7d04775a76-38.PNG" alt="38.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_d9bc776276-40.PNG" alt="40.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_dd41f1f076-39.png" alt="39.png" loading="lazy"><br>
动态规划方程：<br>
1.不买不卖。dp[i][j]=max(dp[i-1][j],dp[i][j]);<br>
2.买一些股票。dp[i][j]=max(dp[i-1][k]-(j-k)*ap[i]);(0&lt;=k&lt;=j&lt;=Maxp)<br>
3.卖一些股票。dp[i][j]=max(dp[i-1][k]+(k-j)*bp[i]);(0&lt;=j&lt;=k&lt;=Maxp)<br>
注意：<br>
1.把所有未定义的状态都设置为-INF，1~w+1天得初始化，因为这些天不能有前面的状态推出来，初始化为对应购买多少股票所减去的钱数，因为一开始只有买，不能卖。<br>
2.循环的递减还是递增问题，跟当前要访问的状态有关。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=2010;
int f[N][N];
int ap[N],bp[N];//买入价格，卖出价格 
int as[N],bs[N];//买入限制，卖出限制
int q[N];
int n,m,w;

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;w);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d%d%d%d&quot;,&amp;ap[i],&amp;bp[i],&amp;as[i],&amp;bs[i]);
    
        memset(f,-0x3f,sizeof f);
        f[0][0]=0;
        for(int i=1;i&lt;=w+1;i++)
            for(int j=0;j&lt;=as[i];j++)
                f[i][j]=-j*ap[i];
        
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=0;j&lt;=m;j++)
                f[i][j]=max(f[i][j],f[i-1][j]);//没有交易
            if(i &lt;= w+1) continue;
            int hh=0,tt=-1;
            for(int j=0;j&lt;=m;j++)
            {
                if(hh &lt;= tt &amp;&amp; j-as[i] &gt; q[hh]) 
                    hh++;
                
                while(hh&lt;=tt &amp;&amp; f[i-w-1][j]+j*ap[i] &gt;= f[i-w-1][q[tt]]+q[tt]*ap[i])
                    tt--;
                q[++tt]=j;
                f[i][j]=max(f[i][j],f[i-w-1][q[hh]]+q[hh]*ap[i]-j*ap[i]);//买入 
             } 
             
            hh=0,tt=-1;
            for(int j=m;j&gt;=0;j--)
            {
                if(hh &lt;= tt &amp;&amp; j+bs[i] &lt; q[hh]) 
                    hh++;
                
                while(hh&lt;=tt &amp;&amp; f[i-w-1][j]+j*bp[i] &gt;= f[i-w-1][q[tt]]+q[tt]*bp[i])
                    tt--;
                q[++tt]=j;
                f[i][j]=max(f[i][j],f[i-w-1][q[hh]]+q[hh]*bp[i]-j*bp[i]);//卖出 
             } 
        }
        printf(&quot;%d\n&quot;,f[n][0]);
    }
    return 0;
 } 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[欧拉路径]]></title>
        <id>https://caifxh.github.io/post/ou-la-lu-jing/</id>
        <link href="https://caifxh.github.io/post/ou-la-lu-jing/">
        </link>
        <updated>2020-04-04T15:37:39.000Z</updated>
        <content type="html"><![CDATA[<h4 id="欧拉路">欧拉路</h4>
<p>通过图（无向图或有向图）中所有边一次且仅一次行遍图中所有顶点的通路称为欧拉通路，通过图中所有边一次且仅一次行遍所有顶点的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_eebc2c825a-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_025de6545a-3.PNG" alt="3.PNG" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_06e3a60e5a-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_0436e9d05a-5.PNG" alt="5.PNG" loading="lazy"><br>
(注意：这里说有向图连通，说的是有向图是弱连通图。即把有向图中的边变成无向边，只要该图连通，那么原有向图即是弱连通图。实际中可用并查集判断是否弱连通)<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_bfab780c5a-6.PNG" alt="6.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_0be375da5a-7.PNG" alt="7.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_c5661c205a-8.PNG" alt="8.PNG" loading="lazy"></p>
<p>• 欧拉回路的求解方法主要有两种：</p>
<ul>
<li>DFS搜索</li>
<li>Fleury算法</li>
</ul>
<p>用 DFS 搜索思想求解欧拉回路的思路为：</p>
<ul>
<li>利用欧拉定理判断出一个图存在欧拉通路或欧拉回路。</li>
<li>选择一个正确的起始顶点，用 DFS 算法遍历所有的边（每条边<br>
只遍历一次），遇到走不通就回退。 • 在搜索前进方向上将遍历过的边按顺序记录下来。</li>
<li>这组边的排列就组成了一条欧拉通路或欧拉回路。</li>
</ul>
<h4 id="例题">例题</h4>
<p>给定 n 张骨牌，每张骨牌有左右两个点数（从 1 到 6）。问能不能<br>
通过交换骨牌的顺序和交换左右两个点数，使得任意两个相邻骨牌的<br>
相邻段为相等的数字。<br>
原始： (1 2)(2 4)(2 4)(6 4)(2 1)<br>
重排后： (4 2)(2 1)(1 2)(2 4)(4 6)</p>
<p>本题可以转化成欧拉回路或欧拉通路的求解问题。</p>
<ul>
<li>首先要构造一个图？</li>
<li>每张骨牌当一个点？</li>
<li>如何解决交换骨牌内部两个点数？</li>
</ul>
<p>图建好之后，先判断是否存在欧拉通路或欧拉回路。<br>
总结：存在 ➔ 选择正确的起点 ➔ 6 ➔ 开始 DFS</p>
<p><a href="https://www.acwing.com/problem/content/1125/">acwing1123</a><br>
我们将这个图看成有向图，对于每输入一组数据加两条有向边，需要每条边都至少走一遍<br>
我们先回想一下存在有向图的欧拉路径的充分必要条件</p>
<ul>
<li>所有点的入度都等于出度</li>
<li>除了两个点以外的点入度等于出度，</li>
</ul>
<p>这两个点一个 入度 = 出度 + 1，另一个 入度 = 出度 - 1<br>
因此，我们考虑每加一条边，每个点的入度和出度都加1<br>
所以，每个点的入度都一定等于出度,符合上述的第一条<br>
故这个图存在欧拉路径，并且可以选任意点为起点<br>
所以我们只需统计所有的边的长度总和，跟据20km/h 算出时间即可</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    double x1, y1, x2, y2;
    cin &gt;&gt; x1 &gt;&gt; y1;

    double sum = 0;
    while (cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)
    {
        double dx = x1 - x2;
        double dy = y1 - y2;
        sum += sqrt(dx * dx + dy * dy) * 2;
    }

    int minutes = round(sum / 1000 / 20 * 60);
    int hours = minutes / 60;
    minutes %= 60;

    printf(&quot;%d:%02d\n&quot;, hours, minutes);

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1126/">acwing1124</a></p>
<p>无向图的欧拉路径&amp;欧拉回路裸题</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=510;
int n=500,m;
int g[N][N];
int ans[1100];
int cnt;
int d[N];

void dfs(int u)
{
    for(int i=1;i&lt;=n;i++)//从小到大枚举，字典序最小
    {
        if(g[u][i])
        {
            g[u][i]--,g[i][u]--;
            dfs(i);
        }
    }
    
    ans[cnt++]=u;
}

int main()
{
    cin&gt;&gt;m;
    
    int l=500,r=1;
    while(m--)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        l=min(l,min(a,b));
        r=max(r,max(a,b));
        g[a][b]++,g[b][a]++;
        d[a]++,d[b]++;
    }
    
    int start=l;
    for(int i=l;i&lt;=r;i++)
    {
        if(d[i] % 2)
        {
            start=i;
            break;
        }
    }
    
    dfs(start);//欧拉回路从哪开始都可以搜，欧拉路要从奇点开始
    
    for(int i=cnt-1;i&gt;=0;i--)//逆序输出
        printf(&quot;%d\n&quot;,ans[i]);
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1187/">acwing1185</a><br>
有向图，首尾连单词，可用DFS和并查集判断连通性</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 26, L = 1005;
int n, cnt, g[N][N], in[N], out[N];
char s[L];

void dfs(int u) {
    for (int i = 0; i &lt; 26; i++) {
        if(g[u][i]) {
            cnt++;
            g[u][i] --;
            dfs(i);
        }
    }
}
int main() {
    int T; scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        cnt = 0;
        memset(g, 0, sizeof g);
        memset(in, 0, sizeof in);
        memset(out, 0, sizeof out);
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 0; i &lt; n; i++) {
            scanf(&quot;%s&quot;, s);
            int u = s[0] - 'a', v = s[strlen(s) - 1] - 'a';
            g[u][v]++;
            out[u]++, in[v]++;
        }

        bool ok = true;
        int s = 0, t = 0;
        for (int i = 0; i &lt; 26; i++) {
            if(in[i] != out[i]) {
                if(in[i] == out[i] + 1) t ++;
                else if(in[i] + 1 == out[i]) s++;
                else { ok = false; break; }
            }
        }


        if(!(!s &amp;&amp; !t || (s == 1 &amp;&amp; t == 1))) ok = false;

        s = 0;
        while(!out[s]) s++;
        for (int i = 0; i &lt; 26; i++)
            if(in[i] + 1 == out[i]) { s = i; break; }

        dfs(s);

        if(cnt &lt; n) ok = false;
        puts(ok ? &quot;Ordering is possible.&quot; : &quot;The door cannot be opened.&quot;);
    }
    return 0;
}
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=30;
int n;
int din[N], dout[N], p[N];
bool st[N];


int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        memset(din,0,sizeof din);
        memset(dout,0,sizeof dout);
        memset(st,0,sizeof st);
        for(int i=0;i&lt;26;i++)
            p[i]=i;
        
        for(int i=0;i&lt;n;i++)
        {
            char str[1010];
            scanf(&quot;%s&quot;,str);
            int len=strlen(str);
            int a=str[0]-'a',b=str[len-1]-'a';
            st[a]=st[b]=true;
            dout[a]++,din[b]++;
            p[find(a)]=find(b);
        }
        
        int start=0,end=0;
        bool success=true;
        for(int i=0;i&lt;26;i++)
            if(din[i] != dout[i])
            {
                if(din[i] == dout[i] + 1)
                    end++;
                else if(din[i] + 1 == dout[i])
                    start++;
                else
                {
                    success=false;
                    break;
                }
            }
            
        if(!(!start &amp;&amp; !end ||start == 1 &amp;&amp; end == 1))
            success=false;
        int rep = -1;
        for (int i = 0; i &lt; 26; i ++ )
            if (st[i])
            {
                if (rep == -1) rep = find(i);
                else if (rep != find(i))
                {
                    success = false;
                    break;
                }
            }

        if (success) puts(&quot;Ordering is possible.&quot;);
        else puts(&quot;The door cannot be opened.&quot;);

    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>