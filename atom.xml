<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caifxh.github.io</id>
    <title>Gridea</title>
    <updated>2020-07-10T09:29:31.589Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caifxh.github.io"/>
    <link rel="self" href="https://caifxh.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://caifxh.github.io/images/avatar.png</logo>
    <icon>https://caifxh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[搜索]]></title>
        <id>https://caifxh.github.io/post/sou-suo/</id>
        <link href="https://caifxh.github.io/post/sou-suo/">
        </link>
        <updated>2020-05-29T16:22:16.000Z</updated>
        <content type="html"><![CDATA[<h4 id="dfs代码框架">DFS代码框架</h4>
<pre><code>ans;                  //答案，用全局变量表示
void dfs(层数，其他参数){
    if (出局判断){    //到达最底层，或者满足条件退出 
        更新答案;     //答案一般用全局变量表示
        return;       //返回到上一层
    }
    (剪枝)            //在进一步DFS之前剪枝
    for (枚举下一层可能的情况)    //对每一个情况继续DFS 
        if (used[i] == 0) {       //如果状态i没有用过，就可以进入下一层
            used[i] = 1;   //标记状态i,表示已经用过，在更底层不能再使用
            dfs(层数+1，其他参数);    //下一层 
            used[i] = 0;   //恢复状态，回溯时，不影响上一层对这个状态的使用
            }
    return;          //返回到上一层
}
</code></pre>
<p><a href="https://vjudge.net/problem/UVA-1599">uva1599</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/15/9969_28f1216a96-15.png" alt="15.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
const int N=100010,M=400010,INF=0x3f3f3f3f;
int h[N],e[M],ne[M],w[M],idx;
int dist[N];
int q[N];
int ans[N];
bool st[N];
int n,m;

void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

void bfs1()//从终点开始bfs 
{
	memset(dist,-1,sizeof dist);
	int hh=0,tt=-1;
	q[++tt]=n;
	dist[n]=0;
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=h[t];~i;i=ne[i])
		{
			int j=e[i];
			if(dist[j] == -1) 
			{
				dist[j]=dist[t]+1;
				q[++tt]=j;
			}
		}
	}
}

void bfs2()//从起点开始bfs 
{
	memset(ans,0,sizeof ans);
	memset(st,0,sizeof st);
	queue&lt;int&gt; q;
	q.push(1);
	
	while(q.size())
	{
		int t=q.front();
		q.pop();
		if(t == n)
		{
			cout&lt;&lt;ans[0];
			for(int i=1;i&lt;=dist[1]-1;i++)
				cout&lt;&lt;' '&lt;&lt;ans[i];
			cout&lt;&lt;endl;
			return;
		}
		int minc=INF;
		for(int i=h[t];~i;i=ne[i])
		{
			int j=e[i];
			if(dist[t] - 1 == dist[j])
				minc=min(minc,w[i]);
		}

		for(int i=h[t];~i;i=ne[i])
		{
			int j=e[i];
			if(dist[t] - 1 == dist[j] &amp;&amp; w[i] == minc &amp;&amp; !st[j])
				q.push(j),st[j]=true;
		}
		int k=dist[1]-dist[t];
		if(ans[k] == 0) ans[k] = minc;
		else ans[k]=min(ans[k],minc);
	}
}

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		memset(h,-1,sizeof h);
		idx=0;
		while(m--)
		{
			int a,b,c;
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
			add(a,b,c);
			add(b,a,c);
		}
		
		bfs1();
		cout&lt;&lt;dist[1]&lt;&lt;endl;
		
		bfs2();
	
	}
}
</code></pre>
<p>bfs2需要一个st数组，防止下一层的结点多次入队（存在重边）</p>
<p><a href="https://www.luogu.com.cn/problem/P1118">P1118</a><br>
题目描述：写出一个1至N的排列ai，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列都比上一次的序列长度少1，直到只剩下一个数字位置。下面是一个例子：<br>
  3  1  2  4<br>
    4  3  6<br>
     7  9<br>
      16<br>
  最后得到16这样一个数字。<br>
  现在倒着玩这样一个游戏，如果知道N，知道最后得到的数字的大小sum，请你求出最初序列ai，为1至N的一个排列。若答案有多种可能，则输出字典序最小的那一个。n≤12, sum≤12345。</p>
<p>题解：<br>
  （1）暴力法。对1～N这N个数做从小到大的全排列，对每个全排列进行三角形的计算，判断是否等于N。<br>
  对每个排列进行三角形计算，需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>次。例如第1行有5个数{a,b,c,d,e}，那么第2行计算4次，第3行计算3次…等等，总次数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的。<br>
  a    b    c    d    e<br>
    a+b    b+c   c+d   d+e<br>
      a+2b+c b+2c+d c+2d+e<br>
       a+3b+3c+d b+3c+3d+e<br>
          a+4b+6c+4d+e<br>
  共有N!=4亿个排列，总复杂度是$O(N!N^2)的，显然会超时。<br>
  2）三角计算优化+剪枝。<br>
  1）三角计算的优化。对排列进行三角形计算，并不需要按部就班地算，比如{a,b,c,d,e}这5个数，直接算最后一行的公式a+4b+6c+4d+e就好了，复杂度是O(N)的。不同的N有不同的系数，比如5个数的系数是{1,4,6,4,1}，提前算出所有N的系数备用。可以发现，这些系数正好是杨辉三角。<br>
  2）剪枝。即使有了杨辉三角的优化，总复杂度还是有O(N!N)，所以必须进行最优性剪枝。对某个排列求三角形和时，如果前面几个元素和已经大于sum，那么后面的元素就不用再算了。例如，N=9时，计算到排列{2,1,3,4,5,6,7,8,9}，如果前5个元素{2,1,3,4,5}求和已经大于sum，那么后面的{6,7,8,9}～{9,8,7,6}都可以跳过，下一个排序从{2,1,3,4,6,5,7,8,9}开始。本题sum≤12345，和不大，用这个简单的剪枝方法可以通过。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=15;
int c[N][N];
int path[N];
bool st[N];
int n,sum;

void init()
{
	for(int i=0;i&lt;=n;i++)
		for(int j=0;j&lt;=i;j++)
			if(!j) c[i][j]=1;
			else c[i][j]=c[i-1][j]+c[i-1][j-1];
}

bool dfs(int dep,int s)
{
	if(s &gt; sum) return false;
	
	if(dep == n) 
	{
		if(s == sum)
		{
			for(int i=0;i&lt;n;i++)
				cout&lt;&lt;path[i]&lt;&lt;' ';
			cout&lt;&lt;endl;
			return true;
		}
		return false;
	}
	
	for(int i=1;i&lt;=n;i++)
		if(!st[i])
		{
			st[i]=true;
			path[dep]=i;
			if(dfs(dep+1,s+i*c[n-1][dep])) return true;;
			st[i]=false;
		}
	return false;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;sum;
	
	init();
	
	dfs(0,0);
	
	return 0;
}
</code></pre>
<h4 id="奇偶剪枝">奇偶剪枝</h4>
<p>搜索用BFS还是DFS？对于路径问题，应该用DFS，因为DFS“一路深入”，天然就产生了一条路径，而BFS逐层推进，把层与层之间连续的路径打断了，想表示一个路径很困难。<br>
首先考虑暴力搜索的复杂度。在所有可能的路径中，看其中是否有长度为T的路径。<br>
直接搜所有的路径，会超时。有多少可能的路径呢？这题图很小，但是路径数量很惊人。1 &lt; N, M &lt; 7，最多36个格子，设最长路径是36，每个点有3个出口，那么就有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>36</mn></msup></mrow><annotation encoding="application/x-tex">3^{36}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>个路径，是天文数字。即使在DFS的时候加上一点限制条件，即格子不能重复走，那么也会搜到百万以上的的路径。<br>
这一题最重要的技术，网上称为“奇偶剪枝”。不过，本文认为“奇偶剪枝”这个说法不准确，称为“奇偶判断”更合适，因为它并不需要在DFS内部剪枝，见本节后面的讨论。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/05/15/9969_5d530dd696-16.PNG" alt="16.PNG" loading="lazy"><br>
以上2个优化很有限，真正有用的是“奇偶剪枝”：若tmp是偶数，则可能有解；若tmp是奇数，肯定无解。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/15/9969_96d5692896-17.PNG" alt="17.PNG" loading="lazy"><br>
所以，奇偶判断应该在DFS之前做，判断有解后再进行DFS。DFS内部的奇偶判断是多余的；奇偶判断并不能减少DFS内部搜索的数量，因为这是独立的两件事。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/15/9969_cc68d46296-18.PNG" alt="18.PNG" loading="lazy"><br>
所以，给定起点S、终点D，以及限制的步数T，可以立刻判断是否有解：<br>
（1）S和D同0或同1，T是偶数，可能有解；T是奇数，必定无解。<br>
（2）S和D不同，T是奇数，可能有解；T是偶数，必定无解。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/15/9969_cd5666f496-19.PNG" alt="19.PNG" loading="lazy"><br>
最后，从以上分析可以知道，奇偶判断只能用在方格图上。方格里允许有不可走的障碍，这些障碍不影响逻辑正确性。</p>
<pre><code> #include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=10;
typedef pair&lt;int,int&gt; PII;
char g[N][N];
bool vis[N][N];
PII st,ed;
int n,m,t;
int dx[]={-1,0,1,0},dy[]={0,1,0,-1};

bool dfs(int x,int y,int cnt)
{
	if(x == ed.first &amp;&amp; y == ed.second)
	{
		if(cnt == t)
			return true;
		return false;
	}
	
	if(cnt &gt; t) return false;
	int remain=t-cnt-abs(x-ed.first)-abs(y-ed.second);
	if(remain &lt; 0) return false;
	
	for(int i=0;i&lt;4;i++)
	{
		int a=x+dx[i],b=y+dy[i];
		if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m) continue;
		if(g[a][b] == 'X') continue;
		if(vis[a][b]) continue;
		vis[a][b]=1;
		if(dfs(a,b,cnt+1)) return true;
		vis[a][b]=0;
	}
	return false;
}

int main()
{
	while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t))
	{
		if(!n &amp;&amp; !m &amp;&amp; !t) break;
		memset(vis,0,sizeof vis);
		for(int i=0;i&lt;n;i++)
			for(int j=0;j&lt;m;j++)
			{
				char c;
				cin&gt;&gt;c;
				g[i][j]=c;
				if(c == 'S') st={i,j};
				if(c == 'D') ed={i,j};
			}
			
		int f=t-abs(st.first-ed.first)-abs(st.second-ed.second);
		
		if(f &amp; 1) // 无解
		{
			puts(&quot;NO&quot;);
			continue;
		 } 
		 
		vis[st.first][st.second]=1;
		if(dfs(st.first,st.second,0))
		 	puts(&quot;YES&quot;);
		else 
			puts(&quot;NO&quot;);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1126">P1126</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/17/9969_ec4cc5d897-21.PNG" alt="21.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int N=55;
struct Point
{
	int x,y,dir,dist;
};
int g[N][N];
bool vis[N][N][5];
Point st,ed;
int dx[]={0,1,0,-1},dy[]={1,0,-1,0}; //E,S,W,N
int n,m;

inline int mod(int x)
{
	return (x%4+4)%4;
}

int get(char c)
{
	if(c == 'E') return 0;
	else if(c == 'S') return 1;
	else if(c == 'W') return 2;
	else return 3;
}

int bfs()
{
	queue&lt;Point&gt; q;
	st.dist=0;
	q.push(st);
	vis[st.x][st.y][st.dir]=1;
	while(q.size())
	{
		Point t=q.front();
		q.pop();
		
		if(t.x == ed.x &amp;&amp; t.y == ed.y)
			return t.dist;
			
		for(int i=1;i&lt;=3;i++)
		{
			int a=t.x+i*dx[t.dir];
			int b=t.y+i*dy[t.dir];
			if(a &lt;= 0 || a &gt;= n || b &lt;= 0 || b &gt;= m || g[a][b] == 1) break;
			if(vis[a][b][t.dir]) continue;
			vis[a][b][t.dir]=1;
			q.push({a,b,t.dir,t.dist+1});                                      
		}
		if(!vis[t.x][t.y][mod(t.dir+1)])
		{
			vis[t.x][t.y][mod(t.dir+1)]=1;
			q.push({t.x,t.y,mod(t.dir+1),t.dist+1});
		}
		if(!vis[t.x][t.y][mod(t.dir-1)])
		{
			vis[t.x][t.y][mod(t.dir-1)]=1;
			q.push({t.x,t.y,mod(t.dir-1),t.dist+1});
		}
	}	
	
	return -1;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
		{
			cin&gt;&gt;g[i][j];
			if(g[i][j] == 1)
			{
				g[i-1][j-1]=g[i-1][j]=g[i][j-1]=1;
			}
		}
	
	char c;
	cin&gt;&gt;st.x&gt;&gt;st.y&gt;&gt;ed.x&gt;&gt;ed.y&gt;&gt;c;
	st.dir=get(c);

	int t=bfs();
	
	cout&lt;&lt;t&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/170/">acwing168</a><br>
可以发现从上往下 r 和 h 都是递增的。<br>
因此 r[1] 和 h[1] 至少是 m。这样就可以从第一层开始枚举 r[1] 和 h[1]，接下来每层都进行枚举。</p>
<ul>
<li>一个比较显然的最优化剪枝：如果 S &gt; ans 可以结束搜索</li>
<li>进一步的，因为第 i 层的半径和高度至少是 i。所以表面积和体积都是存在下界 lowS[i] 和 lowV[i] 的。<br>
可以加两个可行性剪枝：</li>
<li>如果当前的 V + lowV[i] &gt; N，那么肯定不行。</li>
<li>如果当前的 S + lowS[i] &gt; ans，那么也肯定不是答案。</li>
<li>最后还有个重要的可行性剪枝：<br>
如果拿剩下的全部体积来做一个圆柱体（这样是理论上的表面积最小值，因为半径越大，高度越小，则侧面积越小），加上当前的表面积 S 都会超过 ans，<br>
那么结束搜索。</li>
<li>if (2 * (N - V) / r + S &gt; ans) return;<br>
（推导：2rh = S, r2h = N-V）</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=25,INF=0x3f3f3f3f;
int minv[N],mins[N];
int n,m;
int ans;

void dfs(int dep,int s,int v,int r,int h)
{
	if(s &gt; ans) return;
	if(s + mins[dep] &gt; ans) return;
	if(v + minv[dep] &gt; n) return;
	if(s + 2*(n-v)/r &gt; ans) return;
	
	if(!dep)
	{
		if(v == n)
			ans=s;
		return;
	}
	
	for(int i=r-1;i&gt;=dep;i--)
	{
		if(dep == m) s=i*i;
		for(int j=h-1;j&gt;=dep;j--)
			dfs(dep-1,s+2*i*j,v+i*i*j,i,j);
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=m;i++)
	{
		minv[i]=minv[i-1]+i*i*i;
		mins[i]=mins[i-1]+2*i*i;
	}
	
	ans=INF;
	dfs(m,0,0,100,10000);
	
	if(ans == INF) cout&lt;&lt;0&lt;&lt;endl;
	else cout&lt;&lt;ans&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/Aizu-0525">Aizu - 0525</a></p>
<ul>
<li>行数比较小，先不考虑对列的操作，将行数的所有情况举出来最多2^10种情况。</li>
<li>对于已经固定了行操作后，这种情况下对列的最优操作就是对每一列，如果此时1比0多就不变，不然就反转。</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;sstream&gt;
#include&lt;set&gt;
using namespace std;
int dx[]={-1,0,1,0},dy[]={0,1,0,-1};
const int N=10010;
int g[15][N];
int n,m;
int ans;

void dfs(int u)
{
   if(u == n)
   {
       int sum=0;
       for(int j=0;j&lt;m;j++)
       {
           int tot=0;
           for(int i=0;i&lt;n;i++)
               if(g[i][j] == 1) tot++;
           sum+=max(tot,n-tot);
       }
       ans=max(ans,sum);
       return;
   }

   dfs(u+1);//not reverse

   for(int i=0;i&lt;m;i++) g[u][i]=!g[u][i];
   dfs(u+1);
   for(int i=0;i&lt;m;i++) g[u][i]=!g[u][i];
}

int main()
{
   while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
   {
       if(!n &amp;&amp; !m) break;

       for(int i=0;i&lt;n;i++)
           for(int j=0;j&lt;m;j++)
               cin&gt;&gt;g[i][j];

       ans=0;
       dfs(0);

       cout&lt;&lt;ans&lt;&lt;endl;
   }
  // system(&quot;pause&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优先队列]]></title>
        <id>https://caifxh.github.io/post/you-xian-dui-lie/</id>
        <link href="https://caifxh.github.io/post/you-xian-dui-lie/">
        </link>
        <updated>2020-05-05T15:08:37.000Z</updated>
        <content type="html"><![CDATA[<h4 id="优先队列">优先队列</h4>
<p><a href="https://vjudge.net/problem/HDU-4006">hdu4006</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/05/9969_45c264ba8e-%E5%9B%BE%E7%89%871.png" alt="图片1.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,k;

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k))
	{
		priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; heap;	
		for(int i=1;i&lt;=n;i++)
		{
			char op[2];
			scanf(&quot;%s&quot;,op);
			if(*op == 'I')
			{
				int x;
				scanf(&quot;%d&quot;,&amp;x);
				if(heap.size() &lt; k)
					heap.push(x);
				else if(heap.top() &lt; x)
					heap.pop(),heap.push(x);
			}
			else 
				printf(&quot;%d\n&quot;,heap.top());
		}
	}
	return 0;
 } 
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2833">poj2833</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/05/9969_391cc90c8e-8.png" alt="8.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
int n,n1,n2;

int main()
{
	while(~scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;n2,&amp;n))
	{
		if(!n1 &amp;&amp; !n2 &amp;&amp; !n) break;
		
		priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; heap1;
		priority_queue&lt;int&gt; heap2;
		
		LL sum=0;
		for(int i=0;i&lt;n;i++)
		{
			int x;
			scanf(&quot;%d&quot;,&amp;x);
			sum+=x;
			
			if(heap1.size() &lt; n1) heap1.push(x);
			else if(heap1.top() &lt; x)
				heap1.pop(),heap1.push(x);
			
			if(heap2.size() &lt; n2) heap2.push(x);
			else if(heap2.top() &gt; x)
				heap2.pop(),heap2.push(x);
		}
		while(!heap1.empty()) sum-=heap1.top(),heap1.pop();
		while(!heap2.empty()) sum-=heap2.top(),heap2.pop();
		
		printf(&quot;%.6f\n&quot;,(double)sum/(n-n1-n2));
	}
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2431">poj2431</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/05/9969_ca5052fa8e-9.PNG" alt="9.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int N=10010;
typedef pair&lt;int,int&gt; PII;
PII sta[N];
int n,L,P;

int main()
{
	cin&gt;&gt;n;
	
	for(int i=0;i&lt;n;i++)
	cin&gt;&gt;sta[i].first&gt;&gt;sta[i].second;

	cin&gt;&gt;L&gt;&gt;P;
	
	sort(sta,sta+n,greater&lt;PII&gt;());
	n++;
	sta[n-1]={0,0};
	
	int res=0;
	int oil=P;
	int last=L;
	priority_queue&lt;int&gt; heap;
	bool flag=true;
	for(int i=0;i&lt;n;i++)
	{
		oil-=last-sta[i].first;	
		//cout&lt;&lt;last-sta[i].first&lt;&lt;endl;
		last=sta[i].first;
	
		while(oil &lt; 0)
		{
			if(heap.empty())
			{
				flag=false;
				break;
			}
			int t=heap.top();
			heap.pop();
			res++;
			oil+=t;
		}
		
		if(!flag) break;
		
		heap.push(sta[i].second);
	}
	if(!flag) res=-1;
	printf(&quot;%d\n&quot;,res);

	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3614">poj3614</a><br>
把每头奶牛按照minSPF[i]的值从小到大排序，把防晒霜也按照SPF[i]的值从小到大排序，加一个优先队列，让maxSPF[i]小的奶牛先使用防晒霜，因为maxSPF大的奶牛有更大的选择空间。用一个最小堆q维护maxSPF的最小值，可以高效解决问题。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int N=2510;
typedef pair&lt;int,int&gt; PII;
PII cow[N];
PII bottle[N];
int n,m;

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=0;i&lt;n;i++) cin&gt;&gt;cow[i].first&gt;&gt;cow[i].second;
	
	for(int i=0;i&lt;m;i++) cin&gt;&gt;bottle[i].first&gt;&gt;bottle[i].second;

	sort(cow,cow+n);
	sort(bottle,bottle+m);
	
	int res=0;
	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; heap;
	for(int i=0,j=0;i&lt;m;i++)
	{
		while(j&lt;n &amp;&amp; cow[j].first &lt;= bottle[i].first)
		{
			heap.push(cow[j].second);
			j++;
		}
		
		while(!heap.empty() &amp;&amp; bottle[i].second)
		{
			int spf=heap.top();
			heap.pop();
			if(spf &gt;= bottle[i].first)
			{
				res++;
				bottle[i].second--;
			}
		}
	}
	
	cout&lt;&lt;res&lt;&lt;endl;
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL]]></title>
        <id>https://caifxh.github.io/post/stl/</id>
        <link href="https://caifxh.github.io/post/stl/">
        </link>
        <updated>2020-04-30T00:30:24.000Z</updated>
        <content type="html"><![CDATA[<h4 id="stl的lower_bound和upper_bound">STL的lower_bound()和upper_bound()</h4>
<p>如果只是简单地找x或x附近的数，就用STL的lower_bound()和upper_bound()函数。有以下情况：<br>
（1）查找第一个大于x的元素的位置：upper_bound()。代码例如：</p>
<center>pos = upper_bound(a, a+n, test) - a;</center>
（2）查找第一个等于或者大于x的元素：lower_bound()。
（3）查找第一个与x相等的元素：lower_bound()且 = x。
（4）查找最后一个与x相等的元素：upper_bound()的前一个且 = x。
（5）查找最后一个等于或者小于x的元素：upper_bound()的前一个。
（6）查找最后一个小于x的元素：lower_bound()的前一个。
（7）单调序列中数x的个数：upper_bound() - lower_bound()。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #636 (Div. 3)]]></title>
        <id>https://caifxh.github.io/post/codeforces-round-636-div-3/</id>
        <link href="https://caifxh.github.io/post/codeforces-round-636-div-3/">
        </link>
        <updated>2020-04-23T09:46:47.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://codeforces.ml/contest/1343/problem/C">C. Alternating Subsequence</a><br>
首先，让我们通过包含由具有相同符号的数字组成的数组的分段来提取最大值。 例如，如果数组为[1,1,2，-1，-5,2,1，-3]，则这些段为[1,1,2]，[-1，-5]，[2， 1]和[−3]。 我们可以使用任何类似于“两个指针”的算法来做到这一点。 这些段的数量是交替子序列的最大可能长度，因为我们只能从每个块中提取一个元素。 当我们想最大化总和时，我们需要从每个块中取最大元素。<br>
时间复杂度：O（n）</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
const int N=2e5+10;
int a[N];
int n;

int sgn(int x)
{
	if(x&gt;0) return 1;
	return 0;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		int n;
		cin&gt;&gt;n;
		for(int i=1;i&lt;=n;i++)
			cin&gt;&gt;a[i];
		
		LL sum=0;
		for(int i=1;i&lt;=n;i++)
		{
			int cur=a[i];
			int j=i;
			while(j&lt;=n &amp;&amp; sgn(a[i]) == sgn(a[j]))
			{
				cur=max(cur,a[j]);
				j++;
			}
			sum+=cur;
			i=j-1;
		}
		cout&lt;&lt;sum&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="https://codeforces.ml/contest/1343/problem/D">D - Constant Palindrome Sum</a><br>
差分数组维护取某个值为定值时所需要的最少操作次数</p>
<p>分类讨论得到：</p>
<p>一、如果定值 x 在 [2,minn] 之间，即使将较大的数更改为1后，和也是大于x，说明此时这两个数都需要更改，所以这段区间的操作数+2</p>
<p>二、如果定值 x 在 [maxn+k+1,2*k]之间，即使将较小的数更改为k后，和也是小于x，说明此时这两个数都需要更改，所以这段区间的操作数+2</p>
<p>三、如果定值 x 在 [minn+1,maxn+k] 之间且不等于 sum，能够做到只改变其中一个数就使得和等于x，所以这个范围内操作数+1</p>
<p>四、特殊处理，如果定值 x 等于 sum，不需要更改任何一个数，所以这个点的操作数不需要增加</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=2e5+10;
int a[N],b[N*2];
int n,k;

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		memset(b,0,sizeof b);
		
		scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
		
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		
		for(int i=1;i&lt;=n/2;i++)
		{
			int maxv=max(a[i],a[n-i+1]);
			int minv=min(a[i],a[n-i+1]);
			
			int sum=a[i]+a[n-i+1];
			
			b[2]+=2;
			b[minv+1]-=2;
			
			b[maxv+k+1]+=2;
			b[2*k+1]-=2;
			
			b[minv+1]++;
			b[maxv+k+1]--;
			
			b[sum]--;
			b[sum+1]++;
		}
		
		int ans=n;
		for(int i=2;i&lt;=2*k;i++)
		{
			b[i]+=b[i-1];
			ans=min(ans,b[i]);
		}
		
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="https://codeforces.ml/contest/1343/problem/E">E. Weights Distributing</a><br>
如果我们以最优方式分配成本，那么这对路径（a→b和b→c）看起来就像是一条直线路径，不会两次访问相同的顶点，或者就像是三个具有一个交点x的直线路径。 第一种情况基本上是第二种情况的子情况（具有相交点a，b或c）。 因此，如果我们固定交点x，则这两个路径（a→b和b→c）变为四个路径（a→x，x→b，b→x和x→c）。 我们可以注意到，我们表示的每条路径都应该是最短的路径，因为如果不是最短的路径，那么我们将使用一些我们无法使用的价格。<br>
dist（a，x）+ dist（b，x）+ dist（c，x）最小成本。 现在，我们希望以某种方式在这三个路径之间分配这些成本。 我们可以看到从b到x的路径被使用了两次，因此沿这部分分配最小的成本是最优的。 因此，令prefi为前i个最小费用的总和（只是排序数组p上的前缀总和）。 那么对于交点x，答案是pref[dist（b，x）]+ pref[dist（a，x）+ dist（b，x）+ dist（c，x）]（如果dist（a，x）+ dist（b，x ）+ dist（c，x）≤m）。<br>
时间复杂度：O（mlogm）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
const int N=2e5+10,INF=0x3f3f3f3f;
vector&lt;int&gt; g[N];
int p[N];
LL sum[N];
int dist[3][N];
int n,m,a,b,c;

void bfs(int u,int type)
{
	memset(dist[type],0x3f,sizeof dist[type]);
	dist[type][u]=0;
	queue&lt;int&gt; q;
	q.push(u);

	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		for(int i=0;i&lt;g[t].size();i++)
		{
			int j=g[t][i];
			if(dist[type][j] == INF)
			{
				dist[type][j]=dist[type][t]+1;
				q.push(j);
			}	
		}
	}
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;c;
		
		for(int i=1;i&lt;=n;i++)	
			g[i].clear();
			
		for(int i=1;i&lt;=m;i++)
			scanf(&quot;%d&quot;,&amp;p[i]);
		sort(p+1,p+m+1);
		
		for(int i=1;i&lt;=m;i++)
			sum[i]=sum[i-1]+p[i];
		
		for(int i=0;i&lt;m;i++)
		{
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			g[a].push_back(b);
			g[b].push_back(a);
		}
		
		bfs(a,0);
		bfs(b,1);
		bfs(c,2);
		
		LL ans=4e18;
		for(int i=1;i&lt;=n;i++)
		{
			int t=dist[0][i]+dist[1][i]+dist[2][i];
			if(t &lt;= m) ans=min(ans,sum[t]+sum[dist[1][i]]);
		}
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进阶指南第一章]]></title>
        <id>https://caifxh.github.io/post/jin-jie-zhi-nan-di-yi-zhang/</id>
        <link href="https://caifxh.github.io/post/jin-jie-zhi-nan-di-yi-zhang/">
        </link>
        <updated>2020-04-17T13:50:13.000Z</updated>
        <content type="html"><![CDATA[<h4 id="递推和递归">递推和递归</h4>
<p><a href="https://www.acwing.com/problem/content/description/97/">acwing95</a></p>
<ul>
<li>每个位置至多只会被点击一次</li>
<li>若固定了第一行，则满足题意的点击方案至多只有一种。原因：当第i行某一位为1时，若前i行已被固定，只能点击第i+1行该位置上的数字才能使dii行的这一位变成0.从上到下使用归纳法可得上述结论。</li>
<li>点击的先后顺序不影响最终结果</li>
</ul>
<p>于是，我们不妨先考虑第一行如何点击。在枚举第一行的点击方案后，就可以认为第一行固定不动，在考虑2~5行如何点击</p>
<p>若到达第n行是不全为1，说明这种点击方式不合法。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=6,INF=0x3f3f3f3f;
int g[N][N];
int tmp[N][N];
int dx[]={0,-1,0,1,0},dy[]={0,0,-1,0,1};

void modify(int x,int y)
{
	for(int i=0;i&lt;5;i++)
	{
		int a=x+dx[i],b=y+dy[i];
		if(a&gt;=0 &amp;&amp; a&lt;5 &amp;&amp; b&gt;=0 &amp;&amp; b&lt;5)
		    tmp[a][b]^=1;
	}
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		for(int i=0;i&lt;5;i++)
			for(int j=0;j&lt;5;j++)
			{
			    char c;
			    cin&gt;&gt;c;
			    g[i][j]=c-'0';
			}

		int ans=INF;
		int cnt=0;
		for(int s=0;s&lt;1&lt;&lt;5;s++)//枚举第一行点击方案
		{
			cnt=0;
			memcpy(tmp,g,sizeof g);
			for(int i=0;i&lt;5;i++)
			    if(s&gt;&gt;i &amp; 1) 
			    {
			        modify(0,i);
			        cnt++;
			    }
  
			for(int i=0;i&lt;4;i++)
				for(int j=0;j&lt;5;j++)
					if(!tmp[i][j])
					{
						modify(i+1,j);
						cnt++;
					}
			
			bool flag=true;
		    for(int i=0;i&lt;5;i++)
		        if(!tmp[4][i])   
		            flag=false;
		
			if(flag) ans=min(ans,cnt);
		}
		
		if(ans &gt; 6) cout&lt;&lt;-1&lt;&lt;endl;
	    else cout&lt;&lt;ans&lt;&lt;endl;
	}

	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/98/">aciwng96</a></p>
<ul>
<li>我们先考虑三个塔的汉诺塔问题，最优秀方案：必然是先挪走n-1个圆盘，然后再挪走圆盘N，<br>
因此可以得出递推方程也就是 d[i]=d[i-1]*2+1;</li>
<li>之所以要乘以2，是因为第一次挪到第二个塔，然后还要挪移回到第三个塔，下面四个塔也是这样的<br>
接着考虑四塔问题，我们可以这么思考，首先挪走j个塔，也就是有四个塔可以选择，然后再挪走剩下的n-j个塔，此时有三个塔可以选择，因此这就是我们的状态转移方程：f[i]=min(f[i],f[j]*2+d[n-j]);//i表示当前一共有几个塔，也就是上文所说的n</li>
</ul>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int d[15],f[15];

int main()
{
    for (int i=1;i&lt;=12;i++)
        d[i]=2*d[i-1]+1;
        
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    
    for (int i=1;i&lt;=12;i++)
        for (int j=0;j&lt;i;j++)
            f[i]=min(f[i],f[j]+f[j]+d[i-j]);
    
    for (int i=1;i&lt;=12;i++)
        cout&lt;&lt;f[i]&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/100/">acwing98</a><br>
1.绕原点顺时针旋转θ角度的变换矩阵</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \
 at position 34: … cosθ &amp; sinθ \\\̲
̲   -sinθ &amp; cosθ…'> \begin{matrix}
   cosθ &amp; sinθ \\\
   -sinθ &amp; cosθ  \\\
  \end{matrix} 
</p>
<p>2.为方便计算，下标从1开始</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;LL,LL&gt; PLL;
int n;
LL a,b;

PLL calc(int n,LL m)
{
	if(!n) return {0,0};
	LL len=1ll&lt;&lt;(n-1),cnt=1ll&lt;&lt;(2*n-2);
	PLL pos=calc(n-1,m%cnt);
	LL x=pos.first,y=pos.second;
	LL z=m/cnt;
	if(z == 0) return {y,x};
	else if(z == 1) return {x,y+len};
	else if(z == 2) return {x+len,y+len};
	else return {2*len-1-y,len-1-x};
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;
		PLL pa=calc(n,a-1);
		PLL pb=calc(n,b-1);

		double dx=pa.first-pb.first,dy=pa.second-pb.second;
		printf(&quot;%.0f\n&quot;,round(sqrt(dx*dx+dy*dy)*10));
	}
	return 0;
}
</code></pre>
<h4 id="差分">差分</h4>
<p><a href="https://www.acwing.com/problem/content/102/">acwing100</a><br>
因为是区间整体加减1，所以我们很自然的就可以想到用差分求解。</p>
<p>这道题可以看做求出原序列的差分之后，将 S[2...n] 全部变为0所需的最少的步数和可以使 S[1] 变为多少种不同的数。</p>
<p>求出a的差分序列b，其中b1 = a1,b(i) = a(i) - a(i - 1) (2 &lt;= i &lt;= n)。令b(n + 1) = 0，题目对序列a的操作，相当于每次可以选出b1,b2…b(n + 1)中的任意两个数，一个加1，另外一个减一。目标是把b2,b3,…bn变为全0。最终得到的数列a就是由 n 个 b1 构成的</p>
<p>任选两个数的方法可分为四类<br>
1、2 &lt;= i , j &lt;=n（优先）<br>
2、i = 1, 2 &lt;=j &lt;=n<br>
3、2 &lt;= i &lt;= n , j = n + 1<br>
4、i = 1, j = n + 1（没有意义）</p>
<p>设b2,b3....bn中正数总和为p，负数总和的绝对值为q。首先以正负数匹配的方式尽量执行1类操作，可执行min(p,q)次。剩余|p - q|个为匹对，每个可以选与b1或b(n + 1)匹配，即执行2 或 3 类操作，共需|p - q|次</p>
<p>综上所诉，最少操作次数为min(p,q) + |p - q|。根据|p - q|次第2、3类操作的选择分配情况，能产生|p - q| + 1中不同的b1的值，即最终得到的序列a可能有|p - q| + 1 种</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int N=500010;
int a[N],b[N];
int n;

int main()
{
	cin&gt;&gt;n;
	
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	
	for(int i=1;i&lt;=n;i++) b[i]=a[i]-a[i-1];
	
    LL pos=0,neg=0;
	for(int i=2;i&lt;=n;i++)
		if(b[i] &gt; 0) pos+=b[i];
		else neg-=b[i];
		
	cout&lt;&lt;min(pos,neg)+abs(pos-neg)&lt;&lt;endl;
	cout&lt;&lt;abs(pos-neg)+1&lt;&lt;endl;
	
	return 0; 
 } 
</code></pre>
<h4 id="二分">二分</h4>
<p>通过二分给定一个平均数，如果把数列中每个数都减去平均数得到数组B[]，就转换为判定“是否存在一个长度不小于L的子段，子段和非负”</p>
<p>上述问题中，需要对B[]数组进行前缀和sun[],[i,j]表示长度为L的区间，minv表示sum[i]的最小值（该最小值的位置和 j 位置的距离一定大于等于L），通过j枚举整个数组B[]，若sum[j] - minv &gt;= 0 则表示存在该平均数使得该平均数满足题目条件，返回ture，否则返回false</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int a[N];
double s[N];
int n,m;

bool check(double mid)
{
	for(int i=1;i&lt;=n;i++)
		s[i]=s[i-1]+a[i]-mid;
	
	double val=1e9;
	for(int i=m;i&lt;=n;i++)
	{
		val=min(val,s[i-m]);
		if(s[i] - val &gt;= 0) return true;
	}
	return false;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	double l=0,r=0;
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;a[i],r=max(r,(double)a[i]);
		
	while(r-l&gt;1e-5)
	{
		double mid=(l+r)/2;
		if(check(mid)) l=mid;
		else r=mid;
	}
	
	printf(&quot;%d\n&quot;,int(r*1000));
	
	return 0;
}
</code></pre>
<h4 id="离散化">离散化</h4>
<p><a href="https://www.acwing.com/problem/content/105/">acwing103</a></p>
<p>m 部电影和 n 个人最多涉及 2<em>m + n 种语言，我们把所有的电影和人涉及的语言放进一个数组，排序并离散化， 用一个 1~2</em>m+n 之间的整数代替每种语言。此时我们就可以用数组直接统计会上述每种语言的人的数量，从而选择满足题目要求的电影。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=2e5+10;
int a[N],b[N],c[N];
int cma[3*N],tot;
int cnt[3*N];
int n,m;

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		cma[tot++]=a[i];
	}
	
	cin&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;b[i]);
		cma[tot++]=b[i];
	}
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;c[i]);
		cma[tot++]=c[i];
	}
	
	sort(cma,cma+tot);
	int len=unique(cma,cma+tot)-cma;
	
	
	for(int i=1;i&lt;=n;i++)
	{
		int ta=lower_bound(cma,cma+len,a[i])-cma;
		cnt[ta]++;
	}
	
	int res1=-1,res2=-1,ans=0;
	for(int i=1;i&lt;=m;i++)
	{
		int tb=lower_bound(cma,cma+len,b[i])-cma;
		int tc=lower_bound(cma,cma+len,c[i])-cma;
		if(cnt[tb] &gt; res1)
			res1=cnt[tb],res2=cnt[tc],ans=i;
		else if(cnt[tb] == res1 &amp;&amp; cnt[tc] &gt; res2)
			res2=cnt[tc],ans=i;
	}
	
	cout&lt;&lt;ans&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<h4 id="中位数">中位数</h4>
<p>均分纸牌：<a href="https://www.luogu.com.cn/problem/P1031">P1031</a></p>
<ul>
<li>第一堆牌相差的牌只能由第二堆牌承担（给予或索要）</li>
<li>第一堆牌都达到要求了又去动它干嘛，可以直接删除第一堆牌</li>
<li>第二堆牌变成了第一堆牌</li>
<li>重复上述操作</li>
<li>如果当前牌没操作就已经达标了跳过</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=110;
int a[N];
int n;

int main()
{
	cin&gt;&gt;n;
	
	int sum=0;
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]),sum+=a[i];
	
	int avg=sum/n;
	int ans=0;
	for(int i=1;i&lt;=n;i++)
		if(abs(a[i]-avg))
			a[i+1]+=a[i]-avg,ans++;
	
	cout&lt;&lt;ans&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p>动态维护中位数：对顶堆<br>
设当前序列长度为M<br>
1.序列中从小到大排名为1~M/2的整数存储在大根堆中<br>
2.序列中从小到大排名为M/2+1~M的整数存储在小根堆中</p>
<p>每次读入一个数值x，若x比中位数小，则插入大根堆，否则插入小根堆，在插入之后检查并维护上述性质即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,k;

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		cin&gt;&gt;k&gt;&gt;n;
		cout&lt;&lt;k&lt;&lt;' '&lt;&lt;(n+1)/2&lt;&lt;endl;
		
		priority_queue&lt;int&gt; down;
		priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; up;
		
		int cnt=0;
		for(int i=1;i&lt;=n;i++)
		{
			int x;
			scanf(&quot;%d&quot;,&amp;x);
			if(down.empty() || x&lt;=down.top()) down.push(x);
			else up.push(x);
			
			if(down.size() &gt; up.size()+1) up.push(down.top()),down.pop();
			if(up.size() &gt; down.size()) down.push(up.top()),up.pop();
			
			if(i % 2)
			{
				cout&lt;&lt;down.top()&lt;&lt;' ';
				if(++cnt % 10 == 0) puts(&quot;&quot;);
			}
		}
		if(cnt % 10) puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>
<h4 id="第k大数">第k大数</h4>
<ul>
<li>从大到小进行快速排序算法的思想是：在每一层递归中，随机选取一个数为基准，把比他大的数交换到左半段，把其余的数和基准值自身一起作为右半段，然后继续递归对左右两边分别进行排序，</li>
<li>实际上在每次选取基准值后，我们可以统计处大于基准值的数的数量cnt，如果k&lt;=cnt，我们就在左半段（比基准值大的数中）寻找第k个数，如果k&gt;=cnt，我们就在有半段（小于或等于基准值的数中）寻找第k-cnt大数。</li>
</ul>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int q[N];

int quick_sort(int q[],int l,int r,int k)
{
    if(l&gt;=r)
        return q[l];
    int i=l-1,j=r+1;
    int x=q[l+r&gt;&gt;1];
    while(i&lt;j)
    {
        do i++;while(q[i]&lt;x);
        do j--;while(q[j]&gt;x);
        if(i&lt;j)
            swap(q[i],q[j]);
    }
    int s=j-l+1;
    if(k&lt;=s)
        quick_sort(q,l,j,k);
    else 
        quick_sort(q,j+1,r,k-s);
}

int main()
{
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;q[i];
    
    cout&lt;&lt;quick_sort(q,0,n-1,k)&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<h4 id="逆序对">逆序对</h4>
<p>合并两个有序序列a[i<sub>mid]与a[mid+1</sub>r],可以采用两个指针i与j分别对二者进行扫描的方式，不断比较两个指针所指向的数值a[i]和a[j]的大小，将小的那个加入排序的结果数组中。若小的那个是a[j],则a[i~mid]都比a[j]大，它们都会与a[j]构成逆序对，可统计到答案中。</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int q[N],temp[N];
typedef long long LL;

LL merge_sort(int l,int r)
{
    if(l&gt;=r)
        return 0;
    int mid=l+r&gt;&gt;1;
    LL res=merge_sort(l,mid)+merge_sort(mid+1,r);
    
    int i=l,j=mid+1,k=0;
    
    while(i&lt;=mid  &amp;&amp; j&lt;=r)
    {
        if(q[i]&lt;=q[j])
            temp[k++]=q[i++];
        else
        {
            temp[k++]=q[j++];
            res+=mid-i+1;
        }
    }
    while (i &lt;= mid) temp[k ++ ] = q[i ++ ];
    while (j &lt;= r) temp[k ++ ] = q[j ++ ];
    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = temp[j];
    return res;
}

int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;q[i];
        
    cout&lt;&lt;merge_sort(0,n-1)&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="习题">习题</h4>
<p><a href="https://www.acwing.com/problem/content/118/">acwing116</a><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi><mi mathvariant="normal">解</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">，</mi><mn>396</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">DFS解法，396 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">解</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mord">9</span><span class="mord">6</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=5,M=20;
int g[N][N];
int x[M],y[M];
int ansx[M],ansy[M];
int ans=M;

bool check()
{
	for(int i=0;i&lt;4;i++)
		for(int j=0;j&lt;4;j++)
			if(g[i][j] == 1) return false;
	return true;
}

void turn(int u)
{
	int x=u/4;
	int y=u%4;
	
	for(int i=0;i&lt;4;i++)
	{
		g[x][i]^=1;
		g[i][y]^=1;
	}
	g[x][y]^=1;
}

void dfs(int u,int cnt)// 遍历到第 u 个, 翻转了 cnt个
{
	if(check())
	{
		if(ans &gt; cnt)
		{
			ans=cnt;
			for(int i=0;i&lt;cnt;i++)
			{
				ansx[i]=x[i];
				ansy[i]=y[i];
			}
		}
		return;
	}
	if(u &gt; 15) return;
	
	dfs(u+1,cnt);
	
	turn(u);
	x[cnt]=u/4+1;
	y[cnt]=u%4+1;
	dfs(u+1,cnt+1);
	turn(u);//还原现场
}

int main()
{
	for(int i=0;i&lt;4;i++)
		for(int j=0;j&lt;4;j++)
		{
			char c;
			cin&gt;&gt;c;
			if(c == '+') g[i][j]=1;
			else g[i][j]=0;
		}
		
	dfs(0,0);
	
	cout&lt;&lt;ans&lt;&lt;endl;
	
	for(int i=0;i&lt;ans;i++)
		cout&lt;&lt;ansx[i]&lt;&lt;' '&lt;&lt;ansy[i]&lt;&lt;endl;
		
	return 0;
}
</code></pre>
<p>对一个开关进行操作n次，如果n为偶数，那么这个开关以及同行、同列的开关状态都不发生改变，等价于没有操作；如果n为奇数，那么这个开关以及同行同列的开关状态全都发生改变，等价于只操作了一次。</p>
<p>要想使所有开关状态全部打开（全部是-），就要把所有+变成-，所有-不改变。我们要做的就是找到一种“公式”，策略，使得不改变已经关闭开关状态的情况下，把开着的开关关闭。</p>
<p>我们找到的策略就是：把开关本身以及其同一行同一列的开关（总共7个）都进行一次操作，结果是，开关本身状态改变了7次，开关同一行、同一列的开关状态改变了4次，其他开关状态改变了2次。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/04/29/9969_56e9980289-59.PNG" alt="59.PNG" loading="lazy"></figure>
<p>如开关坐标为第二行第三列的（2，3），那么按照上述策略（把开关本身以及其同一行同一列的开关都进行一次操作），结果分析如下：</p>
<p>对于黄色部分的开关，只有与此黄色开关同一行和同一列的两个红色开关操作时，此黄色开关的状态才会发生改变，因此所有黄色部分状态改变次数为2，相当于0次</p>
<p>对于红色部分的开关，只有与此红色开关同一列或同一列的开关操作时，此红色开关状态才会发生改变，一行或者一列有4个开关，因此红色部分开关状态改变次数为4，相当于0次</p>
<p>对于最原始的那个黑色开关，所有红色开关操作时，它的状态改变一次，然后黑色开关自己操作一次，因此黑色开关状态改变7次，相当于改变1次。</p>
<p>总结上述分析可以得出结论，把开关本身以及其同一行同一列的开关都进行一次操作，最终结果是只有开关本身状态发生变化，其他所有开关状态都不变。</p>
<p>策略找到之后，那我们就想，如果对于所有打开着的开关都进行一次上述策略，那么肯定是能把冰箱关闭的，下面我们要做的就是把一些无用的，重复的操作去掉即可。</p>
<p>1 2 1 1<br>
0 2 0 0<br>
0 2 0 0<br>
1 2 1 1<br>
对于样例中的每一个+开关，进行一次策略，记录数组所记录的每一个开关操作的次数变化如上所示。那么在最终得到的数组中可以看出，有些开关操作了偶数次，有些操作了奇数次。操作了偶数次的开关就是上面所说的无用的，重复的操作，直接去掉，留下奇数次的就最终的答案。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">性</mi><mi mathvariant="normal">质</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">，</mi><mn>112</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">性质法，112 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">质</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=5,M=20;
char map[N][N];
int ansx[M],ansy[M];
int cnt[N][N];
int ans;


void turn(int x,int y)
{
	for(int i=0;i&lt;4;i++)
	{
		cnt[x][i]++;
		cnt[i][y]++;
	}
	cnt[x][y]--;
}

int main()
{
	for(int i=0;i&lt;4;i++)
		for(int j=0;j&lt;4;j++)
		{
			char c;
			cin&gt;&gt;c;
			map[i][j]=c;
		}
	
	for(int i=0;i&lt;4;i++)
		for(int j=0;j&lt;4;j++)
		{
			if(map[i][j] == '+') turn(i,j);
		}
	
	for(int i=0;i&lt;4;i++)
		for(int j=0;j&lt;4;j++)
			if(cnt[i][j] &amp; 1)
			{
			    ans++;
				ansx[ans]=i+1;
				ansy[ans]=j+1;
			}
	
	cout&lt;&lt;ans&lt;&lt;endl;
	
	for(int i=1;i&lt;=ans;i++)
		cout&lt;&lt;ansx[i]&lt;&lt;' '&lt;&lt;ansy[i]&lt;&lt;endl;
		
	return 0;
}
</code></pre>
<h4 id="平面最近点对分治">平面最近点对（分治）</h4>
<p>方法1：穷举<br>
1）算法描述：已知集合S中有n个点，一共可以组成n(n-1)/2对点对，暴力法就是对这n(n-1)/2对点对逐对进行距离计算，通过循环求得点集中的最近点对<br>
2）算法时间复杂度：算法一共要执行 n(n-1)/2次循环，因此算法复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</p>
<p>方法2：分治</p>
<ol>
<li>把它分成两个或多个更小的问题；</li>
<li>分别解决每个小问题；</li>
<li>把各小问题的解答组合起来，即可得到原问题的解答。小问题通常与原问题相似，可以递归地使用分而治之策略来解决</li>
</ol>
<p>将所给平面上n个点的集合S分成两个子集S1和S2，每个子集中约有n/2个点。然后在每个子集中递归地求最接近的点对。在这里，一个关键的问题是如何实现分治法中的合并步骤，即由S1和S2的最接近点对，如何求得原集合S中的最接近点对。如果这两个点分别在S1和S2中，问题就变得复杂了。</p>
<p>为了使问题变得简单，首先考虑一维的情形。此时，S中的n个点退化为x轴上的n个实数x1，x2，...，xn。最接近点对即为这n个实数中相差最小的两个实数。显然可以先将点排好序，然后线性扫描就可以了。但我们为了便于推广到二维的情形，尝试用分治法解决这个问题。</p>
<p>假设我们用m点将S分为S1和S2两个集合，这样一来，对于所有的p(S1中的点)和q(S2中的点)，有p&lt;q。<br>
递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设<br>
d = min{ |p1-p2| , |q1-q2| }</p>
<p>由此易知，S中最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{q3,p3}，如下图所示。<br>
<img src="http://dl2.iteye.com/upload/attachment/0063/9665/dd5564a9-08db-3810-aef2-cbc013d152c5.png" alt="" loading="lazy"></p>
<p>如果最接近点对是{q3,p3}，即|p3-q3|&lt;d，则p3和q3两者与m的距离都不超过d，且在区间(m-d,]m和(m,m+d]各有且仅有一个点。这样，就可以在线性时间内实现合并。<br>
此时，一维情形下的最近点对时间复杂度为O(nlogn)。</p>
<p>在二维的情况下:<br>
我们仿照一维的情况先把所有点按照x(横坐标)从左到右升序排列.<br>
<img src="https://img-blog.csdn.net/20141122234553999" alt="" loading="lazy"><br>
以X横坐标中间的点作为分界线.将平面的点分成左边和右边,以上图为例,分为左边5个右边5个.<br>
然后找到左边的点中最近点对的距离d1,和右边最近点对的距离d2。<br>
令d=min{d1,d2}.那么d是当前整个平面的最近点对的距离吗?<br>
答案不是!!</p>
<p>当前的d1,d2都是两边各自的点的最近距离,但是没有考虑到两边的点相互配对的情况,即是点对一个在左边区域,一个在右边区域.如果我们这个时候把两边相互配对的所有情况全部罗列出来那么时间复杂度就变为第一种方法的O(n2).</p>
<p>这个时候我们便可以用上面找到的d来限制配对.即是明显超过d的两点不需要配对.如下：<br>
<img src="https://img-blog.csdn.net/20141123002457437" alt="" loading="lazy"></p>
<p>那么在范围内的只有三个点,也就是说只有这个三个点相互配对的距离才可能比d小.那么再按照方法一一样在这些点中找到最短距离再跟d去比较.小的就是当前整个平面中所考虑的所有点中最近点对的距离。</p>
<p>然而在以上问题处理上,有一个问题尚未解决就是如何找到两边区域中的最近点对的距离d1,d2 ?<br>
我们可以发现在处理上面这个问题的时候，和最开始处理所有平面的点最近点距离的问题类似，只是点的数目减半了.<br>
那么我们可以递归以上问题.直到划分的区域中只有一个或者两个点.这样,该区域的最近点对距离就是无穷大或者该两点的距离。这也是递归终止的条件。</p>
<p>但是存在一个最坏情况，即通过左右两个区域计算得到的 dis距离来划分的第三区域可能包含集合所有的点，这时候进行遍历查找，时间复杂度仍然和 bruteforce方法相同，都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。因此需要对此进行深一步的考虑。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/04/29/9969_208e64a489-60.PNG" alt="60.PNG" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt; 
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define x first
#define y second
const int N=4e5+10;
const double INF=1e20;
typedef pair&lt;double,double&gt; PDD;
PDD p[N],temp[N];
int n;

bool cmp(PDD a,PDD b)
{
	if(a.y == b.y) return a.x &lt; b.x;
	return a.y &lt; b.y;
}

double dist(PDD a,PDD b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

double merge(int l,int r)
{
	double dis=INF;
	if(l == r)
		return dis;
	if(l+1 == r) 
		return dist(p[l],p[r]);
	
	int mid=l+r&gt;&gt;1;
	double d1=merge(l,mid);
	double d2=merge(mid+1,r);
	dis=min(d1,d2);
	
	int k=0;
	for(int i=l;i&lt;=r;i++)
		if(fabs(p[i].x-p[mid].x) &lt;= dis)
			temp[k++]=p[i];
	sort(temp,temp+k,cmp);
	for(int i=0;i&lt;k;i++)
		for(int j=i+1; j&lt;k &amp;&amp; temp[j].y-temp[i].y &lt; dis;j++)
			dis=min(dis,dist(temp[i],temp[j]));
	
	return dis;
	
}

int main()
{
	cin&gt;&gt;n;
	
	for(int i=0;i&lt;n;i++)
		cin&gt;&gt;p[i].x&gt;&gt;p[i].y;
	sort(p,p+n);
	
	printf(&quot;%.4f\n&quot;,merge(0,n-1));
}
</code></pre>
<p>归并排序优化：</p>
<pre><code>#include&lt;iostream&gt; 
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define x first
#define y second
const int N=2e5+10;
const double INF=1e20;
typedef pair&lt;double,double&gt; PDD;
PDD p[N],temp[N];
int n;

double dist(PDD a,PDD b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

double merge(int l,int r)
{
	if (l == r) return INF;

    int mid = l + r &gt;&gt; 1;
    double midx=p[mid].x;
    double dis = min(merge(l, mid), merge(mid + 1, r));

    int k = 0, i = l, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= r)
    {
        if (p[i].y &lt; p[j].y) temp[k ++ ] = p[i ++ ];
        else temp[k ++ ] = p[j ++ ];
    }
    while (i &lt;= mid) temp[k ++ ] = p[i ++ ];
    while (j &lt;= r) temp[k ++ ] = p[j ++ ];

    for (int i = l, j = 0; j&lt;k; i ++, j ++ ) p[i] = temp[j];
	
    k = 0;
    for (int i = l; i &lt;= r; i ++ )
        if(abs(p[i].x - midx) &lt;= dis)
            temp[k ++ ] = p[i];

    for (int i = 0; i &lt; k; i ++ )
        for (int j = i + 1; j &lt; k &amp;&amp; temp[j].y - temp[i].y &lt;= dis; j ++ )
            dis = min(dis, dist(temp[i], temp[j]));

    return dis;
}

int main()
{
	cin&gt;&gt;n;
	
	for(int i=0;i&lt;n;i++)
		cin&gt;&gt;p[i].x&gt;&gt;p[i].y;
	sort(p,p+n);
	
	printf(&quot;%.4f\n&quot;,merge(0,n-1));
	
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/122/">acwing120</a><br>
1、奇数位存在性<br>
整个序列中至多有一个位置的数字所占数量是奇数，所以如果存在奇数位，则整个数列的总和必然是奇数（奇数 + 偶数 = 奇数，偶数 + 偶数 = 偶数）。反之，若不存在奇数位，则一定是偶数。故只需判断数的总和的奇偶性即可。</p>
<p>2.O(n)时间求出区间sum[x]的数字个数<br>
设整个数列的最小位置为minn<br>
这里，我们枚举每一个等差数列（它的起点为s，终点为e，差为d）。若s&lt;=x，则两区间存在交集。<br>
则它与[minn,x]的共同区间为[s,min(e,x)]。那么此区间包含此数列的个数是⌊(min(e,x)−s)/d⌋+1。头尾的位置上都有数字，差为d，则数字的数量就是⌊(min(e,x)−s)/d⌋+1。</p>
<p>时间复杂度：O(nlogn)<br>
二分的时间为O(logn)<br>
，每次check()的时间为O(n)，故总的时间复杂度为O(nlogn)。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=200010;
struct Node
{
	int s,e,d;
}a[N];
int n;

LL check(int x)
{
	LL res=0;
	for(int i=0;i&lt;n;i++)
		if(x &gt;= a[i].s)
		{
			int e=min(x,a[i].e),s=a[i].s,d=a[i].d;
			res+=(e-s)/d+1;
		}
		
	return res;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		cin&gt;&gt;n;
		int l=0,r=0;
		for(int i=0;i&lt;n;i++)
		{
			int s,e,d;
			scanf(&quot;%d%d%d&quot;,&amp;s,&amp;e,&amp;d);
			a[i]={s,e,d};
			r=max(r,e);
		}
		
		while(l&lt;r)
		{
			int mid=l+r&gt;&gt;1;
			if(check(mid) &amp; 1) r=mid;
			else l=mid+1;
		}
		
		LL sum=check(l)-check(l-1);
		if(sum &amp; 1) printf(&quot;%d %lld\n&quot;,l,sum);
		else puts(&quot;There's no weakness.&quot;);
	}
	return 0;
}
</code></pre>
<h4 id="糖果传递">糖果传递</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/30/9969_5d01d8e08a-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/30/9969_f4bd502e8a-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/30/9969_07bf0a648a-3.PNG" alt="3.PNG" loading="lazy"></p>
<p>这时我们返回来看所求,要求传递价值最小，<br>
这就是说，要求最小化 ∣X1∣+∣X2∣+⋅⋅⋅+∣Xn∣<br>
而该式等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mn>1</mn><mo>−</mo><mn>0</mn><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mn>1</mn><mo>−</mo><mi>C</mi><mn>1</mn><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mn>1</mn><mo>−</mo><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X1-0|+|X1-C1|+...|X1-C_{n-1}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">1</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span><br>
要想最小化上式，我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>看成数轴上的一个个点，现在问题就转化成了找出一个点X1，使得她到各个Ci上的点的距离和最小。而这个点就是这n个点的中位数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1e6+10;
int a[N],c[N];
int n;

int main()
{
	cin&gt;&gt;n;
	
	LL sum=0;
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]),sum+=a[i];
	
	LL avg=sum/n;
	c[1]=0;
	for(int i=2;i&lt;=n;i++)
		c[i]=c[i-1]+a[i-1]-avg;
	sort(c+1,c+n+1);
	
	int midx=c[(n+1)/2];
	LL res=0;
	for(int i=1;i&lt;=n;i++)
		res+=abs(midx-c[i]);
	
	cout&lt;&lt;res&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<h4 id="士兵">士兵</h4>
<p>问题分析：<br>
通过适当的移动顺序和移动路线可以使得同一时刻不会有两名士兵站在同一点。<br>
题目要求移动的最少步数</p>
<p>题目要求可转化为求士兵站立的“最终位置”，即如何取“最终位置”使得士兵移动的步数最少</p>
<ol>
<li>Y轴方向上的考虑(找出Y0的值)<br>
设目标坐标为Y0，即n个士兵最终需要移动到的Y轴的坐标值为M<br>
n个士兵的Y轴坐标分别为： Y1，Y2 …… …… Yn<br>
移动步数S=|Y1-Y0|+|Y2-Y0|+ …… …… +|Yn-Y0|<br>
结论：Y0取所有Yi的中间值时可以使得S达到最小。</li>
</ol>
<p>1.对所有的Y轴坐标进行排序（O（nlogn））或者进行线性时间选择（O（n））然后取“中间”点的Y轴坐标值作为最佳位置Y0的值<br>
2.通过公式求出Y轴方向上移动的最优步数</p>
<ol start="2">
<li>X轴方向上的考虑<br>
（1）首先需要对所有士兵的X轴坐标值进行排序<br>
（2）然后，按从左至右的顺序依次移动到每个士兵所对应的“最终位置”（最优），所移动的步数总和就是X轴方向上需要移动的步数</li>
</ol>
<p>设排序后n个士兵在X轴坐标为： X1’，X2’ …… …… Xn’<br>
他们最终位置”的X轴坐标值为：X0，X0+1，X0+2 …… …… X0+（n-1），所处的最终位置与初始位置有着相同的大小关系，即<br>
X1，X2 …… …… Xn移动至最优位置时的相对大小关系不变。</p>
<p>则所求移动的步数 S=|X1’-X0| + |X2’-(X0+1)|+ …… +|Xn’-(X0+(n-1)|<br>
经过变形 S=|X1’–X0|+ |(X2’-1)–X0|+ …… +|(Xn’-(n-1))–X0|<br>
注意到公式的形式与Y轴方向上的考虑一样，同样是n个已知数分别减去一个待定数后取绝对值，然后求和</p>
<p>问题转化为：求出x1’,x2’-1,…Xn’-(n-1)的中位数，即求得X0值，最后算出最优解。</p>
<h4 id="中位数寻找的快速算法">中位数寻找的快速算法</h4>
<p>一般寻找中位数可以先将数组排序，按照次序将中间的数据作为中位数即可，其时间复杂度主要取决于排序算法的时间复杂度，利用快速排序可以将其控制为线性对数量级。</p>
<p>但是能否打破线性对数的限制呢？其中最关键的问题是，寻找中位数并不需要整个数组完全有序，如果把多余的元素排序省略掉，那么就可以超越线性对数的限制实现最快的算法。</p>
<p>启发来源于快速排序算法中的切分法，比如我们需要找到数组中第 k小的元素，首先将数组a[lo,hi]切分返回整数j，使得a[lo,j-1]都小于等于a[j]，而a[j+1,hi]都大于等于a[j]，如果j==k，那么j位置的元素就是我们要找的第k小的元素，而如果j&gt;k，就要切分左子数组，如果j&lt;k，就要切分右子数组，不断缩小选定的子数组的规模直到只剩下一个元素，则它就是最终我们要找的第k小的元素。</p>
<p>经过数学推导，这种快速切分法寻找中位数仅仅为线性量级，是寻找中位数最为快速的算法。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=10010;
int x[N],y[N];
int n;

int quick(int q[],int l,int r,int k)
{
	if(l &gt;= r) return q[l];

	int i=l-1,j=r+1;
	int x=q[l+r&gt;&gt;1];
	while(i&lt;j)
	{
		do i++; while(q[i] &lt; x);
		do j--; while(q[j] &gt; x);
		if(i &lt; j) swap(q[i],q[j]);
	}
	int s=j-l+1;
	if(k &lt;= s) quick(q,l,j,k);
	else quick(q,j+1,r,k-s);
}

int solve(int *a)
{
	int res=0;
	int midx=quick(a,1,n,(n+1)/2);
	for(int i=1;i&lt;=n;i++) 
		res+=abs(a[i]-a[(n+1)/2]);
	
	return res;
}

int main()
{
	cin&gt;&gt;n;
	
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;x[i]&gt;&gt;y[i];
	
	sort(x+1,x+n+1);
	
	for(int i=1;i&lt;=n;i++)
		x[i]-=i-1;
		
	cout&lt;&lt;solve(x)+solve(y)&lt;&lt;endl;
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[康托展开]]></title>
        <id>https://caifxh.github.io/post/kang-tuo-zhan-kai/</id>
        <link href="https://caifxh.github.io/post/kang-tuo-zhan-kai/">
        </link>
        <updated>2020-04-15T07:11:49.000Z</updated>
        <content type="html"><![CDATA[<p>1.康托展开是个啥<br>
一句话，给出一个全排列，求它是第几个全排列，叫做康托展开。<br>
另一句话，给出全排列长度和它是第几个全排列，求这个全排列，叫做逆康托展开。<br>
这里，全排列的顺序定义和火星人中的定义是一样的。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_8977d0167e-20.PNG" alt="20.PNG" loading="lazy"></figure>
<p>拿52413举例子：<br>
1、首先看第一个数 5，不管第一位是什么数，后面都有四位数，那么这四位数全排列的方式有 4！种，而如果第一位是 1 或 2 或 3 或 4 都会比5开头的字典序要小，所以可以令1，2，3，4分别作为开头，这样的话就会有 4 * 4！种排法要比  52413这种排法的字典序要小。<br>
那么第一个数是1，2，3，4时候的字典序的个数数完了是 4 * 4！ 种，且这些字典序都要比52413的字典序要小。</p>
<p>2、那么就可以固定第一位5，找下一位2，这时5已经用过了，所以从剩下的 1，2，3，4 里挑选比2小的数，一共1个，后面还剩三位，也就是3！种排列方式，那么这时候比 52413 字典序要小的又有  1 * 3！种，也就是当5在第一位，1在第二位的时候。</p>
<p>3、再看第三位3，这时5，2都用了，所以从剩下的 1，3，4种找比他小的数的个数，原理同上，所以这时候也可以有 1 * 2!种排列方式的字典序小于 52413</p>
<p>4、再看第四位1，这时候会有 0 * 1！种</p>
<p>5、再看第五位3，这时候会有0 * 0！种</p>
<p>综上所述：<br>
对于序列： 52413 该序列展开后为： 4 * 4! + 1 * 3! + 2 * 2! + 0 * 1! + 0 * 0! ，计算结果是： 106<br>
由于是从0开始计数的，所以最后 52413 的编号为 107</p>
<p>为什么从0开始计数？<br>
可以这样看：我现在让你求12345的康托展开值，也就是：0<em>4！+ 0</em>3！+ 0<em>2！+ 0</em>1！+0*0！ =  0 所以明白了吧~~<br>
康托公式最小字典序的编号就是0，一般求出来后咱们往往习惯于从1开始。</p>
<p>暴力：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=1e7+10,mod=998244353;
int a[N];
LL fac[N];
int c[N];
int n;

void init()
{
	fac[0]=1;
	for(int i=1;i&lt;=n;i++)
		fac[i]=fac[i-1]*i%mod;
}

int main()
{
	cin&gt;&gt;n;
	
	init();
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		int cnt=0;
		for(int j=i+1;j&lt;=n;j++)
			if(a[i] &gt; a[j])
				cnt++;
		ans=(ans+cnt*fac[n-i])%mod;
	}
	
	printf(&quot;%d\n&quot;,ans+1);
	
	return 0;
}
</code></pre>
<p>树状数组优化：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=1e7+10,mod=998244353;
int a[N];
LL fac[N];
int c[N];
int n;

void init()
{
	fac[0]=1;
	for(int i=1;i&lt;=n;i++)
		fac[i]=fac[i-1]*i%mod;
}

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x,int v)
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		c[i]+=v;
}

int query(int x)
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res=(res+c[i])%mod;
	return res;
}

int main()
{
	cin&gt;&gt;n;
	
	init();
	
	for(int i=1;i&lt;=n;i++)	
		add(i,1);
	
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		ans=(ans+(query(a[i])-1)*fac[n-i])%mod;
		add(a[i],-1);
	}	
	
	printf(&quot;%d\n&quot;,ans+1);
	
	return 0;
}
</code></pre>
<h4 id="康托逆展开">康托逆展开</h4>
<p>和上面相反，已知某排列的排名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，求这个排列。</p>
<p>解决思路基本没区别（说是相反也行）：</p>
<p>假设我们现在要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值，首先可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi><mo>÷</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">b_i=x\div (n-i)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span>。</p>
<p>那么也就是知道了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在当前未出现过的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>中的排名。</p>
<p>但仅仅知道这个不能直接计算，所以我们还要记录一下前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位出现过的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>枚举求出答案。</p>
<p>下面是一个例子：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_d39f25127e-21.png" alt="21.png" loading="lazy"><br>
此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>8</mn><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n=8,i=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>位出现了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">1,4,6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span></span></span></span>。</p>
<p>假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">b_i=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在未出现的数里排名第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p>
<p>由于排名是从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是灰色的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>。</p>
<p>以{3,4,1,5,2}为例，其康托展开值为61：</p>
<ul>
<li>
<p>用 61 / 4! = 2余13，则a[1] = 2，即首位右边比首位小的数有2个，所以首位为3。</p>
</li>
<li>
<p>用 13 / 3! = 2余1，则a[2] = 2，即在第二位之后小于第二位的数有2个，所以第二位为4。</p>
</li>
<li>
<p>用 1 / 2! = 0余1，则a[3] = 0，即在第三位之后没有小于第三位的数，所以第三位为1。</p>
</li>
<li>
<p>用 1 / 1! = 1余0，则a[4] = 1，即在第四位之后小于第四位的数有1个，所以第四位为5。</p>
</li>
<li>
<p>最后一位自然就是剩下的数2。</p>
</li>
</ul>
<p>通过以上分析，所求排列组合为 34152。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=10010;
int a[N];
LL fac[N];
bool vis[N];
int n,m,k;

void init()
{
	fac[0]=1;
	for(int i=1;i&lt;=n;i++)	
		fac[i]=fac[i-1]*i;
}

void incantor()
{
	for(int i=1;i&lt;=n;i++)
	{
		int t=k/fac[n-i];
		k%=fac[n-i];
		
		int cnt=0;
		int j;
		for(j=1;;j++)
		{
			if(!vis[j]) cnt++;
			if(cnt &gt; t) break;
		}
		a[i]=j;
		vis[j]=1;
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;k;
	k--;
	
	init();
	
	incantor();

	for(int i=1;i&lt;=n;i++)
		printf(&quot;%d &quot;,a[i]);
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客寒假第三场]]></title>
        <id>https://caifxh.github.io/post/niu-ke-han-jia-di-san-chang/</id>
        <link href="https://caifxh.github.io/post/niu-ke-han-jia-di-san-chang/">
        </link>
        <updated>2020-04-14T14:40:10.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3004/A">A</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_0fe2b4a07e-18.PNG" alt="18.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=55,mod=1e9+7;
char g[N][N];
int f[N][N];
int n,m;

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;m;j++)
		{
			char c;
			cin&gt;&gt;c;
			g[i][j]=c;
		}
		
	f[0][0]=1;
		
	for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;m;j++)
		{
			if(g[i][j] == 'R') f[i][j+1]=(f[i][j+1]+f[i][j])%mod;
			if(g[i][j] == 'D') f[i+1][j]=(f[i+1][j]+f[i][j])%mod;
			if(g[i][j] == 'B') f[i+1][j]=(f[i+1][j]+f[i][j])%mod,f[i][j+1]=(f[i][j+1]+f[i][j])%mod;
		}
		
	cout&lt;&lt;f[n-1][m-1]&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://ac.nowcoder.com/acm/contest/3004/H">H</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_2add4ae47f-28.PNG" alt="28.PNG" loading="lazy"><br>
题解：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_384a5f467f-29.PNG" alt="29.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010;
bool st[N];
int cnt[N],f[N];
int n,m;

void init(int n)
{
	for(int i=2;i&lt;=n;i++)
	{
		if(!st[i])
		{
			for(int j=i+i;j&lt;=n;j+=i)
				st[j]=true;
		}
		else 
		{
			for(int j=i;j&lt;=n;j+=i)
				cnt[j]++;
		}
		f[cnt[i]]++;
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	init(n);
	
	while(m--)
	{
		int k;
		scanf(&quot;%d&quot;,&amp;k);
		printf(&quot;%d\n&quot;,f[k]);
	}
	return 0;
}
</code></pre>
<p><a href="https://ac.nowcoder.com/acm/contest/3004/F">F</a><br>
题意：<br>
给定长度为n的01串，任意两个1之间能够产生的能量为它们的下标差，求01串能量总和。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_da11e1147f-30.PNG" alt="30.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010,mod=1e9+7;
typedef long long LL;
char str[N];
int pos[N];
int d[N];
int n;
 
int main()
{
    cin&gt;&gt;n;
    cin&gt;&gt;str+1;
     
    int cnt=0;
    for(int i=1;i&lt;=n;i++)
        if(str[i] == '1')
            pos[cnt++]=i;
             
    for(int i=1;i&lt;cnt;i++)
        d[i]=pos[i]-pos[i-1];
     
    int ans=0;
    for(int i=1;i&lt;cnt;i++)
        ans=(ans+(LL)i*(cnt-i)%mod*d[i]%mod)%mod;
         
    cout&lt;&lt;ans&lt;&lt;endl;
     
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_67f03a167f-31.PNG" alt="31.PNG" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010,mod=1e9+7;
typedef long long LL;
char str[N];
int p[N];
int s[N];
int n;

int main()
{
	cin&gt;&gt;n;
	cin&gt;&gt;str+1;
	
	int cnt=0;
	for(int i=1;i&lt;=n;i++)
		if(str[i] == '1')
			p[++cnt]=i;
			
	for(int i=1;i&lt;=cnt;i++)
		s[i]=(s[i-1]+p[i])%mod;
	
	int ans=0;
	for(int i=1;i&lt;=cnt;i++)
		ans=(ans+(LL)(i-1)*p[i]-s[i-1]+mod)%mod;
	
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[贪心]]></title>
        <id>https://caifxh.github.io/post/tan-xin/</id>
        <link href="https://caifxh.github.io/post/tan-xin/">
        </link>
        <updated>2020-04-14T13:57:45.000Z</updated>
        <content type="html"><![CDATA[<h4 id="贪心法正确性证明方法">贪心法正确性证明方法</h4>
<p>方法一：数学归纳法<br>
主要步骤如下：<br>
（1）叙述一个论证算法正确性的与自然数相关的命题P(n)，这里的n可以代表算法步数或者实例规模。例如：<br>
对于任何正整数n，贪心法的前n步选择将导致最优解。<br>
对于任何正整数n，贪心法对于规模为n的任何实例都得到最优解。</p>
<p>（2）使用第一或者第二数学归纳法证明上述命题P(n)。<br>
第一数学归纳法：<br>
证：<br>
P(1)为真；<br>
若P(n)为真，则P(n+1)为真。</p>
<p>第二数学归纳法：<br>
证：<br>
P(1)为真；<br>
若对所有k&lt;n，有P(k)为真， 则P(n)为真。</p>
<p>方法二：交换论证法<br>
主要步骤如下：<br>
（1）分析一般最优解与贪心法的解的区别，然后定义一种转换规则，使得从任意一个最优解出发，经过不断对解的某些成分的排列次序进行交换或者用其他元素替换，将这个解最终能够转变成贪心法的解。<br>
（2）证明在上述转换中解得优化函数值不会变坏。<br>
（3）证明上述转换在有限步结束。</p>
<p>1.活动安排问题<br>
<a href="https://www.acwing.com/problem/content/910/">acwing908</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_47c476f27e-16.PNG" alt="16.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010;

struct Range
{
    int l,r;
    bool operator&lt; (const Range &amp;w)const
    {
        return r&lt;w.r;
    }
}ranges[N];

int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        int l,r;
        cin&gt;&gt;l&gt;&gt;r;
        ranges[i]={l,r};
    }
    
    sort(ranges,ranges+n);
    int res=0,ed=-2e9;
    for(int i=0;i&lt;n;i++)
        if(ranges[i].l&gt;ed)
        {
            res++;
            ed=ranges[i].r;
        }
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>2.区间覆盖问题<br>
<a href="https://www.acwing.com/problem/content/description/909/">acwing907</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_7a77c5687e-17.PNG" alt="17.PNG" loading="lazy"></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100010;
struct Range
{
    int l, r;
    bool operator&lt; (const Range &amp;W)const
    {
        return l &lt; W.l;
    }
}range[N];
int n;

int main()
{
    int st, ed;
    scanf(&quot;%d%d&quot;, &amp;st, &amp;ed);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++ )
    {
        int l, r;
        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    int res = 0;
    int j=0;
    while(st &lt; ed)
    {
        int r=-2e9;
        while(j &lt; n &amp;&amp; range[j].l &lt;= st)
            r=max(r,range[j].r),j++;
        
        if(r &lt; st)
        {
            res=-1;
            break;
        }
        st=r;
        res++;
    }
    
    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
<p>3.最优装载<br>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2570">hdu2570</a><br>
有n种体积V都相同，浓度为Pi%的万能药水，挑选尽可能多的万能药水混合，需满足混合后的浓度≤W%。</p>
<p>解题思路：<br>
此题是一道贪心题，为了能够选择尽可能多的万能药水，所以我们应该先选浓度低的，可以达到降低混合后浓度的作用。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=110;
int a[N];
int n,v,w;

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;v,&amp;w);
		
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);
		
		sort(a+1,a+1+n);
		
		double sum=0;
		int cnt=0;
		int i;
		for(i=1;i&lt;=n;i++)
			if((sum+a[i])/i &lt;= w)
				sum+=a[i],cnt++;
			else 
				break;
		
		if(cnt==0) printf(&quot;0 0.00\n&quot;);
		else printf(&quot;%d %.2lf\n&quot;,cnt*v,sum/100/cnt);
	}
	return 0;
}
</code></pre>
<p>4.多机调度</p>
<p>设有n个独立的作业，由m台相同的机器进行加工处理。作业i所需的处理时间为t[i]。任何作业可以在任何一台机器上面加工处理，但未完工之前不允许中断处理。任何作业不能拆分成更小的作业。要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。</p>
<p>采用最长处理时间作业优先的贪心选择策略，可以设计出解多机调度问题较好的近似算法。</p>
<ul>
<li>
<p>当n&lt;=m(作业数小于机器数)时，只要将机器 i 的 时间区间分配给作业 i 即可</p>
</li>
<li>
<p>当n&gt;m时，首先将n个作业从大到小排序，然后依此顺序将作业分配给空闲的处理机。也就是说从剩下的作业中，选择需要处理时间最长的，然后依次选择处理时间次长的，直到所有的作业全部处理完毕，或者机器不能再处理其他作业为止。如果我们每次是将需要处理时间最短的作业分配给空闲的机器，那么可能就会出现其它所有作业都处理完了只剩所需时间最长的作业在处理的情况，这样势必效率较低。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客寒假第二场]]></title>
        <id>https://caifxh.github.io/post/niu-ke-han-jia-di-er-chang/</id>
        <link href="https://caifxh.github.io/post/niu-ke-han-jia-di-er-chang/">
        </link>
        <updated>2020-04-14T01:59:49.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3003/E">E</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/13/9969_636ed1dc7d-46.PNG" alt="46.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/13/9969_9270230a7d-1.PNG" alt="1.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

int main()
{
	int n;
	cin&gt;&gt;n;
	int res=0;
	for(int i=1;i*i&lt;=n;i++)
	{
		int t=i*i;
		for(int j=1;j*j&lt;=t;j++)
			if(t % j == 0)
			{
				res++;
				if(j != t/j) res++;
			}
	}
	
	cout&lt;&lt;res&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://ac.nowcoder.com/acm/contest/3003/H">H</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_c4cc6de67d-7.PNG" alt="7.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_d0e452887d-8.PNG" alt="8.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=3e5+10,INF=0x3f3f3f3f;
int f[N];
int a[N];
int n,k;

int main()
{
	cin&gt;&gt;n&gt;&gt;k;
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a+1,a+n+1);
	
	f[0]=0;
	for(int i=1;i&lt;k;i++)
		f[i]=INF;
		
	int val=INF;
	for(int i=k;i&lt;=n;i++)
	{
		val=min(val,f[i-k]-a[i-k+1]);
		f[i]=val+a[i];
	}
	
	cout&lt;&lt;f[n]&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://ac.nowcoder.com/acm/contest/3003/I">I</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_b557694a7e-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_c911d2cc7e-11.PNG" alt="11.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
vector&lt;int&gt; a;
map&lt;int,int&gt; vis;
int n;

int main()
{
	cin&gt;&gt;n;
	
	for(int i=1;i&lt;=n;i++)
	{
		int x;
		scanf(&quot;%d&quot;,&amp;x);
		if(vis[x]) continue;
        vis[x]=1;
		a.push_back(x);
	}
	
	n=a.size();
	
	if(n == 1)
	{
		puts(&quot;0&quot;);
		return 0;
	}
	
	for(int i=0;i&lt;=30;i++)
	{
		int cnt=0;
		for(int j=0;j&lt;n;j++)
			if(a[j]&gt;&gt;i &amp; 1) cnt++;
		if(cnt &gt; 0 &amp;&amp; cnt &lt; n)
		{
			printf(&quot;%lld\n&quot;,(1ll&lt;&lt;i)*(n-1));
			return 0;
		}
	}
	
}
</code></pre>
<p><a href="https://ac.nowcoder.com/acm/contest/3003/J">J</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_0c9c79727e-14.PNG" alt="14.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/14/9969_1f4a261e7e-15.PNG" alt="15.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc u&lt;&lt;1
#define rc u&lt;&lt;1|1
typedef long long LL;
const int N=2e5+10,mod=1e9+7;
struct Node1
{
	int l,r;
	LL k;
}tr1[N&lt;&lt;2];
struct Node2
{
	int l,r;
	LL val;
}tr2[N&lt;&lt;2];
struct f
{
	LL k,val;
};
int k[N],b[N];
int n,m;

void pushup(int u)
{
	tr1[u].k=(LL)tr1[lc].k*tr1[rc].k%mod;
	tr2[u].val=((LL)tr2[lc].val*tr1[rc].k%mod+tr2[rc].val)%mod;
}

void build(int u,int l,int r)
{
	tr1[u].l=tr2[u].l=l,tr1[u].r=tr2[u].r=r;
	if(l == r)
	{
		tr1[u].k=k[l];
		tr2[u].val=b[l];
		return;
	}
	int mid=l+r&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u);
}

void modify(int u,int x,int k,int b)
{
	if(tr1[u].l == tr1[u].r)
	{
		tr1[u].k=k;
		tr2[u].val=b;
		return;
	}
	int mid=tr1[u].l+tr1[u].r&gt;&gt;1;
	if(x&lt;=mid) modify(lc,x,k,b);
	else modify(rc,x,k,b);
	pushup(u);
}

f query(int u,int l,int r)
{
	if(l == tr1[u].l &amp;&amp; tr1[u].r == r)
		return {tr1[u].k, tr2[u].val};

	int mid=tr1[u].l+tr1[u].r&gt;&gt;1;
	if(r &lt;= mid) 
		return query(lc,l,r);
	else if(l &gt; mid) 
		return query(rc,l,r);
	else 
	{
		f left=query(lc,l,mid);
		f right=query(rc,mid+1,r);
		return {left.k*right.k%mod,(left.val*right.k%mod+right.val)%mod};
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;k[i]);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
		
	build(1,1,n);	
	
	while(m--)
	{
		int t;
		scanf(&quot;%d&quot;,&amp;t);
		if(t == 1)
		{
			int i,k,b;
			scanf(&quot;%d%d%d&quot;,&amp;i,&amp;k,&amp;b);
			modify(1,i,k,b);
		}
		else 
		{
			int l,r;
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			auto t=query(1,l,r);
			printf(&quot;%d\n&quot;,(t.k+t.val)%mod);
		}
	}
	
	return 0;
}
</code></pre>
<p><a href="https://ac.nowcoder.com/acm/contest/3003/F">F</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_a68e8e207e-25.PNG" alt="25.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_bbb04b187e-26.PNG" alt="26.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; PII;
const int N=2e5+10;
int a[N],b[N];
PII c[N];
int n;

bool cmp(PII x,PII y)
{
	return x.first &gt; y.first;
}

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;b[i]);
	for(int i=1;i&lt;=n;i++)
		c[i].first=a[i]+b[i],c[i].second=i;
	
	sort(c+1,c+n+1,cmp);
	
	for(int i=2;i&lt;=n;i+=2)
		printf(&quot;%d &quot;,c[i].second);
	puts(&quot;&quot;);
	
	for(int i=1;i&lt;=n;i+=2)
		printf(&quot;%d &quot;,c[i].second);
	puts(&quot;&quot;);
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分]]></title>
        <id>https://caifxh.github.io/post/er-fen/</id>
        <link href="https://caifxh.github.io/post/er-fen/">
        </link>
        <updated>2020-04-13T13:18:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1462">P1462</a><br>
∎题目描述<br>
　给定无向图，n个点，m条双向边，每个点有点权fi（这个点的过路费），有边权ci（这条路的血量）。求起点1到终点N的所有可能路径中，在总边权（总血量）不超过给定的b的前提下，所经过的路径中最大点权（这条路径上过路费最大的那个点）的最小值是多少。<br>
题目数据：n≤10000，m≤50000，fi，ci，B≤1e9。<br>
　　<br>
∎题解<br>
对点权fi进行二分，用dijkstra求最短路，检验总边权是否小于b。二分法是最小化最大值问题。<br>
这一题是二分法和最短路算法的简单结合。<br>
（1）对点权（过路费）二分。题目的要求是：从1到N有很多路径，其中的一个可行路径Pi，它有一个点的过路费最大，记为Fi；在所有可行路径中，找到那个有最小F的路径，输出F。解题方案是：先对所有点的fi排序，然后用二分法，找符合要求的最小的fi。二分次数log(fi)=log(1e9) &lt; 30。<br>
（2）在检查某个fi时，删除所有大于fi的点，在剩下的点中，求1到N的最短路，看总边权是否小于b，如果满足，这个fi是合适的（如果最短路的边权都大于b，那么其他路径的总边权就更大，肯定不符合要求）。一次Dijkstra求最短路，复杂度是O(mlogn)。<br>
总复杂度满足要求。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=10010,M=100010,INF=0x3f3f3f3f;
int h[N],e[M],ne[M],w[M],idx;
int n,m,b;
int f[N],cost[N];
int dist[N];
typedef pair&lt;int,int&gt; PII;
bool st[N];
int sum;

void add(int a,int b,int c)
{
    e[idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx++;
}

bool check(int x)
{
    memset(dist,0x3f,sizeof dist);
    memset(st,false,sizeof st);
    dist[1]=0;
    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; heap;
    heap.push({0,1});

    while(heap.size())
    {
        PII t=heap.top();
        heap.pop();
        int distance=t.first,ver=t.second;
        if(st[ver])
            continue;
        st[ver]=true;
        for(int i=h[ver];~i;i=ne[i])
        {
            int j=e[i];
            if(dist[j] &gt; distance + w[i] &amp;&amp; cost[j] &lt;= x)
            {
                dist[j] = distance + w[i];
                heap.push({dist[j],j});
            }
        }
    }

    if(dist[n] &lt;= b)
        return true;
    else
        return false;
}

int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;b);
    memset(h,-1,sizeof h);
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;f[i];
        cost[i]=f[i];
    }
    while(m--)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
        add(b,a,c);
    }

    sort(f+1,f+n+1);

    int l=1,r=n;

    //在点权最大的情况下，依旧大于b，不满足
    if(!check(f[n]+10))
    {
        cout&lt;&lt;&quot;AFK&quot;&lt;&lt;endl;
        return 0;
    }
    while(l &lt; r)
    {
        int mid=l+r&gt;&gt;1;
        if(check(f[mid]))
            r=mid;
        else
            l=mid+1;
    }

    cout&lt;&lt;f[l]&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1824">P1624</a><br>
在一条很长的直线上，指定n个坐标点（x1, …, xn）。有c头牛，安排每头牛站在其中一个点（牛棚）上。这些牛喜欢打架，所以尽量距离远一些。问最近的两头牛之间距离的最大值可以是多少。<br>
这个题目里，所有的牛棚两两之间的距离有个最小值，题目要求使得这个最小值最大化。<br>
∎题解<br>
（1）暴力法。从小到大枚举最小距离的值dis，然后检查，如果发现有一次不行，那么上次枚举的就是最大值。如何检查呢？用贪心法：第一头牛放在x1，第二头牛放在xj≥x1+dis的点xi,第三头牛放在xk≥xj+dis的点xk，等等，如果在当前最小距离下，不能放c条牛，那么这个dis就不可取。复杂度O(nc)。<br>
（2）二分。分析从小到大检查dis的过程，发现可以用二分的方法找这个dis。这个dis符合二分法：它有上下边界、它是单调递增的。复杂度O(nlogn)。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010;
int q[N];
int n,c;

//相距x，是否能放置c头牛
bool check(int dist)
{
    int cnt=1,last=0;

    for(int i=1;i&lt;n;i++)
    {
        if(q[i] - q[last] &gt;= dist)
        {
            cnt++;
            last=i;
        }
    }

    if(cnt &gt;= c)
        return true;
    else
        return false;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;c;

    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;q[i];
    sort(q,q+n);
    int l=1,r=q[n-1]-q[0];
    while(l &lt; r)
    {
        int mid=l+r+1&gt;&gt;1;
        if(check(mid))
            l=mid;
        else
            r=mid-1;
    }

    cout&lt;&lt;l&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="实数二分">实数二分</h4>
<pre><code>const double eps =1e-7;        //精度。如果下面用for，可以不要eps
while(right - left &gt; eps){     //for(int i = 0; i&lt;100; i++){
      double mid = left+(right-left)/2;
      if (check(mid)) right = mid;           //判定，然后继续二分
      else            left  = mid;
}
</code></pre>
<p>其中，循环用2种方法都可以：</p>
<pre><code>while(right - left &gt; eps)  　{ ... }
或者：
for(int i = 0; i &lt; 100; i++) { ... }
</code></pre>
<p>如果用for循环，由于循环内用了二分，执行100次，相当于实现了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>100</mn></msup></mrow><annotation encoding="application/x-tex">1/2^{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>的精度，一般比eps更精确。<br>
for循环的100次，比while的循环次数要多。如果时间要求不是太苛刻，用for循环更简便</p>
<p><a href="https://vjudge.net/problem/POJ-3122">poj3122</a><br>
主人过生日，m个人来庆生，有n块半径不同的圆形蛋糕，由m+1个人（加上主人）分，每人的蛋糕必须一样重，而且是一整块（不能是几个蛋糕碎块，也就是说，每个人的蛋糕都是从一块圆蛋糕中切下来的完整一块）。问每个人能分到的最大蛋糕是多大。<br>
∎题解<br>
最小值最大化问题。设每人能分到的蛋糕大小是x，用二分法枚举x。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const double PI=acos(-1.0);
const int eps=1e-8;
const int N=100010;
double s[N];
int n,m;

bool check(double mid)
{
	int sum=0;
	for(int i=0;i&lt;n;i++)
		sum+=int(s[i]/mid);
	
	if(sum &gt;= m) return 1;
	else return 0;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		m++;
		
		double l=0,r=0;
		for(int i=0;i&lt;n;i++)
		{
			int x;
			scanf(&quot;%d&quot;,&amp;x);
			s[i]=PI*x*x;
			r=max(r,s[i]);
		}
		
		for(int i=0;i&lt;100;i++)
		{
			double mid=l+(r-l)/2;
			if(check(mid)) l=mid;
			else r=mid;
		}
		
		printf(&quot;%.4f\n&quot;,l);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.org/problem/P1419">P1419</a><br>
题意理解<br>
就是给你一些区间,要求选择的区间包含以下条件.</p>
<ul>
<li>选取区间总长度最大</li>
<li>选取的区间之间不得用重叠部分,包括区间左右端点部分</li>
</ul>
<p>状态设计<br>
解决一道动态规划的题目,最主要的就是状态设计和状态转移<br>
一个个区间,都包含了[l,r],因此我们可以设置.每一个点,作为分段点<br>
因此,我们得出了.f[i]表示[1,i]区间的最大利润</p>
<p>状态转移<br>
假如说,我们现在位于i这个节点处.那么对于这个点而言,显然包含它的区间的右端点一定为i<br>
换种表达为,[s,i]为包含这个端点的区间<br>
当然s是属于一类集合,也就是,所有右端点为i的区间.</p>
<p>因此我们不难推导出转移方程.<br>
f[i]=f[i−1]不选择当前任何一个区间<br>
f[i]=max(f[i],f[sj]+(i−sj+1))选择[sj,i]这个区间i−sj+1为该区间的利润</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
const int N=3e6+10;
int f[N];
vector&lt;int&gt; g[N];
int n;

int main()
{
	cin&gt;&gt;n;
	
	int r=0;
	for(int i=1;i&lt;=n;i++)
	{
		int a,b;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		r=max(r,b);
		g[b].push_back(a);
	}
	
	for(int i=1;i&lt;=r;i++)
	{
		f[i]=f[i-1];
		for(int j=0;j&lt;g[i].size();j++)
        {
            int t=g[i][j];
			f[i]=max(f[i],f[t-1]+(i-t+1));
        }
	}
	
	printf(&quot;%d\n&quot;,f[r]);
	
	return 0;
}
</code></pre>
<p>二分+DP</p>
<ul>
<li>线段不重复，可以借用贪心的思想，对右端点进行从小到大的排序，排除后效性。</li>
<li>以 f[i]表示前 i 条线段中选出若干条（必选第 i 条）的最大总长度。</li>
<li>简单地说，就是只要保证后一条线段不与当前线段重合，就可以添加当前线段。</li>
<li>f[i]=max(f[j],r(j)&lt;l(i)+length(i)</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
const int N=150010;
int f[N];
struct line
{
	int l,r;
	int val;
	
	bool operator&lt;(const line &amp;W) const
	{
		return r&lt;W.r;
	}
}g[N];
int n;

int find(int l,int r,int key)
{
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(g[mid].r &lt; key) l=mid;
		else r=mid-1;
	}
	
	return l;
}

int main()
{
	cin&gt;&gt;n;

	for(int i=1;i&lt;=n;i++)
	{
		int x,y;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		g[i].l=x,g[i].r=y,g[i].val=y-x+1;
	}
	
	sort(g+1,g+n+1);
	
	for(int i=1;i&lt;=n;i++)
	{
		f[i]=f[i-1];
		int t=find(0,i-1,g[i].l);
		f[i]=max(f[i],f[t]+g[i].val);
		
	}
	
	printf(&quot;%d\n&quot;,f[n]);
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1419">P1419</a><br>
题意：求一个连续子段，其长度在[S,T]之间，使其平均值最大。保留三位小数<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/11/9969_5053302e7b-43.PNG" alt="43.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/11/9969_5baa00f67b-44.PNG" alt="44.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010;
double a[N];
double s[N];
int q[N];
int n;
int S,T;

bool check(double mid)
{
	for(int i=1;i&lt;=n;i++)	
		s[i]=s[i-1]+a[i]-mid;
		
	int hh=0,tt=-1;

	for(int i=S;i&lt;=n;i++)
	{
		if(hh &lt;= tt &amp;&amp; i-T &gt; q[hh])
			hh++;

		while(hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i-S])
			tt--;
		q[++tt]=i-S;
		
		if(hh&lt;=tt &amp;&amp; s[i] &gt;= s[q[hh]])
			return true;
	}
	return false;
}

int main()
{
	cin&gt;&gt;n;
	cin&gt;&gt;S&gt;&gt;T;
	
	double l=10000,r=-10000;
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf&quot;,&amp;a[i]);
		r=max(r,a[i]);
		l=min(l,a[i]);
	}
	
	while(r-l&gt;1e-5)
	{
		double mid=l+(r-l)/2;
		if(check(mid))
			l=mid;
		else 
			r=mid;
	}
		
	printf(&quot;%.3f\n&quot;,l);
	
	return 0;
}
</code></pre>
<p>反思<br>
一直没有推到最后一步。依然在判断a[l]+...+a[r]≥k∗(r−l+1)的子序列的存在问题。<br>
事实上这样的判断让二分没有意义了。我们是在找最大的一段a了，跟k完全没有关系。因为是求平均值，一段和较大的子序列不一定平均值就大了。我们巧妙地通过将k移项，使平均值问题转化为了求和问题。</p>
<p><a href="https://www.luogu.com.cn/problem/P1258">P1258</a><br>
由题意知，若要二人一起到达B点时耗时相同且最短，则二人走的路程、坐车的路程以及走和坐车的时间相同，并且车只能回接一次。<strong>设第一个人走的路程为x、时间为t1，坐车的时间为t2，车返回接另一个人所用时间为t3，</strong><br>
则t1=x/a，t2=(s-x)/b，t3=(s-2x)/b;（甲和乙走的路程均为x）</p>
<p>t2+t3=t1=(2s-3x)/b=x/a,解得x=2as/(3a+b) 故轻松地用数学解出此题。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;

int main()
{
	double s,a,b;
	cin&gt;&gt;s&gt;&gt;a&gt;&gt;b;
	double x=2*a*s/(3*a+b);
	
	printf(&quot;%.6f\n&quot;,x/a+(s-x)/b);
	
	return 0;
}
</code></pre>
<p>既然是个二分题，当然也可以用二分做了。我们可以二分车回接另一个人时的位置，算出若在此位置车回接，二人到终点分别的总耗时t1、t2，若t1==t2，输出答案，若t1&gt;t2，使左端点等于mid，若t1&lt;t2，则使右端点等于mid，直至有答案产生或两端点的差距小于1e-8为止。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
const double eps=1e-8;
double s,a,b;

int main()
{
	cin&gt;&gt;s&gt;&gt;a&gt;&gt;b;
	
	double l=0,r=s;
	while(r-l&gt;1e-8)
	{
		double mid=l+(r-l)/2;
		
		double t1=(s-mid)/a+mid/b;
		double t2=mid/b+
				(mid-mid/b*a)/(a+b)+
				(s-(mid/b+(mid-mid/b*a)/(a+b))*a)/b;
		if(t1 &gt; t2)
			l=mid;
		else 
			r=mid;
	}
	
	printf(&quot;%.6f\n&quot;,l/b+(s-l)/a);
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P2678">P2678</a><br>
可以去模拟这个跳石头的过程。开始你在i(i=0)位置，我在跳下一步的时候去判断我这个当前跳跃的距离，如果这个跳跃距离比二分出来的mid小，那这就是一个不合法的石头，应该移走。为什么？我们二分的是最短跳跃距离，已经是最短了，如果跳跃距离比最短更短岂不是显然不合法，是这样的吧。移走之后要怎么做？先把计数器加上1，再考虑向前跳啊。去看移走之后的下一块石头，再次判断跳过去的距离，如果这次的跳跃距离比最短的长，那么这样跳是完全可以的，我们就跳过去，继续判断，如果跳过去的距离不合法就再拿走，这样不断进行这个操作，直到i = n+1，为啥是n+1？河中间有n块石头，显然终点在n+1处。</p>
<p>模拟完这个过程，我们查看计数器的值，这个值代表的含义是我们以mid作为答案需要移走的石头数量，然后判断这个数量 是不是超了就行。如果超了就返回false，不超就返回true。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=50010;
int d[N];
int L,n,m;

bool check(int mid)
{
	int cnt=0,last=0;
	for(int i=1;i&lt;=n;i++)
		if(d[i]-last &lt; mid) cnt++;
		else last=d[i];
		
	return cnt&lt;=m;
}

int main()
{
	cin&gt;&gt;L&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;d[i];
		
	d[++n]=L;
	int l=0,r=L;
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(check(mid))
			l=mid;
		else 
			r=mid-1;
	}
	
	cout&lt;&lt;l&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/501/">acwing499</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/12/9969_0cfbbd5a7c-45.PNG" alt="45.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=2e5+10;
int w[N],v[N];
int l[N],r[N];
LL s[N];
int cnt[N];
LL n,m,S;
LL ans;

LL get(int mid)
{
	for(int i=1;i&lt;=n;i++)
	{
		if(w[i] &gt;= mid)
		{
			s[i]=s[i-1]+v[i];
			cnt[i]=cnt[i-1]+1;
		}
		else 
		{
			s[i]=s[i-1];
			cnt[i]=cnt[i-1];
		}
	}
	
	LL res=0;
	for(int i=1;i&lt;=m;i++)
		res+=((cnt[r[i]]-cnt[l[i]-1])*(s[r[i]]-s[l[i]-1]));
	
	return res;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;S;
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d%d&quot;,&amp;w[i],&amp;v[i]);
		
	for(int i=1;i&lt;=m;i++)
		scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]);
		
	int l=1,r=1e6+1;//r要多1，才能枚举到一个都不选的情况 
	
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(get(mid) &gt;= S)
			l=mid;
		else 
			r=mid-1;
	}
	
	cout &lt;&lt; min(abs(get(r) - S), abs(get(r + 1)-S)) &lt;&lt; endl;
	//r为&gt;=S的情况下最小值，而求的是abs最小，需要和r+1情况下的最小值比较一下 
	
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3104">poj3104</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/14/9969_d774c16495-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/14/9969_da4a6b4695-12.PNG" alt="12.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1e5+10;
typedef long long LL;
int a[N];
int n,k;

bool check(int mid)
{
	LL sumt=0;
	for(int i=0;i&lt;n;i++)
	{
		if(a[i] &gt; mid)
			sumt+=(a[i]-mid+k-2)/(k-1);//上取整 
	}
	
	return sumt &lt;= mid;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	int l=1,r=0;
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]),r=max(r,a[i]);
	
	scanf(&quot;%d&quot;,&amp;k);
	
	if(k == 1)
	{
		cout&lt;&lt;r&lt;&lt;endl;
		return 0;
	}

	while(l&lt;r)
	{
		int mid=l+r&gt;&gt;1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	
	cout&lt;&lt;l&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2002">poj2002</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/15/9969_3608931496-13.png" alt="13.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/05/15/9969_38d0bed296-14.png" alt="14.png" loading="lazy"><br>
解题思路：</p>
<ul>
<li>把输入数据放入哈希表</li>
<li>根据两个点（x1,y1）,(x2,y2），得到另外2个点（x3,y3）,(x4,y4），在哈希表中查找是否存在，如果存在，计数；</li>
<li>根据两个点（x1,y1）,(x2,y2），得到另外2个点（x5,y5）,(x6,y6），在哈希表中查找是否存在，如果存在，计数；</li>
<li>计数时每个正方形每条边都枚举了一次，所以答案除以4。。</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=1010,mod=1003;
typedef pair&lt;int,int&gt; PII;
int px[N],py[N];
int h[N],ne[N],idx;
PII e[N];
int n;

void insert(int x,int y)
{
	int k=(x*x+y*y)%mod;
	e[idx]=make_pair(x,y);
	ne[idx]=h[k];
	h[k]=idx++;
}

bool find(int x,int y)
{
	int k=(x*x+y*y)%mod;
	for(int i=h[k];~i;i=ne[i])
	{
		PII t=e[i];
		if(t.first == x &amp;&amp; t.second == y) return true;
	}
	return false;
}

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)
	{
		memset(h,-1,sizeof h);
		idx=0;
		for(int i=0;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;px[i],&amp;py[i]);
			insert(px[i],py[i]);
		}
		
		int ans=0;
		for(int i=0;i&lt;n;i++)
			for(int j=i+1;j&lt;n;j++)
			{
				int x1=px[i]+(py[j]-py[i]);
				int y1=py[i]+(px[i]-px[j]);
				int x2=px[j]+(py[j]-py[i]);
				int y2=py[j]+(px[i]-px[j]);
				if(find(x1,y1) &amp;&amp; find(x2,y2))
					ans++;
			}
		
		for(int i=0;i&lt;n;i++)
			for(int j=i+1;j&lt;n;j++)
			{
				int x1=px[i]-(py[j]-py[i]);
				int y1=py[i]-(px[i]-px[j]);
				int x2=px[j]-(py[j]-py[i]);
				int y2=py[j]-(px[i]-px[j]);
				if(find(x1,y1) &amp;&amp; find(x2,y2))
					ans++;
			}
		
		ans&gt;&gt;=2;
		printf(&quot;%d\n&quot;,ans);
	}
}
</code></pre>
]]></content>
    </entry>
</feed>