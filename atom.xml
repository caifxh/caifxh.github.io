<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caifxh.github.io</id>
    <title>fxh</title>
    <updated>2020-03-27T09:24:59.752Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caifxh.github.io"/>
    <link rel="self" href="https://caifxh.github.io/atom.xml"/>
    <subtitle>菜</subtitle>
    <logo>https://caifxh.github.io/images/avatar.png</logo>
    <icon>https://caifxh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, fxh</rights>
    <entry>
        <title type="html"><![CDATA[字符串复习（二）]]></title>
        <id>https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/</id>
        <link href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/">
        </link>
        <updated>2020-03-27T09:11:49.000Z</updated>
        <content type="html"><![CDATA[<h4 id="manacher">Manacher</h4>
<p>回文串:对于一个长度为 n 的字符串 str，如果它正着读和反着读一样，即 str[i] = str[n - i + 1] (1 &lt;= i &lt; n - i + 1),如 aba，acbbca 就是回文串，abc，abab 就不是回文串。</p>
<p>Manacher 算法可以求出以每个位置为中心，向两边能扩展的最长回文子串长度 p[i]，它的时间复杂度是 O(n) 的。<br>
注意到回文子串的长度可能是偶数， 如 abba，中心不是某个字符（中心是两个 b 之间的空隙），所以先要在相邻的<br>
字符中插入一个标识符，例如 #,这样例如 #a#b#b#a# 的中心就是 # 了。</p>
<p>我们用 abbabcba 来举例。<br>
先插入 # 得到 #a#b#b#a#b#c#b#a#。<br>
然后用 Manacher 可以得到如下的 p 数组。<br>
对于每个 p[i]，一定有 str[i + j] == str[i - j] (1 ≤ j &lt; p[i])<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_9f85dc7c62-36.PNG" alt="36.PNG" loading="lazy"></p>
<p>类比 Z 算法，我们也维护一个 mx 和 id，表示对于当前计算的所有 i，i + p[i] 的最大值是 mx，mx 对应的 i 记为id。<br>
当你现在开始计算 p[i] 时，默认 p[1..i-1] 都已经算出。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_ca02b89262-38.PNG" alt="38.PNG" loading="lazy"></p>
<h4 id="计算最长回文子串长度">计算最长回文子串长度</h4>
<p>以字符串&quot;cabbaf&quot;为例，将预处理后的新字符串&quot;#c#a#b#b#a#f#&quot;变成一个字符数组arr，定义一个辅助数组int[] p，p的长度与arr等长，p[i]表示以arr[i]字符为中心的最长回文半径，p[i]=1表示只有arr[i]字符本身是回文子串。</p>
<pre><code>i       0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i]  # c # a # b # b # a #  f  #
p[i]    1 2 1 2 1 2 5 2 1 2 1  2  1
</code></pre>
<p>我们来比对分下一下最长回文半径和原字符串之间的关系。在上面例子中，最长回文子串是&quot;#a#b#b#a#&quot;，它以arr[6]为中心，半径是5，其代表的原始字符串是&quot;abba&quot;，而&quot;abba&quot;的长度为4，可以通过5减去1得到，是字符串&quot;cabbaf&quot;中的最长回文子串，那么我们是不是可以得出最长回文半径和最长回文子串长度之间的关系？</p>
<p>让我们再多看几个例子，如&quot;aba&quot;，转换后是&quot;#a#b#a#&quot;，以字符'b'为中心的回文，半径是4，减1得到3，3是原字符串的最长回文子串长度。</p>
<p>再例如&quot;effe&quot;，转换后是&quot;#e#f#f#e#&quot;，以最中间的'#'为中心的回文，半径是5，减1得到4，4是原字符串的最长回文子串长度。</p>
<p>因此，最后我们得到最长回文半径和最长回文子串长度之间的关系：int maxLength = p[i]-1。maxLength表示最长回文子串长度。</p>
<h4 id="计算最长回文子串起始索引">计算最长回文子串起始索引</h4>
<p>知道了最长回文子串的长度，我们还需要知道它的起始索引值，这样才能截取出完整的最长回文子串。<br>
继续以第三步中的字符串&quot;cabbaf&quot;为例，p[6]=5，是最长半径，用6(i)减去最长半径5(p[i])得到1，而1恰好是最长回文子串&quot;abba&quot;的起始索引。<br>
我们再来看一个奇回文的例子。例如&quot;aba&quot;，转换后是&quot;#a#b#a#&quot;，p[3]=4，最长半径是4，i为3，用i减去4得到-1，数组下标越界了。<br>
在偶回文的情况下，可以满足i减最长半径，而奇回文却会下标越界，我们需要在转换后的字符串前面再加一个字符，解决下标越界的问题，不能是'#'，那就加个'$'字符吧，但是加过一个字符后，字符串的长度不是奇数了，只能在尾部再加一个不会重复出现的字符，比如'@'(也可不加，因为字符串结尾为'\0')，这样字符串的长度依旧是奇数了，满足前面第三部分的条件。</p>
<p>加多一个字符后，奇回文可以正常做减法了，偶回文呢？</p>
<pre><code>i       0 1 2 3 4 5 6 7 8 9 10 11 12 13
arr[i]  $ # c # a # b # b # a  #  f  #
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1
</code></pre>
<p>在补上字符'$'后，p[7]=5，用i减去最长半径，7-5=2，而理想的结果应该是1，那就再除以2吧，这样就能得到1了。而奇回文&quot;aba&quot;在用i减去最长半径后得到的是0，除以2后还是0，可以完美解决下标越界的问题。</p>
<p><code>结论：最长回文子串的起始索引int index = (i - p[i])/2。</code><br>
<a href="https://www.luogu.com.cn/problem/P3805">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=11000010;
char s[N];
charma[N&lt;&lt;1];
int p[N&lt;&lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i]&gt;mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	while(~scanf(&quot;%s&quot;,s))
	{
		int len=strlen(s);
		manacher(s,len);
		int ans=0;
		for(int i=0;i&lt;2*len+2;i++)
			ans=max(ans,p[i]-1);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://codeforces.ml/problemset/problem/17/E">Codeforces 17E</a><br>
给出一个字符串 s。 求 s 有多少对相交的回文子串。包含也算作相交。<br>
如 babb 一共有 6 对相交的回文子串：<br>
s[1..1] and s[1..3]<br>
s[1..3] and s[2..2]<br>
s[1..3] and s[3..3]<br>
s[1..3] and s[3..4]<br>
s[3..3] and s[3..4]<br>
s[3..4] and s[4..4]<br>
|s| ≤ 2·e6</p>
<p>正难则反<br>
统计不相交的回文子串对数。<br>
不相交的回文子串假设端点分别为 x1,y1,x2,y2<br>
那么一定有 x1 &lt;= y1 &lt; x2 &lt;= y2<br>
我们只要统计出以 i 为起点的回文串个数 st[i]，和以 i为终点的回文串个数 ed[i]。<br>
然后计算<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_4bb23d6462-39.PNG" alt="39.PNG" loading="lazy"><br>
在使用 manacher 算法的时候，对每个 i 都计算出了 p[i]<br>
那么我们就要把[i-p[i], i+p[i]] 这个极大回文子串对 st和 ed 的贡献算进去。<br>
对于 st: [i-p[i]+1, i] 这些点每个位置都要 +1<br>
对于 ed：[i, i+p[i]-1] 这些点每个位置都要 +1<br>
只需要通过差分转化为单点修改即可。<br>
最后用总的回文子串对数减去不相交的回文子串对数即是答案</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=2e6+10,mod=51123987;
char s[N];
int p[N&lt;&lt;1];
int n;
char ma[N&lt;&lt;1];
int l[N&lt;&lt;1],r[N&lt;&lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,s);
	manacher(s,n);
	n=n*2+2;
	
	int ans=0;
	for(int i=0;i&lt;n;i++)
	{
		l[i-p[i]+1]++,l[i+1]--;
		r[i]++,r[i+p[i]]--;
		ans=(ans+p[i]/2)%mod;
	}
	ans=(LL)ans*(ans-1)/2%mod;
	
	int sum=0;
	for(int i=1;i&lt;n;i++)
	{
		l[i]+=l[i-1];r[i]+=r[i-1];
		if(i&amp;1) continue;
		ans=(ans-(LL)sum*l[i]%mod+mod)%mod;
		sum=(sum+r[i])%mod;
	}
	printf(&quot;%d&quot;,ans);
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P4555">BZOJ 2565</a><br>
定义双回文串 T，满足存在 T = ab，其中 a 和 b 都是回文串。<br>
给定字符串 S，求一个 S 的最长的双回文子串 T。<br>
|S| ≤ 1e6</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_562e454c62-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG" loading="lazy"><br>
Lmax是一个点往左扩展，越靠右越可能长，所以做逆推；Rmax是一个点往右扩展，越靠左越可能长，所以做顺推。递推式子见代码。处理好之后扫一遍就出解了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int n;
int l[N*2],r[N*2],p[N*2];
char ma[N*2],a[N];

void manacher(char *s,int len)
{
    int k=0;
    ma[k++]='$';
    ma[k++]='#';
    for(int i=0;i&lt;len;i++)
    {
        ma[k++]=s[i];
        ma[k++]='#';
    }
    ma[k]=0;
    int mx=0,id=0;
    for(int i=0;i&lt;k;i++)
    {
        if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]] == ma[i-p[i]])
            p[i]++;
        if(i+p[i]&gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
        l[i+p[i]-1]=max(l[i+p[i]-1],p[i]-1);
        //cout&lt;&lt;l[i+p[i]-1]&lt;&lt;' '&lt;&lt;p[i]-1&lt;&lt;endl;
        r[i-p[i]+1]=max(r[i-p[i]+1],p[i]-1);
        //cout&lt;&lt;r[i-p[i]+1]&lt;&lt;' '&lt;&lt;p[i]-1&lt;&lt;endl;
    }
}

 
int main()
{
	scanf(&quot;%s&quot;,a);
	
	int n=strlen(a);
	manacher(a,n);
	n=n*2+2;
	
	for(int i=1;i&lt;n;i+=2) r[i]=max(r[i],r[i-2]-2);
	for(int i=n-1;i&gt;=1;i-=2) l[i]=max(l[i],l[i+2]-2);
	
	int ans=0;
	for(int i=1;i&lt;n;i++) 
		if(l[i] &amp;&amp; r[i])
			ans=max(ans,l[i]+r[i]);
	cout&lt;&lt;ans;
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P4324">bzoj4755</a><br>
有两个长度均为 N 的字符串 A 和 B。<br>
扭动的字符串 S(i,j,k) 定义为 A[i..j]+B[j..k] 若 A=’xyz’, B=‘uvw’, 则 S(1,2,3)=‘xyvw’<br>
定义扭动的回文串为如下情况中的一个；<br>
A 中的一个回文串<br>
B 中的一个回文串<br>
某一个回文的扭动字符串S(i,j,k)<br>
求最长的扭动回文串<br>
1≤N≤100000，字符串只含大写字母</p>
<blockquote></blockquote>
<p>样例：<br>
5<br>
ABCDE<br>
BAECB<br>
答案：<br>
5<br>
最长的扭动回文串是 S(2,3,5) = BCECB</p>
<p>对于前两种情况，我们只需要用 manacher 算法求出每个位置的回文扩展半径，然后取一个最大值即可。<br>
对于第三种情况，需要在两个字符串中各取一段拼起来。<br>
我们可以把答案字符串分解为 STS’<br>
其中 S’ 是 S 的反串，T 是回文串。</p>
<p>可以发现一定是 S 在一个串，TS’ 在另一个串；或者 ST 在一个串，S’在另一个串。<br>
且<code>T 一定是极大的回文子串。</code></p>
<p>那么我们只要枚举极大回文子串 T 即可。<br>
假设中心在 A 中，枚举中心 i。<br>
(1)假设A[i-p[i], i+p[i]] 是极大回文子串。<br>
枚举 A[i+p[i]+1..n] 的前缀和 B[1..i-p[i]] 的后缀最长能匹配上多少。</p>
<p>(2)假设B[i-p[i], i+p[i]] 是极大回文子串。<br>
枚举 A[1..i-p[i]-1] 的后缀 和 B[i + p[i]..n] 的前缀最长能匹配上多少。<br>
这两部分的最大值 * 2 + 极大回文子串的长度就是答案了。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef unsigned long long ULL;
const int N=100010,M=N&lt;&lt;1,P=131;
char a[N],b[N];
char ma[M];
int pa[M],pb[M];
int n;
ULL ha[N],hb[N],p[N];
int ans;

ULL getha(int l,int r)
{
	return ha[r]-ha[l-1]*p[r-l+1];
}

ULL gethb(int l,int r)
{
	return hb[l]-hb[r+1]*p[r-l+1];
}

void manacher(char *s,int len,int p[])
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=1;i&lt;=len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l++]=0;
	
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx &gt; i) p[i]=min(p[2*id-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}	
}

int search(int L,int R)
{
	int l=0,r=min(L,n-R+1);
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(getha(L-mid+1,L) == gethb(R,R+mid-1))
			l=mid;
		else 
			r=mid-1;
	}
	return l;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,a+1);
	scanf(&quot;%s&quot;,b+1);
	
	p[0]=1;
	for(int i=1;i&lt;=n;i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&lt;=n;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=n;i&gt;=1;i--)
		hb[i]=hb[i+1]*P+b[i];
	
	manacher(a,n,pa);
	manacher(b,n,pb);
	n=n*2+1;
	for(int i=1;i&lt;=n;i++) ans=max(ans,pa[i]-1);
	for(int i=1;i&lt;=n;i++) ans=max(ans,pb[i]-1);
	for(int i=1;i&lt;=n;i++)
	{
		int l=(i-pa[i])/2+1,r=(i+pa[i])/2-1;//下标从1开始
		if(l&lt;=r)
			ans=max(ans,pa[i]-1+search(l-1,r)*2);
	}
	for(int i=1;i&lt;=n;i++)
	{
		int l=(i-pb[i])/2+1,r=(i+pb[i])/2-1;
		if(l&lt;=r)
			ans=max(ans,pb[i]-1+search(l,r+1)*2);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/SP7586">SP7586</a><br>
求一个串中包含几个回文串<br>
用马拉车求出以每个字母为对称轴的回文串长度，因为一个回文串长度/2就是这个回文串包含的子回文串长度，所以最后统计一下即可<br>
<a href="https://paste.ubuntu.com/p/bg75xXjG4R/">代码</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3501">BZOJ 2084 Antisymmetry</a><br>
给定一个长度为 n 的01串，问有多少个子串满足翻转并取反后和原来一样。<br>
比如0101翻转并取反后还是和原来一样。</p>
<p>只要定义 0 = 1， 0 ≠ 0，1 ≠ 1 即可。跑一遍 Manacher 即可。<br>
以 0/1 扩展的 p[i] 一定是 0 （即没有奇数长度的合法子串）<br>
以 # 扩展的累加起来即可<br>
接下来我们来考虑如果我们确定了一个中心后，向外扩展出一个最大可能的反对称串，那么这个串中一定含有len/2个满足条件的串，其中len为串长，因为要想大的满足条件，则在里面的小串必须满足是反对称的</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=500010;
char s[N];
char ma[N&lt;&lt;1];
int p[N&lt;&lt;1];
int n;

void manacher(char *s,int len)
{
    int l=0;
    ma[l++]='$';
    ma[l++]='#';
    for(int i=0;i&lt;len;i++)
    {
        ma[l++]=s[i];
        ma[l++]='#';
    }
    ma[l]=0;
    int mx=0,id=0;
    for(int i=1;i&lt;l;i+=2)
    {
        if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]]-'0'+ma[i-p[i]]-'0'==1 || (ma[i+p[i]]==ma[i-p[i]] &amp;&amp; ma[i+p[i]]=='#'))
            p[i]++;
        if(i+p[i]&gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
    }
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,s);
    manacher(s,n);
    long long ans=0;
    for(int i=1;i&lt;n*2+2;i+=2)
    	ans+=p[i]/2;
	
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3790">BZOJ 3790</a><br>
母亲节就要到了，小 H 准备送给她一个特殊的项链。这个项链可以看作一个用小写字母组成的字符串，每个小写字母表示一种颜色。为了制作这个项链，小 H 购买了两个机器。第一个机器可以生成所有形式的回文串，第二个机器可以把两个回文串连接起来，而且第二个机器还有一个特殊的性质：假如一个字符串的后缀和一个字符串的前缀是完全相同的，那么可以将这个重复部分重叠。<br>
例如：aba和aca连接起来，可以生成串abaaca或 abaca。现在给出目标项链的样式，询问你需要使用第二个机器多少次才能生成这个特殊的项链。</p>
<blockquote></blockquote>
<p>样例：<br>
abcdcba （答案：0）<br>
abacada （答案：2）<br>
abcdef （答案：5）</p>
<p>题目的意思就是用尽可能少的回文子串去覆盖原串。<br>
我们可以先跑一遍 Manacher 算法得到每个位置的覆盖半径。<br>
问题转化为了有许多个区间 [i-p[i], i+p[i]]，要选出尽可能少的区间来覆盖 [1, n] 区间</p>
<p>贪心即可。<br>
对所有的区间按照左端点从小到大排序。<br>
每次都选右端点最远的那个区间。<br>
设当前覆盖到的右端点为 right。<br>
每次找出左端点在[1, right] 中的右端点的最大的那个线段，再做一次覆盖。<br>
时间复杂度 O(n log n)<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_83262ddc62-tempsnip.png" alt="tempsnip.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=50010,M=N&lt;&lt;1;
char s[N],ma[M];
int p[M];
struct Node
{
	int l,r;
	bool operator&lt;(const Node &amp;W) const
	{
		return l&lt;W.l;
	}
}e[M];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
		e[i].l=i-p[i]+1,e[i].r=i+p[i]-1;
	}
}

int main()
{
	while(~scanf(&quot;%s&quot;,s))
	{
		int n=strlen(s);
		manacher(s,n);
		
		n=n*2+1;
		sort(e+1,e+n+1);
		
		int st=1,j=1,ed=n;
		int res=0;
		
		while(st &lt; ed)
		{
			int r=0;
			while(j &lt;= n &amp;&amp; e[j].l &lt;= st)
				r=max(r,e[j].r),j++;
			
			st=r;
			res++;
		}
		printf(&quot;%d\n&quot;,res-1);
	}
}
</code></pre>
<h4 id="trie">trie</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_465a00d061-17.PNG" alt="17.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_568cd63061-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_58b69c0c61-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_830379da61-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_84e99b6c61-21.png" alt="21.png" loading="lazy"></p>
<pre><code>void insert(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-'a';
        if(!trie[p][k])
            trie[p][k]=++idx;
        p=trie[p][k];
    }
    cnt[p]=true;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_037d465861-22.png" alt="22.png" loading="lazy"></figure>
<pre><code>int query(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-'a';
        p=trie[p][k];
        if(!p)
            return 0;
    }
    return cnt[p];
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/837/">模板题</a></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_2cda862961-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_371889c861-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_40813ee261-25.png" alt="25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_6342628a61-26.png" alt="26.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_65f359bc61-27.png" alt="27.png" loading="lazy"></p>
<h4 id="例题">例题</h4>
<p><a href="https://vjudge.net/problem/POJ-2503">poj2503</a><br>
您刚从滑铁卢搬到大城市。 这里的人说的是一门不可理解的外语。 幸运的是，您有一本字典来帮助您理解它们。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ae53dcea61-28.png" alt="28.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;sstream&gt;
using namespace std;
const int N=1000010,M=26;
int trie[N][M];
int cnt[N],idx=1;
char word[N][15];

void insert(string str,int k)
{
	int len=str.size(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=str[i]-'a';
		if(!trie[p][ch])
			trie[p][ch]=++idx;
		p=trie[p][ch];
	}
	cnt[p]=k;
}

int query(string str)
{
	int len=str.size(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int k=str[i]-'a';
		p=trie[p][k];
		if(!p)
			return 0;
	}
	return cnt[p];
}

int main()
{
	string s,str;
	int k=1;
	while(getline(cin,s))
	{
		if(s.empty())
			break;
		stringstream ss(s);
		ss&gt;&gt;word[k]&gt;&gt;str;
		insert(str,k);
		k++;
	}
	
	while(cin&gt;&gt;s)
	{
		int k=query(s);
		if(k)
			cout&lt;&lt;word[k]&lt;&lt;endl;
		else 
			cout&lt;&lt;&quot;eh&quot;&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="">poj3630</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_360d81f861-29.png" alt="29.png" loading="lazy"><br>
给定一个电话号码列表，判断它是否一致，即没有号码是另一个号码的前缀。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ae1e7c4461-29.png" alt="29.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;sstream&gt;
using namespace std;
const int N=100010,M=10;
int trie[N][M];
bool cnt[N];
int idx;
int n;

bool insert(char *s)
{
	int p=1;
	int len=strlen(s);
	for(int i=0;i&lt;len;i++)
	{
		int k=s[i]-'0';
		if(!trie[p][k])
			trie[p][k]=++idx;
		else if(i == len-1)//字符串处理完毕，仍不空，说明该串是其它串的前缀 
			return true;
		p=trie[p][k];
		if(cnt[p])//其他串是该串前缀 
			return true;
	}
	cnt[p]=true;
	return false;
}

int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		idx=1;
		bool ans=false;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
		{
			char s[15];
			scanf(&quot;%s&quot;,s);
			if(ans)
				continue;
			if(insert(s))//不能立即结束，仍要读取n个串 
				ans=true;
		}
		if(ans)
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//有前缀输出NO 
		else
			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1251">hdu1251</a><br>
Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1f376a1261-30.png" alt="30.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=500005;
const int maxz=26;//不同字符个数，例如数字10，小写字母26
int trie[maxn][maxz];
int cnt[maxn];//计数器 
void insert(string s)//将字符串s插入到字典树中 
{
	int len=s.length(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=s[i]-'a';//转换成数字
		if(!trie[p][ch]) 
			trie[p][ch]=++tot;//记录下标 
		p=trie[p][ch];
		cnt[p]++;//统计有多少个单词经过 
	}
}

int query(string s)
{
	int len=s.length(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=s[i]-'a';//转换成数字
		p=trie[p][ch];
		if(!p)
			return 0;
	}
	return cnt[p];	
}

int main()
{	
	string s;
	memset(trie,0,sizeof(trie));
	memset(cnt,0,sizeof(cnt));
	tot=1;
	while(getline(cin,s))
	{
		if(!s.size())
			break;
		insert(s);
	}
	while(cin&gt;&gt;s)
		cout&lt;&lt;query(s)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>若反过来问，单词表中有多少单词是当前查询单词的前缀，只需统计查询时经过的end标记数量即可。</p>
<p><a href="https://vjudge.net/problem/POJ-2513">poj2513</a><br>
给你一堆木棍。 每个棍子的每个端点都带有某种颜色。是否可以将操纵杆沿一条直线对齐，以使触摸的端点的颜色具有相同的颜色？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_dcdfe70261-31.png" alt="31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_e6f7e0d261-32.png" alt="32.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=500010,M=26;
int trie[N][M];
int cnt[N];
int d[N];
int idx=1;
int color;
int p[N];

int find(int x)
{
	if(x != p[x])
		p[x]=find(p[x]);
	return p[x];
}

int insert(char *s)
{
	int len=strlen(s),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int k=s[i]-'a';
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	if(cnt[p])
		return cnt[p];
	else 
	{
	    cnt[p]=++color;
	    return cnt[p];
	}
}

int main()
{
	for(int i=1;i&lt;N;i++)
		p[i]=i;
	char a[15],b[15];
	while(~scanf(&quot;%s%s&quot;,a,b))
	{
		int i=insert(a);
		int j=insert(b);
		d[i]++;
		d[j]++;
		//cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;
		int pi=find(i);
		int pj=find(j);
		p[pi]=pj;
	}
	
	int s=find(1);
	int num=0;
	for(int i=1;i&lt;=color;i++)
	{
		if(d[i] % 2 == 1)
			num++;
		if(num &gt; 2 || find(i) != s)
 		{
 			puts(&quot;Impossible&quot;);
			return 0;
		}
 	}
	if(num == 0 || num == 2)
		puts(&quot;Possible&quot;);
	else 
		puts(&quot;Impossible&quot;);
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3764">poj3764</a><br>
给出n个节点的树，每条边有边权w。 • 请你找一条路径，使得这条路径上所有边权的异或和最大。<br>
• 数据范围<br>
• n &lt;= 100,000, 0 &lt; w &lt; 2^31</p>
<p>暴力的做法：<br>
• 枚举每个点当根<br>
• dfs整颗树，获得根到每个节点的路径异或和s[]<br>
• 时间复杂度O(n^2)</p>
<p>异或的性质<br>
x xor x = 0<br>
• 一个数异或两次会抵消掉。<br>
• x到y的路径异或和就等于s[x] xor s[y] !<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_9a3f466e61-33.png" alt="33.png" loading="lazy"><br>
这样只要任取一个点为根，dfs得到s[]数组后，枚举x， y即可，还是O(n^2)</p>
<p>现在的问题是，给定一个s[]数组，找两个元素，使得他<br>
们的异或和最大。<br>
• 给一个数x，在数组s中找一个数y使其和x的异或和最大。<br>
• 涉及二进制的题，我们可以选择按位来考虑。</p>
<p>假设x的二进制有31位，我们把它的二进制写出来，最高位称为第30位，最低位称为第0位。<br>
因为要让异或值最大，所以我们从高位开始考虑。<br>
• 如果x的第30位是1 —— if (x &gt;&gt; 30 &amp; 1)<br>
• 那我们一定希望y的第30位是0，这样异或之后的第30位 是1.<br>
• 否则就算第29～0位异或后都是1，也比2^30小。<br>
• 同理，如果x的第30位是0，我们希望y的第30位是1.</p>
<p>运用贪心的思想，假设现在枚举到x的第i位<br>
• if x第i位是1 我们要尽可能找第i位为0的y<br>
• if x第i位是0 我们要尽可能找第i位为1的y<br>
涉及前缀判断，采用trie</p>
<p>先把所有的数的二进制当作字符串，存进trie中。<br>
• 从高往低枚举二进制位时，设置一个指针p，一开始指向trie的根节点。<br>
• if x第i位是1 我们要尽可能找第i位为0的y 如果说明存在第i位为0的数，我们就让p往0节点走，答案中的第i位为1。<br>
• 如果不存在第i位为0的数，我们只能退而求其次，让p往1节点走，答案中的第i位为0.<br>
• if x第i位是0 我们要尽可能找第i位为1的y ， 同理</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010*31,M=N&lt;&lt;1;
int trie[N][2],tot=1;
int d[N];
int n;
int h[N],e[M],ne[M],w[M],idx;

void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j == fa)
			continue;
		d[j]=d[u]^w[i];
		dfs(j,u);
	}
}

void insert(int x)
{
	int p=1;
	for(int i=30;i&gt;=0;i--)
	{
		int u=x&gt;&gt;i&amp;1;
		if(!trie[p][u])
			trie[p][u]=++tot;
		p=trie[p][u];
	}
}

int query(int x)
{
	int p=1;
	int res=0;
	for(int i=30;i&gt;=0;i--)
	{
		int k=x&gt;&gt;i&amp;1;
		if(trie[p][!k])
		{
			res+=1&lt;&lt;i;
			p=trie[p][!k];
		}	
		else 
			p=trie[p][k];
	}
	return res;
}

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		memset(h,-1,sizeof h);
		memset(d,0,sizeof d);
		memset(trie,0,sizeof trie);
		idx=0;
		tot=1;
		for(int i=0;i&lt;n-1;i++)
		{
			int a,b,c;
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
			a++,b++;
			add(a,b,c);add(b,a,c);
		}
		dfs(1,-1);
		int res=0;
//		for(int i=1;i&lt;=n;i++)
//			cout&lt;&lt;d[i]&lt;&lt;' ';
		
		for(int i=1;i&lt;=n;i++)
		{
			insert(d[i]);
			res=max(res,query(d[i]));
		}
		printf(&quot;%d\n&quot;,res);
	}
	return 0;
}
</code></pre>
<h4 id="ac自动机">AC自动机</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_62b82fa863-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_661c7b4063-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_72245a5d63-4.png" alt="4.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_865c0f8863-5.png" alt="5.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_8d6beb0e63-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_9969b29c63-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_a53131a463-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_cbf0cdb863-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_cec6648a63-10.png" alt="10.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d9867a9063-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_af41834663-13.png" alt="13.png" loading="lazy"><br>
每个结点的26个指针都有指向<br>
匹配时判断后缀是不是单词，若为单词则也需要统计上<br>
<a href="https://www.acwing.com/problem/content/description/1284/">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=5e5+10,M=1e6+10;
int trie[N][26],cnt[N],idx;
char s[M];
int q[N],ne[N];
int n;

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-'a';
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;26;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;26;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	int res=0;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-'a';
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			res+=cnt[p];
			cnt[p]=0;
			p=ne[p];
		}
	}
	return res;
}

void print()
{
	for(int i=0;i&lt;idx;i++)
	{
		cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ne[i]&lt;&lt;&quot;: &quot;;
		for(int j=0;j&lt;26;j++)
			if(trie[i][j])
			    cout&lt;&lt;char(j+'a')&lt;&lt;' '&lt;&lt;trie[i][j]&lt;&lt;&quot;  &quot;;
		cout&lt;&lt;endl;
	}
	cout&lt;&lt;endl;
}

int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		memset(ne,0,sizeof ne);
		idx=0;
		scanf(&quot;%d&quot;,&amp;n);
		
		for(int i=0;i&lt;n;i++)
		{
			char str[55];
			scanf(&quot;%s&quot;,str);
			insert(str);
		}
		
		build();
		//print();
		scanf(&quot;%s&quot;,s);
		printf(&quot;%d\n&quot;,query(s));
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2896">hdu2896</a><br>
小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_a190a2ac63-14.png" alt="14.png" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1e5+10,M=10010;
int trie[N][128],idx;
char s[M];
int q[N],ne[N];
int n,m;
int ans[N],cnt;
int id[N];
int tot;

void insert(char *s,int i)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-32;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	id[p]=i;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;128;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;128;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	bool flag = false;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-32;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			if(id[p])
			{
				flag=true;
				ans[cnt++]=id[p];
				//cout&lt;&lt;&quot;---&quot;&lt;&lt;id[p]&lt;&lt;endl;
			}
			p=ne[p];
		}
	}
	return flag;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		char str[210];
		scanf(&quot;%s&quot;,str);
		insert(str,i);
	}
	
	build();

	scanf(&quot;%d&quot;,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s&quot;,s);
		cnt=0;
		if(query(s))
		{
			tot++;
			printf(&quot;web %d:&quot;,i);
			cnt=unique(ans,ans+cnt)-ans;
			sort(ans,ans+cnt);
			for(int i=0;i&lt;cnt;i++)
				printf(&quot; %d&quot;,ans[i]);
			puts(&quot;&quot;);
		}
	}
	
	printf(&quot;total: %d\n&quot;,tot);
	return 0;
}
</code></pre>
<p>1.本题不是计数，不需判重复，只需标记病毒编号为true，多次标记不影响最终答案<br>
2.多个主串，字典树下一次还要再查询，不能改变字典树<br>
附：ASCII表<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_8f7d399863-ASCII%E8%A1%A8.jpg" alt="ASCII表.jpg" loading="lazy"></p>
<p><a href="https://vjudge.net/problem/POJ-2778">poj2778</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_ce862d4c63-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d228a30863-16.png" alt="16.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d4f32f6863-17.png" alt="17.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_ec73a48863-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_eea68e4663-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_fd08f70863-20.png" alt="20.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=110,mod=100000;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n,m;
int q[N];
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
	matrix(int c[][N])
	{
		memcpy(m,c,sizeof m);
	}
};

int get(char c)
{
	switch(c)
	{
		case 'A' : return 0;
		case 'G' : return 1;
		case 'C' : return 2;
		case 'T' : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;	
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&lt;=idx;i++)
		for(int j=0;j&lt;=idx;j++)
			for(int k=0;k&lt;=idx;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&lt;=idx;i++)
		res.m[i][i]=1;
	while(k)
	{
		if(k &amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&gt;&gt;=1;
	}
	return res;
}

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;n;i++)
	{
		char str[15];
		scanf(&quot;%s&quot;,str);
		insert(str);
	}
	
	build();
	
	matrix g;
	for(int i=0;i&lt;=idx;i++)
	{
		if(cnt[i]) continue;
		for(int j=0;j&lt;4;j++)
		{
			int p=trie[i][j];
			if(!cnt[p])
				g.m[i][p]=(g.m[i][p]+1)%mod;
		}
	}
	
//	for(int i=0;i&lt;=idx;i++)
//	{
//		for(int j=0;j&lt;=idx;j++)
//			cout&lt;&lt;g.m[i][j]&lt;&lt;' ';
//		cout&lt;&lt;endl;
//	}
	
	g=qmi(g,m);
	int res=0;
	for(int i=0;i&lt;=idx;i++)
		res=(res+g.m[0][i])%mod;
	
	printf(&quot;%d&quot;,res);
	
	return 0;
}
</code></pre>
<p>最后的答案为什么是g.m[0][i]求和?<br>
矩阵g的n次幂表示构造长度为n的DNA序列的方案数（g的i次幂表示构造长度为n的DNA序列的方案数），类似离散数学中二元关系的复合运算，二元关系&lt;1,2&gt; ,&lt;2,3&gt; 复合一次可得到关系&lt;1,3&gt;</p>
<p>由于从根结点出发构造序列，且根结点idx为0.g.m[0][i]表示从根结点走i步的方案数，即从根节点开始构造长度为i的序列的方案数。</p>
<p><a href="https://www.acwing.com/problem/content/1055/">poj3691</a><br>
AC自动机+DP<br>
为每个结点构造失败指针的同时，检查其失败指针所指向的节点是否为危险节点，如果是的话也需要把当前节点标记为危险节点。<br>
所谓的危险节点，就是指以当前节点为结尾的字符串是某个病毒串，或者包含了某个病毒串。如果在bfs的同时进行这项操作的时候就非常方便，在构造完当前失败指针的同时检查其所指向的节点是否为危险节点。</p>
<p>根据危险DNA序列所建的字典树，我们用模拟的方式 ，从第一个字符开始构造， 依次递增，找到一个满足要求的字符串，在构造此字符串的同时，比较该字符串和输入要判断的序列S，若该位置i的字符和s[i]，相同，则表示，此位置的字符不需要改变，反则，需要把s[i]该为词字符，为一次改变操作.</p>
<p>状态表示：dp[i][j]，表示到达查找串第i个字符时，对应于AC自动机的j节点所需要的最小改变数。<br>
状态转移为dp[i][son[j]] = min( dp[i][son[j]], dp[i-1][j] + s[i-1]!=k )</p>
<p>读到i个字符时，对应于j状态（DP的过程要两重循环i和j），要转移到son[j]（j的子节点状态，在这里用k在[0,3]一重循环遍历所有可以转字符），如果第i个字符跟所要转移到的字符相同，则代价为0，因为不需要改变；否则代价为1，因为需要改变。</p>
<p>如果当前状态不可达，则不需要对其进行后续运算。</p>
<p>如果子节点为危险节点，则不可以进行转移，即不可以使用上面的状态方程。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n;
char s[N];
int f[N][N];
int q[N];

int get(char c)
{
	switch(c)
	{
		case 'A' : return 0;
		case 'G' : return 1;
		case 'C' : return 2;
		case 'T' : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

void print()
{
    for(int i=0;i&lt;=idx;i++)
    {
        cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ne[i]&lt;&lt;&quot;: &quot;;
        for(int j=0;j&lt;4;j++)
            if(trie[i][j])
                cout&lt;&lt;trie[i][j]&lt;&lt;' ';
        cout&lt;&lt;endl;
    }
}

int main()
{
	int kas=1;
	while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)
	{
		memset(trie,0,sizeof trie);
		memset(ne,0,sizeof ne);
		memset(cnt,0,sizeof cnt);
		idx=0;
		for(int i=0;i&lt;n;i++)
		{
			char str[25];
			scanf(&quot;%s&quot;,str);
			insert(str);
		}
		
		build();
		
		//print();
		
		scanf(&quot;%s&quot;,s+1);
		int len=strlen(s+1);
		
		memset(f,0x3f,sizeof f);
		f[0][0]=0;
		for(int i=1;i&lt;=len;i++)
			for(int j=0;j&lt;=idx;j++)
				for(int k=0;k&lt;4;k++)
				{
					int t=get(s[i]) != k;
					int p=trie[j][k];
					if(!cnt[p])
						f[i][p]=min(f[i][p],f[i-1][j]+ t);
				}
				
		int res=INF;
		for(int i=0;i&lt;=idx;i++)
			res=min(res,f[len][i]);
		
		if(res == INF)
			res=-1;
		printf(&quot;Case %d: %d\n&quot;,kas++,res);
	}
	return 0;
}
</code></pre>
<p>最后，循环dp[len][j]，即在读完最后一个字符后检查所有状态的最终值，取其最小。如果均不可达，则返回-1。<br>
类似题：求主串至少包含一个模式串的方案数，正难则反。<br>
<a href="https://paste.ubuntu.com/p/8cQmVfDpxH/">代码</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2243">hdu2233</a><br>
长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？<br>
比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为<br>
(2个) aa,ab,<br>
(26个)aaa,aab,aac...aaz,<br>
(26个)aba,abb,abc...abz,<br>
(25个)baa,caa,daa...zaa,<br>
(25个)bab,cab,dab...zab。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_e378c0a064-21.png" alt="21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_f3a3c3da64-22.png" alt="22.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_025f2e9e64-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_05abfa1e64-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_be3731ec64-25.png" alt="25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_c20f74aa64-26.png" alt="26.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_d039051e64-27.png" alt="27.png" loading="lazy"><br>
<a href="https://paste.ubuntu.com/p/vVvdmfW8dV/">代码</a><br>
若要求长度正好为L，原矩阵的L次幂即可<br>
长度不超过L，需要累加</p>
<p><a href="https://www.acwing.com/problem/content/1287/">acwing1285</a><br>
每次插入一个单词时把所有路径上的点都+1，每个单词的出现次数就是其结尾节点的fail树子树和。因为其fail指针指向的节点一定包含当前字符串。<br>
统计贡献时要从下往上按照拓扑排序加，<br>
<a href="https://paste.ubuntu.com/p/sxwbtsytTg/">代码</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3695">hdu3695</a><br>
给出 n 个模式串，给出一个长串 S，找出 S 中出现了几种模式串。注意模式串在 S 中正着出现和反着出现都算出<br>
现。S 可能有些段是压缩过的，格式为[tx]，t 是一个数字，x 是一个字母，代表有 t 个 x。把 a[3b]c 解压后会得到<br>
abbbc。<br>
n≤250，模式串的长度不超过1000，t≤5·1e6, 解压后的长串的长度不超过 5100000.</p>
<blockquote></blockquote>
<p>样例输入：<br>
3<br>
2<br>
AB DCB<br>
DACB<br>
3<br>
ABC CDE GHI<br>
ABCCDEFIHG<br>
4<br>
ABB ACDEE BBB FEEE<br>
A[2B]CD[4E]F<br>
样例输出：<br>
0<br>
3<br>
2</p>
<p>我们可以把这 n 个串插入 Trie 树，建成 AC 自动机。然后把解压后的 S 正着在 AC 自动机上跑一遍，再反着在<br>
AC 自动机上跑一遍，对于覆盖过的模式串，打一个标记。最后统计标记的总数即可</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=250010,M=5100010;
int trie[N][26],idx;
char s[M],tmp[M];
int ne[N];
int dar[N];
int n;
int q[N];

void insert(char *s,int k)
{
    int p=0;
    for(int i=0;s[i];i++)
    {
        int k=s[i]-'A';
        if(!trie[p][k])
        {
        	trie[p][k]=++idx;
        	memset(trie[idx],0,sizeof trie[idx]);
        	dar[idx]=0;
		}
        p=trie[p][k];
    }
   	dar[p]++;
}

void build()
{
    int hh=0,tt=-1;
    for(int i=0;i&lt;26;i++)
        if(trie[0][i])
        {
        	int t=trie[0][i];
        	q[++tt]=t;
        	ne[t]=0;
		}
    
    while(hh &lt;= tt)
    {
        int t=q[hh++];
        for(int i=0;i&lt;26;i++)
        {
            int p=trie[t][i];
            if(!p) trie[t][i]=trie[ne[t]][i];
            else 
            {
                ne[p]=trie[ne[t]][i];
                q[++tt]=p;
            }
        }
    }
}

int query(char *s,int type)
{
    int len=strlen(s);
    if(type)
        reverse(s,s+len);
    //cout&lt;&lt;&quot;---&quot;&lt;&lt;s&lt;&lt;endl;
    int res=0;
    for(int i=0,j=0;s[i];i++)
    {
        int k=s[i]-'A';
        j=trie[j][k];
        int p=j;
        while(p)
        {
        	if(dar[p])
        	{
        		res+=dar[p];
        		dar[p]=0;
			}
			else 
				break;
            p=ne[p];
        }
    }
    return res;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
    	memset(trie[0],0,sizeof trie[0]);
    	ne[0]=0;
    	dar[0]=0;
        idx=0;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
        {
            char str[1010];
            scanf(&quot;%s&quot;,str);
            insert(str,i);
        }
        
        build();
        
        scanf(&quot;%s&quot;,s);
        int l=0;
        for(int i=0;s[i];i++)
        {
            if(s[i] !='[')
                tmp[l++]=s[i];
            else
            {
                i++;
                int len=0;
                while(s[i] &gt;='0' &amp;&amp; s[i] &lt;='9')
                {
                    len=len*10+s[i]-'0';
                    i++;
                }
                for(int k=0;k&lt;len;k++)
                    tmp[l++]=s[i];
                i++;
            }
        }
        tmp[l]=0;
        
        printf(&quot;%d\n&quot;,query(tmp,0)+query(tmp,1));
    }
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4763">hdu4763</a><br>
给你一个字符串 S。<br>
请你把这个 S 划分成 EAEBE 的形式。<br>
其中 A 和 B 可以包含任意个（可以是0个）字符。<br>
求 E 的最大长度。字符串的长度之和不会超过1e6</p>
<blockquote></blockquote>
<p>Sample Input<br>
5<br>
xy<br>
abc<br>
aaa<br>
aaaaba<br>
aaxoaaaaa</p>
<blockquote></blockquote>
<p>Sample Output<br>
0<br>
0<br>
1<br>
1<br>
2</p>
<p>观察 EAEBE。<br>
首先要保证 E 既是 S 的前缀又是 S 的后缀。<br>
且去除掉前缀 E 和后缀 E 之后，中间剩下的还要出现一次 E。 对 S 跑一次扩展 KMP 中的 Z 算法。<br>
如果 i+Z[i]-1 == n ，就说明 S[i..n] 可以作为 E。<br>
那么就要求在 S[Z[i]+1..i-Z[i]] 中，还得存在一个 j 满足 Z[j] ≥ Z[i]</p>
<p>问题变成了先找 i+Z[i]-1 = n 的 符合条件的i<br>
然后在[Z[i]+1..i-Z[i]] 中，查询 Z 的最大值，如果比Z[i] 大，那么就可以把 Z[i] 作为答案。最后取最大值即可。<br>
查询区间最大值我们可以用线段树 / ST 表来维护。<br>
最后的时间复杂度都是 O(n log n)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单调队列优化dp]]></title>
        <id>https://caifxh.github.io/post/dan-diao-dui-lie-you-hua-dp/</id>
        <link href="https://caifxh.github.io/post/dan-diao-dui-lie-you-hua-dp/">
        </link>
        <updated>2020-03-27T08:58:09.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/1090/">acwing1088</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_76add7ca6f-34.PNG" alt="34.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_8d36e0fe6f-35.PNG" alt="35.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_8fa6f3ba6f-36.PNG" alt="36.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=2e6+10;
typedef long long LL;
int p[N],d[N];
LL s[N];
int q[N];
bool ans[N];
int n;

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;p[i],&amp;d[i]);
        p[i+n]=p[i];
        d[i+n]=d[i];
    }

    for(int i=1;i&lt;=n*2;i++) s[i]=s[i-1]+p[i]-d[i];

    int hh=0,tt=-1;
    for(int i=1;i&lt;=n*2;i++)//顺时针求长度为n的窗口内前缀和的最小值
    {
        if(hh &lt;= tt &amp;&amp; i - q[hh] &gt;= n) hh++;

        while(hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i])
            tt--;
        q[++tt]=i;
        if(i &gt;= n &amp;&amp; s[q[hh]] &gt;= s[i-n])
            ans[i-n+1]=true;
    }

    d[0]=d[n];
    for(int i=n*2;i&gt;=1;i--) s[i]=s[i+1]+p[i]-d[i-1];

    hh=0,tt=-1;
    for(int i=n*2;i&gt;=1;i--)//逆时针求长度为n的窗口内后缀和的最小值
    {
        if(hh &lt;= tt &amp;&amp; q[hh]-i &gt;= n) hh++;

        while(hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i])
            tt--;
        q[++tt]=i;
        if(i&lt;=n+1 &amp;&amp; s[q[hh]] &gt;= s[i+n])
            ans[i-1]=true;
    }

    for(int i=1;i&lt;=n;i++)
        if(ans[i]) puts(&quot;TAK&quot;);
        else puts(&quot;NIE&quot;);
    return 0;   
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1091/">acwing1089</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_85f4d2e66f-37.PNG" alt="37.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 2e5 + 10, INF = 0x3f3f3f3f;
int n, m;
int w[N], q[N];
int f[N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);

    int hh = 0, tt = 0;
    q[0]=0;
    for (int i = 1; i &lt;= n; i ++ )
    {
        if (i - q[hh] &gt; m) hh ++ ;
        f[i] = f[q[hh]] + w[i];
        while (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt -- ;
        q[ ++ tt] = i;
    }

    int res = INF;
    for (int i = n - m + 1; i &lt;= n; i ++ ) res = min(res, f[i]);
    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1092/">acwing1090</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_54a8eb906f-38.PNG" alt="38.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=50010,INF=0x3f3f3f3f;
int n,t;
int a[N];
int f[N];
int q[N];

bool check(int mid)
{
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
        if(hh &lt;= tt &amp;&amp; i - q[hh] &gt; mid+1) hh++;
        f[i]=f[q[hh]]+a[i];
        while(hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i])
            tt--;
        q[++tt]=i;
    }
    
    int res=INF;
    for(int i=n-mid;i&lt;=n;i++)
        res=min(res,f[i]);
    
    return res&lt;=t;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;t;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;a[i];

    int l=0,r=n;
    while(l &lt; r)
    {
        int mid=l+r&gt;&gt;1;
        if(check(mid))
            r=mid;
        else
            l=mid+1;
    }
    
    cout&lt;&lt;l&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1089/">acwing1087</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_0b8755dc6f-39.PNG" alt="39.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010;
LL f[N][2];
int n,k;
int e[N];
LL s[N];
int q[N];

int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;e[i];
        
    for(int i=1;i&lt;=n;i++)
    	s[i]=s[i-1]+e[i];
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
    	f[i][0]=max(f[i-1][0],f[i-1][1]);
    	if(hh &lt;= tt &amp;&amp; i-q[hh] &gt; k) hh++;
    	
    	f[i][1]=f[q[hh]][0]-s[q[hh]]+s[i];
    	while(hh &lt;= tt &amp;&amp; f[i][0]-s[i] &gt;= f[q[tt]][0] -s[q[tt]])
    		tt--;
    	q[++tt]=i;
	}
	
	cout&lt;&lt;max(f[n][0],f[n][1])&lt;&lt;endl;
	return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_3893cee86f-40.PNG" alt="40.PNG" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010,INF=0x3f3f3f3f;
LL f[N];
int n,k;
int e[N];
LL s[N];
int q[N];

int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;e[i];
        
    for(int i=1;i&lt;=n;i++)
    	s[i]=s[i-1]+e[i];
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
    	if(hh &lt;= tt &amp;&amp; i-q[hh] &gt; k) hh++;
    	
    	f[i]=f[q[hh]-1]-s[q[hh]]+s[i];
    	while(hh &lt;= tt &amp;&amp; f[i-1]-s[i] &gt;= f[q[tt]-1] -s[q[tt]])
    		tt--;
    	q[++tt]=i;
	}
	
	LL res=-1e18;
	for(int i=n-k;i&lt;=n;i++)
	    res=max(res,f[i]);
	cout&lt;&lt;res&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1093/">acwing1091</a><br>
先用滑动窗口+单调队列求出每一行长度为k的连续序列中的最大值、最小值，<br>
存到rmin[i][j],rmax[i][j]两个数组里，<br>
再用相同的方法求这两个数组中每一列长度为k的连续序列的最大值、最小值存到cmin[i],cmax[i]中。<br>
遍历cmin,cmax得出答案。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int n,m,k;
int a[N][N];
int rmax[N][N],rmin[N][N];
int cmax[N],cmin[N];
int tmp[N];
int q[N];

void get(int a[],int b[],int len,int type)//0:最小值，1：最大值 
{
    int hh=0,tt=-1;
    for(int i=1;i&lt;=len;i++)
    {
        if(hh &lt;= tt &amp;&amp; i-q[hh] &gt;=k) hh++;
        while(hh &lt;= tt &amp;&amp;(type?a[q[tt]]&lt;=a[i]:a[q[tt]]&gt;=a[i]))
            tt--;
        q[++tt]=i;
        b[i]=a[q[hh]];
    }
}

int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf(&quot;%d&quot;,&amp;a[i][j]);

    for(int i=1;i&lt;=n;i++)
    {
        get(a[i],rmin[i],m,0);
        get(a[i],rmax[i],m,1);
    }

    int ans=INF;
    for(int i=k;i&lt;=m;i++)
    {
        for(int j=1;j&lt;=n;j++) tmp[j]=rmin[j][i];
        get(tmp,cmin,n,0);

        for(int j=1;j&lt;=n;j++) tmp[j]=rmax[j][i];
        get(tmp,cmax,n,1);

        for(int j=k;j&lt;=n;j++)
            ans=min(ans,cmax[j]-cmin[j]);
    }

    printf(&quot;%d\n&quot;,ans);

    return 0;   
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树状数组]]></title>
        <id>https://caifxh.github.io/post/shu-zhuang-shu-zu/</id>
        <link href="https://caifxh.github.io/post/shu-zhuang-shu-zu/">
        </link>
        <updated>2020-03-27T08:07:13.000Z</updated>
        <content type="html"><![CDATA[<h4 id="树状数组">树状数组</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_ea7daa625c-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_0f4727c45c-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_112b51965c-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_12d4d95e5c-4.png" alt="4.png" loading="lazy"><br>
sum[9]=c[9]+c[8];<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_14c27b045c-6.png" alt="6.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_3a25eb745c-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_43ddb14c5c-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_4f04036e5c-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_515eba325c-10.png" alt="10.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_9040bed05c-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_92bda3c65c-12.png" alt="12.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_94af6ee45c-13.png" alt="13.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_96e8e8165c-14.png" alt="14.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_b5133a945c-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_b7c387305c-16.png" alt="16.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_cbe5e53c5c-17.png" alt="17.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=10000;
int n,a[maxn],c[maxn],s[maxn];

int lowbit(int i)//c[i]的区间长度 
{
	return (-i)&amp;i;
}

void add(int i,int z)//a[i]加上z
{
	for(;i&lt;=n;i+=lowbit(i))//直接后继，即父亲i+=lowbit(i)
		c[i]+=z;	
} 

int sum(int i)//求前缀和a[1]..a[i] 
{
	int s=0;
	for(;i&gt;0;i-=lowbit(i))//直接前驱 i-=lowbit(i);
		s+=c[i];
	return s; 
}

int sum(int i,int j)//求区间和a[i]..a[j] 
{
	return sum(j)-sum(i-1); 
}

int main()
{
	memset(c,0,sizeof(c));
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;a[i];
		add(i,a[i]);//加入树状数组 
	} 
	int x1,x2;
	cin&gt;&gt;x1;
	cout&lt;&lt;sum(x1)&lt;&lt;endl;
	cin&gt;&gt;x1&gt;&gt;x2;
	cout&lt;&lt;sum(x1,x2)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_dbe5964e5c-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_fc9f24365c-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_ff208a885c-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_02536ad65c-21.png" alt="21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_050a62ac5c-22.png" alt="22.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=10000;
int n,a[maxn][maxn],c[maxn][maxn];//二维树状数组 

int lowbit(int i)//区间长度 
{
	return (-i)&amp;i;
}

void add(int x,int y,int z)//a[x][y]加上z
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		for(int j=y;j&lt;=n;j+=lowbit(j))
			c[i][j]+=z;
} 

int sum(int x,int y)//求左上角(1,1)到右下角(x,y)矩阵区间和 
{
	int s=0;
	for(int i=x;i&gt;0;i-=lowbit(i))
		for(int j=y;j&gt;0;j-=lowbit(j))
			s+=c[i][j];
	return s; 
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1); 
}

int main()
{
	for(int i=1;i&lt;=n;i++)
		memset(c[i],0,sizeof(c[i]));
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			cin&gt;&gt;a[i][j];
			add(i,j,a[i][j]);//加入树状数组 
		} 
	int x1,y1,x2,y2;
	cin&gt;&gt;x1&gt;&gt;y1;
	cout&lt;&lt;sum(x1,y1)&lt;&lt;endl;
	cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
	cout&lt;&lt;sum(x1,y1,x2,y2)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2352">poj2352</a><br>
统计x前面比它小的星星的个数。注意的是：给的点的坐标是从0开始的，树状数组下标为0的位置不可用，所以我们需要在输入x坐标时+1。</p>
<p>因为本题给出的数据就是已经按照y从小到大排好序的,也就是说，当前读到一个点的时候，当前点的y坐标肯定比已经读入的大，或者等于。就算是等于的话，也是x坐标比我当前点的x坐标小，所以我们每次只要算x坐标比我们小的就行了 。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_42b726085c-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_fef8cc6a5c-24.png" alt="24.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
#define maxn 32010
int ans[maxn],tr[maxn];//等级统计，每个值的数量 
int n;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x,int c)//将第i个元素增加val，其后继也要增加
{
	for(int i=x;i&lt;=maxn;i+=lowbit(i))//是x点的范围，注意不是星星的个数n 
		tr[i]+=c;//i的后继（父结点） 
}

int sum(int x)//前缀和 
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];//i的前驱
	return res;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int x,y;
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        x++;
        ans[sum(x)]++;
        add(x,1);//x的数量c[x]增1,若是统计小于等于x的数量，则先执行add操作再查询 
    }
    for(int i=0;i&lt;n;i++)
        printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
</code></pre>
<h4 id="树状数组求逆序对">树状数组求逆序对</h4>
<p>1）逆序数问题定义<br>
给一个1~n的排列，求满足i&lt;j且a[i]&gt;a[j]的二元组对数，比如[4,2,1,5,3]这个序列，满足条件的二元组为{&lt;4,2&gt;, &lt;4,1&gt;, &lt;4,3&gt;, &lt;2,1&gt;, &lt;5,3&gt;}，故逆序数是5</p>
<p>2）树状数组求逆序数的原理<br>
首先明确树状数组在此问题中维护信息是某个区间中数字出现的个数，sum(a[i])可求得[1, a[i]]的区间和，这恰好代表第i个数字前小于它的个数，，那么大于它的显然就有sum(n)-sum(a[i])个,然后将源数据按其原本顺序插入树状数组，第i个数字插入的方式为将树状数组的第a[i]位设为1，同时更新覆盖到它的父区间。</p>
<pre><code>for (int i = 1; i &lt;= n; i++) 
{
    ans += sum(n) - sum(a[i]);
    add(a[i], 1);
}
</code></pre>
<p>累加每步的结果后可得逆序数为5，用树状数组的好处在于add操作和sum的操作时间复杂度都为O(logn)，非常的巧妙</p>
<p><a href="https://vjudge.net/problem/POJ-3067">poj3067</a><br>
由于x是从小到大排序的，假设当前我们在处理第k条边，那么第1~k-1条边的x必然是小于（等于时候暂且不讨论）第k条边的 x 的，那么前k-1条边中，与第k条边相交的边的y值必然大于yk的，所以此时我们只需要求出在前k-1条边中有多少条边的y值在区间[yk, M]即可,也就是求yk的逆序数，M为西岸城市个数，即y的最大值。</p>
<p>所以就将问题转化成区间求和的问题，树状数组解决。当两条边的x相同时，我们记这两条边的y值分别为ya，yb（ya&lt;yb),我们先处理（x，ya），再处理（x，yb），原因很明显，因为当x相同时，这两条边是认为没有交点的，若先处理（x，yb），那么下次处理（x，ya）时，（x，ya）就会给（x，yb）增加一个逆序，也就是将这两条边做相交处理了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1010,M=1000010;
int tr[N];
int n,m,k;
struct Edge 
{
    int x, y;
    bool operator&lt; (const Edge &amp;W) const 
    {
    	if(x == W.x)
    		return y&lt;W.y;
    	else
    		return x&lt;W.x;
	}
}e[M];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x)//加1操作，参数省略
{
	for(int i=x;i&lt;=m;i+=lowbit(i))//y点有m个
		tr[i]++;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))
    	res+=tr[i];
    return res;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    for(int kase=1;kase&lt;=T;kase++)
	{
		memset(tr,0,sizeof tr);
	    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	    for(int i=1;i&lt;=k;i++)
			scanf(&quot;%d%d&quot;,&amp;e[i].x,&amp;e[i].y);
	    sort(e+1,e+k+1);
	    LL ans=0;
	    for(int i=1;i&lt;=k;i++)
		{
			ans+=sum(m)-sum(e[i].y);
			add(e[i].y);
	    }
	    printf(&quot;Test case %d: %lld\n&quot;,kase,ans);
	}
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/243/">acwing241</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_933d74f25c-25.PNG" alt="25.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N = 200010;
int n;
int a[N];
int tr[N];
int bigger[N], lower[N];

int lowbit(int x)
{
    return x &amp; -x;
}

void add(int x, int c)
{
    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++ )//从左向右扫
    {
        bigger[i] = sum(n) - sum(a[i]);//1~i-1有多少数大于y（y+1~n）
        lower[i] = sum(a[i]);//1~i-1有多少数小于y（1~y-1）
        add(a[i], 1);
    }

    memset(tr, 0, sizeof tr);
    LL res1 = 0, res2 = 0;
    for (int i = n; i; i -- )//从右向左扫
    {
        res1 += bigger[i] * (LL)(sum(n) - sum(a[i]));//i+1~n有多少数大于y
        res2 += lower[i] * (LL)(sum(a[i]));//i+1~n有多少数小于y
        add(a[i], 1);
    }

    printf(&quot;%lld %lld\n&quot;, res1, res2);

    return 0;
}
</code></pre>
<h4 id="拓展应用">拓展应用</h4>
<h4 id="1树状数组基本应用-单点修改-区间查询">1.树状数组基本应用. 单点修改 + 区间查询</h4>
<h4 id="2区间修改-单点查询">2.区间修改 + 单点查询</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_bad517fb5c-26.PNG" alt="26.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/248/">acwing242</a></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int a[N];
int n,m;
int tr[N];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x,int c)
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		tr[i]+=c;
}

int sum(int x)
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];
	return res;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		add(i,a[i]-a[i-1]);
	}
	
	while(m--)
	{
		char op[2];
		scanf(&quot;%s&quot;,op);
		if(*op == 'C')
		{
		    int l,r,d;
			scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;d);
			add(l,d);
			add(r+1,-d);
		}
		else
		{
		    int x;
		    scanf(&quot;%d&quot;,&amp;x);
			printf(&quot;%d\n&quot;,sum(x));
		}
	}
	return 0;
 } 
</code></pre>
<h4 id="3区间修改-区间查询">3.区间修改 + 区间查询</h4>
<p><a href="https://www.acwing.com/problem/content/244/">acwing243</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_297f0dc65c-27.PNG" alt="27.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_dbf7552a5c-28.PNG" alt="28.PNG" loading="lazy"></p>
<pre><code>//区间加
//区间和
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
const int N=100010;
int n,m;
int a[N];
LL tr1[N];//维护b[i]的前缀和
LL tr2[N];//维护b[i]*i的前缀和

int lowbit(int x)
{
    return x&amp;-x;
}

void add(LL tr[],int x,LL c)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

LL sum(LL tr[],int x)
{
    LL res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=tr[i];
    return res;
}

LL prefix_sum(int x)
{
    return sum(tr1,x)*(x+1)-sum(tr2,x);
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    for(int i=1;i&lt;=n;i++)
    {
        int b=a[i]-a[i-1];//最大为1e9
        add(tr1,i,b);
        add(tr2,i,(LL)i*b);
    }
    
    while(m--)
    {
        char op[2];
        int l,r,d;
        scanf(&quot;%s%d%d&quot;,op,&amp;l,&amp;r);
        if(*op == 'Q')
            printf(&quot;%lld\n&quot;,prefix_sum(r)-prefix_sum(l-1));
        else
        {
            scanf(&quot;%d&quot;,&amp;d);
            add(tr1,l,d);
            add(tr1,r+1,-d);
            add(tr2,l,l*d);
            add(tr2,r+1,(r+1)*-d);
        }
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/245/">acwing244</a><br>
我们发现,如果说第K头牛的前面有Ak头牛比它矮,那么它的身高Hk就是数值1 n中第Ak+1小的没有在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>H</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">H_{k+1},H_{k+2},…,H_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中出现过的数<br>
所以说,我们需要建立一个长度为n的01序列b,刚开始都是1,然后n到1倒序扫描每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,对于每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
执行查询和修改操作.<br>
也就是说这道题目的题意就是让我们,动态维护一个01序列,支持查询第k个1所在的位置,以及修改序列中的一个数值</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int h[N];
int n;
int tr[N];
int ans[N];

int lowbit(int x)
{
    return x&amp;-x;
}

void add(int x,int c)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))  
        res+=tr[i];
    return res;
}

int main()
{
    cin&gt;&gt;n;
    for(int i=2;i&lt;=n;i++)
        cin&gt;&gt;h[i];
        
    for(int i=1;i&lt;=n;i++)   
        tr[i]=lowbit(i);//相当于add(i,1);
    
    for(int i=n;i;i--)
    {
        int k=h[i]+1;
        int l=1,r=n;
        while(l&lt;r)
        {
            int mid=l+r&gt;&gt;1;
            if(sum(mid) &gt;= k)
                r=mid;
            else
                l=mid+1;
        }
        ans[i]=l;
        add(l,-1);
    }
    
    for(int i=1;i&lt;=n;i++)
        cout&lt;&lt;ans[i]&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-1195">poj1195</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_78e266ec5c-29.PNG" alt="29.PNG" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define maxn 1050
#define lowbit(x) (x)&amp;(-x)
int c[maxn][maxn],n;

void add(int x,int y,int z)//单点更新 
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        for(int j=y;j&lt;=n;j+=lowbit(j))
            c[i][j]+=z;
}

int sum(int x,int y)//区间和：左上角(1,1)到右下角(x,y)矩阵区间和 
{
    int s=0;
    for(int i=x;i&gt;0;i-=lowbit(i))
        for(int j=y;j&gt;0;j-=lowbit(j))
            s+=c[i][j];
    return s;
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1);
}

int main()
{
    int opt,x,y,a,l,b,r,t;
	while(scanf(&quot;%d&quot;,&amp;opt)!=EOF)
	{
		if(opt==3) break;
		if(opt==0)
		{
			scanf(&quot;%d&quot;,&amp;n);
    		memset(c,0,sizeof(c));
		}
		else if(opt==1)
		{
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;a);
            ++x;++y;
            add(x,y,a);
        }
        else
		{
            scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;b,&amp;r,&amp;t);
            ++l,++b,++r,++t;
            printf(&quot;%d\n&quot;,sum(l,b,r,t));
        }
	}
    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3321">poj3321</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_3d7817525c-30.png" alt="30.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_4079f47a5c-31.png" alt="31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_5ffe30ea5c-32.png" alt="32.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_4635be445c-33.png" alt="33.png" loading="lazy"></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=1e5+10;
int n,q;
int c[maxn];
int a[maxn];
int L[maxn],R[maxn];
int head[maxn];
int cnt;
int dfn;
struct edge{
    int u,v;
    int next;
}E[2*maxn];

void adde(int u,int v)
{
    E[++cnt].u=u;
    E[cnt].v=v;
    E[cnt].next=head[u];
    head[u]=cnt;
}

int lowbit(int x)
{
    return x&amp;(-x);
}

void add(int x,int v)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        c[i]+=v;
}

int sum(int x)
{
    int ans=0;
    for(int i=x;i;i-=lowbit(i))
    {
        ans+=c[i];
    }
    return ans;
}


void dfs(int u,int fa)
{
    L[u]=++dfn;
    for(int i=head[u];i;i=E[i].next)
    {
        int v=E[i].v;
        if(v==fa) continue;
        dfs(v,u);
    }
    R[u]=dfn;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int u,v;
    for(int i=1;i&lt;=n;i++)
    {
        c[i]=lowbit(i);
        a[i]=1;
    }
    for(int i=1;i&lt;n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        adde(u,v);
    }
    dfs(1,-1);
//	for(int i=1;i&lt;=n;i++)//测试dfs序列 
//    	printf(&quot;--%d %d\n&quot;,L[i],R[i]);
//  	printf(&quot;\n&quot;);	
    scanf(&quot;%d&quot;,&amp;q);
    char op[10];
    for(int i=1;i&lt;=q;i++)
    {
        scanf(&quot;%s%d&quot;,op,&amp;v);
        if(op[0]=='C')
        {
        	int j=L[v];
            if(a[j])//由于每个节点的dfn编号就是它的左值，所以直接修改左节点
                add(j,-1);
            else
                add(j,1);
            a[j]^=1;
        }
        else
        {
            int s1=sum(R[v]);
            int s2=sum(L[v]-1);
            printf(&quot;%d\n&quot;,s1-s2);
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数论]]></title>
        <id>https://caifxh.github.io/post/shu-lun/</id>
        <link href="https://caifxh.github.io/post/shu-lun/">
        </link>
        <updated>2020-03-26T13:38:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="数论">数论</h3>
<h4 id="除法和模运算">除法和模运算</h4>
<p>计算机中整数和整数的除法是整数除法，即 a ÷ b = ⌊ ab ⌋.<br>
模运算即是两数相除的余数，在 c++ 的代码中用 a%b 来计算这<br>
个数字，通过一些小学知识我们容易得到<br>
a % b = a − ⌊a/b⌋ × b</p>
<h4 id="整除性和约数">整除性和约数</h4>
<p>整除是数论中的一个中心概念。<br>
如果两个数字 a, b, 满足 a % b = 0 , 那么我们就说 a 是 b 的倍数，同时也说 b 是 a 的约数，计做 b | a 。<br>
在通常情况下，我们考虑一个数字的约数和倍数，都只考虑他的正约数和正倍数。<br>
• 记号 d | a 意味着对某个整数 k，有 a = kd。<br>
• 0 可被任何整数整除。0=0*d,d|0<br>
• 如果 d | a 我们称 a 是 d 的倍数，d 是 a 的约数。<br>
• 一个整数 a 的约数最小为 1， 最大为 |a|。 • 例如：12 的约数有 1, 2, 3, 4, 6, 12</p>
<p>求约数<br>
如何才能求出一个数字 n 的所有约数呢？<br>
一个非常朴素的方法, 从 1 到 n 枚举，复杂度 O(n)<br>
注意到约数总是成对出现的，即如果有 a ÷ b = c 就一定会有a ÷ c = b<br>
我们以 ⌊√n⌋ 作为一个限度，只枚举到 √n(注意 n 是完全平方数的情况)</p>
<pre><code>vector&lt;int&gt; get_div(int x)
{
    vector&lt;int&gt; res;
    for (int i = 1; i &lt;= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}

int main()
{
    int n;
    cin &gt;&gt; n;

    while (n -- )
    {
        int x;
        cin &gt;&gt; x;
        auto res = get_div(x);

        for (auto x : res) cout &lt;&lt; x &lt;&lt; ' ';
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="求倍数">求倍数</h4>
<p>一个数字的倍数有无穷多个，所以很难求出所有的倍数，我们通常只求出 n 以内 a 的所有倍数。<br>
和求约数相同，我们同样可以想到一个 O(n) 的简单方法，即枚举<br>
对于一个数字 a , 他的所有倍数一定是 a, 2a, 3a, 4a, . . . , ⌊n/a⌋a, 每个倍数都比前一个倍数多 a, 所以我们可以从 a 开始每次加 a 枚举他的下一个倍数<br>
复杂度分析：考虑一种极限情况，a = 1 , 此时枚举相当于从 1枚举到 n , 所以复杂度其实还是 O(n)<br>
然而我们后面会看到，如果对于每个数字都枚举倍数的话，复杂度会有所下降。</p>
<h4 id="素数和合数">素数和合数</h4>
<p>对于某个整数 a &gt; 1，如果它仅有约数 1 和 a，则称 a 为素数（或质数）<br>
前 10 个素数: 2, 3, 5, 11, 13, 17, 19, 23, 29, 31<br>
不是素数的整数 a &gt; 1 称为合数。<br>
例如，因为 2 | 10，所以 10 是合数。<br>
整数 1 既不是素数也不是合数<br>
如何判断一个数字是否是质数呢？定义判断即可</p>
<pre><code>bool is_prime(int x)
{
    if(x&lt;2)
        return false;
    for(int i=2;i&lt;=x/i;i++)
    {
        if(x%i==0)
            return false;
    }
    return true;
}

int main()
{
    int n;
    cin&gt;&gt;n;
    while(n--)
    {
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        if(is_prime(x))
            puts(&quot;Yes&quot;);
        else
            puts(&quot;No&quot;);
    }
    return 0;
}
</code></pre>
<h4 id="埃拉托斯特尼筛法">埃拉托斯特尼筛法</h4>
<p>埃氏筛法的原理是：每个合数都是多个质数的积；那么从最小的质数2开始，用每一个质数去筛比它大的数，就能筛掉合数。埃氏筛法低效的原因是，一个合数会被它的多个质因子重复筛。<br>
我们考虑这样一个事实，如果一个数字是另外一个数字的倍数，那么这个数字一定不是素数，既然这样我们每枚举到一个数字 i，就可以把他所有的倍数全都设置成不是质数，这样从来没被标记过的数字就是质数了。<br>
算法思想：每个质数都可以把它的倍数筛掉<br>
时间复杂度：O(nloglogn)</p>
<pre><code>int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i &lt;= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j &lt;= n; j += i)
            st[j] = true;
    }
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="https://www.luogu.com.cn/problem/P2926">bzoj1607</a><br>
题意：给定 n 个数，对于其中的每一个数字，询问有多少个数是他的约数。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_96e374aa65-24.PNG" alt="24.PNG" loading="lazy"><br>
<a href="https://paste.ubuntu.com/p/XdnQz8KSnG/">代码</a></p>
<h4 id="线性筛欧拉筛">线性筛（欧拉筛）</h4>
<p>再次把眼光放回如何判断 [1, n]中哪些数字是质数这个问题上来。考虑之前的做法为什么会运行的比较缓慢呢？事实上我们在确认一个数字不是质数的时候，要用很多数字来筛选他才可以，比如数字 6, 我们在枚举 2的倍数的时候筛了他一次，在枚举 3 的倍数的时候筛了他一次，有没有什么办法能够让他只被筛选一次呢？<br>
考虑这样一种想法，如果每个数字都只被他最小的质约数筛一次，那么复杂度就可以达到 O(n)。可是如何才能实现呢？这是一个类似构造的想法</p>
<p>$i=p_1^{k_1} * p_2^{k_2} * ... * p_s^{k_s} <span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>i * primes[j]=primes[j] * p_1^{k_1} * p_2^{k_2} * ... * p_s^{k_s}<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">当</mi><mi>i</mi><mi mathvariant="normal">当</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">
当i%primes[j]不为0时，i*primes[j]的最小质因数为primes[j];
当i%primes[j]为0之后，i*primes[j]的最小质因数为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">当</span><span class="mord mathdefault">i</span></span></span></span>p_1$而不是primes[j],此时不能再用primes[j]筛去，否则违背只用最小质因数筛的方法。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_f46c7ee064-14.png" alt="14.png" loading="lazy"></p>
<pre><code>int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i &lt;= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] &lt;= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
</code></pre>
<h4 id="线性筛欧拉函数">线性筛欧拉函数</h4>
<p>回顾一下，我们在求逆元的时候介绍了一个函数，欧拉函数φ(n), 并介绍了一种 √n求一个欧拉函数的方法，现在我们考虑能不能 O(n) 时间内求出 [1, n] 每个数字的欧拉函数函数值呢？<br>
考虑在线性筛的同时能不能把欧拉函数值也更新一下，注意到线性筛的时候每个数字只会被筛到一次，我们能否在这个时候顺便求出欧拉函数的函数值呢？<br>
考虑他在被筛的时候函数的取值应该是多少</p>
<p>i. I是个质数,phi(p)=p-1<br>
2.如果i % primes[j] = 0, 那么phi(i * primes[j])=primes[j] * phi(i)<br>
原因：i<em>primes[j]的质因数构成和i相同，但primes[j]的次数多1<br>
3.如果 i%prime[j] 不为 0，即primes[j]小于i的最小质因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<br>
phi(i * primes[j]) = phi(i) * primes[j]</em>(1-1/primes[j]) = phi(i)*(primes[j]-1)<br>
也可根据欧拉函数的积性， i mod primes[j] 不为0且primes[j]为质数,所以i与primes[j]互质,<br>
phi(i * primes[j])=phi(i) * phi(primes[j]) 其中phi(primes[j])=primes[j]-1即第一条性质</p>
<pre><code>int primes[N],cnt;
int eulers[N];
bool st[N];

void get_eulers(int n)
{
    eulers[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            eulers[i]=i-1;
        }
        for(int j=0;primes[j]&lt;=n/i;j++)
        {
            int t=i*primes[j];
            st[t]=true;
            if(i%primes[j]==0)
            {
                eulers[t]=eulers[i]*primes[j];
                break;
            }
            eulers[t]=eulers[i]*(primes[j]-1);
        }
    }
}
</code></pre>
<p>积性函数都可以用欧拉筛来求</p>
<h4 id="整除分块数论分块">整除分块（数论分块）</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_86fb14d668-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_a913289c68-11.PNG" alt="11.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_fa92443268-12.PNG" alt="12.PNG" loading="lazy"><br>
证明细节见：<br>
https://blog.csdn.net/qq_41021816/article/details/84842956</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    long long n,ans=0;
    cin &gt;&gt; n;
    for(long long l=1,r;l&lt;=n;l=r+1){
        r = n/(n/l);            //计算r，让分块右移
        ans += (r-l+1)*(n/l);   //求和
        cout &lt;&lt; l &lt;&lt;&quot;&quot;&lt;&lt; r &lt;&lt;&quot;: &quot;&lt;&lt; n/r &lt;&lt; endl;  //打印分块
    }
    cout &lt;&lt; ans;               //打印和
}
</code></pre>
<h4 id="积性函数">积性函数</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_8743c9c868-3.PNG" alt="3.PNG" loading="lazy"><br>
常见的积性函数<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_ea94e71e68-5.PNG" alt="5.PNG" loading="lazy"><br>
积性函数性质<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_65c35fe064-17.png" alt="17.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_b8d1239864-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_fffea8de65-19.PNG" alt="19.PNG" loading="lazy"><br>
p为质数</p>
<h4 id="积性函数的基本问题">积性函数的基本问题</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_a550991468-4.PNG" alt="4.PNG" loading="lazy"></figure>
<h4 id="狄利克雷卷积">狄利克雷卷积</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_b252416668-13.PNG" alt="13.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_f4f399a268-14.png" alt="14.png" loading="lazy"></p>
<h4 id="线性筛求莫比乌斯函数">线性筛求莫比乌斯函数</h4>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_ec2a1d2c68-17.PNG" alt="17.PNG" loading="lazy"></figure>
<pre><code>int primes[N],cnt;
int miu[N];
bool st[N];

void get_eulers(int n)
{
	memset(st,0,sizeof st);
    miu[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            miu[i]=-1;
        }
        for(int j=0;i*primes[j]&lt;=n;j++)
        {
            int t=i*primes[j];
            st[t]=true;
            if(i%primes[j]==0)
            {
                miu[t]=0;
                break;
            }
            miu[t]=-miu[i];//积性函数性质，miu[i]*miu[primes[j]]
        }
    }
}
</code></pre>
<h5 id="莫比乌斯函数性质">莫比乌斯函数性质</h5>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_174abc2868-18.PNG" alt="18.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_52dc47a668-19.PNG" alt="19.PNG" loading="lazy"></p>
<h4 id="莫比乌斯函数的由来">莫比乌斯函数的由来</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_558a917668-15.PNG" alt="15.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_b130ab1468-16.PNG" alt="16.PNG" loading="lazy"></p>
<h4 id="杜教筛">杜教筛</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_e027961068-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_a04adc4668-50.PNG" alt="50.PNG" loading="lazy"><br>
经典的杜教筛题目，例如洛谷P4213，求数论函数的前缀和。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_c85d9f1668-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_0c2fb4a468-2.png" alt="2.png" loading="lazy"></p>
<h4 id="杜教筛公式推导">杜教筛公式推导</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_56ae7dbc68-21.PNG" alt="21.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_5d014d2868-22.PNG" alt="22.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_5f7f273c68-23.png" alt="23.png" loading="lazy"></p>
<h4 id="唯一的因子分解">唯一的因子分解</h4>
<figure data-type="image" tabindex="3"><img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_27bbfea661-35.PNG" alt="35.PNG" loading="lazy"></figure>
<h4 id="约数倍数的特征">约数倍数的特征</h4>
<figure data-type="image" tabindex="4"><img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_c51b34ec64-28.PNG" alt="28.PNG" loading="lazy"></figure>
<h4 id="求质约数">求质约数</h4>
<p>注意到一个数字 n 最多只有一个 &gt; √n 的质约数，所以我们仍然只需要枚举到 √n<br>
一个非常朴素的方法是枚举每个数字，判断是否是约数并判断是否是素数，但是这个方法的复杂度接近 O(n)，并不是一个非常明智的选择<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_eefac25a64-29.PNG" alt="29.PNG" loading="lazy"></p>
<pre><code>void divide(int x)
{
    for (int i = 2; i &lt;= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;
        }
    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;
    cout &lt;&lt; endl;
}

int main()
{
    int n;
    cin &gt;&gt; n;
    while (n -- )
    {
        int x;
        cin &gt;&gt; x;
        divide(x);
    }

    return 0;
}
</code></pre>
<h4 id="快速分解质因数">快速分解质因数</h4>
<p>我们来考虑求出的 prime 数组的一个应用<br>
如何能够在线性筛之后快速的分解一个数字的质约数呢？考虑在筛掉一个数字的时候记录一下他是被哪个质数筛掉的也即他的最小的质约数是谁。这样我们只要每次除掉一个最小的质约数就可以了。</p>
<pre><code>for(int j = 1; prime[j] * i &lt;= Max; ++ j) {
	from[i*prime[j]] = prime[j];
	...
}
</code></pre>
<p>查询时只需递归查询from[x],from[x/from[x]]...,一次查询的时间复杂度是O(logn)</p>
<h4 id="约数个数-约数和">约数个数 约数和</h4>
<p>对于一个大于1正整数n可以分解质因数：n=p1<sup>a1*p2</sup>a2*p3<sup>a3*…*pk</sup>ak,<br>
则由约数个数定理可知n的正约数有(a₁+1)(a₂+1)(a₃+1)…(ak+1)个，</p>
<pre><code>int main()
{
    int n;
    cin &gt;&gt; n;

    unordered_map&lt;int, int&gt; primes;

    while (n -- )
    {
        int x;
        cin &gt;&gt; x;

        for (int i = 2; i &lt;= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x &gt; 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes) res = res * (p.second + 1) % mod;

    cout &lt;&lt; res &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为<br>
f(n)=(p1<sup>0+p1</sup>1+p1<sup>2+…p1</sup>a1)(p2<sup>0+p2</sup>1+p2<sup>2+…p2</sup>a2)…(pk<sup>0+pk</sup>1+pk<sup>2+…pk</sup>ak）</p>
<pre><code>LL res = 1;
for (auto p : primes)
{
    LL a = p.first, b = p.second;
    LL t = 1;
    while (b -- ) t = (t * a + 1) % mod;
    res = res * t % mod;
}
cout &lt;&lt; res &lt;&lt; endl;
</code></pre>
<h4 id="除法定理">除法定理</h4>
<p>对任意整数 a 和任意正整数 n， 存在唯一的整数 q 和 r，<br>
满足 0 &lt;= r &lt; n，并且 a = qn + r.<br>
值 q = a / n称为除法的商<br>
值 r = a mod n 称为除法的余数。<br>
n | a 当且仅当 a mod n = 0。</p>
<h4 id="模-n-等价类">模 n 等价类</h4>
<p>包含整数 a 的模 n 等价类为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>𝒂</mi><msub><mo>]</mo><mi>𝒏</mi></msub></mrow><annotation encoding="application/x-tex">[𝒂]_𝒏</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord boldsymbol" style="margin-right:0.09426em;">a</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight" style="margin-right:0.09426em;">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>= {𝒂 + 𝒌𝒏: 𝒌𝝐𝒁}<br>
例如，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>𝟑</mi><msub><mo>]</mo><mi>𝟕</mi></msub></mrow><annotation encoding="application/x-tex">[𝟑]_𝟕</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathbf">3</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>= {… , −11, −𝟒, 𝟑, 10, 17, … }<br>
𝒃𝝐<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>𝒂</mi><msub><mo>]</mo><mi>𝒏</mi></msub></mrow><annotation encoding="application/x-tex">[𝒂]_𝒏</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord boldsymbol" style="margin-right:0.09426em;">a</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight" style="margin-right:0.09426em;">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 等同于b = a (mod n)<br>
-1 = n – 1 (mod n)</p>
<h4 id="公约数与最大公约数">公约数与最大公约数</h4>
<p>如果 d 是 a 的约数并且也是 b 的约数，则 d 是 a 与 b 的公约数。<br>
例如，12 的约数是 1, 2, 3, 4, 6, 12，因此 8 与 12 的公约数为 1, 2, 4。 1 是任意两个整数的公约数。<br>
公约数的重要性质为：<br>
d | a 且 d | b 蕴含着 d | (a + b) 且 d | (a–b)<br>
更一般的，对任意整数 x 和 y，有<br>
d | a 且 d | b 蕴含着 d | (ax + by)</p>
<p>两个不同时为 0 的整数 a 与 b 的最大公约数表示成gcd(a, b)。<br>
例如 gcd(12, 8) = 4，gcd(5, 9) = 1, gcd(0, 4) = 4.<br>
定义 gcd(0, 0) = 0<br>
gcd 函数的基本性质：<br>
• gcd(a, b) = gcd(b, a)<br>
• gcd(a, b) = gcd(-a, b)<br>
• gcd(a, b) = gcd(|a|, |b|)<br>
• gcd(a, 0) = |a|<br>
• gcd(a, ka) = |a|</p>
<h4 id="gcd-的其他性质">gcd 的其他性质</h4>
<p>如果 a 和 b 是不都为 0 的任意整数，则 gcd(a, b) 是a 与 b 的线性组合集合 {ax + by: x, y ∈ Z}中的最小正元素。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_f657763461-34.PNG" alt="34.PNG" loading="lazy"></p>
<h4 id="裴蜀定理">裴蜀定理</h4>
<p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。<br>
它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.<br>
上述裴蜀定理针对的是两个变量。那么我们很自然的就想到这样的定理能否推广到多个变量呢？显然可以，证明方法同上<br>
<a href="https://www.luogu.com.cn/problem/P4549">模板题</a><br>
我们只需要对这所有的数字求一个gcd，值得注意的是不要忘记数据中有负数，要将其变为正数再求gcd,因为系数的最终答案没有影响。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int n;

int gcd(int a,int b)
{
	return b?gcd(b,a%b) : a;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int ans=0;
	for(int i=0;i&lt;n;i++)
	{
		int x;
		scanf(&quot;%d&quot;,&amp;x);
		if(x&lt;0)	
			x=-x;
		ans=gcd(ans,x);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
<h4 id="gcd-的其他性质-2">gcd 的其他性质</h4>
<p>• 对于任意整数 a 和 b，如果 d | a 并且 d | b，则d | gcd(a, b)<br>
证明：gcd(a,b)|a,gcd(a,b)|b,则gcd为最大的约数，则d | gcd(a, b)</p>
<p>• 对所有正整数 n, a 和 b，如果 n | ab 且 gcd(a, n)=1，则 n | b</p>
<h4 id="互质数">互质数</h4>
<p>如果两个整数 a 和 b 仅有公因数 1，即如果 gcd(a, b) = 1，则 a 与 b 称为互质数。<br>
例如，5 和 9 是互质数。</p>
<p>对任意整数 p, a 和 b，如果 gcd(a, p) = gcd(b, p) = 1， 则 gcd(ab, p) = 1<br>
证明：由线性组合的定理可知，存在整数x,y,x’ ，y’, 满足ax+py=1,bx’+py’=1<br>
把上面两个等式两边相乘，整理得<br>
ab(x x’)+p(ybx’+y’ax+pyy’)=1<br>
因为1是ab与p的一个正线性组合，所以可以证明所需结论</p>
<h4 id="欧几里得算法">欧几里得算法</h4>
<p>欧几里得算法求最大公约数<br>
利用性质：gcd(a, b) = gcd(b, a % b)</p>
<pre><code>int gcd(int a, int b)
{
    return b?gcd(b,a%b):a;
}
</code></pre>
<p>因为每次取模，a 至少会变成原来的二分之一。<br>
整个算法是 O(log n) 的。<br>
求出了 gcd，就可以求出 lcm。</p>
<pre><code>int lcm(int a, int b)
{
    return a / gcd(a, b) * b;
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_80e1553864-30.png" alt="30.png" loading="lazy"></figure>
<h4 id="例题-2">例题</h4>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2503">hdu2503</a><br>
给定 a, b, c, d (0 &lt; a,b,c,d &lt; 1000)。 求 a/b + c/d 的最简形式 e/f。</p>
<blockquote></blockquote>
<p>样例输入：<br>
1 2 1 3<br>
样例输出：<br>
5 6</p>
<p>先通分，求b和d的最小公倍数。<br>
分子相加后，再约掉分子和分母的最大公约数就是答案。<br>
<a href="https://paste.ubuntu.com/p/8ScCf2zhgh/">代码</a></p>
<h4 id="扩展欧几里得算法与二元一次方程的整数解">扩展欧几里得算法与二元一次方程的整数解</h4>
<p>给出整数a,b,n,问方程ax+by=n什么时候有整数解？如何求出所有的整数解?<br>
<code>有解的充分必要条件是gcd(a,b)可以整除n</code><br>
证明：令a=gcd(a,b)a',b=gcd(a,b)b',有ax+by=gcd(a,b)(a'x+b'y)=n;如果x,y,a',b'都是整数，那么n必须是gcd(a,b)的倍数才有解.<br>
例如，4x+6y=8,2x+3y=4有整数解，4x+6y=7没有整数解。<br>
如果有解，一种解题方法是先找到一个解（x0,y0）,那么通解公式如下：<br>
x=x0+bt,y=y0-at,t是任意整数。</p>
<p>扩展欧几里得算法能计算出满足下列条件的整系数 x 和 y：gcd(a, b) = ax + by<br>
我们来直接推倒一下：<br>
ax + by = gcd(a, b)<br>
注意到由欧几里得算法得：<br>
gcd(a, b) = gcd(b, a % b)<br>
因此：<br>
ax + by = bx' + (a % b)y'<br>
= bx' + (a - int(a / b)b)y'<br>
= ay' + b(x - int(a / b)y')<br>
ax + by = ay' + b(x' - int(a / b)y')<br>
每次求gcd的递归过程中同时将系数x，y计算出来，令x=y',y=x'-a/b*y'</p>
<p>例：求 9x + 7y = 1 的一组整数解<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_ad03d25864-31.png" alt="31.png" loading="lazy"></p>
<pre><code>int exgcd(int a, int b, int &amp;x, int &amp;y) {
	if (!b) {
		x = 1, y = 0;
		return a;
	}
	int d = exgcd(b, a % b, x, y);
	int t = x;
	x = y;
	y = t - a / b * y;
	return d;
}
</code></pre>
<h4 id="拓展欧几里得算法的应用">拓展欧几里得算法的应用</h4>
<p>更一般的，求解 ax + by = c<br>
只要 gcd(a, b) | c 就有无数解，否则无解<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_4a0f4a9464-4.PNG" alt="4.PNG" loading="lazy"></p>
<h4 id="逆元">逆元</h4>
<p>乘法逆元：对于一个数字 a, 在模 p 意义下如果存在一个数字 b,<br>
满足 a × b ≡ 1 (mod p), 我们就称 b 是模 p 意义下 a 的乘法逆元，记做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 。<br>
容易发现<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_992c32c264-2.PNG" alt="2.PNG" loading="lazy"><br>
现在我们可以对分子分母取模了！所以进行模运算的重点变成了求逆元。</p>
<h4 id="欧拉函数">欧拉函数</h4>
<p>欧拉函数 φ(n), 定义为 1 到 n 中与 n 互质的数字的个数。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_154c8e8068-6.PNG" alt="6.PNG" loading="lazy"><br>
通过定义容易得到欧拉函数的前几项 1, 1, 2, 2, 4, 2, 6, · · ·<br>
通过定义我们也很容易得到一个质数 p 的欧拉函数 φ(p) = p-1<br>
我们也很容易写出一个求欧拉函数的简易做法，枚举<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_08442e5e68-9.png" alt="9.png" loading="lazy"><br>
注意相同的质约数都是相同的 pi<br>
有了这个公式我们就可以快速的求出一个数字 n 的欧拉函数φ(n) 了。<br>
所以，欧拉函数ϕ(n)的求解，归结到了分解质因子这个问题。试除法：求n的质因子时，逐个检查从2到√n的所有质数，如果它能整除n，就是一个因子。试除法的复杂度是O(√n)</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

int phi(int x)
{
    int res=x;
    for(int i=2;i&lt;=x/i;i++)
    {
        if(x%i==0)
            res=res/i*(i-1);
        while(x%i==0)
            x/=i;
    }
    if(x&gt;1)
        res=res/x*(x-1);
    return res;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    {
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        cout&lt;&lt;phi(x)&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h4 id="数论中的欧拉定理">数论中的欧拉定理</h4>
<p>如果 gcd(a, p) = 1 , 即 a, p 互质则有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> ≡ 1 (mod p)<br>
注意这个定理的强制性要求是 a, p 互质，如果 a, p 不互质直接用这个做法是做不了的，我们还需要拓展欧拉定理才能处理这个问题<br>
由此可以得到求 a 模 m 的逆的方法。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>≡ 1 (mod m)<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a * a^{φ(m)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ≡ 1 (mod m)<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(m)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 就是 a 模 m 的逆。</p>
<h4 id="欧拉定理求逆元">欧拉定理求逆元</h4>
<p>有了这个定理我们要怎么求逆元呢？考虑逆元的定义，对于一个数字 a , 我所要寻找的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 需要满足 a × <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ≡ 1 (mod p), 而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> ≡ 1 (mod p), 这对于我们是否有一些启示呢？<br>
我们将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>写成 a × <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>p</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(p)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 我们惊喜的发现原来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 启示就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>p</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(p)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> !<br>
所以在求出欧拉函数之后我们只需要快速幂就能得到一个数字的逆元了。</p>
<pre><code>int get_inv(int a) {
    return Pow(a,phi(p)-1);
}
</code></pre>
<p>有很多题目中给定的 p 是个质数，就是费马小定理。<br>
如果 a, p 不互质怎么求逆元呢？事实上在后面我们会看到，<code>a, p 不互质的情况下是不存在模 p 意义下 a的逆元的</code>。</p>
<h4 id="欧拉定理求同余方程">欧拉定理求同余方程</h4>
<p>对于同余方程 ax ≡ b (mod m)<br>
两边同乘 a 的逆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(m)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ax ≡ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(m)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> b (mod m)<br>
就可以得到 x ≡ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(m)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> b (mod m)<br>
比如：由φ(10) = 4，对于同余方程 3x ≡ 7 (mod 10)<br>
解为 x ≡ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{φ(m)-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> b ≡ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> * 7 ≡ 9 (mod 10)</p>
<h4 id="扩展欧拉定理">扩展欧拉定理</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_453fa94264-3.PNG" alt="3.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/14/9969_fad90a3c65-25.png" alt="25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/14/9969_e91b801865-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG" loading="lazy"><br>
<a href="https://www.luogu.com.cn/problem/P5091">模板题</a><br>
<a href="https://paste.ubuntu.com/p/4gKK4xy8YN/">代码</a></p>
<h4 id="欧拉函数的性质">欧拉函数的性质</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_4fb5316c68-7.PNG" alt="7.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_e0b6619c64-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_02be7b0864-11.PNG" alt="11.PNG" loading="lazy"></p>
<p>φ(36)=φ(4)φ(9)<br>
第二行和第四行，每个元素都不和 4 互素。<br>
剩下的两行，每个元素都和 4 互素，但各有 6 个数和 9 互素<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_823451c864-12.PNG" alt="12.PNG" loading="lazy"></p>
<figure data-type="image" tabindex="6"><img src="https://cdn.acwing.com/media/article/image/2020/03/18/9969_a838dfd268-8.PNG" alt="8.PNG" loading="lazy"></figure>
<h4 id="同余">同余</h4>
<p>一个便于理解的定义：如果对于两个数字 a, b , 对于一个数字 m的余数相等，我们认为他们对于 m 同余<br>
在数学上的标准定义：设 m 是给定的一个正整数，a, b 是整数，<br>
若满足 m|(a - b) , 则称 a 与 b 对模 m 同余，记做 a ≡ b (mod m)</p>
<ol>
<li>(a + b)%c 是否等于 ((a%c) + (b%c))%c</li>
<li>a ∗ b%c 是否等于 ((a%c) ∗ (b%c))%c</li>
<li>a/b%c 是否等于 (a%c)/(b%c)<br>
对于 1，2 两个式子来说，是正确的，而对于第三个式子来说，是错误的</li>
</ol>
<h4 id="线性同余方程">线性同余方程</h4>
<p>设 x 是未知整数，形如ax ≡ b (mod m)的同余式成为一元线性同余方程<br>
ax ≡ b (mod m)，即ax除以m,b除以m,两者余数相同，这里a,b,m都是整数，求解x的值。<br>
方程也可以这样理解，ax-b是m的整数倍。设y是倍数，那么ax-b=my,移项得到ax-my=b.因为y可以是负数，改写为ax+my=b，这就是在扩展欧几里得算法中提到的二元一次不定方程。<br>
<code>当且仅当gcd(a,m)能整除b时有整数解。</code></p>
<p>ax ≡ 1 (mod m) 的解称为 a 模 m 的逆。<br>
如 7x ≡ 1 (mod 31) 的解满足 x ≡ 9 (mod 31)<br>
设a 模 m 的一个逆为 k，即 ak ≡ 1 (mod m)<br>
对于 ax ≡ b (mod m)，两边同乘以 k，得到 akx ≡ bk(mod m)<br>
也即 x ≡ bk (mod m)</p>
<p>定理：设 p 是素数，正整数 a 是其自身模 p 的逆，当且仅当 a ≡ 1 (mod p) 或 a ≡ -1 (mod p)<br>
证明：若a ≡ 1 (mod p) 或 a ≡ -1 (mod p),则a² ≡ 1 (mod p) ,所以a其自身模p的逆。反过来，若a是其自身模p<br>
的逆，则a²=a·a ≡ 1 (mod p) 。因此，p |(a² -1)。又因为a² -1=（a-1）（a+1），所以p |（a-1）或p |（a+1）。<br>
因此，或者a ≡ 1 (mod p) ，或者a ≡ -1 (mod p)</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

int exgcd(int a,int b,int &amp;x,int &amp;y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    
    int d=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return d;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    {
        int a,b,m;
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;m);
        int x,y;
        int d=exgcd(a,m,x,y);
        if(b%d)
            puts(&quot;impossible&quot;);
        else
            printf(&quot;%d\n&quot;,((long long)b/d*x%m+m)%m);
    }
    return 0;
}
</code></pre>
<h4 id="扩展欧几里得求乘法逆元">扩展欧几里得求乘法逆元</h4>
<p>ax = 1 (mod m)<br>
ax + my = 1<br>
也就是 a, m 是已知数，现在要求出一组 x, y , 使得上面的式子成立。<br>
这也就印证了上面欧拉定理中的一句话，如果想要存在 a 对 m 的逆元，必须要 gcd(a, m) = 1 (1%gcd(a,m) = 0)才可以<br>
当然如果 gcd(a, m) != 1，就无解<br>
注意到 x 的解是 x0 + km （k是任意整数）<br>
我们只要求出一个 k 使得 x0 + km 是最小的正整数即可。<br>
另外需要注意的是我们求出的 x 有可能是负数，这时候我们可以让 x 加上若个个 p, 这样显然是不会影响方程的，例如我在 x 上加了一个 p, 那么在 y 上减去 a 就能保证方程依然成立。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_ab98002464-1.PNG" alt="1.PNG" loading="lazy"></p>
<h4 id="费马小定理">费马小定理</h4>
<p>假如 p 是质数，且 (a, p)=1，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{p-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ≡ 1 (mod p)<br>
因此可以得到，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a * a^{p-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> ≡ 1 (mod p)<br>
所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{p-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 是 a 模 p 的一个逆。<br>
可以用快速幂加速计算。</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
int qml(int a,int b,int p)
{
    int res=1;
    while(b)
    {
        if(b&amp;1)
            res=(LL)res*a%p;
        a=(LL)a*a%p;
        b&gt;&gt;=1;
    }
    return res;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    {
        int b,p;
        scanf(&quot;%d%d&quot;,&amp;b,&amp;p);
        if(b%p==0)
            puts(&quot;impossible&quot;);
        else
            printf(&quot;%d\n&quot;,qml(b,p-2,p));
    }
    return 0;
}
</code></pre>
<h4 id="线性求逆元">线性求逆元</h4>
<p>给定 n, p 求 [1, n] 中所有整数在模 p 意义下的乘法逆元，n ≤ 2 × 1e6, p ≤ 2 × 1e7。<br>
我们考虑从 1 到 n 依此求出每个数字的逆元，枚举变量 i, 1 → n,<br>
默认 [1, i - 1] 每个数字对于 p 的逆元都已经求完,现在我们考虑 i 对 p 的逆元要怎么求。<br>
不妨把 p 写成 ki + b 的形式也即<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_2c9b0d0664-5.PNG" alt="5.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_3ba6cc0464-6.PNG" alt="6.PNG" loading="lazy"><br>
<a href="https://www.luogu.com.cn/problem/P3811">模板题</a></p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=3e6+10;
int inv[N];
int main()
{
    int n,p;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);
    inv[1]=1;
    for(int i=2;i&lt;=n;i++)
        inv[i]=(LL)(p-p/i)*inv[p%i]%p;
    for(int i=1;i&lt;=n;i++)
    	printf(&quot;%d\n&quot;,inv[i]);
    return 0;
}
</code></pre>
<h4 id="阶乘的逆元">阶乘的逆元</h4>
<p>这里特别列出阶乘的逆元，因为后面有组合数学和组合数取模相关的问题，所以这里特别列出了阶乘如何求逆元。<br>
有很多同学会认为先求出 [1, n] 每个数字对p的逆元就可以了。这样处理确实可以，但是过于繁琐，我们考虑一共更简单的做法。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_8a75940664-7.PNG" alt="7.PNG" loading="lazy"></p>
<pre><code>int ifac[N], fac = 1, mod;
for(int i = 2; i &lt;= n; ++ i) 
	fac = (long long) fac * i % mod;
ifac[n] = get_inv(fac, mod);
for(int i = n - 1; i &gt;= 0; -- i) 
	ifac[i] = (long long)ifac[i + 1] * (i + 1) % mod;
</code></pre>
<h4 id="线性同余方程组">线性同余方程组</h4>
<p>第一种：有两个以上的不同模的一元线性同余方程；<br>
第二种：变元数大于 1，方程数大于 1，但是方程的模相同</p>
<h4 id="中国剩余定理">中国剩余定理</h4>
<p>下面取自成书于公元 3 世纪晚期的《孙子算经》的问题。<br>
求一个数，它被 3 除余 1，被 5 除余 2，被 7 除余 3。<br>
这也就等价于如下方程组：<br>
x ≡ 1 (mod 3)<br>
x ≡ 2 (mod 5)<br>
x ≡ 3 (mod 7)</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_6222a04265-21.PNG" alt="21.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_82650ca065-22.PNG" alt="22.PNG" loading="lazy"><br>
正确性显然，代入即可。还需要证明唯一性。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/13/9969_b28449d265-23.PNG" alt="23.PNG" loading="lazy"></p>
<p>x ≡ 1 (mod 3)<br>
x ≡ 2 (mod 5)<br>
x ≡ 3 (mod 7)<br>
现在回到开头的那个方程组，首先有 M = 105<br>
M1 = 35，M2 = 21，M3 = 15<br>
y1 = 2, y2 = 1, y3 = 1<br>
因此 x ≡ 1 * 35 * 2 + 2 * 21 * 1 + 3 * 15 * 1 ≡ 157≡ 52 (mod 105)</p>
<p>中国剩余定理给出了模数两两互质的线性同余方程组的一个特殊解。方程组的通解可以表示为x+kM（k∈Z）。有些题目要求我们求出最小的非负整数解，只需把x对M取模，并让x落在0~M-1的范围内即可。<br>
<a href="https://www.luogu.com.cn/problem/P1495">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=15;
int n;
int a[N],b[N];

void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)
{
	if(!b)
	{
		x=1,y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	LL t=x;
	x=y;
	y=t-a/b*y;
}

LL crt()
{
	LL M=1,res=0;
	for(int i=1;i&lt;=n;i++)
		M*=a[i];
	for(int i=1;i&lt;=n;i++)
	{
		LL m,x,y;
		m=M/a[i];
		exgcd(m,a[i],x,y);
		res=(res+m*x*b[i])%M;
	}
	return (res%M+M)%M;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]);
	printf(&quot;%lld\n&quot;,crt());
	return 0;
}
</code></pre>
<h4 id="扩展中国剩余定理">扩展中国剩余定理</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_7649d6c267-36.PNG" alt="36.PNG" loading="lazy"><br>
证明：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_64d72d8667-35.png" alt="35.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_34150df667-37.png" alt="37.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_3788205467-38.png" alt="38.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_7294073067-39.png" alt="39.png" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/206/">模板题</a><br>
<a href="https://www.acwing.com/activity/content/code/content/238790/">code</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速幂&矩阵快速幂]]></title>
        <id>https://caifxh.github.io/post/kuai-su-mi-andju-zhen-kuai-su-mi/</id>
        <link href="https://caifxh.github.io/post/kuai-su-mi-andju-zhen-kuai-su-mi/">
        </link>
        <updated>2020-03-26T13:37:23.000Z</updated>
        <content type="html"><![CDATA[<h4 id="快速幂">快速幂</h4>
<p>给出 a，b, c，求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span> mod c.a, b, c &lt;= 1e9<br>
枚举 b，连续乘 b 次 a，每乘一次对 c 取模一次。<br>
时间复杂度关于 b 线性。<br>
每次都乘的是 a，重复运算太多，考虑分治</p>
<p>比如计算出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><msup><mi>a</mi><mn>2</mn></msup><mo separator="true">,</mo><msup><mi>a</mi><mn>4</mn></msup><mo separator="true">,</mo><msup><mi>a</mi><mn>8</mn></msup><mo separator="true">,</mo><msup><mi>a</mi><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">a, a^2, a^4, a^8, a^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>, …<br>
对 b 进行二进制转换，比如 b = 11 = 8 + 2 + 1<br>
故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup><mo>=</mo><msup><mi>a</mi><mn>11</mn></msup><mo>=</mo><msup><mi>a</mi><mn>8</mn></msup><mo>∗</mo><msup><mi>a</mi><mn>2</mn></msup><mo>∗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a^b = a^{11} = a^8 * a^2 * a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span><br>
因此，只要预处理出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">log_2 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 个 a 的幂次<br>
计算的时候分解成 log2 b 个乘积即可<br>
<a href="https://www.acwing.com/problem/content/877/">模板题</a></p>
<pre><code>int qmi(int a,int b,int p)
{
    int res=1%p;
    while(b)
    {
        if(b&amp;1)
            res=(long long)res*a%p;
        a=(long long)a*a%p;
        b&gt;&gt;=1;
    }
    return res;
}
</code></pre>
<h4 id="快速乘">快速乘</h4>
<p>给出 a，b, c，求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a * b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> mod c.a, b, c &lt;= 1e18<br>
沿用之前的做法，但是注意这里的模数是 1e18。如果两个小于 1e18 的数相乘，long long也存不下。<br>
考虑到幂次可以转化为连乘，乘法也可以转化为连加。<br>
同样的我们可以得到一个“快速”乘</p>
<p>比如计算出 a, 2a, 4a, 8a, 16a, …<br>
对 b 进行二进制转换，比如 b = 11 = 8 + 2 + 1<br>
故 ba = 11a = 8a + 2a + a<br>
因此，只要预处理出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">log_2 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 个 a 的乘积<br>
计算的时候分解成 log2 b 个加法即可。<br>
因为每次两个小于 1e18 的数相加，long long是可以存的。<br>
<a href="https://www.acwing.com/problem/content/92/">模板题</a></p>
<pre><code>long long mul(long long a, long long b, long long c)
{
    long long ans = 0;
    while (b) 
    {
        if (b &amp; 1) ans = (ans + a) % c;
        b &gt;&gt;= 1;
        a = (a + a) % c;
    }
    return ans; 
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="https://www.luogu.com.cn/problem/P1965">luoguP1965</a><br>
答案显然就是 (x + m * 10^k) % n<br>
根据模运算的的分配率可以得到 (x%n+m%n*10<sup>k%n)%n,只需用快速幂求出10</sup>k就可以了<br>
<a href="https://paste.ubuntu.com/p/Mh8D5CDD3X/">代码</a></p>
<h4 id="矩阵乘法">矩阵乘法</h4>
<p>给定一个大小为 n × m 的矩阵 A[n][m]<br>
和一个大小为 m × r 的矩阵 B[m][r]</p>
<pre><code>    for (int i = 1;i &lt;= n;i ++)
        for (int j = 1;j &lt;= r;j ++)
            for (int k = 1;k &lt;= m;k ++)
                C[i][j] += A[i][k] * B[k][j];
时间复杂度: O(n^3)
</code></pre>
<h4 id="矩阵快速幂">矩阵快速幂</h4>
<p><a href="">poj3233</a><br>
给定一个 n × n 的矩阵 A，和一个正整数 k。 求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>A</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mi>A</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">S = A + A^2 + … + A^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，对 m 取模,n ≤ 30，k ≤ 1e9</p>
<blockquote></blockquote>
<p>样例输入：<br>
2 2 4<br>
0 1<br>
1 1<br>
样例输出：<br>
1 2<br>
2 3</p>
<p>注意到，矩阵乘法也是具有结合律和乘法分配律的。<br>
因此：(I为单位阵)<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>=</mo><mi>A</mi><mo>(</mo><mi>I</mi><mo>+</mo><mi>A</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">A + A^2 = A(I + A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>+</mo><msup><mi>A</mi><mn>3</mn></msup><mo>+</mo><msup><mi>A</mi><mn>4</mn></msup><mo>=</mo><mo>(</mo><mi>A</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>)</mo><mo>(</mo><mi>I</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">A + A^2 + A^3 + A^4 = (A + A^2)(I + A^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>我们记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>A</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">sum(n) = A + A^2 + … + A^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><br>
如果 n 是偶数:<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>(</mo><mi>I</mi><mo>+</mo><msup><mi>A</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">sum(n) = sum(n / 2)(I + A^{n/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
如果 n 是奇数：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><msup><mi>A</mi><mi>n</mi></msup><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>(</mo><mi>I</mi><mo>+</mo><msup><mi>A</mi><mrow><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mi mathvariant="normal">）</mi><mo>+</mo><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">sum(n) = sum(n - 1) + A^n = sum((n - 1) / 2)(I + A^{(n-1)/2}）+ A^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><br>
只需要解决如何快速求 A^n</p>
<p>对于整数的幂次，我们可以用快速幂来求。<br>
对于矩阵的幂次，我们也可以用快速幂来求。<br>
注意的是，初始值要设置为单位矩阵 I。也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">A^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>.</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=35;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
}a;
int n,k,mod;

matrix add(matrix a,matrix b)
{
	matrix res;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			res.m[i][j]=(a.m[i][j]+b.m[i][j])%mod;
	return res;
}

matrix mul(matrix a,matrix b)
{
	matrix c;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			for(int k=1;k&lt;=n;k++)
				c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return c;
}

matrix qmi(matrix a,int k)
{
	matrix c;
	for(int i=1;i&lt;=n;i++)
		c.m[i][i]=1;
	while(k)
	{
		if(k &amp; 1)
			c=mul(c,a);
		a=mul(a,a);
		k&gt;&gt;=1;
	}
	return c;
}

matrix get_sum(matrix a,int k)
{
	if(k == 1)
		return a;
	matrix c;
	for(int i=1;i&lt;=n;i++)
		c.m[i][i]=1;
	
	c=add(c,qmi(a,k&gt;&gt;1));
	c=mul(c,get_sum(a,k&gt;&gt;1));
	if(k &amp; 1)
		c=add(c,qmi(a,k));
	return c;
 } 

int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;mod);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf(&quot;%d&quot;,&amp;a.m[i][j]);
	
	a=get_sum(a,k);
	
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=n;j++)
			printf(&quot;%d &quot;,a.m[i][j]);
		puts(&quot;&quot;);
	}
		
	return 0;
}
</code></pre>
<h4 id="矩阵乘法优化递推">矩阵乘法优化递推</h4>
<p><a href="https://vjudge.net/problem/POJ-3070">poj3070</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_2ef3042460-14.PNG" alt="14.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_620b5d9460-15.PNG" alt="15.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=2,mod=10000;
int n;
struct matrix
{
    int m[N][N];
    matrix()
    {
    	memset(m,0,sizeof m);
	}
    matrix(int a[][N])
    {
        memcpy(m,a,sizeof m);
    }
};

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&lt;2;i++)
		for(int j=0;j&lt;2;j++)
			for(int k=0;k&lt;2;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&lt;2;i++)
		res.m[i][i]=1;
	
	while(k)
	{
		if(k &amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&gt;&gt;=1;
	}
	return res;
}

int main()
{
	while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; ~n)
	{
		int f[N][N]={{1,0}};
		int c[N][N]={{1,1},{1,0}};
		matrix a=c;
		matrix b=f;
		if(n)
		{
			a=qmi(a,n-1);
			b=mul(b,a);
			printf(&quot;%d\n&quot;,b.m[0][0]);
		}
		else 
			printf(&quot;0\n&quot;);	
	}
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_958a265e60-002.PNG" alt="002.PNG" loading="lazy"></figure>
<p><a href="https://www.acwing.com/problem/content/1305/">acwing1303</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_346e767260-001.PNG" alt="001.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/activity/content/code/content/192086/">代码</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_ed62226260-17.PNG" alt="17.PNG" loading="lazy"></p>
<p>数列f[n]=f[n-1]+f[n-2]+1,f[1]=f[2]=1的第n项的快速求法（不考虑高精度）<br>
仿照前例，考虑1×3的矩阵[f[n-2],f[n-1],1]，希望求得某3×3的矩阵A，使得此1×3的矩阵乘以A得到矩阵：<br>
[f[n-1],f[n],1]<br>
即：[]f[n-2],f[n-1],1]* A ＝[f[n-1],f[n],1] =[f[n-1],f[n-1]+f[n-2]+1,1]<br>
容易构造出这个3×3的矩阵A，即：</p>
<pre><code>０ １ ０
１ １ ０
０ １ １
</code></pre>
<p>数列f[n]=f[n-1]+f[n-2]+n+1,f[1]=f[2]=1的第n项的快速求法（不考虑高精度）.<br>
解法：<br>
仿照前例，考虑1×4的矩阵[f[n-2],f[n-1],n,1]，希望求得某4×4的矩阵A，使得此1×4的矩阵乘以A得到矩阵：[f[n-1],f[n],n+1,1]<br>
即：[f[n-2],f[n-1],n,1]* A  = [f[n-1],f[n],n+1,1]＝[f[n-1],f[n-1]+f[n-2]+n+1,n+1,1]<br>
容易构造出这个4×4的矩阵A，即：</p>
<pre><code>０ １ ０ ０
１ １ ０ ０
０ １ １ ０
０ １ １ １
</code></pre>
<h4 id="例题-2">例题</h4>
<p><a href="">poj3735</a><br>
有 n 只小猫，要执行一些操作序列。<br>
g i：给第 i 只小猫一棵花生<br>
e i：让第 i 只小猫吃掉它的所有花生<br>
s i j：让第 i 只小猫和第 j 只小猫交换他们手里的花生。<br>
现在给你一个长度为 k 的序列，让你反复执行这个序列 m<br>
次。问最后每只小猫手里的花生数。n≤100，k≤100，m≤1e9</p>
<p>联系矩阵优化递推。<br>
如果我们也能求出一个序列对应的矩阵。<br>
只要求矩阵的 m 次幂即可。<br>
先考虑如何设计状态：<br>
把刚才那3只猫看做一个矩阵{a,b,c},分别代表他们有的花生个数，显然初始是{0,0,0}<br>
当进行s操作的时候，我们将初始矩阵乘上一个矩阵，得到的那个矩阵最好也是1行3列的。<br>
那肯定我们要构造的那个矩阵是3*3的矩阵<br>
s 1 2交换操作就是{a,b,c}*x={b,a,c}</p>
<pre><code>x=  0 1 0
    1 0 0
    0 0 1
</code></pre>
<p>S操作是这样的，首先将X看做一个单位矩阵，要交换哪两个，只需要交换他们的列就可以了<br>
对于e操作近似于s操作，将e 2举例：{a,b,c}*x={a,0,c}</p>
<pre><code>x=  1 0 0
    0 0 0
    0 0 1
</code></pre>
<p>即将某列置于0</p>
<p>现在问题来了，怎么构造g操作的矩阵。使下面这个等式成立<br>
g 1操作  {a,b,c}*X={a+1,b,c}<br>
g 2操作  {a,b,c}*X={a,b+1,c}<br>
g 3操作  {a,b,c}*X={a,b,c+1}</p>
<p>我们不妨再{a,b,c}矩阵多加一个1，这样我们就能实现我们的+1操作了<br>
要使g 1操作实现{a,b,c,1}*x={a+1,b,c,1}<br>
那么</p>
<pre><code>x=  1 0 0 0
    0 1 0 0
    0 0 1 0
    1 0 0 1
</code></pre>
<p>当然这样构造矩阵，这样并不影响我们前面的s与e操作</p>
<p>这样一系列操作之后：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_4bcc69f260-003.jpg" alt="003.jpg" loading="lazy"></p>
<p>得到这个矩阵后，求它的 m 次幂，然后乘上初始状态对应<br>
的向量，得到的就是答案。<br>
时间复杂度: O(n^3log m)<br>
<a href="https://paste.ubuntu.com/p/THP5WB3nTq/">代码</a></p>
<p><a href="https://vjudge.net/problem/POJ-3150">poj3150</a><br>
有 n 个数排成一个环。定义一次变换为：把这个数变成距离它不超过 d 的位置上的数之和对 m 取模的值。<br>
问这样变换 k 次后，每个位置上的数是多少。<br>
n &lt;= 500, m &lt;= 109, k &lt;= 1e9</p>
<p>对于每一次变换，其实可以写成一个矩阵：<br>
比如题中 d = 2<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_f0d1e4e660-18.PNG" alt="18.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1d68c92a60-000000.png" alt="000000.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/07/9969_95c26eb260-005.png" alt="005.png" loading="lazy"><br>
因此一个矩阵只要存下第一行就可以得到整个矩阵。<br>
计算矩阵乘法的时候，只要枚举 n^2 次。<br>
时间复杂度变成了 O(n^2 log k)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=510;
int n,mod,d,k;
struct matrix 
{
	int m[N];
	matrix()
	{
		for(int i=0;i&lt;N;i++)
			m[i]=0;
	}
	matrix(int a[])
	{
		memcpy(m,a,sizeof m);
	}
};

matrix mul(matrix a,matrix b)
{
	matrix res;
	
	for(int i=0;i&lt;n;i++)//只计算res的第一行 
		for(int k=0;k&lt;n;k++)
			res.m[i]=(res.m[i]+(LL)a.m[k]*b.m[(i-k+n)%n])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	res.m[0]=1;
		
	while(k)
	{
		if(k&amp;1) res=mul(res,a);
		a=mul(a,a);
		k&gt;&gt;=1;
	}
	return res;
}

int main()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;mod,&amp;d,&amp;k);
	matrix b;
	for(int i=0;i&lt;n;i++)
		scanf(&quot;%d&quot;,&amp;b.m[i]);
	matrix a;
	for(int i=0;i&lt;n;i++)
		if(i&lt;=d || (i+d)%n == 0)
			a.m[i]=1;
	a=qmi(a,k);	
//	for(int i=0;i&lt;n;i++)
//		printf(&quot;%d &quot;,a.m[i]);
	b=mul(b,a);
	for(int i=0;i&lt;n;i++)
		printf(&quot;%d &quot;,b.m[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性dp]]></title>
        <id>https://caifxh.github.io/post/xian-xing-dp/</id>
        <link href="https://caifxh.github.io/post/xian-xing-dp/">
        </link>
        <updated>2020-03-26T12:12:57.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_063efe606b-34.png" alt="34.png" loading="lazy"></figure>
<h4 id="多阶段决策问题">多阶段决策问题</h4>
<p>有一类活动的过程，可以分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效。<br>
当然，各个阶段的决策的选取不是任意确定的，它依赖于当前的状态，又会影响以后的发展。</p>
<p>当各个阶段决策决定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。<br>
这种把一个问题看做是一个前后关联、具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为<code>多阶段决策问题</code>。</p>
<p>各个阶段采取的决策， 一般来说是与阶段有关的。<br>
决策依赖于当前的状态，又随即引起状态的转移。<br>
一个决策序列就是在变化的状态中产生出来的。<br>
称这种解决多阶段决策最优化的过程为<code>动态规划（DP）</code>。</p>
<p>动态规划（Dynamic Programming）程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。<br>
由于各种问题的性质不同，确定最优解的条件也互不相同，因此不存在一种万能的动态规划算法可以解决各类最优化问题。</p>
<p>常见的 DP 类型有：<br>
线性模型<br>
区间 DP<br>
背包 DP<br>
数位 DP<br>
状态压缩 DP<br>
树状 DP</p>
<p>常见的 DP 优化方法有：<br>
滚动数组优化<br>
矩阵乘法优化<br>
斜率优化<br>
四边形不等式优化<br>
决策单调性优化<br>
数据结构优化</p>
<h4 id="动态规划的基本概念">动态规划的基本概念</h4>
<p>1.阶段和阶段变量<br>
将问题的全过程恰当地分成若干个相互联系的阶段。<br>
阶段的划分一般根据时间和空间的自然特征去划分。<br>
阶段的划分要便于把问题转化成多阶段决策问题。</p>
<p>2.状态和状态变量<br>
通常一个阶段包含若干状态。<br>
状态可由变量来描述。</p>
<p>3.决策、决策变量和决策允许集合。<br>
在对问题的处理中作出的每种选择性的行动就是决策。<br>
即从该阶段的每一个状态出发， 通过一次选择性的行动转移至下一阶段的相应状态。<br>
一个实际问题可能需要有多次决策和多个决策点，在每一个阶段的每一个状态中都需要有一次决策，<br>
决策也可以用变量来描述，称这种变量为决策变量。<br>
在实际问题中，决策变量的取值往往限制在某一个范围之内，此范围就称为决策允许集合。</p>
<p>4.策略和最优策略<br>
所有阶段一次排列构成问题的全过程。<br>
全过程中各阶段决策变量所组成的有序总体称为策略。<br>
在实际问题中，从决策允许集合中找出最优效果的策略称为最优策略。</p>
<p>5.状态转移方程<br>
前一阶段的终点就是后一阶段的起点，对前一阶段的状态做出某种决策，产生后一种阶段的状态，这种关系描述了从 i<br>
阶段到 i+1 阶段状态的演变规律，称为状态转移方程。</p>
<p>从 n 个数中取出 k 个数，使得他们的和最大。<br>
f[i][j] 表示现在考虑到了第 i 个数，已经选出了 j 个数。<br>
阶段：枚举到第i个数<br>
状态：已经选出了 j 个数。<br>
决策：第i个数选或不选<br>
策略：和最大<br>
状态转移方程：f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[i])</p>
<h4 id="动态规划的性质">动态规划的性质</h4>
<p>什么样的“多阶段决策问题”才可以用动态规划的方法来求解呢？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_a514107a6b-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_cda6e35a6b-2.png" alt="2.png" loading="lazy"><br>
对于不能划分阶段的题，不能用动态规划来解。<br>
不符合最优化原理，不能用动态规划来解。<br>
不具备无后效性原则的，不能用动态规划来解。<br>
误用动态规划解决问题会得到错误的结果</p>
<h4 id="动态规划设计方法">动态规划设计方法</h4>
<p>正推：从初始状态开始，通过对中间阶段的决策的选择，达到结束状态。我们也称递推。<br>
倒推：从结束状态开始，通过对中间阶段的决策的选择，达到开始状态。我们可以把这种方法看成记忆化搜索。</p>
<h4 id="动态规划设计方法的一般模式">动态规划设计方法的一般模式</h4>
<ol>
<li>划分阶段</li>
<li>确定状态和状态变量</li>
<li>确定决策并写出状态转移方程</li>
<li>寻找边界条件</li>
<li>设计并实现程序</li>
</ol>
<h4 id="动态规划与记忆化搜索">动态规划与记忆化搜索</h4>
<p>实现一个函数，用“搜索”的方法实现 DP 的更新。<br>
通常用于解决转移顺序不方便人为确定的 DP。<br>
数字三角形<br>
5<br>
7<br>
3 8<br>
8 1 0<br>
2 7 4 4<br>
4 5 2 6 5<br>
设 f[i][j] 表示走到了第 i 行第 j 列的最大值。<br>
正常 DP：<br>
f[i][j] = max(f[i – 1][j], f[i – 1][j – 1]) + a[i][j]</p>
<p>搜索：</p>
<pre><code>int dp(int i, int j)
{
if (i == 0) return 0;
    return a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
}
</code></pre>
<p>这样有很多状态其实会重复计算。<br>
对于计算过的 dp(i, j)，我们用 f[i][j] 来存。<br>
f 初始化为 -1<br>
记忆化搜索：</p>
<pre><code>int dp(int i, int j){
    if (i == 0) return 0;
    if (f[i][j] &gt;= 0) return f[i][j];
    f[i][j] = a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
    return f[i][j];
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/903/">acwing901</a><br>
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=310;
int h[N][N];
int f[N][N];
int n,m;
int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};

int dp(int x,int y)
{
    if(f[x][y]!=-1)
        return f[x][y];
    
    f[x][y]=1;
    for(int i=0;i&lt;4;i++)
    {
        int a=x+dx[i],b=y+dy[i];
        if(a&gt;=1 &amp;&amp; a&lt;=n &amp;&amp; b&gt;=1 &amp;&amp; b&lt;=m &amp;&amp; h[x][y]&gt;h[a][b])
            f[x][y]=max(f[x][y],dp(a,b)+1);
    }
    return f[x][y];
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf(&quot;%d&quot;,&amp;h[i][j]);
    memset(f,-1,sizeof f);
    
    int res=0;    
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            res=max(res,dp(i,j));
    printf(&quot;%d\n&quot;,res);
    return 0;
}
</code></pre>
<h4 id="线性模型">线性模型</h4>
<p>这里的线性指的是状态的排布是呈线性的。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_004ef4346c-3.png" alt="3.png" loading="lazy"></p>
<p>最长上升子序列问题。<br>
f[i] 表示以 a[i] 结尾的最长上升子序列问题。<br>
计算 f[i] 的时候，只需要去考虑 f[1], f[2], …, f[i-1] 看是否能够转移即可。<br>
f[i] = max{ f[j] + 1 | 1≤j&lt;i, a[j]&lt;a[i] }<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_ce5ad9da6c-5.png" alt="5.png" loading="lazy"><br>
贪心思想，数越小形成的最长上升子序列长度可能越大。</p>
<pre><code>#include&lt;cstdio&gt;//最长上升子序列，优化算法，时间复杂度O(nlogn)
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
int d[maxn];//d[]表示从最长上升序列的元素
int a[maxn];

int main()
{
    int n;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
    int len=1;
    d[1]=a[1];
    for(int i=2;i&lt;=n;i++)
	{
		if(a[i] &gt; d[len])
            d[++len]=a[i];
        else//a[i]覆盖d[]中第一个大于a[i]的数 
        	*lower_bound(d+1,d+len+1,a[i])=a[i];
    }
    printf(&quot;%d\n&quot;,len);
    return 0;
}
</code></pre>
<p>如果题目要求严格递增，则必须用lower_bound，因为要替换掉相同的元素而不是增长序列。<br>
如果题目要求最长不下降子序列，则必须用 upper_bound。</p>
<p><a href="https://vjudge.net/problem/POJ-3486">poj3486</a><br>
你想保证 n 年中你都有一台电脑，一开始你有一台。<br>
如果你在第 y (1≤y≤n) 年购买了一台电脑，那么你需要花费 c的代价。<br>
如果你这台电脑一直用到了第 z 年，在第 z 年又买了一台新的，您需要在您拥有该计算机的每一年中支付维护成本m（y，z）<br>
给定 n，c，数组 m。求最小花费</p>
<p>首先划分阶段。<br>
每一年可以划分为一个阶段。<br>
f[i] 表示直到第 i 年f[0], f[1],…,f[i-1]你手里都有一台电脑的最小花费。<br>
f[i] 需要从 转移过来。<br>
如何转移？<br>
枚举上一次买电脑是哪一年</p>
<p>假设上一次买电脑是第 j 年。<br>
那么1~j-1年就是一个子问题，我们已经算出了 f[j-1] 是满足<br>
这个子问题的最优解，后面我们就不用考虑前 j-1年的情况，<br>
且它也不会影响我们后面的决策。<br>
第 j 年到第 i 年的维修费用是 m(j, i)，花费是 c<br>
因此可以用 f[j-1]+m(j,i)+c 来更新 f[i]<br>
f[i] = min{ f[j-1]+m(j,i) + c | 1≤j≤i }</p>
<p>边界条件：<br>
f[0] = 0<br>
f[1], f[2], …, f[n] 一开始都应该初始化为 +∞<br>
<a href="https://paste.ubuntu.com/p/R4NjkRS6NT/">code</a></p>
<p><a href="https://www.acwing.com/problem/content/280/">acwing278</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_be96b3666c-4.png" alt="4.png" loading="lazy"></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">hdu1003</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_d1d214a06c-6.png" alt="6.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=100005;
int a[maxn],dp[maxn];//dp[i]表示从start开始到第i个元素的最大子段和 
int main()
{
	int t,n,cas=0;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);//也可以省略原数组，直接用dp[] 
		int l=1,r=1;//记录区间
		int start=1;//记录起点
		dp[1]=a[1];
		
		int ans=dp[1];
		for(int i=2;i&lt;=n;i++)
		{
            if(dp[i-1]&gt;=0)//dp[i-1]大于等于0，则累加，否则重新开始 
                dp[i]=dp[i-1]+a[i];
            else
            {
            	dp[i]=a[i];
            	start=i;//重新开始
			}	
            if(dp[i]&gt;ans)//更新最值
            {
            	ans=dp[i];
				l=start;
         	    r=i;
            }
		}
		if(cas)
			printf(&quot;\n&quot;);
		printf(&quot;Case %d:\n&quot;,++cas);
		printf(&quot;%d %d %d\n&quot;,ans,l,r);
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2479">poj2479</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_d98686626c-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_dc09d59c6c-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_f81ff4286c-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_fbc358906c-10.png" alt="10.png" loading="lazy"><br>
因为我们会从左到右枚举每一个lt[i],当然更新一遍lt[i]也没有错。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50010;
const int inf=0x3f3f3f3f;
int lt[maxn],rt[maxn];//lt[i]表示从左端开始，以i结尾的子段和最大值 
int a[maxn];
 
int main()
{
	int t,n;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);
		lt[1]=a[1];
		for(int i=2;i&lt;=n;i++)//从左向右 
			lt[i]=max(a[i],lt[i-1]+a[i]);
		rt[n]=a[n];
		for(int i=n-1;i&gt;=1;i--)//从右向左
			rt[i]=max(a[i],rt[i+1]+a[i]); 
		for(int i=n-1;i&gt;=1;i--)//更新为从右端开始n..i个元素之中最大连续子段和 
			rt[i]=max(rt[i+1],rt[i]);
		int ans=-inf;
		for(int i=2;i&lt;=n;i++)
			ans=max(ans,lt[i-1]+rt[i]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2250">poj2250</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_5f95e4ce6c-11.png" alt="11.png" loading="lazy"><br>
<a href="https://paste.ubuntu.com/p/sqtP3jt5kc/">code</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串复习（一）]]></title>
        <id>https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/</id>
        <link href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/">
        </link>
        <updated>2020-03-26T09:16:46.000Z</updated>
        <content type="html"><![CDATA[<h4 id="哈希表">哈希表</h4>
<p>如果要储存和使用线性表（1，75，324，43，1353，90，46）一般情况下我们会使用一个数组 A[1..7] 来顺序存储这些数。<br>
但是这样的存储结构会给查询算法带来 O(n) 的时间开销。<br>
对 A 排序，使用二分查询法，时间复杂度变为 O(log n)也可以用空间换时间的做法，用数组 A[1..1353] 来表示每个数是否出现，查找的时间复杂度变为 O(1)，但是空间上的开销变得巨大。</p>
<p>优化上一种做法，建立一个哈希函数 h(key) = key % 23.(1, 75, 324, 43, 1353, 90) -&gt; (1, 6, 2, 20, 19, 21, 0)<br>
我们只要用一个 A[0..22] 数组就可以快速的查询每个数是否出现。<br>
这种线性表的结构就称为哈希表（Hash Table）。</p>
<p>可以看出，哈希表的基本原理是用一个下标范围比较大的数组 A 来存储元素。<br>
设计一个函数 h，对于要存储的线性表的每个元素 node，取一个关键字 key，算出函数值 h(key) 然后把这个值作为下标，用 A[h(key)] 来存储 node。<br>
最常见的 h 就是模函数，也就是选定一个 m，令 h(key) =key % m.</p>
<p>但是有一个问题，可能存在两个 key: k1, k2 使得h(k1)=h(k2)，这时也称产生了“冲突”。<br>
解决冲突有很多种办法：<br>
1.开放寻址法<br>
2.拉链法：可以让 A 的每个元素都存一个链表，对于<br>
h(k1)=h(k2)，我们可以让这两个 node 都接在 A[h(k1)]<br>
的链表上</p>
<p>假设我们使用第二种方法解决冲突。<br>
对于插入元素(node, key)：</p>
<ul>
<li>计算 h(key)，把 node 插入 A[h(key)] 链表。</li>
</ul>
<p>对于查询元素(node, key)：</p>
<ul>
<li>计算 h(key)，如果 A[h(key)] 为空，说明 node 不存在。<br>
否则遍历 A[h(key)] 链表，寻找 node。</li>
</ul>
<p><a href="https://www.acwing.com/problem/content/842/">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100003;
int h[N],e[N],ne[N],idx;

void insert(int x)
{
    int k=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}

bool find(int x)
{
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i])
    {
        if(e[i]==x)
            return true;
    }
    return false;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    memset(h,-1,sizeof(h));
    while(n--)
    {
        char op[2];
        int x;
        scanf(&quot;%s%d&quot;,op,&amp;x);

        if(*op=='I')
            insert(x);
        else
        {
            if(find(x))
                puts(&quot;Yes&quot;);
            else
                puts(&quot;No&quot;);
        }
    }
    return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p>已知 X[1..4] 是 [-T, T] 中的整数，求出满足方程AX[1]+BX[2]+CX[3]+DX[4] = P的解有多少组？<br>
|P|≤1e9，|A|,|B|,|C|,|D|≤1e4，T≤500</p>
<p>最直观的方法枚举 X[1..4], 时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)<br>
适当优化，枚举了X[1..3] 之后，实际上 X[4] 已经确定了，时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)<br>
继续优化，采用 meet in the middle 策略：<br>
一边枚举 X[1], X[2]<br>
一边枚举 X[4], X[3]<br>
然后看有哪些方案可以组成方程的解</p>
<p>枚举 X[1], X[2], 然后算出 P-AX[1]-BX[2],把这个值存入一个哈希表，注意要统计次数。<br>
这一步时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)<br>
然后枚举 X[3], X[4], 算出 CX[3]+DX[4],去哈希表里查找这个值出现了几次。<br>
把次数加进答案，这一步时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)<br>
因此总的时间复杂度是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</p>
<h4 id="字符串哈希">字符串哈希</h4>
<p>假设有 n 个长度为 L 的字符串，问其中最多有几个字符串是相等的。<br>
直接比较两个长度为 L 的字符串是否相等时间复杂度是O(L) 的。<br>
因此需要枚举 O(n2) 对字符串进行比较，时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi>L</mi></mrow><annotation encoding="application/x-tex">n^2L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">L</span></span></span></span>)<br>
如果我们把每个字符串都用一个哈希函数映射成一个整数。<br>
问题就变成了查找一个序列的众数。<br>
时间复杂度变为了 O(nL)</p>
<p>一个设计良好的字符串哈希函数可以让我们先用 O(L) 的时间复杂度预处理，之后每次获取这个字符串的一个子串的哈希值都只要 O(1) 的时间。</p>
<p>BKDRHash 的基本思想就是把一个字符串当做一个 k 进制数来处理</p>
<p>假设字符串 s 的下标从 1 开始，长度为 n</p>
<pre><code>ha[0] = 0;
    for (int i = 1;i &lt;= n;i ++)
        ha[i] = (ha[i - 1] * P + str[i]) % M;
</code></pre>
<p>我们知道 ha[i] 就是 s[1..i] 的 BKDRHash<br>
那么现在询问 s[x..y] 的 BKDRHash ，<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/05/9969_37911bd05e-5.png" alt="5.png" loading="lazy"><br>
因此我们预处理出 ha 数组和 k 的幂次，每次询问 s[x..y]的哈希值，只要 O(1) 的时间。</p>
<h4 id="经验值k131m264">经验值，k=131，M=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></h4>
<p><a href="https://www.acwing.com/problem/content/843/">模板题</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 100010, P = 131;
int n, m;
char str[N];
ULL h[N], p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    scanf(&quot;%s&quot;, str + 1);

    p[0] = 1;
    for (int i = 1; i &lt;= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);

        if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);
        else puts(&quot;No&quot;);
    }

    return 0;
}
</code></pre>
<h4 id="例题-2">例题</h4>
<p><a href="https://www.acwing.com/problem/content/description/162/">acwing160</a><br>
核心问题就是：<br>
给定两个字符串 A，B。求出 A 的每个后缀子串和 B 的最长公共前缀。<br>
标准做法是扩展 KMP，时间复杂度线性。<br>
我们来用 Hash 试试看</p>
<p>前面已经提到，我们可以用 O(n)预处理 O(1)处理出一个子串的哈希值。<br>
求字符串 A[i..n] 与字符串 B[1..m] 的最长公共前缀？<br>
二分长度 mid<br>
计算出 A[i..i+mid-1] 和 B[1..mid] 的哈希值，比较是否相等。<br>
因此时间复杂度是 O(nlog n) 的</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 200010, P = 131;
int n, m,q;
char a[N];
char b[N];
ULL ha[N],hb[N],p[N];
int cnt[N];

ULL get(ULL h[],int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m,&amp;q);
    scanf(&quot;%s&quot;, a + 1);
    scanf(&quot;%s&quot;,b+1);

    p[0] = 1;
    for(int i=1;i&lt;=max(n,m);i++)
        p[i]=p[i-1]*P;
    for(int i=1;i&lt;=n;i++)
        ha[i]=ha[i-1]*P+a[i];
    for(int i=1;i&lt;=m;i++)
        hb[i]=hb[i-1]*P+b[i];
    
    for(int i=1;i&lt;=n;i++)
    {
        int l=0,r=min(m,n-i+1);

        while(l&lt;r)
        {
            int mid=l+r+1&gt;&gt;1;
            if(get(ha,i,i+mid-1) == get(hb,1,mid))
                l=mid;
            else
                r=mid-1;
        }
        cnt[l]++;
    }
    while(q--)
    {
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        printf(&quot;%d\n&quot;,cnt[x]);
    }

    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2774">poj2774</a><br>
给出两个字符串 S 和 T，求它们的最长公共子串。|S|, |T| ≤ 1e5</p>
<h4 id="思路">思路</h4>
<p>原始的 DP 做法（最长公共子序列），时间复杂度 O(n^2)<br>
我们可以二分答案 len。然后计算 S 和 T 中所有长度为 len 的子串的哈希值。<br>
这一步是 O(n) 的。<br>
然后比较 S 的哈希值集合中和 T 的哈希值集合中有没有相同的元素。<br>
可以再通过一步哈希找相同的值。这样总共仍然是 O(n)。<br>
总的时间复杂度就是 O(n log n)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010,P=131;
char a[N],b[N];
typedef unsigned long long ULL;
ULL ha[N],hb[N],p[N];
vector&lt;ULL&gt; v;
int la,lb;

ULL get(ULL h[],int l,int r)
{
	return h[r]-h[l-1]*p[r-l+1];
}

bool check(int mid)
{
	v.clear();
	for(int i=mid;i&lt;=la;i++)
		v.push_back(get(ha,i-mid+1,i));
	
	sort(v.begin(),v.end());
	for(int i=mid;i&lt;=lb;i++)
	{
		ULL t=get(hb,i-mid+1,i);
		if(binary_search(v.begin(),v.end(),t))
			return true;
	}
	return false;
}

int main()
{
	scanf(&quot;%s%s&quot;,a+1,b+1);
	la=strlen(a+1);
	lb=strlen(b+1);
	
	p[0]=1;
	for(int i=1;i&lt;=max(la,lb);i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&lt;=la;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=1;i&lt;=lb;i++)
		hb[i]=hb[i-1]*P+b[i];
		
	int l=0,r=1e5;
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(check(mid))
			l=mid;
		else
			r=mid-1;
	}
	printf(&quot;%d\n&quot;,l);
	return 0;
}
</code></pre>
<p>也可手写哈希表：<a href="https://paste.ubuntu.com/p/GdxThx6SK6/">代码</a></p>
<p><a href="https://vjudge.net/problem/CodeForces-580E">Codeforces 580E</a><br>
给出一个数字串，现在有两种操作：<br>
1: l r d: 将[l,r] 中的所有数字都改为 d<br>
2: l r d：询问[l,r]这个子串的周期是否为 d。 1 &lt;= n &lt;= 1e5<br>
首先思考对于一个字符串 S，如何判断它的周期是不是 d？<br>
比如串 ababab 的周期是 2 串 abcabc 的周期是 3 串 abcde 的周期是 5<br>
假设 S 的长度为 n。<br>
只要判断 <code>S[1..n-d+1] 和 S[d+1..n]</code>是否相等即可。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_fd5afb5c5f-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_b6f72f365e-7.png" alt="7.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define lc u&lt;&lt;1
#define rc u&lt;&lt;1|1
int n,m,k;
const int N=100010,P=131,mod=1e9+7;
char s[N];
typedef long long LL;
struct Node
{
	int l,r;
	int tag;
	LL key;
}tr[N&lt;&lt;2];
LL h[N],p[N];//p[i]表示p的i次方，h[i]表示连续i个1的字符串的hash值

void pushup(int u,int k)
{
	tr[u].key=((tr[lc].key*p[k])%mod+tr[rc].key)%mod;
}

void pushdown(int u)
{
	if(tr[u].tag)
	{
		int mid=tr[u].l+tr[u].r&gt;&gt;1,l=tr[u].l,r=tr[u].r;
		tr[lc].key=(tr[u].tag*h[mid-l+1])%mod;
		tr[lc].tag=tr[u].tag;
		tr[rc].key=(tr[u].tag*h[r-mid])%mod;
		tr[rc].tag=tr[u].tag;
		tr[u].tag=0;
	}
}

void build(int u,int l,int r)
{
	if(l == r)
	{
		tr[u]={l,r,0,s[l]-'0'+1};
		return;
	}
	tr[u]={l,r};
	int mid=l+r&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u,r-mid);
}

void modify(int u,int l,int r,int d)
{
	if(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)
	{
		tr[u].key=(d*h[tr[u].r-tr[u].l+1])%mod;
		//cout&lt;&lt;&quot;-----&quot;&lt;&lt;u&lt;&lt;' '&lt;&lt;tr[u].key&lt;&lt;endl;
		tr[u].tag=d;
		return;
	}
	pushdown(u);
	int mid=tr[u].l+tr[u].r&gt;&gt;1;
	if(l &lt;= mid)
		modify(lc,l,r,d);
	if(r &gt; mid)
		modify(rc,l,r,d);
	pushup(u,tr[u].r-mid);
}

int query(int u,int l,int r)
{
	if(tr[u].l == l &amp;&amp; tr[u].r == r)
		return tr[u].key;
	pushdown(u);
	int mid=tr[u].l+tr[u].r&gt;&gt;1;
	if(r&lt;=mid)
		return query(lc,l,r);
	else if(l&gt;mid)
		return query(rc,l,r);
	else 
		return (query(lc,l,mid)*p[r-mid]%mod+query(rc,mid+1,r))%mod;
}

void print(int u)
{
	if(tr[u].key)
	{
		cout&lt;&lt;&quot;--&quot;&lt;&lt;u&lt;&lt;' '&lt;&lt;tr[u].l&lt;&lt;' '&lt;&lt;tr[u].r&lt;&lt;' '&lt;&lt;tr[u].key&lt;&lt;endl;
		print(lc);
		print(rc);
	}
}

int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	scanf(&quot;%s&quot;,s+1);
	
	p[0]=1;
	for(int i=1;i&lt;=n;i++)
	{
		h[i]=(h[i-1]*P%mod+1)%mod;
		p[i]=p[i-1]*P%mod;
	}

	build(1,1,n);
	
	m+=k;
	while(m--)
	{
		int t,l,r,d;
		scanf(&quot;%d%d%d%d&quot;,&amp;t,&amp;l,&amp;r,&amp;d);
		if(t == 1)
			modify(1,l,r,d+1);//加一处理，防止d为0
		else
		{
			if(d == r - l + 1)
			{
                printf(&quot;YES\n&quot;);
                continue;
            }
			if(query(1,l,r-d) == query(1,l+d,r))
				puts(&quot;YES&quot;);
			else
				puts(&quot;NO&quot;);
		}
		//print(1);
	}
	return 0;
}
</code></pre>
<p>坑：第75组数组卡无符号64位自动溢出的hash,防ull溢出的解决方法是取模</p>
<p><a href="https://www.luogu.com.cn/problem/CF955D">Codeforces 955D</a><br>
给出两个字符串 S 和 T。你需要在 S 中选出两个不相交的长度为 k 的子串，使得他们拼起来之后包含 T。<br>
|T| ≤ 2k ≤ |S| ≤ 5·1e5</p>
<blockquote></blockquote>
<p>样例： （答案：Yes 1 5）<br>
7 4 3<br>
baabaab<br>
aaaa</p>
<h4 id="kmp">KMP</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_14fe85145f-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_8d1e51a05f-9.png" alt="9.png" loading="lazy"><br>
我们用形式化的语言来进行描述。<br>
假设现在 T[s+1..s+k] 和 P[1..k] 匹配上了。<br>
此时 T[s+k+1] != P[k+1]。<br>
朴素的做法是：回到 T[s + 2] 和 P[1] 重新开始比较。<br>
KMP算法：找到一个最大的 x，使得 T[s+1..s+k] 的后 x个字符，和 P 的前 x 个字符相同。<br>
这部分就是能匹配上的，我们可以不用逐个判断。</p>
<p>又注意到 T[s+1..s+k] = P[1..k]<br>
那么我们要求的就是一个最大的 x，满足 P[1..k] 的前 x个字符等于它的后 x 个字符。当然 x 要小于 k。<br>
这个 x 记为 next[k]</p>
<p>对于 P = ababaca<br>
我们可以计算出next数组：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_c35dcbf05f-10.PNG" alt="10.PNG" loading="lazy"><br>
有了 next 数组，现在如何匹配两个字符串呢？</p>
<pre><code>for (int i = 1, j = 0; i &lt;= m; i ++ )
{
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == n)
    {
        printf(&quot;%d &quot;, i - n);
        j = ne[j];
    }
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_18d2562c5f-11.png" alt="11.png" loading="lazy"><br>
讲过如何匹配之后，我们还要会高效计算 next 数组。<br>
计算 next 数组的过程就是拿 P 和 P 自己匹配的过程。<br>
只不过要在匹配的过程中，记录每个位置下指针指向的位置，作为 next 数组。</p>
<pre><code>for (int i = 2, j = 0; i &lt;= n; i ++ )
{
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}
</code></pre>
<h4 id="kmp算法复杂度">KMP算法复杂度</h4>
<p>时间复杂度：O(n)<br>
空间复杂度：O(n)</p>
<h4 id="例题-3">例题</h4>
<p><a href="">poj2406</a><br>
给一个字符串 S，求 S 的一个最短的循环节 e，使得 S 可以写成 eee…eee （共|S|/|e|个 e）<br>
输出 |S|/|e| 的最大值。|S| ≤ 1e6</p>
<blockquote></blockquote>
<p>样例：<br>
abcd （答案：1）<br>
aaaa （答案：4）<br>
ababab （答案：3）</p>
<p>假设这个字符串的长度为 len<br>
如果 len 可以被 len-next[len] 整除，那么我们就可以说len-next[len] 是那个循环节的长度。<br>
因为 next[len] 就表示: S[1..next[len]] = S[next[len] + 1..len]<br>
可以证明满足这一条性质的字符串具有长度为 len-next[len] 的循环周期<br>
否则答案就是 1 了。<br>
因为如果存在一个长度为 d 的循环节，那一定满足：<br>
S[1..len-d+1] == S[d + 1 .. len]<br>
但是现在循环节的长度只能是 len-next[len],如果它不是 len 的因子，那就没有可能了。<br>
时间复杂度 O(n)</p>
<blockquote></blockquote>
<p>定理：假设S的长度为len，则S存在最小循环节，循环节的长度L为len-next[len]，子串为S[0…len-next[len]-1]。<br>
（1）如果len可以被len - next[len]整除，则表明字符串S可以完全由循环节循环组成，循环周期T=len/L。<br>
（2）如果不能，说明还需要再添加几个字母才能补全。需要补的个数是循环个数L-len%L=L-(len-L)%L=L-next[len]%L，L=len-next[len]。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1e6+10;
char s[N];
int ne[N];
int n;

int main()
{
	while(scanf(&quot;%s&quot;,s+1))
	{
		if(s[1] == '.')
			break;
		
		n=strlen(s+1);
		for(int i=2,j=0;i&lt;=n;i++)
		{
			while(j &amp;&amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		int t=n-ne[n];
		if(n%t == 0)
			cout&lt;&lt;n/t&lt;&lt;endl;
		else
			cout&lt;&lt;1&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2752">poj2752</a><br>
给定一个字符串 S，求出 S 中所有的既是前缀又是后缀的子串。输出 i 代表 S[1..i]|S| ≤ 400000</p>
<blockquote></blockquote>
<p>样例：<br>
ababcababababcabab（答案：2 4 9 18）<br>
aaaaa（答案：1 2 3 4 5）</p>
<p>求出 next 数组。<br>
答案就是 len, next[len], next[next[len]], …<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_2ee67d465f-12.png" alt="12.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=4e5+10;
char s[N];
int ne[N];
int ans[N];

int main()
{
	while(~scanf(&quot;%s&quot;,s+1))
	{
		int n=strlen(s+1);
		for(int i=2,j=0;i&lt;=n;i++)
		{
			while(j &amp;&amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
	
		int t=ne[n],cnt=0;
		while(t)
		{
			ans[cnt++]=t;
			t=ne[t];
		}
		
		for(int i=cnt-1;i&gt;=0;i--)
			printf(&quot;%d &quot;,ans[i]);
		printf(&quot;%d\n&quot;,n);

	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2594">hdu2594</a><br>
求出最长的既是 s1 的前缀又是 s2 的后缀的子串。</p>
<blockquote></blockquote>
<p>样例：<br>
riemann<br>
marjorie<br>
答案：rie</p>
<p>只要把两个串拼起来，中间用一个分隔符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">,</mo><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">,s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>s2,令len=strlen(s1$s2),则next[len]即为答案<br>
也可不加分隔符，枚举 len, next[len], next[next[len]] ......找到小于 min(|s1|, |s2|) 的最大值即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=50010*2;//数组开两倍!
char s1[N],s2[N];
int ne[N];

int main()
{
	while(~scanf(&quot;%s%s&quot;,s1+1,s2+1))
	{
		strcat(s1+1,&quot;$&quot;);
		strcat(s1+1,s2+1);
		int n=strlen(s1+1);
		for(int i=2,j=0;i&lt;=n;i++)
		{
			while(j &amp;&amp; s1[i] != s1[j+1])
				j=ne[j];
			if(s1[i] == s1[j+1])
				j++;
			ne[i]=j;
		}
		
		int ans=ne[n];
		s1[ans+1]='\0';
		if(ans == 0)
			printf(&quot;0\n&quot;);
		else 
			printf(&quot;%s %d\n&quot;,s1+1,ans);
	}
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/CF526D">Codeforces 526D</a><br>
给出一个字符串 s，判断其每个前缀是否可以表示成ABAB…ABA 的形式（A 和 B 都可以为空， 但是必须满足 A 有 k+1 个，B 有 k 个）<br>
|s|, k ≤ 1e6</p>
<blockquote></blockquote>
<p>输入<br>
7 2<br>
bcabcab<br>
输出<br>
0000011<br>
长度为 6 的前缀，可以取 A=“”,B=“bca”<br>
长度为 7 的前缀，可以取 A=“b”, B=“ca”</p>
<p>对于前缀 P，我们可以把 P 拆成 SSSS…ST，其中 T 是 S的前缀。<br>
这样就可以用 KMP 来做了。<br>
首先 i-next[i] 就是S[1..i] 这一段的最小循环节的长度，<br>
记为 e。<br>
可以发现 e 的倍数 je 也是循环节。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_15c32c7e5f-13.png" alt="13.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=1e6+10;
char s[N];
int n,k;
int ne[N];

bool check(int i,int cir)
{
	int up=i/k/cir;
	int down=ceil((i/(k+1)+1)/(1.0*cir));
	return up&gt;=down || (i % (k+1) == 0 &amp;&amp; (i / (k+1)) % cir == 0);
}

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k))
	{
		scanf(&quot;%s&quot;,s+1);
		
		int len=strlen(s+1);
		for(int i=2,j=0;i&lt;=len;i++)
		{
			while(j &amp;&amp; s[i] != s[j+1])
				j=ne[j];
			
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		for(int i=1;i&lt;=n;i++)
		{
			int cir=i-ne[i];
			printf(&quot;%d&quot;,check(i,cir));
		}
	}
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1054/">acwing</a><br>
首先我们用KMP求出 T 的 next数组。<br>
利用 next数组在长文本中匹配模板串 T的过程：如果下一个字母不匹配，需要一直沿着next指针找：j = next[j]，直到下一个字符匹配或者next指针指向开头为止。<br>
然后我们会发现，假设我们已经匹配完长文本的前个字母，则剩下部分的匹配过程，只跟next指针的位置有关，因此我们可以用二维数组来表示当前状态的方案数：<br>
f[i][j]表示匹配完前 i 个字母时，next指针在 j 时的方案总数。<br>
状态转移：对于每个状态f[i][j]，我们从'a'-'z'枚举下一个字母，然后求出对应的next指针，假设是，则将f[i][j]的方案总数累加到f[i+1][u]。<br>
转移过程中需要注意，因为密码中不能存在 T，所以next指针要避免转移到 T的最后一个字母。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt; 
using namespace std;
const int N=55,mod=1e9+7;
int f[N][N];
int edge[N][26];
char p[N];
int ne[N];
int n;


int main()
{
    cin&gt;&gt;n&gt;&gt;p+1;
    int m=strlen(p+1);
    
    for(int i=2,j=0;i&lt;=m;i++)
    {
        while(j &amp;&amp; p[i] != p[j+1])
            j=ne[j];
        if(p[i] == p[j+1])
            j++;
        ne[i]=j;
    }
    
    for(int i=0;i&lt;m;i++)
        for(char k='a';k&lt;='z';k++)
        {
            int j=i;//已匹配了前i个字母
            while(j &amp;&amp; p[j+1] != k)
                j=ne[j];
            if(p[j+1] == k)
                j++;
            edge[i][k-'a']=j;
        }
        
    f[0][0]=1;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m;j++)
            for(char k='a';k&lt;='z';k++)
            {
                int u=edge[j][k-'a'];
                f[i+1][u]=(f[i+1][u]+f[i][j])%mod;
            }
            
    int res = 0;
    for (int i = 0; i &lt; m; i ++ ) res = (res + f[n][i]) % mod;

    cout &lt;&lt; res &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3193">luoguP3193</a><br>
设f(i,j)表示以准考证号为基准递推，准考证号匹配到第i位，不吉利数字匹配到第j位时（即准考证的后j位等于不吉利数字的前j位），不出现不吉利数字的字符串数量。。</p>
<p>那怎么转移？<br>
既然要以考号为基准递推，就要考虑一位考号对下一位的影响。</p>
<p>而考号是可以随便写的，那我们就要考虑10种数字了。</p>
<p>对于一个新数字new，有以下几种情况：<br>
1.new<br>
与不吉利数字的j+1位匹配，dp(i+1,j+1)的答案数+dp(i,j)<br>
2.上述两者不匹配。</p>
<p>不匹配怎么办？这个不匹配的new一定没有贡献了？<br>
当然不一定。<br>
怎么讲呢，举个例子吧，不吉利数字是12212112。然后你的准考证号枚举到第9位时，前面8位已经枚举成了11112212。可以发现已经匹配了不吉利数字的前5位，现在要匹配第6位。<br>
如果第9位枚举1，那它就匹配了，dp(9,6)+=dp(8,5)。如果第9位枚举2，那它就不匹配。但是会发现，存在 与当前已匹配的不吉利数字的后缀相同 的前缀，可以匹配上这个2！<br>
上一个位置就是不吉利数字的第2位。<br>
它的下一位，第3位2，刚好可以匹配枚举的第9位！<br>
所以此时最多能匹配不吉利数字的前3位，有转移dp(9,3)+=dp(8,5)。</p>
<p>我们只需要沿着不吉利数字的失配指针往前走，找到第一个下一位与new匹配的位置就可以了。<br>
为什么不用考虑再往前的下一位可以匹配new的位置？<br>
因为这是递推，从前往后每一种状态都会被考虑，所以在考虑匹配后面的位之前，前面的位已经匹配好更前面的情况了。</p>
<p>比如不吉利数字1221221211。你目前枚举的准考证号前8位是12212212，现在你要枚举第9<br>
位。很明显当枚举2时，通过找不吉利数字中 后缀相同的前缀，可知dp(8,8)可以转移到dp(9,6)。<br>
但是我们发现也可以转移到dp(9,3)诶！</p>
<p>事实上，在这之前dp(8,5)已经转移到dp(9,3)过了。而dp(8,5)表示什么？它表示准考证号枚举8位，后5位与不吉利数字的前5位匹配上。<br>
dp(8,8)同理，表示准考证号枚举前8位，后8位与不吉利数字的前8位匹配上。<br>
这样直观看起来没什么答案关联。但是仔细考虑以下，不吉利数字的第8位的失配指针指向第5位。</p>
<p>这说明什么？<br>
不吉利数字的前8位中，前5位等于后5位！<br>
<code>匹配5位的情况包含匹配8位的情况！（因为你匹配了8位，根据上推论可知也算在匹配了5位的情况中）</code><br>
这就是别人博客中此题题解经常提到的计数方案会包含的问题。</p>
<p>其实按照AC自动机的构造方式，如果一个点没有字符为new的儿子边的话，它会建出一条对应的虚拟儿子边和点，儿子点上存的是沿着失配指针往回走的上一个实际存在这条字符边所指向的儿子。<br>
当然这题m很小，不吉利数字串自己匹配自己的复杂度很小，可以直接暴力跑失配指针找第一个。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_8bab9de460-00002.PNG" alt="00002.PNG" loading="lazy"><br>
其中g(i,j)表示当前匹配到i个字符，添加一个字符变成匹配为j个字符的方案数。<br>
不吉利数字已经知道了，g数组可以预处理出来（KMP）。</p>
<p>然后我们惊奇地发现n≤1e9，不让你循环推，直接就想到矩阵快速幂优化了。<br>
观察一下转移方程，发现dp[i+1][?]总是由dp[i][?]推来，而且i还是n这个级别的。</p>
<p>又发现每次实际上都是乘一个固定的矩阵g，也就是说整个dp数组的某一位的值其实都是通过一些g数组乘过来的。<br>
所以可以把dp数组直接当成g数组自己乘自己。</p>
<p>比如说，g(4,2)=4。<br>
表示有4种转移情况可以让 与不吉利数字的前4位匹配的情况 在准考证号增加1位后 与不吉利数字的前2位匹配。<br>
所以dp(x+1,2)=dp(x,4)∗g(4,2)=dp(x,4)∗4</p>
<p>而dp(x,4)又是哪来的？<br>
它是通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span>dp(x−1,i)∗g(i,4)转移过来的。</p>
<p>所以一直往前推到x=0，发现dp值的n次转移都只跟转移矩阵g有关，是否与不吉利数字完全匹配等情况可以在弄g数组时就处理掉，即g数组只考虑不吉利数字被匹配0~m−1位的情况，不让它转移到j位都被匹配的情况。<br>
所以就是对g矩阵做快速幂，求它的n次方。</p>
<p>时间复杂度O(log(n)∗m^3)</p>
<h4 id="为什么答案是g0ifor-i-0~m-1">为什么答案是g(0,i)，for i 0~m-1</h4>
<p>考虑g(i,j)的意义。如果g矩阵自己对自己连续进行k次转移（不进行快速幂而循环推），g(i,j)就表示：在进行k次转移前 准考证号匹配不吉利数字的前i位时，准考证号增加k个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。这是矩阵转移的基本概念。</p>
<p>所以进行n次转移后，g(i,j)就表示一开始准考证号匹配不吉利数字的前i位时，准考证号增加n个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。</p>
<p>我们需要取全局情况的答案，而这是很显然的。开始时准考证号匹配不吉利数字的前0位（准考证号还一位都没枚举），所以i为0；而由于已经定义过g数组只考虑不吉利数字被匹配 0~m−1位的情况，所以j在这个区间取任意值，g(0,j)都是答案的一部分。把它们都算上就是答案。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=25;
char p[N];
int n,m,mod;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
};
int ne[N];

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&lt;m;i++)
		for(int j=0;j&lt;m;j++)
			for(int k=0;k&lt;m;k++)
				res.m[i][j]=(res.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return res;
}

int main() 
{
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;mod);
	scanf(&quot;%s&quot;, p+1);
	
	matrix g;
	for(int i=2,j=0;i&lt;=m;i++)
	{
		while(j &amp;&amp; p[i] != p[j+1])
			j=ne[j];
		if(p[i] == p[j+1])
			j++;
		ne[i]=j;
	}
	
	for(int i=0;i&lt;m;i++)
		for(int k=0;k&lt;10;k++)
		{
			int j=i;
			while(j &amp;&amp; p[j+1]-'0' != k)
				j=ne[j];
			if(p[j+1]-'0' == k)
				j++;
			if(j&lt;m)	g.m[i][j]=(g.m[i][j]+1)%mod;
		}
	
	matrix a;
	for(int i=0;i&lt;m;i++)
		a.m[i][i]=1;
	
	while(n)
	{
		if(n &amp; 1) a=mul(a,g);
		g=mul(g,g);
		n&gt;&gt;=1;
	}
//	
//	for(int i=0;i&lt;m;i++)
//	{
//		for(int j=0;j&lt;m;j++)
//			cout&lt;&lt;a.m[i][j]&lt;&lt;' ';
//		cout&lt;&lt;endl;
//	}
	
	int ans = 0;
	for(int i = 0; i &lt; m; ++i)
		ans = (ans + a.m[0][i]) % mod;
	
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1d8bea8860-00001.PNG" alt="00001.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_3048880e63-3.png" alt="3.png" loading="lazy"></p>
<h4 id="z算法">Z算法</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ca07496a60-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_f6f54a1c60-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_33dfcb7e60-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_3623ccf060-4.png" alt="4.png" loading="lazy"><br>
r[5] = 7<br>
r[6] = 7<br>
l[5] = 5<br>
l[6] = 5<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_5abceae260-5.png" alt="5.png" loading="lazy"><br>
对于 Z[2] 我们需要暴力计算。<br>
也就是暴力计算 S[1..|S|] 和 S[2..|S|] 的最长公共前缀。<br>
如果 Z[2] &gt; 0, 那么 r = r[2], l = l[2] = 2<br>
如果 Z[2] = 0, 那么 r = r[2] = 0, l = l[2] = 0</p>
<p>我们的目标就是用已有的 Z[2], Z[3], ..., Z[k-1]，来推<br>
出 Z[k].<br>
假设 k = 121, Z[2..120] 已经知道了<br>
r[120] = 130, l[120] = 100<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_884cb29e60-6.png" alt="6.png" loading="lazy"><br>
划分成[l,i-1],[i,r]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_cfa5d35a60-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_37ddc43260-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_61fb79d060-9.PNG" alt="9.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_83939b3660-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_121af6c460-11.png" alt="11.png" loading="lazy"><br>
蓝色部分一定不相等，否则说明z-box可以右移</p>
<p>第一步：<br>
初始化 Z[]，暴力计算 Z[2]</p>
<pre><code>for(int i = 1;i &lt;= n;i ++) z[i] = 0;
int l, r;
while(str[1 + z[2]] == str[2 + z[2]]) z[2] ++; 
l = 2, r = 2+ z[2]-1;
</code></pre>
<p>第二步：<br>
枚举 i，分三种情况依次计算 Z[i]</p>
<pre><code>for(int i = 3;i &lt;= n;i ++)
{
    if(i &gt; r)
    {
        while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
        l = i, r = i + z[i] - 1;
    }
    else
    {
        if(z[i - l + 1] &lt; r - i + 1) z[i] = z[i - l + 1];
        else
        {
            z[i] = r - i;
            while(str[1 + z[i]] == str[i + z[i]]) z[i] ++; 
            l = i, r = i + z[i] - 1; 
        }
    } 
}
</code></pre>
<h4 id="时间复杂度是-on-的">时间复杂度是 O(n) 的</h4>
<h4 id="扩展kmp">扩展KMP</h4>
<p>给定两个字符串 S 和 T（长度分别为 n 和 m）<br>
定义 extend[i] 为 S[i..n] 与 T 的最长公共前缀的长度。<br>
求出 extend 数组<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_e93cf15860-12.PNG" alt="12.PNG" loading="lazy"><br>
如果 S = T，那么 extend 数组就是 Z 数组。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_fe0303ca60-13.PNG" alt="13.PNG" loading="lazy"></p>
<p>假设现在遍历到了 S[i]，且 S[1], S[2],…, S[i-1]都已经算出<br>
与 Z 算法类似，设置两个变量 l 和 r，r 表示能和 T 匹<br>
配到的最右边的位置，l 为 r 对应的起始位置。<br>
也就是 S[l .. r] = T[1.. r-l+1]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1677f3ac60-14.PNG" alt="14.PNG" loading="lazy"></p>
<p>S[i] 对应的是 T[i-l+1]<br>
现在要计算的是 S[i..n] 与 T 的最长公共前缀<br>
注意到此时 S[i..r] = T[i-l+1 .. r-l+1]<br>
所以我们可以先对 T 求一遍 Z 数组，然后考察一下 Z[i-l+1]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_7411db9460-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_a95260c660-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_de7d174760-16.png" alt="16.png" loading="lazy"></p>
<pre><code>void calc_Z(char *str) 
{
	int n = strlen(str + 1);
	for(int i = 1; i &lt;= n; i ++) z[i] = 0;
	z[1] = n;
	int l, r = 0;
	for(int i = 2; i &lt;= n; i ++) 
	{
		if(i &gt; r) 
		{
			while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
			l = i, r = i + z[i] - 1;
		} else 
		{
			if(z[i - l + 1] &lt; r - i + 1) z[i] = z[i - l + 1];
			else 
			{
				z[i] = r - i + 1;
				while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
				l = i, r = i + z[i] - 1;
			}
		}
	}
}
</code></pre>
<pre><code>void calc_extend(char *S, char *T) 
{
	calc_Z(T);
	int l, r = 0;
	int n = strlen(S + 1);
	int m = strlen(T + 1);
	for (int i = 1; i &lt;= n; i ++) 
	{
		if (i &gt; r) 
		{
			while (i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp;
			        S[i + ext[i]] == T[1 + ext[i]]) ext[i] ++;
			l = i, r = i + ext[i] - 1;
		}
		else 
		{
			if (i + z[i - l + 1] - 1 &lt; r) ext[i] = z[i - l + 1];
			else 
			{
				ext[i] = r - i + 1;
				while (i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp; S[i +ext[i]] == T[1 + ext[i]]) 
					ext[i] ++;
				l = i, r = i + ext[i] - 1;
			}
		}
	}
}
</code></pre>
<h4 id="例题-4">例题</h4>
<p>题意：给你n个字符串，求这n个字符串的最长公共子串</p>
<p><a href="https://vjudge.net/problem/HDU-4333">hdu4333</a><br>
给一个 L 位数的正整数 N，每次可以把这个数的最后一位移到最前面来，得到一个新的数。<br>
总共最多可以得到 n 个数，重复的只算一次。<br>
问这些数中，等于 n 的，小于 n的，大于 n 的数分别有几个。<br>
L ≤ 1e5</p>
<blockquote></blockquote>
<p>样例：<br>
341 （答案： 1 1 1）</p>
<p>我们只需要把这个数复制两遍，然后只考虑长度为 n 的子串。这些子串就是移动过程中产生的数。<br>
如何和原数 N 做比较呢</p>
<p>假设现在的数是 S[i .. i+L-1], N 是 S[1..L]<br>
我们只要求出他们的最长公共前缀 x，如果 x = n 说明这两个数相等。<br>
否则，比较 S[x] 和 S[i+x-1] 的大小，就可以确定他们的大小关系。<br>
求 x ，就是扩展 KMP 中的 Z 算法。x = min(n, Z[i])</p>
<p>最后一步去重。对 N 跑一次 KMP<br>
如果 L-next[L] 是 L 的约数，那么 L-next[L] 是 N 的最小循环节。否则 N 的 最小循环节是 L。<br>
对循环节内的情况枚举一遍即可,或除以最小循环节个数。<br>
时间复杂度 O(L)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=200010;
char str[N];
int ne[N];
int z[N];

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    for(int kas=1;kas&lt;=T;kas++)
    {
        scanf(&quot;%s&quot;,str+1);
        
        int len=strlen(str+1);
        for(int i=2,j=0;i&lt;=len;i++)
        {
            while(j &amp;&amp; str[i] != str[j+1])
                j=ne[j];
            if(str[i] == str[j+1])
                j++;
            ne[i]=j;
        }
        
        for(int i=1;i&lt;=len;i++)
            str[i+len]=str[i];
        str[len*2+1]='\0';
        memset(z,0,sizeof z);
        z[1]=len*2;
        int l,r=0;
        
        for(int i=2;i&lt;=len*2;i++)
        {
            if(i&gt;r)
            {
                while(str[1+z[i]] == str[i+z[i]])
                    z[i]++;
                l=i,r=i+z[i]-1;
            }
            else 
            {
                if(z[i-l+1] &lt; r-i+1)
                    z[i]=z[i-l+1];
                else 
                {
                    z[i]=r-i;
                    while(str[1+z[i]] == str[i+z[i]])
                        z[i]++;
                    l=i,r=i+z[i]-1;
                }
            }
        }
        
        int gre=0,eql=0,les=0;
        for(int i=1;i&lt;=len;i++)
        {
            if(z[i] &gt;= len)
                eql++;
            else if(str[1+z[i]] &gt; str[i+z[i]])
                les++;
            else gre++;
        }
        
        int t;
        if(len%(len-ne[len]) == 0)
            t=len/(len-ne[len]);//循环节个数 
        else 
            t=1;
        printf(&quot;Case %d: %d %d %d\n&quot;,kas,les/t,eql/t,gre/t);
    }
}
</code></pre>
<p>对循环节内的情况枚举<a href="https://paste.ubuntu.com/p/HrvmzSySDv/">代码</a></p>
<p><a href="https://vjudge.net/problem/POJ-3376">poj3376</a><br>
给你 n 个字符串 m[1], m[2], …, m[n]。 求 S = m[i]m[j] （1 &lt;= i,j &lt;= n）是回文串的数量。<br>
n 个字符串的长度之和不超过 2·1e6</p>
<blockquote></blockquote>
<p>样例输入：<br>
3a<br>
ab<br>
ba<br>
答案：5（aa,aba,aba,abba,baab)</p>
<p>考虑什么情况下 i 和 j 拼起来会是回文串。</p>
<ul>
<li>
<p>i的长度小于j，那么i一定是j的反串的前缀，且j的反串剩下的后缀是回文串</p>
</li>
<li>
<p>i的长度等于j，那么i等于j的反串</p>
</li>
<li>
<p>i的长度大于j，那么j的反串一定是i的前缀，且i串剩下的后缀是回文串</p>
</li>
</ul>
<p>我们可以将这n个字符串插入trie，每个节点要维护两个值：<br>
value1. 到当前节点的字符串个数；value2.当前节点后面的回文子串个数</p>
<p>我们用每个字符串的反串去trie上查找，要构成回文串有以下情况：</p>
<ul>
<li>
<p>1.此反串是其他串的前缀，那么组合回文串的数量就要加上value2</p>
</li>
<li>
<p>2.此反串的前缀是某些字符串，且反串剩下的后缀是回文串，那么组合回文串的数量要加上value1</p>
</li>
<li>
<p>3.2的特例：此反串的前缀是某些字符串，且反串剩下的后缀为空，同样要加上value1，这种情况可以和2一起处理</p>
</li>
</ul>
<p>留下的问题就是一个字符串的所有后缀中，哪些是回文串。<br>
对于串 S，我们先求出正串 S 对反串 T 的 extend[i]<br>
那么对于每个 i，如果 S[i..n] 和 T 的最长公共前缀等于<br>
S[i..n] 的长度，说明 S[i..n] 是一个回文串。<br>
因此整道题就在线性的时间复杂度内解决了。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=2e6+10;
int trie[N][26],tot=1;
int n;
char s[N],t[N];
int len[N];
int slen;
int z[N],ext[N];
bool flag[2][N];
int bg[N],ed[N];
typedef long long LL;
struct Node
{
	int v1,v2;
}cnt[N];

void get_z(char *s)
{
	int n=strlen(s+1);
	for(int i=1;i&lt;=n;i++) z[i]=0;
	z[1]=n;
	int l,r=0;
	for(int i=2;i&lt;=n;i++)
	{
		if(i&gt;r)
		{
			while(s[1+z[i]] == s[i+z[i]])
				z[i]++;
			l=i,r=i+z[i]-1;
		}
		else
		{
			if(z[i-l+1] &lt; r-i+1)
				z[i]=z[i-l+1];
			else
			{
				z[i]=r-i;
				while(s[1+z[i]] == s[i+z[i]])
					z[i]++;
				l=i,r=i+z[i]-1;
			}
		}
	}
}

void exkmp(int type,char *s,char *t)
{
	get_z(t);
	int n=strlen(s+1);
	int m=strlen(t+1);
	for(int i=1;i&lt;=n;i++)
		ext[i]=0;
	int l,r=0;
	for(int i=1;i&lt;=n;i++)
	{
		if(i&gt;r)
		{
			while(i+ext[i] &lt;=n &amp;&amp; 1+ext[i] &lt;=m &amp;&amp;
			s[i+ext[i]] == t[1+ext[i]])
				ext[i]++;
			l=i,r=i+ext[i]-1;
		}
		else
		{
			if(z[i-l+1] &lt; r-i+1)
				ext[i]=z[i-l+1];
			else
			{
				ext[i]=r-i+1;
				while(i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp; 
				s[i+ext[i]] == t[1+ext[i]])
					ext[i]++;
				l=i,r=i+ext[i]-1;
			}
		}
	}

	for(int i=1;i&lt;=n;i++)
	{
		//cout&lt;&lt;&quot;---&quot;&lt;&lt;ext[i]&lt;&lt;endl;
		if(ext[i] == n-i+1)
			flag[type][i+slen]=true;//s[i...n]为回文串
	}
}

void insert(int k)
{
	int p=1;
	for(int i=bg[k];i&lt;=ed[k];i++)
	{
		cnt[p].v2+=flag[0][i];
		int ch=s[i]-'a';
		if(!trie[p][ch])
			trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	cnt[p].v1++;
}

void print(int k)
{
	int p=1;
	for(int i=bg[k];i&lt;=ed[k];i++)
	{
		int ch=s[i]-'a';
		p=trie[p][ch];
		cout&lt;&lt;&quot;---&quot;&lt;&lt;cnt[p].v2&lt;&lt;' '&lt;&lt;cnt[p].v1&lt;&lt;endl;
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;len[i]);
		scanf(&quot;%s&quot;,s+1+slen);
		for(int j=1;j&lt;=len[i];j++)
			t[slen+j]=s[slen+len[i]+1-j];
		t[slen+len[i]+1]='\0';
		exkmp(0,s+slen,t+slen);
		exkmp(1,t+slen,s+slen);

		bg[i]=slen+1;
		slen+=len[i];
		ed[i]=slen;

		insert(i);
		//print(i);
	}

	LL ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		int p=1;
		bool f=true;
		for(int j=ed[i];j&gt;=bg[i];j--)//用反串去trie上匹配
		{
			int k=s[j]-'a';
			if(!trie[p][k])
			{
				f=false;
				break;
			}
			else
				p=trie[p][k];
			if(flag[1][bg[i]+ed[i]-j+1] || j == bg[i])
				ans+=cnt[p].v1;
		}
		if(f)
			ans+=cnt[p].v2;
	}

	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>