<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caifxh.github.io</id>
    <title>fxh</title>
    <updated>2020-04-03T02:57:42.901Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caifxh.github.io"/>
    <link rel="self" href="https://caifxh.github.io/atom.xml"/>
    <subtitle>菜</subtitle>
    <logo>https://caifxh.github.io/images/avatar.png</logo>
    <icon>https://caifxh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, fxh</rights>
    <entry>
        <title type="html"><![CDATA[牛客寒假第一场]]></title>
        <id>https://caifxh.github.io/post/niu-ke-han-jia-di-yi-chang/</id>
        <link href="https://caifxh.github.io/post/niu-ke-han-jia-di-yi-chang/">
        </link>
        <updated>2020-04-02T11:15:50.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3002/G">G</a><br>
eli拿到了一个仅由小写字母组成的字符串。<br>
她想截取一段连续子串，这个子串包含至少k个相同的某个字母。<br>
她想知道，子串的长度最小值是多少？</p>
<p>题意<br>
相当于就是找字符串当中拥有k个相同字母的最小长度。<br>
直接模拟，通过二维数组，遇到个字母把在字符串的位置它放到对应字母的后面，然后进行判断，不断更新ans的最小值</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int n,k;
const int INF=0x3f3f3f3f;
int ans=INF;
vector&lt;int&gt; v[26];

int main()
{
    cin&gt;&gt;n&gt;&gt;k;
	string str;
	cin&gt;&gt;str;
	
	for(int i=0;i&lt;str.size();i++)
	{
		int x=str[i]-'a';
		v[x].push_back(i);
		int len=v[x].size();
		if(len &gt;= k)
			ans=min(ans,i-v[x][len-k]+1);
	}
	
	if(ans == INF)
		cout&lt;&lt;-1&lt;&lt;endl;
	else
		cout&lt;&lt;ans&lt;&lt;endl;

    return 0;
}
</code></pre>
<p><a href="https://ac.nowcoder.com/acm/contest/3002/A">A</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_a19ccce474-18.PNG" alt="18.PNG" loading="lazy"></p>
<p>题解<br>
可以把面积为 1 的“好三角形”分为两类分开统计：两条边和两个坐标轴平行；只有一条边和某个坐标轴平行。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_e233367674-2.PNG" alt="2.PNG" loading="lazy"><br>
对于第二种情况，可以分别统计底边为 2 、高为 1 和底边为 1 、高为 2 的情况。要注意底边靠近边界时的特殊讨论。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_451ae75874-3.PNG" alt="3.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int mod=1e9+7;

int main()
{
	LL n,m;
	cin&gt;&gt;n&gt;&gt;m;
	
	LL ans=4*((n-2)*(m-1)%mod + (m-2)*(n-1)%mod)%mod;
	
	ans=(ans+2*(n-2)*(n-2)%mod*(m-1)%mod+2*(m-2)*(m-2)%mod*(n-1)%mod)%mod;
	
	ans=(ans+2*(n-1)*(n-2)%mod*(m-2)%mod+2*(m-1)*(m-2)%mod*(n-2)%mod)%mod;
	
	cout&lt;&lt;ans&lt;&lt;endl;
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP其他优化]]></title>
        <id>https://caifxh.github.io/post/dp-you-hua/</id>
        <link href="https://caifxh.github.io/post/dp-you-hua/">
        </link>
        <updated>2020-04-02T04:45:38.000Z</updated>
        <content type="html"><![CDATA[<h4 id="滚动数组优化">滚动数组优化</h4>
<p><a href="https://www.luogu.com.cn/problem/P2679">P2679</a><br>
有两个仅包含小写英文字母的字符串 A 和 B。现在要从字符串 A 中取出 k 个互不重叠的非空子串，然后把这 k 个子串按照其在字符串 A中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 B 相等？<br>
注意：子串取出的位置不同也认为是不同的方案。<br>
1 ≤ |A| ≤ 1000， 1 ≤ k ≤ |B| ≤ 200<br>
样例输入：（答案：7）<br>
6 3 2<br>
aabaab<br>
aab</p>
<p>我们令f[i][j][k][0/1]表示A串用了前i个字符，B串已覆盖前j个字符，目前为止已经选了<br>
k个子串，最后的0/1表示A串的这个字符选了没有(0没选，1选了)。<br>
为了得出状态转移方程，我们分情况讨论：<br>
先看f[i][j][k]<a href="%E5%BD%93%E5%89%8D%E4%BD%8D%E9%80%89%E4%BA%86">1</a>，显然当且仅当a[i]=b[j]的时候它才有意义，否则<br>
f[i][j][k][1]=0。<br>
到这个状态有三种方法：</p>
<ol>
<li>上一位没有选，新开一个子串</li>
<li>上一位选了，延续这个子串</li>
<li>上一位选了，但是仍然新开一个子串<br>
因此，我们有<br>
f[i][j][k][1]=f[i-1][j-1][k-1][0]+f[i-1][j-1][k][1]+f[i-1][j-1][k-1][1]</li>
</ol>
<p>然后讨论另一种情况：这个字符不选。<br>
这个比较简单，到这个状态有两种方法：</p>
<ol>
<li>上一位没有选，现在仍然不选</li>
<li>上一位选了，结束这个子串<br>
因此，我们有<br>
f[i][j][k][0]=f[i-1][j][k][0]+f[i-1][j][k][1]。</li>
</ol>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=210,M=1010,mod=1e9+7;
int f[2][N][N][2];
int n,m,k;
char a[M],b[N];

int main()
{
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	cin&gt;&gt;a+1&gt;&gt;b+1;
	
	f[0][0][0][0]=1;
	for(int i=1;i&lt;=n;i++)
	{
	    f[i&amp;1][0][0][0]=1;
		for(int j=1;j&lt;=m;j++)
			for(int t=1;t&lt;=k;t++)
				if(a[i] == b[j])
					f[i&amp;1][j][t][1]=((f[i-1&amp;1][j-1][t-1][1]+f[i-1&amp;1][j-1][t][1])%mod+f[i-1&amp;1][j-1][t-1][0])%mod,
					f[i&amp;1][j][t][0]=(f[i-1&amp;1][j][t][1]+f[i-1&amp;1][j][t][0])%mod;
				else 
				 	f[i&amp;1][j][t][0]=(f[i-1&amp;1][j][t][0]+f[i-1&amp;1][j][t][1])%mod,
				 	f[i&amp;1][j][t][1]=0;
	}
	
	printf(&quot;%d\n&quot;,(f[n&amp;1][m][k][0]+f[n&amp;1][m][k][1])%mod);
	return 0;
}
</code></pre>
<h4 id="矩阵乘法优化">矩阵乘法优化</h4>
<p>对于两维以上的 dp，如 f[i][j][k]，如果它的转移全部来自 f[i - 1]，那我们可以使用矩阵来加速。<br>
也就是把 f[i] 压缩成一维数组，f[i-1] 也压缩成一维数组。<br>
转移方程 就相当于 f[i-1] 到 f[i] 乘上的转移矩阵。<br>
<code>比如 f[i][t] += f[i-1][s]，那么转移矩阵中的第 s 行第t 列的元素就要加一。</code><br>
这样对于转移 n 次的 dp，我们只要计算矩阵的 n 次幂即可。<br>
时间复杂度可以从 O(n) 减少为 O(log n)</p>
<p>有 N 个方格排成一列，用红、绿、蓝、黄四种颜色来涂每个方格。<br>
每个格子都必须涂，且只能涂一次。问使得红色和蓝色的格子的数量为偶数的方案数。N ≤ 1e9</p>
<p>简单的线性模型。<br>
我们可以用 f[i][a][b][c][d] 来表示填了前 i 个数字，且4 种颜色的奇偶性分别为 a, b, c, d。（0 表示偶数，1 表<br>
示奇数）<br>
方便起见我们把 abcd 看作一个二进制数 s，范围是 0～15,记为 f[i][s]</p>
<p>思考转移：<br>
f[i][s] 可以转移到哪些状态呢？<br>
枚举第 i+1 位的颜色：一共有 0，1，2，3 四种选择。<br>
假设选择颜色 j，那么颜色 j 的奇偶性会发生改变，也就是<br>
得到了新的状态 s ^ (1 &lt;&lt; j)<br>
f[i + 1][s ^ (1 &lt;&lt; j)] += f[i][s]<br>
可以发现每次都是从 f[i] 转移到 f[i + 1]<br>
因此我们只要让矩阵的第 s 行第 s ^ (1 &lt;&lt; j) 列 加一即可。<br>
然后计算矩阵的 n 次幂，乘上 f[0] 就可以得到 f[n] 了。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=20,mod=10007;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
};
int n;

matrix mul(matrix a,matrix b)
{
	matrix c;
	for(int i=0;i&lt;1&lt;&lt;4;i++)
		for(int j=0;j&lt;1&lt;&lt;4;j++)
			for(int k=0;k&lt;1&lt;&lt;4;k++)
				c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return c;
}

matrix qmi(matrix a,int k)
{
	matrix c;
	for(int i=0;i&lt;1&lt;&lt;4;i++)
		c.m[i][i]=1;
		
	while(k)
	{
		if(k&amp;1) c=mul(c,a);
		a=mul(a,a);
		k&gt;&gt;=1;
	}
	return c;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		
		matrix a;
		for(int s=0;s&lt;1&lt;&lt;4;s++)
			for(int i=0;i&lt;4;i++)
				a.m[s][s^(1&lt;&lt;i)]=1;
		
		a=qmi(a,n);
		
		int ans=0;
		for(int i=0;i&lt;1&lt;&lt;4;i++)
			if(!(i&gt;&gt;1 &amp; 1) &amp;&amp; !(i&gt;&gt;2 &amp; 1))
				ans=(ans+a.m[0][i])%mod;
		
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<h4 id="前缀数组优化">前缀数组优化</h4>
<p>新的电话线架设在已有的 N(2≤N≤100000) 根电话线杆上，第 i 根电话线杆的高度为h<a href="1%E2%89%A4h%5Bi%5D%E2%89%A4100">i</a>。如果两根电话线杆的高度不同，那么就需要支付 C *电话线杆高度差(1≤C≤100)的费用。你不能移动电话线杆，只能按照原有的顺序在相邻的线杆间架设电话线。当然你也可以加高某些电话线杆，加高 X 米需要付出 X2 的费用。<br>
请问最少需要花多少钱建设新的电话线。</p>
<p>基本思路：<br>
观察发现 h[i] 不大，可以作为状态。<br>
用 f[i][j] 表示第 i 根电线杆的长度为 j 时的最小代价。<br>
状态转移：<br>
f[i][j] = min{f[i-1][k] + c * |j - k| + (j - h[i])2}</p>
<p>这样的时间复杂度是 O(NK2)<br>
状态有 NK 个，瓶颈在于计算每个状态需要枚举前一个电线杆的可能的 K 种高度。<br>
f[i][j] = min{f[i-1][k] + c * |j - k|} + (j - h[i])2<br>
但是前一部分还是有 j 在，如果我们能把 j 和 k 分离，我们就可以方便的优化。</p>
<p>我们可以把绝对值拆掉，也就是分类讨论：<br>
如果 j &gt; k，那么 |j - k| = j - k<br>
f[i][j] = min{f[i-1][k] - ck} + cj + (j - h[i])2<br>
如果 j &lt; k，那么 |j - k| = k - j<br>
f[i][j] = min{f[i-1][k] + ck} - cj + (j - h[i])2</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010,M=110,INF=0x3f3f3f3f;
int f[2][M];
int h[N],mx;
int n,c;

int sqr(int x)
{
	return x*x;
}

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;c);
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;h[i]),mx=max(mx,h[i]);
	
	for(int i=1;i&lt;=mx;i++)
	    f[0][i]=f[1][i]=INF;
	
	for(int i=h[1];i&lt;=mx;i++)
		f[1][i]=sqr(i-h[1]);//增高第一个电线杆的高度至i的花费为(i-h[1])(i-h[1]) 
	
	for(int i=2;i&lt;=n;i++)
	{
        int val=INF;
		for(int j=1;j&lt;=mx;j++)
		{
			val=min(val,f[i-1&amp;1][j]-c*j);
			if(j &gt;= h[i])
			    f[i&amp;1][j]=min(f[i&amp;1][j],val+c*j+sqr(j-h[i]));
                //f[i&amp;1]每轮要初始化为INF，因为比较时用到了f[i&amp;1]
		}
		
		val=INF;
		for(int j=mx;j&gt;=h[i];j--)
		{
			val=min(val,f[i-1&amp;1][j]+c*j);
			f[i&amp;1][j]=min(f[i&amp;1][j],val-c*j+sqr(j-h[i]));
		}
		
		for(int j=1;j&lt;=mx;j++)1]
		    f[i+1&amp;1][j]=INF;
	}
	
	int ans=INF;
	for(int i=h[n];i&lt;=mx;i++)
		ans=min(ans,f[n&amp;1][i]);
	
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p>首先考虑计算从 x 到 y 的耗费体力最小的路径。<br>
显然是最短路问题。<br>
因为最多只有 300 个点，可以方便的使用 Floyd 算法先用<br>
O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>V</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">V^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>) 的时间复杂度预处理出任意两点间的最短路。</p>
<p>如何计算耗费体力值的期望值？<br>
只用对每条边考虑有多少概率会经过这条边。<br>
设概率为 p，这条边耗费的体力值是 w<br>
那么这条边对答案的贡献就是 pw。<br>
最后只要把每条边的贡献加起来就是耗费体力值的总和的期望。(期望的可加性)</p>
<p>用 f[i][j][p] 来表示前 i 节课中用了 j 次换教室的机会<br>
的最小体力总和的期望。<br>
p = 0 或 1，表示第 i 节课是否用了换教室的机会。<br>
目的是定位此时牛牛在哪个教室。<br>
p = 0 ➔ 没换，在 c[i] 教室<br>
p = 1 ➔ 换了，在 d[i] 教室</p>
<p>对第 i 节课，考虑决策：换 or 不换。<br>
不换：<br>
牛牛需要赶到教室 c[i]<br>
有两种可能<br>
一种是上一节课换了：</p>
<ul>
<li>有k[i-1]的概率从d[i-1]赶来</li>
<li>有(1-k[i-1])的概率从c[i-1]赶来</li>
</ul>
<p>另一种是没换：</p>
<ul>
<li>从c[i-1]赶来</li>
</ul>
<p>换：<br>
牛牛有 k[i] 的概率需要赶到教室 d[i]， 有 (1-k[i]) 的概率需要赶到教室 c[i]<br>
而上一节课也有两种可能：<br>
上一节课换了：</p>
<ul>
<li>有k[i-1]的概率从d[i-1]赶来</li>
<li>有(1-k[i-1])的概率从c[i-1]赶来</li>
</ul>
<p>上一节课没换：</p>
<ul>
<li>从c[i-1]赶来</li>
</ul>
<p>最后的答案就是 min{f[n][i][0], f[n][i][1] | 0≤i≤m}<br>
预处理最短路：<br>
时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>V</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">V^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)<br>
DP状态数 O(nm)，转移 O(1)，时间复杂度 O(nm)<br>
由于 f[i] 由 f[i-1] 转移过来，可以使用滚动数组优化空间。空间复杂度 O(m)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const double INF=1e9;
const int N=2010,M=310;
int c[N],d[N];
double k[N];
int dist[N][N];
double f[2][N][2];//f[i][j][0/1]表示前i节课用来j次换教室的机会，上节课换/没换 
int n,m,v,e;

void floyd()
{
    for(int k=1;k&lt;=v;k++)
        for(int i=1;i&lt;=v;i++)
            for(int j=1;j&lt;=v;j++)
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;v&gt;&gt;e;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;c[i];
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;d[i];
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;k[i];

    memset(dist,0x3f,sizeof dist);
    for(int i=1;i&lt;=v;i++) dist[i][i]=0;//初始化为0，因为可能通过换教室使得下节课教室不变
    while(e--)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        dist[a][b]=dist[b][a]=min(dist[a][b],c);
    }

    floyd();

    for(int j=0;j&lt;=m;j++)
        f[0][j][0]=f[0][j][1]=f[1][j][0]=f[1][j][1]=INF;

    f[1][0][0]=f[1][1][1]=0;
    for(int i=2;i&lt;=n;i++)
        for(int j=0;j&lt;=m;j++)
        {
            //这节不换,上节换/不换 
            f[i&amp;1][j][0]=min(f[i-1&amp;1][j][0]+dist[c[i-1]][c[i]],
                            f[i-1&amp;1][j][1]+k[i-1]*dist[d[i-1]][c[i]]+
                            (1-k[i-1])*dist[c[i-1]][c[i]]);

            //这节换，上节换/不换
            if(j)
            f[i&amp;1][j][1]=min(f[i-1&amp;1][j-1][0]+dist[c[i-1]][c[i]]*(1-k[i])+
                            dist[c[i-1]][d[i]]*k[i],
                            f[i-1&amp;1][j-1][1]+(1-k[i-1])*dist[c[i-1]][c[i]]*(1-k[i])+
                            (1-k[i-1])*dist[c[i-1]][d[i]]*k[i]+
                            k[i-1]*dist[d[i-1]][c[i]]*(1-k[i])+
                            k[i-1]*dist[d[i-1]][d[i]]*k[i]);    
        }

    double ans=INF;
    for(int i=0;i&lt;=m;i++)
        ans=min(ans,min(f[n&amp;1][i][0],f[n&amp;1][i][1]));

    printf(&quot;%.2f\n&quot;,ans);

    return 0;

}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2294">hdu2294</a><br>
你有 k 种珍珠，想用它们组成一个长度在1～n之间的一条首饰并且满足 k 种珍珠都至少出现一次。<br>
问有多少种不同的首饰。n ≤ 1e9, k ≤ 30<br>
样例：<br>
n = 3, k = 2<br>
答案：8（ab,ba,aab,aba,abb,baa,bab,bba)</p>
<p>用 f[i][j] 表示现在拼出了长度为 i 的序列，用了 j 种珍珠。<br>
决策是第 i 个珍珠是否使用新的种类：<br>
如果是旧的，那么有 j 种可能： j * f[i-1][j]<br>
如果是新的，那么有 k-j+1 种可能：(k-j+1)*f[i-1][j-1]<br>
因此我们得到了：<br>
f[i][j] = j * f[i - 1][j] + (k - j + 1) * f[i - 1][j - 1];</p>
<p>答案就是 f[0][k] + f[2][k] + … + f[n][k]<br>
由于 n 特别大，我们只能考虑矩阵乘法优化。<br>
显然 f[i] 都是由 f[i - 1] 转移过来的。</p>
<p>那么我们可以把 f[i] 看作是一个长度为 k + 1 的向量。<br>
[ f[i][0], f[i][1], …, f[i][k] ]<br>
然后就可以构造转移矩阵 A。<br>
这样 f[i] = f[i-1] * A</p>
<p>f[n] = f[0] * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><br>
f[n - 1] = f[0] * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">A^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> …<br>
f[0]=[ 1, 0, 0,.., 0]<br>
因此我们需要计算出 f[0] * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>I</mi><mo>+</mo><mi>A</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mi>A</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(I + A + A^2 + … + A^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
这是一个经典问题，二分 + 矩阵快速幂即可解决。</p>
<p>a.data[0][k] 即为答案。(相当于f[0][k] + f[2][k] + … + f[n][k])<br>
时间复杂度 O(k^3log n)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=35,mod=1234567891;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
};
int n,k;

matrix add(matrix a,matrix b)
{
	matrix c;
	for(int i=0;i&lt;=k;i++)
		for(int j=0;j&lt;=k;j++)
			c.m[i][j]=((LL)a.m[i][j]+b.m[i][j])%mod;
	return c;
}

matrix mul(matrix a,matrix b)
{
	matrix c;
	for(int i=0;i&lt;=k;i++)
		for(int j=0;j&lt;=k;j++)
			for(int t=0;t&lt;=k;t++)
				c.m[i][j]=(c.m[i][j]+(LL)a.m[i][t]*b.m[t][j])%mod;
	
	return c;
}

matrix qmi(matrix a,int b)
{
	matrix c;
	for(int i=0;i&lt;=k;i++)
		c.m[i][i]=1;
		
	while(b)
	{
		if(b &amp; 1) c=mul(c,a);
		a=mul(a,a);
		b&gt;&gt;=1;
	}
	
	return c;
}

matrix sum(matrix a,int b)
{
	if(b == 1) return a;
	matrix c;
	for(int i=0;i&lt;=k;i++)
		c.m[i][i]=1;
	
	c=add(c,qmi(a,b&gt;&gt;1));
	c=mul(c,sum(a,b&gt;&gt;1));
	if(b &amp; 1) c=add(c,qmi(a,b));
	
	return c;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
		
		matrix a;
		for(int i=0;i&lt;=k;i++)
		{
			a.m[i][i]=i;
			a.m[i-1][i]=k-i+1;
		}	

		a=sum(a,n);

		printf(&quot;%d\n&quot;,a.m[0][k]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[状压dp]]></title>
        <id>https://caifxh.github.io/post/zhuang-ya-dp/</id>
        <link href="https://caifxh.github.io/post/zhuang-ya-dp/">
        </link>
        <updated>2020-04-01T09:12:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="棋盘类基于连通性状压dp">棋盘类（基于连通性）状压dp</h3>
<h4 id="1十字型">1.十字型</h4>
<p><a href="https://www.acwing.com/problem/content/329/">玉米田</a></p>
<h4 id="输入样例">输入样例：</h4>
<pre><code>2 3
1 1 1
0 1 0
</code></pre>
<h4 id="输出样例">输出样例：</h4>
<pre><code>9
</code></pre>
<p>用二进制数来描述一行中方格的状态，1表示种玉米，0表示不种玉米<br>
样例第一行有以下5种种玉米的方案<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/12/9969_861e7ce04d-101.PNG" alt="101.PNG" loading="lazy"><br>
根据题意，把每一行的状态用二进制的数表示，0代表不在这块放牛，1表示在这一块放牛。首先很容易看到，每一行的状态要符合牧场的硬件条件，即牛必须放在能放牧的方格上。这样就能排除一些状态。另外，牛与牛之间不能相邻，这样就要求每一行中不能存在两个相邻的1，这样也能排除很多状态。然后就是根据上一行的状态转移到当前行的状态的问题了。必须符合不能有两个1在同一列（两只牛也不能竖着相邻）的条件。这样也能去掉一些状态。然后，上一行的所有符合条件的状态的总的方案数就是当前行该状态的方案数。</p>
<p>（1）初始化所有合法状态，即找没有相邻1的二进制数。用state[]存储合法状态<br>
（2）枚举不同合法状态之间的转移关系，只要a&amp;b == 0,状态a就可转到b<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_730aad4a74-51.png" alt="51.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;bitset&gt;
using namespace std;
const int N=15,M=1&lt;&lt;12,mod=1e8;
int f[N][M];
int g[N];
int n,m;
vector&lt;int&gt; state;
vector&lt;int&gt; head[M];

bool check(int state)//判断相邻两列
{
    if(state &amp; state&lt;&lt;1)
        return false;
    return true;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;m;j++)
        {
            int x;
            cin&gt;&gt;x;//若x为1，表示玉米田不可用
            g[i]+=!x&lt;&lt;(m-1-j);
        }

    for(int i=0;i&lt;1&lt;&lt;m;i++)
        if(check(i))
            state.push_back(i);//所有合法状态
    
    f[0][0]=1;//边界
    for(int i=1;i&lt;=n+1;i++)//枚举到第n+1行，省略求和
        for(int a=0;a&lt;state.size();a++)//第i行状态为a，i-1行状态为b
            for(int b=0;b&lt;state.size();b++)
            {
                if((g[i] &amp; state[a]) == 0 &amp;&amp; (state[a] &amp; state[b]) == 0) //不与上一行冲突，且不能在地图上0的地方种玉米
                    f[i][a]=(f[i][a]+f[i-1][b])%mod;
                }
    
    cout&lt;&lt;f[n+1][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/294/">炮兵阵地</a><br>
状态：f[i][j][k],已经摆完前i行，第i行状态是j，第i-1行状态是k的摆放方案<br>
属性： max<br>
划分依据，<br>
第i行状态不仅和第i-1行状态有关，还和第i-2行状态有关,所有f[i][j][k]第i行状态是j，第i-1行状态是k，依据i-2行状态来划分。<br>
a表示第i行状态，b表示第i-1行状态，c表示第i-2行状态<br>
要求：<br>
（1）每行的意大利炮不能相互攻击到，((a &amp; b) || (a &amp; c) || (a &amp; b))==0<br>
（2）意大利炮只能放在平地上,(g[i] &amp; a )||(g[i-1] &amp; b),无需判断g[i-2]行，若g[i-2]行意大利炮放到了山地上属于不合法状态，一定为0<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_8df3199474-52.png" alt="52.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_923b747474-53.png" alt="53.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
const int N=110,M=1&lt;&lt;10;//n的范围远大于m的范围，以列作为枚举的状态
int g[N];
int cnt[M];//状态对应的1的个数
vector&lt;int&gt; state;
int n,m;
int f[2][M][M];//f[i,j,k] 第i行状态是j，第i-1行状态是k

bool check(int state)
{
    if((state &amp; state&lt;&lt;1) || (state &amp; state&lt;&lt;2))
        return false;
    return true;
}

int count(int state)
{
    int res=0;
    for(int i=0;i&lt;m;i++)
        if(state&gt;&gt;i &amp;1)
            res++;
    return res;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;m;j++)
        {
            char c;
            cin&gt;&gt;c;
            if(c == 'H')
                g[i]+=1&lt;&lt;(m-1-j);
        }
        
    for(int i=0;i&lt;1&lt;&lt;m;i++)
    {
        if(check(i))
        {
            state.push_back(i);
            cnt[i]=count(i);
        }
    }
    //f[i,j,k] 已经摆完前i行，第i行状态是j，第i-1行状态是k
    for(int i=1;i&lt;=n+2;i++)
        for(int j=0;j&lt;state.size();j++)
            for(int k=0;k&lt;state.size();k++)
                for(int u=0;u&lt;state.size();u++)
                {
                    int a=state[j],b=state[k],c=state[u];//a表示第i行状态，b表示第i-1行状态，c表示第i-2行状态
                    if((a &amp; b) || (a &amp; c) || (a &amp; b))//相邻两行不能相互攻击到
                        continue;
                    if((g[i] &amp; a )||(g[i-1] &amp; b))//意大利炮不能放山地上
                        continue;
                    f[i&amp;1][a][b]=max(f[i&amp;1][a][b],f[i-1&amp;1][b][c]+cnt[a]);
                }
                
    cout&lt;&lt;f[n+2&amp;1][0][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="2井字型">2.井字型</h4>
<p><a href="https://www.acwing.com/problem/content/1066/">骑士</a><br>
状态：f[i][j][k],已经摆完前i行，第i行摆放状态是j（二进制位为1表示摆放，0表示不摆），已经摆了k个<br>
属性：count<br>
状态划分：<br>
要求：国王不能左右相邻，不能上下相邻，不能对角相邻，第i行状态为a，i-1行状态为b<br>
（1）每行内部不能有两个1相邻,（预处理）<br>
（2）第i行和第i-1行状态不能相互攻击到，(a &amp; b) == 0 ,a|b不能有两个相邻的1</p>
<pre><code>//第i行状态只跟第i-1行状态有关
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
const int N=12,M=1&lt;&lt;10,K=110;
typedef long long LL;
LL f[N][M][K];
vector&lt;int&gt; state;
int cnt[M];//每个状态对应1的数目
int n,m;

bool check(int state)
{
    for(int i=0;i&lt;n;i++)
    {
        if((state&gt;&gt;i &amp;1) &amp;&amp; (state&gt;&gt;i+1 &amp;1))
            return false;
    }
    return true;
}

int count(int state)
{
    int res=0;
    for(int i=0;i&lt;n;i++)    
        res+=state&gt;&gt;i &amp;1;
    return res;
}

int main()
{
    
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=0;i&lt;1&lt;&lt;n;i++)//如果满足左右互不相邻，则存储当前状态
        if(check(i))
        {
            state.push_back(i);
            cnt[i]=count(i);
        }
    //cout&lt;&lt;state.size()&lt;&lt;endl;
    f[0][0][0]=1;
    for(int i=1;i&lt;=n+1;i++)
        for(int a=0;a&lt;state.size();a++) 
            for(int k=0;k&lt;=m;k++)
                for(int b=0;b&lt;state.size();b++)
                {
                    int sa=state[a],sb=state[b];//sa表示第i行状态,sb表示第i-1行状态
                    if((sa &amp; sb) == 0 &amp;&amp; check(sa|sb))
                    {
                        int c=cnt[sa];
                        //cout&lt;&lt;sa&lt;&lt;' '&lt;&lt;sb&lt;&lt;' '&lt;&lt;k&lt;&lt;' '&lt;&lt;c&lt;&lt;endl;
                        if(k&gt;=c)
                            f[i][sa][k]+=f[i-1][sb][k-c];
                    }
                }
    
    cout&lt;&lt;f[n+1][0][m]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="3插头型">3.插头型</h4>
<p><a href="https://www.acwing.com/problem/content/293/">蒙德里安的梦想</a><br>
考虑决策——骨牌的放法：横着 或者 竖着。</p>
<p>如果横着：<br>
需要两个连续的空位，并且上一行的这两个位置也得已经被覆盖。</p>
<p>如果竖着：<br>
(a) 上一行对应的位置是空的，我们把那个空填上。<br>
(b) 上一行对应的位置是被覆盖的，那么我们把这一行的位置设为空，表示下一行的对应位置必须竖放，填上这块空白</p>
<p>状态表示：f[i][j],表示第i行的形态为j时的摆放方案数量<br>
j是用十进制记录的m位二进制数，其中第k（0&lt;=k&lt;m）位为1表示第k列是一个竖着的1*2的长方形的上面一半。</p>
<blockquote>
<p>记第i-1行状态为k，第i行状态为j<br>
k能转移到j，当且仅当：<br>
(1)j和k执行按位与为0，保证每个数字1下必须是0，才得以补全1<em>2的长方形<br>
(2)j和k执行按位或的结果，连续的0必须是偶数。这些0表示若干横着的1</em>2长方形，奇数个0无法满足这种摆放形态。</p>
</blockquote>
<h4 id="可以预处理出02m-1内所有满足连续的0必须是偶数的整数">可以预处理出[0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>-1]内所有满足连续的0必须是偶数的整数</h4>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 12, M = 1 &lt;&lt; N;
int st[M];
long long f[N][M];

int main()
{
    int n, m;
    while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n)
    {

        for (int i = 0; i &lt; 1 &lt;&lt; m; i ++)
        {
            int cnt = 0;// cnt 为当前已经存在多少个连续的0
            st[i] = true;
            for (int j = 0; j &lt; m; j ++)
                if (i &gt;&gt; j &amp; 1)
                {
                    if (cnt &amp; 1) //当前位为1，上一段连续为0的位置已结束
                        st[i] = false; 
                    cnt = 0;
                }
                else cnt ++;
            if (cnt &amp; 1) st[i] = false; // 扫完后要判断一下最后一段有多少个连续的0
        }
    
        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for (int i = 1; i &lt;= n; i ++)
            for (int j = 0; j &lt; 1 &lt;&lt; m; j ++)
                for (int k = 0; k &lt; 1 &lt;&lt; m; k ++)
                    if ((j &amp; k) == 0 &amp;&amp; (st[j | k])) 
                    // j &amp; k == 0 表示 i 行和 i-1 行不能同时捅出来
                    // st[j | k] == 1 表示 在 i 列状态 j， i - 1 列状态 k 的情况下（连续的0必须有偶数个）是合法的.
                        f[i][j] += f[i - 1][k];      
        cout &lt;&lt; f[n][0] &lt;&lt; endl;
    }
    return 0;
}

</code></pre>
<blockquote></blockquote>
<h3 id="集合类每个元素是否在集合里面状压dp">集合类（每个元素是否在集合里面）状压dp</h3>
<p><a href="https://www.acwing.com/problem/content/93/">最短Hamilton路径</a><br>
给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。<br>
状态表示：dp[i][j] ：所有从0走到j，走过的所有点的状态是i的最短路径<br>
状态划分：<br>
dp[i][j]表示所有从0走到j，当前已经走过点的为i的集合。所以这个状态转移方程就是找一个中间点k，将已经走过点的集合i中去除掉j（表示j不在经过的点的集合中），然后再加上从k到j的权值。问题在于如何表达已经走过点的集合i，其实很简单，假如走过0,1,4这三个点，我们用二进制10011就可以表示，2,3没走过所以是0。<br>
那么走过点的集合i中去除掉点j也很容易表示i - (1 &lt;&lt; j)，比方说i是{0,1,4}，j是1，那么i = 10011，(1 &lt;&lt; j) = 10，i - (1 &lt;&lt; j) = 10001<br>
那么问题的答案就应该是dp[01....111][n-1]，表示0~n-1都走过，且当前移动到n-1这个点。<br>
下时间复杂度：<br>
n为20的时候，外层循环(1&lt;&lt;20)，内层循环20，所以整体时间复杂度O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi mathvariant="normal">∗</mi><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">20∗2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">∗</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>)，这比O(n∗n!)快多了</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 20, M = 1 &lt;&lt; N;

int n;
int w[N][N];
int f[M][N];

int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i ++ )
        for (int j = 0; j &lt; n; j ++ )
            cin &gt;&gt; w[i][j];

    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;//第一个点是不需要任何费用的
    /*
    注意循环顺序
    如果反过来写，不能保证在f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j])中右边的状态在左边的状态之前被计算出来。
    */
    for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//i代表着是一个方案集合，其中每一个位置1和0，代表着这个点经过还是没有经过
        for (int j = 0; j &lt; n; j ++ )//枚举当前到了哪一个点
            if (i &gt;&gt; j &amp; 1)//如果i集合中第j位是1，也就是到达过这个点
                for (int k = 0; k &lt; n; k ++ )//枚举到达j的点k
                    if (i &gt;&gt; k &amp; 1)
                        f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]);

    cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1];

    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=2288">poj2288</a><br>
题意：<br>
给出n个点，m条边的无向图，给出每个点的点权，求点权和最小的哈密顿路径，相邻两个点要加上点权的乘积，形成环要加上环上的点权<br>
这题先占个坑，以后补。。。。</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1074">hdu1074</a><br>
题意：<br>
给了n个家庭作业，然后给了每个家庭作业的完成期限和花费的实践，如果完成时间超过了期限，那么就要扣除分数，然后让你找出一个最优方案使扣除的分数最少，当存在多种方案时，输出字典序最小的那种，因为题意已经说了家庭作业的名字是按照字典序从小到大输入的，所以处理起来就好多了。</p>
<h4 id="思路">思路</h4>
<p>在引出正解前，我们从DFS开始引入，如果这题用DFS来写，想必大家都有思路，很好理解。因为每个作业要么写，要么不写，因此开个布尔数组搜就行了，而且这题n &lt;= 15;仔细想来，加点剪枝还是可以过的没准。<br>
如果我们把布尔数组看成一个二进制位，进行状态压缩，很明显可以知道，最多只有2的15次方位的1二进制大小的状态。因此可以用2进制所对应的10进制来表示状态，这就是状态压缩。<br>
状态表示:dp[i]记录完成作业状态为i时的最少损失的分数。<br>
状态划分：<br>
1.状态a能做第i号作业的条件是a中作业i尚未完成，即a&amp;i=0。<br>
2.若有两个状态dp[a],dp[b]都能到达dp[i],那么选择能使到达i扣分小的那一条路径，若分数相同，转入3<br>
3.这两种状态扣的分数相同，那么选择字典序小的，由于作业按字典序输入，故即dp[i].pre = min(a,b);<br>
最后dp[2^n-1]即为最少扣分，课程安排可递归的输出</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;bitset&gt;
using namespace std;
const int N=20,M=1&lt;&lt;15;
const int INF=0x3f3f3f3f;
struct
{
    char sbj[110];
	int deadline;
	int fintime;
}w[N];
int dp[M];//dp[i]表示当前写作业状态是i的情况下被扣分的最小值 
int pre[M];//记录前驱 
int day[M];//记录当前写作业状态是i的情况下已经过了多少天 
int n;

void print_path(int state)
{
    if(state==0)return;
    int t=0;
    for(int i=0;i&lt;n;i++)
      if( (state&amp;(1&lt;&lt;i))!=0 &amp;&amp; (pre[state]&amp;(1&lt;&lt;i))==0 )
      {
          t=i;
          break;//按字典序最小输出，由于输入时已按字典序输入，找到第一个满足的break 
      }
    print_path(pre[state]);
    cout&lt;&lt;w[t].sbj&lt;&lt;endl;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=0;i&lt;n;i++)
          scanf(&quot;%s%d%d&quot;,&amp;w[i].sbj,&amp;w[i].deadline,&amp;w[i].fintime);
        memset(dp,0x3f,sizeof dp);
        memset(day,0,sizeof day); 
        dp[0]=0;//当前还未做作业时被扣分为0 
        for(int i=0;i&lt;1&lt;&lt;n;i++)
        {
        	//cout&lt;&lt;(bitset&lt;3&gt;(i))&lt;&lt;&quot; : &quot;&lt;&lt;endl;
            for(int j=0;j&lt;n;j++)
            {
                if(i&amp;(1&lt;&lt;j))continue;//第j位为1，表示第j位上的作业已完成，continue 
                int today=0;
//                for(int k=0;k&lt;n;k++)
//                  if(i&amp;(1&lt;&lt;k))
//                     today+=w[k].fintime;
//                today+=w[j].fintime;
				today=day[i]+w[j].fintime;//today表示今天是第几天 
				int score=0; 
                if(today&gt;w[j].deadline) 
					score=today-w[j].deadline;//完成日期与截止日期的差值 ，若差值&lt;0,则不需扣分 
                if(dp[i|(1&lt;&lt;j)]&gt;dp[i]+score)
                {
                    dp[i|(1&lt;&lt;j)]=dp[i]+score;
                    day[i|1&lt;&lt;j]=day[i]+w[j].fintime;
                    //cout&lt;&lt;&quot;--&quot;&lt;&lt;(bitset&lt;3&gt;(i|(1&lt;&lt;j)))&lt;&lt;' '&lt;&lt;dp[i|(1&lt;&lt;j)]&lt;&lt;endl;
                    pre[i|(1&lt;&lt;j)]=i;
                }
            }
            //cout&lt;&lt;endl;
        }
        printf(&quot;%d\n&quot;,dp[(1&lt;&lt;n)-1]);
        print_path((1&lt;&lt;n)-1);
    }
    return 0;
}
</code></pre>
<h4 id="旅行商问题tsp">旅行商问题(TSP)，</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/13/9969_0b0799de4e-lxs.PNG" alt="lxs.PNG" loading="lazy"><br>
TSP问题是NP难度的，没有多项式时间的高效算法。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_1125f75e4e-2221.png" alt="2221.png" loading="lazy"><br>
假设最短的TSP路径是path=（v0-&gt;v1-&gt;v2-&gt;v3-&gt;v4-&gt;v0）</p>
<h4 id="那么pathv0-v1v1-v2-v3-v0">那么path=(v0-&gt;v1)+(v1-&gt;v2-&gt;v3-&gt;v0)</h4>
<h4 id="所以问题转变为求经过所有城市的最短回路-从某个城市回到起点的最短路径">所以问题转变为：求经过所有城市的最短回路-&gt;从某个城市回到起点的最短路径</h4>
<p>DP状态：假设已经访问过的城市集合是S（已访问为1，未访问为0），当前所在城市是u，用dp[S][u]表示从u出发访问剩余的所有城市最后回到<strong>起点</strong>的路径费用总和的最小值。<br>
状态转移方程：<br>
dp[S][u]=min(dp[S∪{v}][v]+dist(u,v)|v∉S}<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/13/9969_63474b444e-%E5%9B%BE%E7%89%872.png" alt="图片2.png" loading="lazy"></p>
<h4 id="临界条件如果递推的话是起点递归的话是终点">临界条件如果递推的话是起点，递归的话是终点</h4>
<pre><code>#include&lt;cstring&gt;//递推，输出路径 
#include&lt;bitset&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=0x3f3f3f3f;
int dp[1&lt;&lt;15][15];//dp[S][u]:S表示已经过的节点，从u出发走完所有剩余顶点回到起点的最短距离
int g[15][15];
int path[1&lt;&lt;15][15];//最优路径
int n,m; //n个节点，m条边

void Init()
{
    memset(dp,0x3f,sizeof(dp));
    memset(g,0x3f,sizeof(g));
    memset(path,-1,sizeof(path));
}

void Traveling()//计算dp[S][u]
{
    dp[(1&lt;&lt;n)-1][0]=0;//注意：1&lt;&lt;n一定要加括号 
	for(int S=(1&lt;&lt;n)-2;S&gt;=0;S--)
        for(int u=0;u&lt;n;u++)
            for(int v=0;v&lt;n;v++)
			{//u可以等于0,起点0可看做已访问（从起点0出发回到起点0） 
            	if((u!=0&amp;&amp;!(S&gt;&gt;u&amp;1))||g[u][v]==INF) continue;，//若 u!=0，则u必须已访问 
				if(!(S&gt;&gt;v&amp;1)&amp;&amp;dp[S][u]&gt;dp[S|1&lt;&lt;v][v]+g[u][v])
                {
                    dp[S][u]=dp[S|1&lt;&lt;v][v]+g[u][v];
                    cout&lt;&lt;&quot;S=&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;\t   u=&quot;&lt;&lt;u&lt;&lt;&quot;\tv=&quot;&lt;&lt;v&lt;&lt;&quot;\tdp[&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;][&quot;&lt;&lt;u&lt;&lt;&quot;]=&quot;;
					cout&lt;&lt;&quot;dp[&quot;&lt;&lt;(bitset&lt;5&gt;(S|1&lt;&lt;v))&lt;&lt;&quot;][&quot;&lt;&lt;v&lt;&lt;&quot;]+&quot;&lt;&lt;g[u][v]&lt;&lt;&quot;=&quot;&lt;&lt;dp[S][u]&lt;&lt;endl;
                    path[S][u]=v;//记录后继节点
                }
        	}
}

void print(int S,int u)//打印路径
{
    if(S==(1&lt;&lt;n)-1) return;
    int v=path[S][u];//u的后继v
    cout&lt;&lt;&quot;---&gt;&quot;&lt;&lt;v;
	print(S|1&lt;&lt;v,v);//将v加入已走过的节点集合，再从v出发
}

int main()
{
	int u,v,w;//u,v代表城市，w代表u和v城市之间路的长度
    cin&gt;&gt;n&gt;&gt;m;
    Init();
    for(int i=0;i&lt;m;i++)
    {
       cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
       //g[u][v]=g[v][u]=w;//无向图 
       g[u][v]=w;//有向图 
    }
    Traveling();
    cout&lt;&lt;&quot;最短路径: &quot;&lt;&lt;0;
    print(0,0);
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;最短路径长度:&quot;&lt;&lt;dp[0][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_2800cfd84e-115.PNG" alt="115.PNG" loading="lazy"></figure>
<pre><code>#include&lt;cstring&gt;//记忆化递归，输出路径 
#include&lt;bitset&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=0x3f3f3f3f;
int dp[1&lt;&lt;15][15];//dp[S][u]:S表示已经过的节点，从u出发走完所有剩余顶点回到起点的最短距离
int g[15][15];
int path[1&lt;&lt;15][15];//最优路径
int n,m; //n个节点，m条边

void Init()
{
    memset(dp,-1,sizeof(dp));
    memset(g,0x3f,sizeof(g));
    memset(path,-1,sizeof(path));
}

int Traveling(int S,int u)//计算dp[S][u],记忆化递归 
{
    if(dp[S][u]&gt;=0)
    	return dp[S][u];
	if(S==(1&lt;&lt;n)-1&amp;&amp;u==0)
		return dp[S][u]=0;//递归结束条件
    int ans=INF;
	for(int v=0;v&lt;n;v++)
		if(!(S&gt;&gt;v&amp;1)&amp;&amp;g[u][v]!=INF)
		{
			int tmp=Traveling(S|1&lt;&lt;v,v)+g[u][v];
			if(ans&gt;tmp)
			{
				ans=tmp;
				cout&lt;&lt;&quot;S=&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;\t   u=&quot;&lt;&lt;u&lt;&lt;&quot;\tv=&quot;&lt;&lt;v&lt;&lt;&quot;\tdp[&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;][&quot;&lt;&lt;u&lt;&lt;&quot;]=&quot;;
				cout&lt;&lt;&quot;dp[&quot;&lt;&lt;(bitset&lt;5&gt;(S|1&lt;&lt;v))&lt;&lt;&quot;][&quot;&lt;&lt;v&lt;&lt;&quot;]+&quot;&lt;&lt;g[u][v]&lt;&lt;&quot;=&quot;&lt;&lt;ans&lt;&lt;endl;
				path[S][u]=v;//记录后继节点
			}		
		}
    return dp[S][u]=ans;
}

void print(int S,int u)//打印路径
{
    if(S==(1&lt;&lt;n)-1) return;
    int v=path[S][u];//u的后继v
    cout&lt;&lt;&quot;---&gt;&quot;&lt;&lt;v;
	print(S|1&lt;&lt;v,v);//将v加入已走过的节点集合，再从v出发
}

int main()
{
	int u,v,w;//u,v代表城市，w代表u和v城市之间路的长度
    cin&gt;&gt;n&gt;&gt;m;
    Init();
    for(int i=0;i&lt;m;i++)
    {
       cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
       //g[u][v]=g[v][u]=w;
       g[u][v]=w;
    }
    Traveling(0,0);
    cout&lt;&lt;&quot;最短路径: &quot;&lt;&lt;0;
    print(0,0);
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;最短路径长度:&quot;&lt;&lt;dp[0][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="http://poj.org/problem?id=3311">poj3311</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_c0342f484e-poj.png" alt="poj.png" loading="lazy"></p>
<h4 id="思路-2">思路</h4>
<p>由于题中明确说了两个城市间的直接可达路径（即不经过其它城市结点）不一定是最短路径，所以需要借助邻接矩阵首先求出任意两个城市间的最短距离（因为这里的点可以多次遍历，并没有次数限制，所以才能用floyd的，如果有次数限制x的话，就不能用floyd预处理，而应该用x进制的状态压缩了）。这一步骤使用Floyd最短路径算法即可。然后，在此基础上来求出遍历各个城市后回到出发点的最短路径的距离，即求解TSP问题。</p>
<pre><code>//求走过所有点并回到原点的最短路,可以走一个点多次.
//因为可以走一个点多次，所以，可以先求出每两个点之间的最短路，然后用经典的旅行商问题的状态压缩DP做法。
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=12,M=1&lt;&lt;11,INF=0x3f3f3f3f;
int n;
int g[N][N];
int dp[M][N];

void Init()
{
    memset(dp,-1,sizeof(dp));
    memset(g,0x3f,sizeof(g));
}

void floyd()
{
    for(int k=0;k&lt;n;k++)
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
}

int Tsp(int S,int u)//计算dp[S][u],记忆化递归 
{
	if(dp[S][u]&gt;=0)
    	return dp[S][u];
	if(S==(1&lt;&lt;n)-1&amp;&amp;u==0)//递归结束条件
		return dp[S][u]=0;
    int ans=INF;
	for(int v=0;v&lt;n;v++)
		if(!(S&gt;&gt;v&amp;1)&amp;&amp;g[u][v]!=INF)
			ans=min(ans,Tsp(S|1&lt;&lt;v,v)+g[u][v]);
    return dp[S][u]=ans;
}

int main()
{
    while(~scanf(&quot;%d&quot;,&amp;n),n)
    {
        n++;//源点0加上 
		Init();
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                scanf(&quot;%d&quot;,&amp;g[i][j]);
        floyd();
        printf(&quot;%d\n&quot;,Tsp(0,0));
    }
    return 0;
}
</code></pre>
<p>递推</p>
<pre><code>//求走过所有点并回到原点的最短路,可以走一个点多次.
//因为可以走一个点多次，所以，可以先求出每两个点之间的最短路，然后用经典的旅行商问题的状态压缩DP做法。
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=12,M=1&lt;&lt;11,INF=0x3f3f3f3f;
int n;
int g[N][N];
int dp[M][N];

void Init()
{
    memset(dp,0x3f,sizeof(dp));//递推时初始化为INF，记忆化递归初始化为-1 
    memset(g,0x3f,sizeof(g));
}

void floyd()
{
    for(int k=0;k&lt;n;k++)
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
}

void Tsp()//计算dp[S][u]
{
    dp[(1&lt;&lt;n)-1][0]=0;//注意：1&lt;&lt;n一定要加括号 
	for(int S=(1&lt;&lt;n)-2;S&gt;=0;S--)
        for(int u=0;u&lt;n;u++)
            for(int v=0;v&lt;n;v++)
			{
            	if((u!=0&amp;&amp;!(S&gt;&gt;u&amp;1))||g[u][v]==INF) continue;//可以加约束条件，不加状态多 
				if(!(S&gt;&gt;v&amp;1))
                    dp[S][u]=min(dp[S][u],dp[S|1&lt;&lt;v][v]+g[u][v]);
        	}
}

int main()
{
    while(~scanf(&quot;%d&quot;,&amp;n),n)
    {
        n++;//加上源点 
		Init();
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                scanf(&quot;%d&quot;,&amp;g[i][j]);
        floyd();
		Tsp();
        printf(&quot;%d\n&quot;,dp[0][0]);
    }
    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=2686">poj2686</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_9fa870324f-2686.png" alt="2686.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_ae8bd9ea4f-268.png" alt="268.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_ce1e0b0c4f-2681.png" alt="2681.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_d30d5e064f-2688.png" alt="2688.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_59ec7a564f-26888.png" alt="26888.png26882.png " loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_8ec6bde04f-26882.png" alt="26882.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=10,M=35,INF=0x3f3f3f3f;
int n,m,p,a,b;
int t[N];
int g[M][M];
double dp[1&lt;&lt;8][M];//d[S][u],所用车票状态是S,从起点走到点u所需的最短时间 

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;a&gt;&gt;b &amp;&amp; n)
	{
		for(int i=0;i&lt;n;i++)
			cin&gt;&gt;t[i];
		memset(g,0x3f,sizeof g);
		while(p--)
		{
			int a,b,c;
			cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a][b]=g[b][a]=c;
		}
		//memset(dp,0x3f,sizeof(dp));//double不可以memset 
	    for(int i=0;i&lt;1&lt;&lt;n;i++)
	    	fill(dp[i]+1,dp[i]+m+1,INF);
	//	for(int i=0;i&lt;1&lt;&lt;n;i++)
	//		for(int j=1;j&lt;=m;j++)
	//			dp[i][j]=INF;
		dp[(1&lt;&lt;n)-1][a]=0;
		double ans=INF;
		for(int S=(1&lt;&lt;n)-1;S&gt;=0;S--)//状态 
		{
			for(int u=1;u&lt;=m;u++)//城市 
				for(int i=0;i&lt;n;i++)//车票 
					if(S&gt;&gt;i &amp; 1)
						for(int v=1;v&lt;=m;v++)//城市 
							if(g[u][v] != INF)
								dp[S-(1&lt;&lt;i)][v]=min(dp[S-(1&lt;&lt;i)][v],dp[S][u]+g[u][v]/(double)t[i]);
			ans=min(ans,dp[S][b]);
		}
							
		if(ans == INF)
			puts(&quot;Impossible&quot;);
		else
			printf(&quot;%.3f\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3001">hdu3001</a><br>
题意：<br>
ACMer 想要游玩n个城市，告诉我们每个城市间的旅行费用，并且要求每个城市最多走两遍！问最小花费是多少<br>
本题n=10，数据很小，但是由于每个城市可以走两遍，可能的路线就变成了(2n)!,所以不能暴力<br>
用状压dp，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>3</mn><mi>n</mi></msup><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(3^{n}n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_a79d1b884f-3001.png" alt="3001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_c0dd19cc4f-30012.png" alt="30012.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_caa8c2f84f-30013.png" alt="30013.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=15,M=60000,INF=0x3f3f3f3f;
int n,m;
int bit[12]={0,1,3,9,27,81,243,729,2187,6561,19683,59049};//三进制每位为1时对应十进制，如第3位是1，(100)3=9 
int tri[M][N];//dp[S][j]状态S的第j位是多少
int dp[M][N];
int g[N][N];

int main()
{
	//cout&lt;&lt;pow(3,10)&lt;&lt;endl;
	for(int i=0;i&lt;59050;i++)//预处理所有合法状态 
	{
		int t=i;
		for(int j=1;j&lt;=10;j++)
		{
			tri[i][j]=t%3;//预处理当前状态S下每个顶点的访问次数 
			t/=3;
			if(!t)
				break;
		}
	}
	
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) 
	{
		int ans=INF;
		memset(g,0x3f,sizeof g);
		memset(dp,0x3f,sizeof dp);
		
		while(m--)
		{
			int a,b,c;
			cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a][b]=g[b][a]=min(g[a][b],c);
		}
		
		for(int i=1;i&lt;=n;i++)
			dp[bit[i]][i]=0;//每个顶点都可以作为起点，初始化状态为tri[i]时，从i出发最小费用为0
		
		for(int S=0;S&lt;bit[n+1];S++)
		{
			bool visit_all=true;//标记所有的城市都遍历1次以上 
			for(int u=1;u&lt;=n;u++)
			{
				if(tri[S][u] == 0)//u点没被访问 
				{
					visit_all=false;//当前状态不能访问所有顶点至少一次 
					continue; 
				}
				for(int v=1;v&lt;=n;v++)
				{
					if(tri[S][v] == 0)//v点未访问
						continue;
					if(g[u][v] != INF)
						dp[S][u]=min(dp[S][u],dp[S-bit[u]][v]+g[u][v]);//u从S中减去 
				}
			}
			if(visit_all)//所有的城市都遍历1次以上
				for(int u=1;u&lt;=n;u++)
					ans=min(ans,dp[S][u]);
		}
			
		if(ans == INF)
			puts(&quot;-1&quot;);
		else
			cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4628">hdu4628</a><br>
有一个长度不超过 16 的字符串。<br>
每次你可以从中删除一个子序列，但是要求这个子序列是回文的。<br>
问最少删除几次可以把这个字符串删光。<br>
样例：<br>
2<br>
aa （1次）<br>
abb （2次）</p>
<p>每次可以选择一个子序列，而子序列是可以用二进制来表示的。<br>
用一个 n 位的二进制数 s 来表示，如果第 i 位是 1，则表示第 i 个数在这个子序列中。<br>
由此衍生出：用 f[s] 来表示把 s 这个子序列删完的最小步数。<br>
答案自然就是 f[(1 &lt;&lt; n) - 1]</p>
<p>一个显然的想法，可以把 s 分成两个不相交的集合 x 和 y， 即 x ∩ y = ∅，x ∪ y = s<br>
f[s] = min(f[s], f[s-x] + 1) (x 是回文子串）<br>
如何判断x是s的子集？<br>
x|s == s</p>
<p>直接枚举 x 和 y 的时间复杂度是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)，对于每个状态都有枚举2^n,总时间复杂度是O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">4^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)，无法承受。</p>
<p>注意到 x 和 y 都是 s 的子集。<br>
所有集合的子集个数之和的级别是 O(3^n)<br>
就是说一个集合,有n个元素,2<sup>n个子集,把这2</sup>n个子集的所有子集数相加就是3^n<br>
证明可以对每个集合考虑贡献，二项式定理<br>
空集的子集只有一个——它本身.即C(n,0)×2<sup>0个.有一个元素的子集有C(n,1)=n个,它们分别有2</sup>1=2个子集.共C(n,1)×2<sup>1个.有两个元素的子集有C(n,2)个,它们分别有2</sup>2=4个子集.共C(n,2)×2^2个...<br>
我们只要枚举 s 的子集 x，那么 y 自然就是 s - x</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=20,M=1&lt;&lt;16;
char s[N];
int f[M];
bool st[M];
int n;

bool check(int x)
{
    char str[20];
    int tot=0;
    for(int i=0;i&lt;n;i++)
        if(x&gt;&gt;i &amp; 1) str[tot++]=s[i];
    
    for(int i=0;i&lt;tot/2;i++)
        if(str[i] != str[tot-1-i])
            return 0;
    
    return 1;
}

void init()
{
    memset(st,0,sizeof st);
    for(int i=0;i&lt;1&lt;&lt;n;i++)
        if(check(i))
            st[i]=true;
}

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        scanf(&quot;%s&quot;,s);
        n=strlen(s);
        init();
        
        memset(f,0x3f,sizeof f);
        f[0]=0;
        for(int i=0;i&lt;1&lt;&lt;n;i++)
            for(int j=i;j;j=(j-1)&amp;i)
                if(st[j]) f[i]=min(f[i],f[i-j]+1);
        
        printf(&quot;%d\n&quot;,f[(1&lt;&lt;n)-1]);
    }
    return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6149">hdu6149</a><br>
给定一张 N 个点 M 条边的无向图，其中有 K 个点被标记为高点，剩下的 (N-K) 个点是低点。<br>
图中的山谷定义为三元组 &lt;X,Y,Z&gt;，满足X和Y之间有边，Y与 Z之间也有边，同时X和Z是高点，Y是低点。<br>
问这个图中最多有几个山谷（一个点只能出现在一个山谷中）N ≤ 30, K ≤ min(N,15)</p>
<p>高点最多只有 15 个。<br>
可以考虑用状态压缩，s 表示高点的使用状态。<br>
低点排成一个长度为 n-k 的序列。<br>
f[i][s] 表示前 i 个低点，使用过的高点的状态为 s 的情况下，组成的山谷的最大可能值。</p>
<p>转移 f[i][s] 的时候，取出第 i+1 个低点。<br>
枚举不在 s 中的两个高点 p 和 q.<br>
检查 p 和 q 和第 i+1 个低点能否配对。<br>
如果可以，那么就可以用 f[i][s] + 1 去更新<br>
f[i + 1][s | (1 &lt;&lt; p) | (1 &lt;&lt; q)]<br>
答案就是 max{ f[n-k][i] | 0 ≤ i &lt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> }</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef pair&lt;int,int&gt; PII;
const int N=35,M=1&lt;&lt;15;
int f[N][M];
int g[N][N];
int n,m,k;
int high[N],low[N];
bool st[N];
vector&lt;PII&gt; trans[N];
int tot;

void init()
{
	for(int i=1;i&lt;=n;i++)
		if(!st[i])
			low[++tot]=i;
	
	for(int i=1;i&lt;=tot;i++)
	{
		trans[i].clear();
		for(int p=0;p&lt;k;p++)
			if(g[low[i]][high[p]])
				for(int q=p+1;q&lt;k;q++)
					if(g[low[i]][high[q]])
						trans[i].push_back(make_pair(p,q));							
	}
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		memset(g,0,sizeof g);
		memset(st,0,sizeof st);
		memset(f,0,sizeof f);
		tot=0;
		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
		for(int i=0;i&lt;m;i++)
		{
			int x,y;
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			g[x][y]=g[y][x]=1;
		}
		
		for(int i=0;i&lt;k;i++)
		{
			scanf(&quot;%d&quot;,&amp;high[i]);
			st[high[i]]=true;
		}
		
		init();
		
		for(int i=1;i&lt;=tot;i++)
		{
			for(int s=0;s&lt;1&lt;&lt;k;s++)
				f[i][s]=f[i-1][s];//不选第i个点
			
			for(int s=0;s&lt;1&lt;&lt;k;s++)
			{
				for(int j=0;j&lt;trans[i].size();j++)
				{
					int x=trans[i][j].first;
					int y=trans[i][j].second;
					if(s&gt;&gt;x &amp; 1) continue;
					if(s&gt;&gt;y &amp; 1) continue;
					f[i][s|(1&lt;&lt;x)|(1&lt;&lt;y)]=max(f[i][s|(1&lt;&lt;x)|(1&lt;&lt;y)],f[i-1][s]+1);//选第i个点
				}
			}
		}
			
		int ans=0;
		for(int i=0;i&lt;1&lt;&lt;k;i++)
			ans=max(ans,f[tot][i]);
		
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/526/">acwing524</a><br>
数据范围非常小，可以考虑状态压缩DP。 设 f[s] 表示清除掉 s 集合中的猪花费的最小步数。<br>
思考转移。<br>
在已有的 s 集合基础上，再选择一条抛物线使得它经过 t集合的点。<br>
那么就可以用 f[s] + 1 去更新 f[s | t]</p>
<p>三点确定一条抛物线。<br>
而三点之中必须有一个原点，因此只要两个点就能确定一条抛物线。<br>
因此我们可以枚举 s 集合以外的任意两个点，算出经过这两个点的抛物线，枚举所有的点看是否落在抛物线上，得到抛<br>
物线经过的点集 t。<br>
f[s | t] = min(f[s | t], f[s] + 1);</p>
<p>经过点 i 和 j 的抛物线经过的点集 t[i][j] 可以预处理。时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)<br>
之后 DP 枚举每个集合，对每个集合都要枚举两个点。<br>
时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</p>
<p>预处理：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>[</mo><mi>i</mi><msup><mo>]</mo><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>y</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ax[i]^2 + bx[i] = y[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>[</mo><mi>j</mi><msup><mo>]</mo><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>y</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ax[j]^2 + bx[j] = y[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span><br>
解二元一次方程组，得到 a 和 b。<br>
如果 a &gt;= 0，不符合题意，t[i][j] = 0<br>
否则对每个点判断一下是否落在这条抛物线上，如果第 k 个点落在抛物线上，<br>
t[i][j] |= (1 &lt;&lt; (k - 1));</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=20,M=1&lt;&lt;18;
const double eps=1e-8;
double x[N],y[N];
int path[N][N];
int f[M];
int n,m;

int cmp(double a,double b)
{
	if(fabs(a-b) &lt; eps) return 0;
	else return a&lt;b? -1 : 1;
}

void init()
{
	for(int i=0;i&lt;n;i++)
	{
	    path[i][i] |= 1&lt;&lt;i;
	    
		for(int j=i+1;j&lt;n;j++)
		{
			if(!cmp(x[i],x[j])) continue;
			
			double a=(y[i]/x[i]-y[j]/x[j])/(x[i]-x[j]);
			if(cmp(a,0) &gt;= 0) continue;
			double b=y[i]/x[i]-a*x[i];
			
			for(int k=0;k&lt;n;k++)
				if(!cmp(a*x[k]*x[k]+b*x[k],y[k])) path[i][j]|=1&lt;&lt;k;
		}
	}
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for(int i=0;i&lt;n;i++)
			scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]);
		memset(path,0,sizeof path);
		
		init();
		
		memset(f,0x3f,sizeof f);
		f[0]=0;
		for(int s=0;s&lt;1&lt;&lt;n;s++)
			for(int i=0;i&lt;n;i++)
				if(!(s&gt;&gt;i &amp; 1))
				{
					for(int j=i;j&lt;n;j++)//记得处理只射一只猪的情况(i == j)
					{
					    if(!(s&gt;&gt;j &amp; 1))
							f[s|path[i][j]] = min(f[s|path[i][j]],f[s]+1);
					}
					break;
					//对于我们枚举的每一个状态i，我们找到它正数第一只没射掉的猪进行转移后break。
                    //因为如果我们转移了第一只后面的没射的猪，到时候还要回头来将第一只猪射掉。
                    //所以后面的没射的猪的转移其实是多余的，射完第一只猪后按顺序接着往后射就可以了。
				}
						
		printf(&quot;%d\n&quot;,f[(1&lt;&lt;n)-1]);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/531/">acwing529</a><br>
简化版题目：<br>
给定一个 n 个点 m 条边的图，请你求出一个有根树，满足每个点的深度和它到父节点的边权乘积之和最小。<br>
n ≤ 12，m ≤ 1000</p>
<p>考虑到点数只有12个，可以考虑状态压缩 DP。 用 s 表示当前加入的点集。<br>
为了方便转移，我们不记录根是谁，而是直接去考虑深度。<br>
也就是用 f[i][s] 表示当前的点集是 s，最深的点为 i。<br>
然后我们去枚举 s 的补集的子集 t，把 t 都作为第 i+1 层加入 s。</p>
<p>我们不用去考虑 t 里的点在这颗树中是否真的是第 i+1层<br>
因为如果不是的话只可能小于i+1层，答案会更小。<br>
那么一定存在一种转移顺序，考虑到这种更优的情况，也就是先把这个点加入 s 集合。<br>
例如，如果第j层中用到的某条边(a, b)应该在比j小的层，假设a是S中的点，b是第j层的点，则在枚举S + {b}时会得到更小的花费。</p>
<p>具体的操作是：<br>
对于 s，枚举 t（s 的补集的子集），检查 t 里的点是否都和 s 里的点有连边，处理出每个点到 s 里的点的最短边。<br>
设这些最短边边权之和为 v。<br>
那么 f[i][s | t] = min(f[i][s | t], f[i - 1][s] + (i - 1) * v)</p>
<p>时间复杂度分析：<br>
s 一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个，s 的补集的子集一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">3^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个。<br>
处理 t 里的每个点到 s 里的点的最短边，预处理时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)<br>
验证 t 是否可行，时间复杂度 O(n)。<br>
转移时对每个深度都要更新一次，时间复杂度O(n)<br>
总时间复杂度就是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><msup><mn>2</mn><mi>n</mi></msup><mo>+</mo><mi>n</mi><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n^22^n + n3^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)，即 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n3^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using namespace std;
const int N=15,M=1&lt;&lt;12,INF=0x3f3f3f3f;
int f[M][N];
int g[N][N];
int dist[M][N];
int n,m;

void init()
{
    memset(dist,0x3f,sizeof dist);

    for(int s=0;s&lt;1&lt;&lt;n;s++)//集合s 
        for(int i=0;i&lt;n;i++)
            if(!(s&gt;&gt;i &amp; 1))//枚举不在集合s中的点i 
                for(int j=0;j&lt;n;j++)
                    if(s&gt;&gt;j &amp; 1)//预处理出i到集合s的最短距离 
                        dist[s][i]=min(dist[s][i],g[i][j]);
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    memset(g,0x3f,sizeof g);
    while(m--)
    {
        int a,b,c;
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        a--,b--;
        g[a][b]=g[b][a]=min(g[a][b],c);
    }

    init();

    memset(f,0x3f,sizeof f);
    for(int i=0;i&lt;n;i++) f[1&lt;&lt;i][1]=0;

    for(int s=0;s&lt;1&lt;&lt;n;s++)//集合s 
    {
        int c=(1&lt;&lt;n)-1-s;
        for(int t=c;t;t=(t-1)&amp;c)//集合s的补集t 
        {
            int sum=0;
            for(int i=0;i&lt;n;i++)
                if(t&gt;&gt;i &amp; 1)
                {
                    sum+=dist[s][i];
                    if(sum &gt;= INF) break;
                }   

            if(sum &lt; INF)
                for(int i=1;i&lt;=n;i++)
                    f[s|t][i]=min(f[s|t][i],f[s][i-1]+(i-1)*sum);
        }
    }

    int ans=INF;
    for(int i=1;i&lt;=n;i++)
        ans=min(ans,f[(1&lt;&lt;n)-1][i]);

    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无向图/有向图的连通性复习]]></title>
        <id>https://caifxh.github.io/post/wu-xiang-tu-you-xiang-tu-de-lian-tong-xing-fu-xi/</id>
        <link href="https://caifxh.github.io/post/wu-xiang-tu-you-xiang-tu-de-lian-tong-xing-fu-xi/">
        </link>
        <updated>2020-04-01T06:55:40.000Z</updated>
        <content type="html"><![CDATA[<h4 id="相关概念">相关概念</h4>
<h4 id="1无向图">1.无向图</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_e9d8ce8650-%E5%9B%BE%E7%89%871.png" alt="图片1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_30fd91a250-%E5%9B%BE%E7%89%872.png" alt="图片2.png" loading="lazy"></p>
<h4 id="2有向图">2.有向图</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_68b062be50-%E5%9B%BE%E7%89%874.png" alt="图片4.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_75791d1050-%E5%9B%BE%E7%89%875.png" alt="图片5.png" loading="lazy"></p>
<h4 id="3割点和桥">3.割点和桥</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_97f43b7250-%E5%9B%BE%E7%89%876.png" alt="图片6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_9a82923050-%E5%9B%BE%E7%89%877.png" alt="图片7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_b95a655250-%E5%9B%BE%E7%89%878.png" alt="图片8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_bbf3de2450-%E5%9B%BE%E7%89%879.png" alt="图片9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_4cf211d450-%E5%9B%BE%E7%89%8710.png" alt="图片10.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_6a3d954c50-%E5%9B%BE%E7%89%8712.png" alt="图片12.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_836f7e0450-%E5%9B%BE%E7%89%8713.png" alt="图片13.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_aff6e25c51-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_c688d7f051-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_997fdc8e50-%E5%9B%BE%E7%89%8714.png" alt="图片14.png" loading="lazy"></p>
<h4 id="4tarjan算法">4.tarjan算法</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_0ed9e31a50-%E5%9B%BE%E7%89%8717.png" alt="图片17.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_16c7513450-%E5%9B%BE%E7%89%8718.png" alt="图片18.png" loading="lazy"></p>
<h4 id="41无向图的桥">4.1无向图的桥</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_3364dd5250-%E5%9B%BE%E7%89%8719.png" alt="图片19.png" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&gt;dfn[u])
				cout&lt;&lt;u&lt;&lt;&quot;—&quot;&lt;&lt;v&lt;&lt;&quot;是桥&quot;&lt;&lt;endl; 
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
				tarjan(1,0);
	}
	return 0;
}
</code></pre>
<h4 id="42无向图的割点">4.2无向图的割点</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_9b23cd3650-%E5%9B%BE%E7%89%8720.png" alt="图片20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_36cbb05e50-%E5%9B%BE%E7%89%8721.png" alt="图片21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_3fabda8c50-%E5%9B%BE%E7%89%8722.png" alt="图片22.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt,root;
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	int count=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&gt;=dfn[u])
			{
				count++;
				if(u!=root||count&gt;1)
					cout&lt;&lt;u&lt;&lt;&quot;是割点&quot;&lt;&lt;endl; 
			}	
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i,0);
			 } 
	}
	return 0;
}
</code></pre>
<h4 id="有向图的强连通分量scc">有向图的强连通分量（SCC）</h4>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_91ef325650-%E5%9B%BE%E7%89%8723.png" alt="图片23.png" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
stack&lt;int&gt;s;
bool ins[maxn];
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		cout&lt;&lt;&quot;连通分量：&quot;;
		do
		{
			v=s.top();
			s.pop();
			cout&lt;&lt;v&lt;&lt;&quot; &quot;;
			ins[v]=false;
		}while(v!=u);
		cout&lt;&lt;endl;
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(ins,0,sizeof(ins));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
	}
	return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="http://poj.org/problem?id=1144">poj1144</a><br>
求割点数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=105;
int n,root;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn*maxn];

int low[maxn],dfn[maxn],num;
bool cut[maxn];
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	dfn[u]=low[u]=++num;
	int flag=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]&gt;=dfn[u])
			{
				flag++;
				if(u!=root||flag&gt;1)//u不是根或者u是根但至少有两个子结点
					cut[u]=true; 			
			}
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(cut,false,sizeof(cut));
	cnt=num=0;
}

int main()
{ 
	while(cin&gt;&gt;n&amp;&amp;n)
	{
		init(); 
		int u,v;
		while(cin&gt;&gt;u&amp;&amp;u)
		{
			while(1)
			{
				char c=getchar();
				if(c=='\n')
					break;
				cin&gt;&gt;v;
				add(u,v);
				add(v,u);
			}
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i);
			}
		int ans=0;
		for(int i=1;i&lt;=n;i++)
			if(cut[i])
				ans++;
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=3532">poj3352</a><br>
最少加几条边，才能使无向图变成边双连通图。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_65ccf7c051-%E5%9B%BE%E7%89%8724.png" alt="图片24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_8fec68a651-%E5%9B%BE%E7%89%8725.png" alt="图片25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_92f0d99251-%E5%9B%BE%E7%89%8726.png" alt="图片26.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],degree[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(degree,0,sizeof(degree));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
			add(v,u);
		}
		tarjan(1,-1);
		for(int u=1;u&lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(low[u]!=low[v])
					degree[low[u]]++;
			}
		int leaf=0;
		for(int i=1;i&lt;=n;i++)
			if(degree[i]==1)
				leaf++;
		cout&lt;&lt;(leaf+1)/2&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p>换种写法：(可求得所有点双连通分量)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=5010,M=200010;
int h[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
int d[N];
bool is_bridge[M];
int id[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u,int fa)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        if(!dfn[j])
        {
            tarjan(j,u);
            low[u]=min(low[u],low[j]);
            if(dfn[u] &lt; low[j])
                is_bridge[i]=is_bridge[i^1]=true;
        }
        else
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++dcc_cnt;
        int y;
        do{
            y=stk[top--];
            id[y]=dcc_cnt;
        }while(y != u);
    }
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        add(a,b);
        add(b,a);
    }
    
    tarjan(1,-1);
    
    for(int i=0;i&lt;idx;i++)
        if(is_bridge[i])
            d[id[e[i]]]++;
            
    int cnt=0;
    for(int i=1;i&lt;=dcc_cnt;i++)
        if(d[i] == 1)
            cnt++;
    cout&lt;&lt;(cnt+1)/2&lt;&lt;endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_056f276c51-%E5%9B%BE%E7%89%8728.png" alt="图片28.png" loading="lazy"></figure>
<blockquote></blockquote>
<p><a href="http://poj.org/problem?id=2553">poj2553</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_d26602d651-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG" loading="lazy"><br>
求解强连通分量，缩点，计算缩点的出度，统计出度为0的顶点。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5af107cc51-%E5%9B%BE%E7%89%8729.png" alt="图片29.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;stack&gt;
using namespace std;
const int maxn=5050;
int n,m;
bool ins[maxn];//标记是否在栈内 
int head[maxn],id[maxn],dout[maxn];
int low[maxn],dfn[maxn];
stack&lt;int&gt; s;
int cnt,num,scc_cnt;
struct Egde
{
	int to,next;
}e[maxn*maxn];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(ins,false,sizeof(ins));
	memset(dout,0,sizeof(dout));
	memset(id,0,sizeof(id));
	cnt=num=0;
	scc_cnt=0;
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		++scc_cnt;
		do
		{
			v=s.top();
			s.pop();
			id[v]=scc_cnt;
			ins[v]=false;
		}while(v!=u);
	}
}

int main()
{
	while((cin&gt;&gt;n)&amp;&amp;n)
	{
		cin&gt;&gt;m;
		init();
		while(m--)
		{
			int u,v;
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
		for(int u=1;u&lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(id[u]!=id[v])
					dout[id[u]]++; 
			}
		int flag=1;
		for(int i=1;i&lt;=n;i++)
		{
			if(!dout[id[i]])
			{
				if(flag)
					flag=0;
				else
					cout&lt;&lt;&quot; &quot;;
				cout&lt;&lt;i;
			}		
		}
		cout&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=1236">poj1236</a>/<a href="https://www.acwing.com/problem/content/369/">acwing367</a><br>
至少添加几条边，使得有向图为强连通图<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5b172a9851-%E5%9B%BE%E7%89%8730.png" alt="图片30.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5e7c024451-%E5%9B%BE%E7%89%8731.png" alt="图片31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_1f7d3e4051-%E5%9B%BE%E7%89%8732.png" alt="图片32.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=110,M=N*N;
int n;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N];
int stk[N],top;
bool in_stk[N];
int scc_cnt,timestamp;
int id[N];
int dout[N],din[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    in_stk[u]=true;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(in_stk[j])
            low[u]=min(low[u],dfn[j]);
    }   
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            //cout&lt;&lt;y&lt;&lt;' ';
            in_stk[y]=false;
            id[y]=scc_cnt;
        }while(y != u);
        //cout&lt;&lt;endl;
    }
}

int main()
{
    cin&gt;&gt;n;
    memset(h,-1,sizeof h);
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        while(cin&gt;&gt; x &amp;&amp; x)
            add(i,x);
    }
        
    
    for(int i=1;i&lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
    
    // for(int i=1;i&lt;=n;i++)
    // {
    //     cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;id[i]&lt;&lt;endl;
    // }
    for(int i=1;i&lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                dout[a]++;
                din[b]++;
            }
        }
     
    int a=0,b=0;  
    for(int i=1;i&lt;=scc_cnt;i++)
    {
        if(!din[i])
            a++;
        if(!dout[i])
            b++;
    }
    
    cout&lt;&lt;a&lt;&lt;endl;
    if(scc_cnt == 1)
        cout&lt;&lt;0&lt;&lt;endl;
    else
        cout&lt;&lt;max(a,b)&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1176/">acwing1174</a><br>
（1）若采用暴力求解，先建反图，判断从每个点出发能否到达所有点。时间复杂度：$O(n(n+m))<br>
（2）若为拓扑图，则只需判断出度为0的点，若出度为0的点大于1个，则答案为0，若出度为0的点为1，则答案为1.<br>
先求出所有强连通分量，然后缩点，判断出度为0的分量，答案为该分量里的点的数目。</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010, M = 50010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, cnt[N];//强连通分量编号，每个分量里点的数目
int dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            cnt[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b);
    }

    for (int i = 1; i &lt;= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 1; i &lt;= n; i ++ )
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b) dout[a] ++ ;
        }

    int zeros = 0, sum = 0;
    for (int i = 1; i &lt;= scc_cnt; i ++ )
        if (!dout[i])
        {
            zeros ++ ;
            sum += cnt[i];
            if (zeros &gt; 1)
            {
                sum = 0;
                break;
            }
        }

    printf(&quot;%d\n&quot;, sum);

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1177/">acwing1175</a><br>
求最大半连通子图的结点数和最大半连通子图数。<br>
(1)对于任何一个强连通分量（tarjan），一定是半连通分量。<br>
(2)缩点，建图得到一个有向无环图（拓扑图），求拓扑图上的最长链（最长链包含的结点数即为最大半连通子图的结点数）。缩完点之后的图中出现了重边怎么办,那就会使方案数莫名增多.所以对于缩完点后的图还要判重边<br>
(3)最长链的条数即为最大半连通子图数。<br>
求最长链采用dp，跑最长路,我们只需要找出一条点权最大的路径就行了，不限制点的个数。<br>
所以首先对这个图进行tarjan缩点，并记录下每个连通块的大小，和每个点所在的连通块。<br>
缩点之后，会发现这个图变成了一个dag（有向无环图），我们要对这个dag求出最长链的大小和个数。<br>
因为这个图是无环的，所以我们可以按照拓扑序进行DP</p>
<h4 id="tarjan缩点后的点的标号顺序是逆拓扑序所以不需要对新图进行拓扑排序">Tarjan缩点后的点的标号顺序是逆拓扑序，所以不需要对新图进行拓扑排序</h4>
<p>状态表示: f[i]表示到第i个连通块的最长链大小，g[i]表示个数。<br>
很容易就想到了转移的方法：<br>
1.{g[i]=g[i]+g[j]}(条件：f[j]+number[i]==f[i])<br>
2.{g[i]=g[j],f[i]=f[j]+number[i]}(条件：f[j]+number[i]&gt;f[i])。<br>
按照这个转移状态就可以啦。<br>
总结：强连通分量+缩点+去重+DAGdp</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;unordered_set&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100010,M=2000010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m,mod;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N],g[N];
typedef pair&lt;int,int&gt; PII;
int stk[N],top;
bool ins[N];
typedef long long LL;

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]++;
        }while(y != u);
    }
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    unordered_set&lt;LL&gt; S;//(u,v)-&gt;u*1000000+v
    for(int i=1;i&lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            LL hash=a*1000000ll+b;
            if(a != b &amp;&amp; !S.count(hash))
            {
                add(hs,a,b);
                S.insert(hash);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
        if (!f[i])//代表它是入度为0的点 
        {
            f[i] = Size[i];
            g[i] = 1;
        }
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
                g[k]=g[i];
            }
            else if(f[k] == f[i] + Size[k])
                g[k]=(g[k]+g[i])%mod;
        }
    }
    
    int maxf=0,sum=0;
    for(int i=1;i&lt;=scc_cnt;i++)
        if(f[i]&gt;maxf)
        {
            maxf=f[i];
            sum=g[i];
        }
        else if(f[i] == maxf)
            sum=(sum+g[i])%mod;
    
    cout&lt;&lt;maxf&lt;&lt;endl;
    cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
    
}
</code></pre>
<p>补一个缩点的模板<a href="https://www.luogu.com.cn/problem/P3387">缩点</a>`</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=10010,M=200010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N];
int stk[N],top;
bool ins[N];
int p[N];//点权 

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]+=p[y];
        }while(y != u);
    }
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    	cin&gt;&gt;p[i];
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    for(int i=1;i&lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                add(hs,a,b);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
    	if(!f[i])
    	{
    		f[i]=Size[i];
		}
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
            }
        }
    }
    
    int maxf=0;
    for(int i=1;i&lt;=scc_cnt;i++)
  		maxf=max(maxf,f[i]);
    cout&lt;&lt;maxf&lt;&lt;endl;
    return 0;
    
}
</code></pre>
<p>再补一个DAGdp的简单题<a href="https://www.luogu.com.cn/problem/P1137">P1137</a></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=100000+15;
int n,m,idx;
int head[maxn],din[maxn],dp[maxn];
struct EDGE
{
    int to;
	int next;
}edge[maxn&lt;&lt;2];
int q[maxn],hh,tt=-1;

void add(int x,int y)
{
    edge[++idx].next=head[x];
    edge[idx].to=y;
    head[x]=idx;
}

void topsort()
{
    
    for (int i=1;i&lt;=n;i++)
	    if (din[i]==0) 
			q[++tt]=i;
			
    while (hh&lt;=tt)
    {
        int t=q[hh++];
        for (int i=head[t];i;i=edge[i].next)
        {
            int v=edge[i].to;
            din[v]--;
            if (din[v]==0)
            	q[++tt]=v;
        }
    }
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        add(u,v);
        din[v]++;
    }
    
    topsort();
    
    for (int i=1;i&lt;=n;i++)
    {
        int u=q[i-1];
        if(!dp[u])
        	dp[u]=1;
        for (int j=head[u];j;j=edge[j].next)
        {
            int v=edge[j].to;
            dp[v]=max(dp[v],dp[u]+1);
        }
    }
    for (int i=1;i&lt;=n;i++)
    	printf(&quot;%d\n&quot;,dp[i]);
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1185/">acwing1183</a><br>
题意：求删除一个点后，图中最多有多少个连通块。</p>
<pre><code>/*
1.统计连通块数量
2.枚举每一个连通块删除割点后所得的最大连通块数ans
3.ans+cnt-1即为答案
*/
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=10010,M=30010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int ans;
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &gt;= dfn[u])
            {
                cnt++;
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }

    if(u != root &amp;&amp; cnt)//不是根节点，还要加上父节点的那一块连通分量
        cnt++;
    ans=max(ans,cnt);//每一个连通块删除割点后所得的最大连通块数ans
}

int main()
{
    while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n)
    {
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(low,0,sizeof low);
        idx=timestamp=0;
        ans=0;

        while(m--)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            add(a,b);
            add(b,a);
        }

        int cnt=0;
        for(root=0;root&lt;n;root++)
            if(!dfn[root])
            {
                cnt++;//连通块数
                tarjan(root);
            }
        
        cout&lt;&lt;ans+cnt-1&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/398/">acwing396</a><br>
题意：<br>
就是有很多个点，在某个时候一个点将会塌陷，你要建造一些点，使任意一点塌陷时其他点都能成功逃脱<br>
情况一：当前连通块内没有一个割点<br>
那么此时至少要建立两个点，使得在任意一点坍塌时能顺利逃脱，那么此时要建立的点的个数就是2，<br>
而方案数则是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">C_n^2 = \frac{n(n−1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,n为点数<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5e45159651-111.PNG" alt="111.PNG" loading="lazy"><br>
情况二：当前连通块中有一个割点<br>
此时在当前点双连通分量中非割点位置任意选取一个顶点建立1个出口即可，方案数为；cnt-1（cnt为当前连通分量中点数）<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_f1256c0851-222.PNG" alt="222.PNG" loading="lazy"><br>
情况三：当前连通块中中有一个割点以上，无需设置出口（一个割点时已设置出口，且各个v-dcc连通，无论删去任意一个出口or割点or普通点，都可保证剩下点可成功逃离）</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 1010, M = 1010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
vector&lt;int&gt; dcc[N];
bool cut[N];
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    if(u == root &amp;&amp; h[u] == -1)
    {
        dcc_cnt++;
        dcc[dcc_cnt].push_back(u);
        return;
    }
    
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &gt;= dfn[u])
            {
                cnt++;
                if(u != root || cnt &gt;1)
                    cut[u]=true;
                ++dcc_cnt;
                int y;
                do{
                    y=stk[top--];
                    dcc[dcc_cnt].push_back(y);
                }while(y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }
}

int main()
{
    int kase=1;
    while(cin&gt;&gt;m &amp;&amp; m)
    {
        for(int i=1;i&lt;=dcc_cnt;i++)
            dcc[i].clear();
        idx=n=timestamp=top=dcc_cnt=0;
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(cut,0,sizeof cut);
        
        while(m--)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            n=max(n,a),n=max(n,b);
            add(a,b);
            add(b,a);
        }
        
        for(root = 1; root &lt;= n; root ++)
        {
            if(!dfn[root])
                tarjan(root);
        }
        
        int res=0;
        ULL num=1;
        for(int i=1;i&lt;=dcc_cnt;i++)
        {
            int cnt=0;//统计当前v-dcc中割点的数量
            for(int j=0;j&lt;dcc[i].size();j++)
                if(cut[dcc[i][j]])
                    cnt++;
            
            if(cnt == 0)
            {
                if(dcc[i].size()&gt;1)
                    res+=2,num*=dcc[i].size()*(dcc[i].size()-1)/2;
                else 
                    res++;//孤立点
            }
            else if (cnt == 1)
            {
                res++,num*=dcc[i].size()-1;
            }
        }
         printf(&quot;Case %d: %d %llu\n&quot;, kase++, res, num);
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/370/">acwing368</a><br>
图片转自<a href="https://www.acwing.com/user/myspace/index/11971/">@xxh</a>的题解<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/18/9969_55ff82da52-cf30.PNG" alt="cf30.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/18/9969_6544d1be52-cf31.PNG" alt="cf31.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 600010;

int n, m;
int h[N], hs[N], e[M], ne[M], w[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, size[N];
int dist[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    for (int i = 1; i &lt;= n; i ++ ) add(h, 0, i, 1);

    while (m -- )
    {
        int t, a, b;
        scanf(&quot;%d%d%d&quot;, &amp;t, &amp;a, &amp;b);
        if (t == 1) add(h, b, a, 0), add(h, a, b, 0);
        else if (t == 2) add(h, a, b, 1);
        else if (t == 3) add(h, b, a, 0);
        else if (t == 4) add(h, b, a, 1);
        else add(h, a, b, 0);
    }

    tarjan(0);//从超级源点可到所有点

    bool success = true;
    for (int i = 0; i &lt;= n; i ++ )
    {
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a == b)
            {
                if (w[j] &gt; 0)//只要任意一个SCc里有边权大于0的边，则存在正环
                {
                    success = false;
                    break;
                }
            }
            else 
                add(hs, a, b, w[j]);
        }
        if (!success) 
            break;
    }

    if (!success) puts(&quot;-1&quot;);
    else
    {
        for (int i = scc_cnt; i; i -- )
        {
            //入度为0的点dist为0
            for (int j = hs[i]; ~j; j = ne[j])
            {
                int k = e[j];
                dist[k] = max(dist[k], dist[i] + w[j]);
            }
        }

        LL res = 0;
        for (int i = 1; i &lt;= scc_cnt; i ++ ) 
            res += (LL)dist[i] * size[i];

        printf(&quot;%lld\n&quot;, res);
    }

    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3627">P3627</a><br>
题意：<br>
在有向图中找一条路径，使得经过的点的点权和最大（每个点可以经过多次，但只有一次对答案的贡献<br>
思路：<br>
首先看见可以重复走路径，那么就想到其实这些路口可以构成一个个强连通分量（因为只要我们能到达一个强连通分量其中某一个点，那么我们就能到达这个强连通分量的其余所有点，根据贪心策略，这样得到的答案保证更优）。那就很容易想到缩点加最长路。<br>
缩点+spfa最长路<a href="https://paste.ubuntu.com/p/ftjQ8xspVv/">code</a></p>
<p>推荐博客：<br>
https://blog.csdn.net/acmmmm/article/details/16361033<br>
https://blog.csdn.net/sentimental_dog/article/details/53790582</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[求组合数]]></title>
        <id>https://caifxh.github.io/post/qiu-zu-he-shu/</id>
        <link href="https://caifxh.github.io/post/qiu-zu-he-shu/">
        </link>
        <updated>2020-03-28T02:16:07.000Z</updated>
        <content type="html"><![CDATA[<h4 id="组合数的计算">组合数的计算</h4>
<h4 id="求组合数-i杨辉三角递推法">求组合数 I（杨辉三角递推法）</h4>
<p>给定 n, m，计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>对 109+7 取模的结果。<br>
当 n，m 都比较小的时候且需要频繁地调用组合数的时候,采用 Pascal 公式预处理出所有对a，b对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>a</mi><mi>b</mi></msubsup></mrow><annotation encoding="application/x-tex">C_a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><br>
若只要求一个组合数的话，也可以滚动一下这个数组，节约空间，但同时m这一维要倒着枚举，就像01背包一样。程序如下：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=2010,mod=1e9+7;
int c[N][N];

int main()
{
    for(int i=0;i&lt;N;i++)
        for(int j=0;j&lt;=i;j++)
            if(!j)
                c[i][j]=1;
            else
                c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    
    int n;
    cin&gt;&gt;n;
    while(n--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        printf(&quot;%d\n&quot;,c[a][b]);
    }
    return 0;
}
</code></pre>
<p>滚动数组优化:</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int n,m;
long long c[10005];
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    m=min(m,n-m);
    c[0]=1;
    for (int i=1;i&lt;=n;i++)
    {
        for (int j=m;j&gt;=1;j--)
        {
            c[j]=c[j]+c[j-1];
        }
    }
    cout&lt;&lt;c[m];
}
</code></pre>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mrow><mi>n</mi><mi mathvariant="normal">−</mi><mi>m</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_n^m=C_n^{n−m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0183309999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">−</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>，所以m可以取m和n-m中小的那一个，以节省时间。但复杂度还是过高，约为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<h4 id="求组合数-ii乘法逆元">求组合数 II（乘法逆元）</h4>
<p><code>这种方法只适用于对答案模一个大质数的情况</code>。<br>
当 n, m &gt; 10000的时候，就不能再使用 O(n^2) 的做法了。需要使用公式：<img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_e3438e0c67-40.PNG" alt="40.PNG" loading="lazy"><br>
第一种做法：（费马小定理）<br>
令 fact[n]=n!</p>
<pre><code>fact[0] = 1;
for (int i = 1;i &lt;= n;i ++)
    fact[i] =(LL) fact[i - 1] * i % p;
</code></pre>
<p>令分母 k =(LL)fact[m] * fact[n - m] % p<br>
计算 k 模 p 的逆元，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">k^{p-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> MOD p<br>
答案就是(LL)fact[n] *  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">k^{p-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> MOD p<br>
这样需要一次快速幂，时间复杂度 O(nlog n)</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010,mod=1e9+7;
int fact[N],infact[N];
typedef long long LL;

int qmi(int a,int k,int p)
{
    int res=1;
    while(k)
    {
        if(k&amp;1)
            res=(LL)res*a%p;
        a=(LL)a*a%p;
        k&gt;&gt;=1;
    }
    return res;
}

void init()
{
    fact[0]=infact[0]=1;
    for(int i=1;i&lt;N;i++)
    {
        fact[i]=(LL)fact[i-1]*i%mod;
        infact[i]=qmi(fact[i],mod-2,mod);
    }
}

int main()
{
    init();
    
    int n;
    cin&gt;&gt;n;
    while(n--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        printf(&quot;%d\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod);
    }
    return 0;
}
</code></pre>
<p>第二种做法：(递推)<br>
我们先处理每个数关于 p 的逆元 inv[n]。<br>
inv[1] = 1<br>
现在假设我们要求 inv[i]，首先拿 p 除以 i，得到 k，余数是 r。<br>
那么 p = ki + r (r &lt; i, 1 &lt; i &lt; p)<br>
两边都 MOD p，得到 ki + r = 0 (mod p)<br>
ki + r = 0 (mod p)<br>
两边同时乘上 i<sup>{-1}r</sup>{-1}<br>
得到 kr^{-1} + i^{-1} = 0 (mod p)<br>
i^{-1} = -kr^{-1} (mod p)<br>
k = p / i, r = p % i<br>
由于 r &lt; i，所以算inv[i]的时候，inv[r]显然已经算好了<br>
因此 inv[i] = (-p / i) * inv[p % i]</p>
<p>在处理出了每个数关于 p 的逆元。</p>
<pre><code>for (int i = 2;i &lt;= n;i ++)
    inv[i] = (LL)inv[i - 1] * inv[i] % p;
</code></pre>
<p>就可以得到 i! 关于 p 的逆元<br>
此时答案就是<br>
(LL)fact[n] * inv[m] % p * inv[n - m] % p</p>
<p>p一定要是大质数!，起码得大于m。为什么呢？若要求a在模p下的乘法逆元，必须要保证a与p互质。在此题中，要求m!的乘法逆元，那么p必须与m!互质，那么p就要大于m，且是个质数。</p>
<h4 id="求组合数-iiilucas定理">求组合数 III（Lucas定理）：</h4>
<p>适用于对答案模一个质数的情况。<br>
和上面的乘法逆元求组合数的条件对比一下，只相差了一个大字。也就是说这个质数不用很大，非常小也行。<br>
给定 n, m，计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>对 1000003 取模的结果。n, m &lt;= 1e18<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_9dc1cf7267-41.PNG" alt="41.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/activity/content/code/content/122436/">code</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/16/9969_610b591267-42.PNG" alt="42.PNG" loading="lazy"></p>
<h4 id="求组合数-iv分解质因数">求组合数 IV（分解质因数）</h4>
<p>乘法逆元只能处理模数为大质数的情况，卢卡斯定理只能处理模数为质数的情况，那有没有一种方法能处理模数不是质数的情况呢？显然是有的。而且不取模也是可以的。<br>
我们可以把组合数中要乘或除的每一个数分解质因数，再把分母的质因数减掉，最后把剩下的质因数乘起来，边乘边模p就行了。 （如果需要取模的话）<br>
对于n!包含质因子x个数：fac[x]=n/x+n/x2+……+n/xk(直到n/xk=0结束)。<br>
<a href="https://www.acwing.com/activity/content/code/content/122520/">code</a></p>
<h4 id="总结">总结</h4>
<p>每种算法都有其优点与局限性。递推写起来快，思维简单，但时间复杂度高。乘法逆元用得比较普遍，因为一般都是模一个大质数，复杂度也几乎是线性的。卢卡斯定理只会在特定的题目里做到，但其实编程复杂度并不高，就是在乘法逆元的基础上加几句话。质因数分解的适用性最广，编程复杂度也最高，这就是完美的代价吧。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/20/9969_d1e87a9c6a-15.png" alt="15.png" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[倍增 ST表 RMQ]]></title>
        <id>https://caifxh.github.io/post/bei-zeng-st-biao-rmq/</id>
        <link href="https://caifxh.github.io/post/bei-zeng-st-biao-rmq/">
        </link>
        <updated>2020-03-28T02:12:15.000Z</updated>
        <content type="html"><![CDATA[<h4 id="倍增">倍增</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_63a9254055-100.png" alt="100.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_7a1c78cc55-101.png" alt="101.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_7e531b9e55-102.png" alt="102.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_8ae2291855-103.png" alt="103.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_949b394055-104.png" alt="104.png" loading="lazy"></p>
<h4 id="st表">ST表</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_cc79cf4855-105.png" alt="105.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_d06c8c3055-106.png" alt="106.png" loading="lazy"></p>
<h4 id="st表创建">ST表创建</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_dfa53a7655-107.png" alt="107.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_104f583c55-110.png" alt="110.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_ca30b97a55-121.PNG" alt="121.PNG" loading="lazy"></p>
<h4 id="st表查询">ST表查询</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_dea27ee855-122.png" alt="122.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_f3b6ffac55-123.png" alt="123.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;//使用log函数
/*log():以e为底的对数，exp(5)=e^5,log(exp(5))=5
  log10():以10为底的对数
  log2():以2为底的对数 
  任何一个其它的对数logm(n)=log(n)/log(m)*/
using namespace std;
const int maxn=105;
int n,a[maxn],F[maxn][maxn];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

void ST_create()
{
	for(int i=1;i&lt;=n;i++)//初始化 
		F[i][0]=a[i];
	int k=log2(n);//log(n)/log(2);
	for(int j=1;j&lt;=k;j++)
		for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)//n-2^j+1
			F[i][j]=max(F[i][j-1],F[i+(1&lt;&lt;(j-1))][j-1]);
}

int ST_query(int l,int r)//求区间[l..r]的最值 
{
	int k=log2(r-l+1);
	return max(F[l][k],F[r-(1&lt;&lt;k)+1][k]);//取两个区间最值 
}

int ST_print()
{
	int k=log2(n);
	for(int j=0;j&lt;=k;j++)
	{	
		for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)//n-2^j+1,打印第一列 
			cout&lt;&lt;F[i][j]&lt;&lt;&quot; &quot;;
		cout&lt;&lt;endl;
	}
}

int ST_print2()//按列打印 
{
	int k=log2(n);
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=0;j&lt;=k;j++)
			cout&lt;&lt;F[i][j]&lt;&lt;' ';
		cout&lt;&lt;endl;
	}
}

int main()
{
	int l,r;
	int i,v;
	cin&gt;&gt;n;
	for(i=1;i&lt;=n;i++)
		cin&gt;&gt;a[i];//5 3 7 2 12 1 6 4 8 15
	ST_create();//创建ST表
	ST_print();
	cout&lt;&lt;&quot;输入查询最值的区间l r:&quot;&lt;&lt;endl;
	cin&gt;&gt;l&gt;&gt;r;
	cout&lt;&lt;ST_query(l,r)&lt;&lt;endl;//求区间[l..r]的最值
	return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="http://poj.org/problem?id=3264">poj3264</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_96072edc55-130.png" alt="130.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;//min,max
#include&lt;cmath&gt;//log
using namespace std;
const int maxn=50010;
int h[maxn];
int Fmax[maxn][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j
int Fmin[maxn][20];
int N,Q;

void ST_create()
{
	for(int i=1;i&lt;=N;i++)//初始化 
		Fmax[i][0]=Fmin[i][0]=h[i];
	int k=log2(N);//log(N)/log(2.0);
	for(int j=1;j&lt;=k;j++)
		for(int i=1;i&lt;=N-(1&lt;&lt;j)+1;i++)//N-2^j+1
		{
			Fmax[i][j]=max(Fmax[i][j-1],Fmax[i+(1&lt;&lt;(j-1))][j-1]);
			Fmin[i][j]=min(Fmin[i][j-1],Fmin[i+(1&lt;&lt;(j-1))][j-1]);
		}			
}

int RMQ(int l,int r)//求区间[l..r]的最值差 
{
	int k=log2(r-l+1);
	int m1=max(Fmax[l][k],Fmax[r-(1&lt;&lt;k)+1][k]);
	int m2=min(Fmin[l][k],Fmin[r-(1&lt;&lt;k)+1][k]);
	return m1-m2;//取两个区间最值差 
}

int main()
{
	int a,b;
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;Q))
	{
		for(int i=1;i&lt;=N;i++)//下标从1开始 
			scanf(&quot;%d&quot;,&amp;h[i]);
		ST_create();
		for(int j=1;j&lt;=Q;j++)
		{
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			printf(&quot;%d\n&quot;,RMQ(a,b));
		}
	}
	return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=3368">poj3368</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_1fce3d8456-001.png" alt="001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_2d5faac856-002.png" alt="002.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_395ba96d56-003.png" alt="003.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010;
int lb[N];		
int f[N][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

int n,Q;
int a[N];

void ST_create()
{	
	for(int j=1;j&lt;=lb[n];j++)
		for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)
			f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);	
}

int RMQ(int l,int r)
{
	if(l &gt; r)
		return 0;
	int k=lb[r-l+1];
	return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;(i-1));
	while(~scanf(&quot;%d%&quot;,&amp;n) &amp;&amp; n)
	{
		scanf(&quot;%d&quot;,&amp;Q);
		for(int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
			if(i == 1)
			{
				f[i][0]=1;
				continue;
			}
			if(a[i] == a[i-1])
				f[i][0]=f[i-1][0]+1;
			else 
				f[i][0]=1;
		}
		ST_create();
		for(int j=1;j&lt;=Q;j++)
		{
			int l,r;
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			int t=l;
			while(t&lt;=r &amp;&amp; a[t] == a[t-1])
				t++;
			printf(&quot;%d\n&quot;,max(t-l,RMQ(t,r)));
		}
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3486">hdu3468</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_dc1676a656-005.png" alt="005.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=200010;
int a[N];
int n,k;
int F[N][20],lb[N];

void Initlog()
{
	lb[0]=-1;
    for(int i=1;i&lt;=N;i++)
        lb[i]=lb[i-1]+(i&amp;(i-1)?0:1);
}

void ST()
{
    for(int i=1;i&lt;=n;i++)
		F[i][0]=a[i];
    for(int j=1;j&lt;=lb[n];j++)
        for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)
            F[i][j]=max(F[i][j-1],F[i+(1&lt;&lt;(j-1))][j-1]);
}

int query(int l,int r)
{
    int k=lb[r-l+1];
    return max(F[l][k],F[r-(1&lt;&lt;k)+1][k]);
}

bool check(int mid)
{
    int t=n/mid,s=0;
    for(int i=0;i&lt;mid;i++)
		s+=query(t*i+1,t*i+t);
    return s&gt;k;
}

int main()
{
    lb[0]=-1;
	for(int i=1;i&lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;(i-1));
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k),n&gt;=0||k&gt;=0)
    {
        int sum=0;
        for(int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
            sum+=a[i];
        }
        if(sum&lt;=k)
		{
			printf(&quot;-1\n&quot;);
			continue;
		}
		ST();
		int l=1,r=n;
		while(l&lt;r)//二分找划分数 
    	{
	        int mid=(l+r)/2;
	        if(check(mid)) r=mid;
	        else l=mid+1;
    	}
		printf(&quot;%d\n&quot;,l);
    }
    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=2019">poj2019</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_3d701b9256-007.png" alt="007.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
const int maxn=260,INF=0x3f3f3f3f;
using namespace std;
int a[maxn][maxn],lb[maxn];
int Fmax[maxn][maxn][8],Fmin[maxn][maxn][8];
int n,m,k;

void ST()
{
	for(int k=1;k&lt;=n;k++)//多一维 
        for(int i=1;i&lt;=n;i++)
            Fmax[k][i][0]=Fmin[k][i][0]=a[k][i];	
	for(int k=1;k&lt;=n;k++)
		for(int j=1;j&lt;=lb[n];j++)
			for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)
			{
				Fmax[k][i][j]=max(Fmax[k][i][j-1],Fmax[k][i+(1&lt;&lt;(j-1))][j-1]);
				Fmin[k][i][j]=min(Fmin[k][i][j-1],Fmin[k][i+(1&lt;&lt;(j-1))][j-1]);
			}
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&lt;maxn;i++)
		lb[i]=(i&amp;(i-1))?lb[i-1]:lb[i-1]+1;
	while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k))
	{
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				scanf(&quot;%d&quot;,&amp;a[i][j]);	
		ST();
		for(int i=0;i&lt;k;i++)
		{
			int x,y;
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			int k=lb[m];
    		int maxx=-INF;
			int minx=INF;
    		int l=y,r=y+m-1;//从坐标为(x,y)的地方开始，右下扩展B长度 
    		for(int i=x;i&lt;x+m;i++)//查询每一行的最值 
		    {
		        maxx=max(maxx,max(Fmax[i][l][k],Fmax[i][r-(1&lt;&lt;k)+1][k]));
		        minx=min(minx,min(Fmin[i][l][k],Fmin[i][r-(1&lt;&lt;k)+1][k]));
		    }
			printf(&quot;%d\n&quot;,maxx-minx);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数位dp]]></title>
        <id>https://caifxh.github.io/post/shu-wei-dp/</id>
        <link href="https://caifxh.github.io/post/shu-wei-dp/">
        </link>
        <updated>2020-03-27T16:26:14.000Z</updated>
        <content type="html"><![CDATA[<p>问题的一般形式是这样的：<br>
定义一个条件 A，比如：被 7 整除、数位中含有 3 等等。<br>
询问区间 [L, R] 中有几个数满足条件 A L 和 R 的范围一般非常大，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span><br>
通过数位 DP，我们会发现这些问题的规模实际上是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>R</mi></mrow><annotation encoding="application/x-tex">log_{10} R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></p>
<p>数位 DP 就是考虑数字的每一位。<br>
问题的规模变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>R</mi></mrow><annotation encoding="application/x-tex">log_{10} R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><br>
每一位作为不同的阶段，设计状态。<br>
我们从高位往低位依次枚举。<br>
每一位的数选择的范围是不同的，依据前面选的数决定。</p>
<p><a href="https://www.acwing.com/problem/content/1087/">acwing1085</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_5b537e9670-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_a726651870-3.PNG" alt="3.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_55592c3c70-16.PNG" alt="16.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_1cf88f0a70-6.PNG" alt="6.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_2cd3e1cc70-7.PNG" alt="7.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_46b4d2ae70-8.PNG" alt="8.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_5d38098870-9.PNG" alt="9.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_8bf3feda70-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_a49f78ce70-11.PNG" alt="11.PNG" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int dp[15][15];
int num[15];

void init(){//预处理 
    dp[0][0]=1;
    for(int i=1;i&lt;=9;i++)
        for(int j=0;j&lt;=9;j++){
            if(j==4)
                dp[i][j]=0;
            else
                for(int k=0;k&lt;=9;k++){
                    if(j==6&amp;&amp;k==2)
                        continue;
                    dp[i][j]+=dp[i-1][k];
                }
        }
}

int solve(int x)//求解[1..x]之间满足条件的个数 
{
    int ans=0,cnt=0;
    while(x)
        num[++cnt]=x%10,x/=10;
    num[cnt+1]=0;
    for(int i=cnt;i&gt;=1;i--){//高位向低位计算 
        for(int j=0;j&lt;num[i];j++)
            if(j==4||(j==2&amp;&amp;num[i+1]==6))
            	continue;
            else
				ans+=dp[i][j];
        if(num[i]==4||(num[i]==2&amp;&amp;num[i+1]==6)){
			ans--;//减1，例如4，统计0，1 ，2，3共4个其实只有3个满足（不包括0） 
				 //例如3，统计0，1 ，2共3个满足，0相当于统计了3本身 
            break;
    	}
    }
    return ans;
}

void print(){//输出初始化处理后的dp数组 
	printf(&quot;  j=\t&quot;);
	for(int j=0;j&lt;=9;j++)
		printf(&quot;%-10d&quot;,j);
	printf(&quot;\n&quot;);
	for(int i=1;i&lt;=9;i++){
    	printf(&quot;i=%d\t&quot;,i);
		for(int j=0;j&lt;=9;j++)
			printf(&quot;%-10d&quot;,dp[i][j]);	
		printf(&quot;\n&quot;);
	}
}

int main()
{
    int n,m;
    memset(dp,0,sizeof dp);
    init();//初始化处理 
    //print();//输出dp数组 
    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n),n+m){//测试 1 24  62 386
    	//printf(&quot;%d\n&quot;,solve(n));
    	//printf(&quot;%d\n&quot;,solve(m));
        printf(&quot;%d\n&quot;,solve(n)-solve(m-1));
	}
    return 0;
}
</code></pre>
<h4 id="记忆化递归">记忆化递归</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_e2f83cfa70-12.PNG" alt="12.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_ef66924870-13.PNG" alt="13.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_038a069c70-14.PNG" alt="14.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_17c8b8e270-15.PNG" alt="15.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_752403fc70-17.PNG" alt="17.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_b902736a70-18.PNG" alt="18.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_de4ca76c70-19.PNG" alt="19.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_89782eea70-25.PNG" alt="25.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_2799b6c670-21.PNG" alt="21.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_4679d09470-22.PNG" alt="22.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_6c99dc9c70-23.PNG" alt="23.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_6f0abf1470-24.PNG" alt="24.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[20];
int dp[20][2];
//dp[pos][sta]表示当前第pos位，sta状态下满足条件的个数，sta表示前一位是否是6，只有0和1两种状态
int dfs(int pos,bool sta,bool limit)
{
    if(pos==0) return 1;
    if(!limit&amp;&amp;dp[pos][sta]!=-1) return dp[pos][sta];
    int len=limit?a[pos]:9;
    int ans=0;
    for(int i=0;i&lt;=len;i++)
    {
        if(sta&amp;&amp;i==2)continue;
        if(i==4) continue;//都是保证枚举合法性
        ans+=dfs(pos-1,i==6,limit&amp;&amp;i==len);
    }
    if(!limit) dp[pos][sta]=ans;
    return ans;
}

int solve(int x)//求解[0..x]之间满足条件的个数 
{
    int pos=0;
    while(x){
        a[++pos]=x%10;
        x/=10;
    }
    return dfs(pos,0,1);//如果不包括0，此处减1即可
}

void print(){//输出dp数组 
	printf(&quot;  j=\t&quot;);
	for(int j=0;j&lt;=1;j++)
		printf(&quot;%-10d&quot;,j);
	printf(&quot;\n&quot;);
	for(int i=1;i&lt;=9;i++){
    	printf(&quot;i=%d\t&quot;,i);
		for(int j=0;j&lt;=1;j++)
			printf(&quot;%-10d&quot;,dp[i][j]);	
		printf(&quot;\n&quot;);
	}
}

int main()
{
    int a,b;
    memset(dp,-1,sizeof dp);
    while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b),a+b)//测试24 386 
    {
		//printf(&quot;%d\n&quot;,solve(a));
		//print();
    	//printf(&quot;%d\n&quot;,solve(b));
    	//print();
		printf(&quot;%d\n&quot;,solve(b)-solve(a-1));
    }
    return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3555">hdu3555</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_0523299470-26.png" alt="26.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_00483fe070-27.png" alt="27.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_11b93f5470-28.png" alt="28.png" loading="lazy"></p>
<h4 id="正向做法">正向做法</h4>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=20;
LL f[N][2];
LL ten[N];
int num[N];
LL n;

LL dfs(int pos,bool sta,bool limit)
{
	if(pos == 0) return 0;
	if(!limit &amp;&amp; f[pos][sta] != -1)
		return f[pos][sta];
	
	int len=limit?num[pos]:9;
	LL ans=0;
	for(int i=0;i&lt;=len;i++)
	{
		if(sta &amp;&amp; i==9)
			ans+=limit?n%ten[pos-1]+1:ten[pos-1];
		else
			ans+=dfs(pos-1,i==4,limit&amp;&amp;i==len);
	}
	if(!limit)
		f[pos][sta]=ans;
	return ans;
}

LL dp(LL n)//求解[1..x]之间满足条件的个数 
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,1);
}

int main()
{
	int T;
	cin&gt;&gt;T;
	memset(f,-1,sizeof f);
	ten[0]=1;
	for(int i=1;i&lt;N;i++)
		ten[i]=ten[i-1]*10;
	while(T--)
	{
		scanf(&quot;%lld&quot;,&amp;n);
		printf(&quot;%lld\n&quot;,dp(n));
	}
	return 0;
}
</code></pre>
<h4 id="反向做法">反向做法</h4>
<pre><code>#include&lt;cstdio&gt;//求不包含49的个数ans(不包括0)，然后n-ans
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;//注意！！本题数据类型为ll 
const int N=30;
int dig[N];
LL dp[N][2],n;
//dp[pos][sta]表示当前第pos位，sta状态下满足条件的个数，sta表示前一位是否是4，只有0和1两种状态
LL dfs(int pos,bool sta,bool limit)//求不包含49的个数
{
    if(!pos) return 1;//包括0 
    if(!limit&amp;&amp;dp[pos][sta]!=-1) return dp[pos][sta];
    int len=limit?dig[pos]:9;
    LL ans=0;
    for(int i=0;i&lt;=len;i++)
    {
        if(sta&amp;&amp;i==9)
        	continue;
        ans+=dfs(pos-1,i==4,limit&amp;&amp;i==len);
    }
    if(!limit) dp[pos][sta]=ans;
    return ans;
}

LL solve(LL x)//求解[1..x]之间不包含49的个数 
{
    int pos=0;
    while(x){
        dig[++pos]=x%10;
        x/=10;
    }
    return dfs(pos,0,1)-1;//除去0 
}

int main()
{
    memset(dp,-1,sizeof(dp));
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--){
		scanf(&quot;%I64d&quot;,&amp;n);
		printf(&quot;%I64d\n&quot;,n-solve(n));
	}
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/340/">acwing338</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_79719d0070-29.png" alt="29.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_7c8b84ec70-30.png" alt="30.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=10;
int f[N][10][N];
int num[N];
int ans1[N];
int ans2[N];

int dfs(int pos,int val,int cnt,bool lead,bool limit)
{
    if(pos == 0) return cnt;
    if(!limit &amp;&amp; !lead &amp;&amp; f[pos][val][cnt] != -1)
        return f[pos][val][cnt];

    int len=limit?num[pos]:9;
    int ans=0,t=0;
    for(int i=0;i&lt;=len;i++)
    {
        if(val != i) t=cnt;
        else 
        {
            if(lead &amp;&amp; val==0)
                t=0;
            else  
                t=cnt+1;
        }
        ans+=dfs(pos-1,val,t,lead&amp;&amp;i==0,limit&amp;&amp;i==len);
    }
    if(!limit &amp;&amp; !lead) f[pos][val][cnt]=ans;
    return ans;
}

void dp(int n,int ans[])
{
    int pos=0;
    while(n)
    {
        num[++pos]=n%10;
        n/=10;
    }

    for(int i=0;i&lt;=9;i++)
        ans[i]=dfs(pos,i,0,1,1);
}

int main()
{
    memset(f,-1,sizeof f);
    int a,b;
    while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b))
    {
        if(!a &amp;&amp; !b) break;
        if(a&gt;b) swap(a,b);
        dp(b,ans1);
        dp(a-1,ans2);
        for(int i=0;i&lt;10;i++)
            printf(&quot;%d &quot;,ans1[i]-ans2[i]);
    }
    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3252">poj3252</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_5712eaa670-32.png" alt="32.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=35;
int f[N][N][N];
int num[N];

int dfs(int pos,int cnt0,int cnt1,bool lead,bool limit)
{
	if(pos == 0) return cnt0&gt;=cnt1;
	if(!limit &amp;&amp; !lead &amp;&amp; f[pos][cnt0][cnt1] != -1)
		return f[pos][cnt0][cnt1];

	int len=limit?num[pos]:1;
	int ans=0;
	for(int i=0;i&lt;=len;i++)
	{
		if(lead &amp;&amp; !i)
			ans+=dfs(pos-1,0,0,1,limit&amp;&amp;i==len);
		else 
			ans+=dfs(pos-1,cnt0+(i==0),cnt1+(i==1),0,limit&amp;&amp;i==len);
	}
	if(!limit &amp;&amp; !lead)
		f[pos][cnt0][cnt1]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%2;
		n/=2;
	}
	
	return dfs(pos,0,0,1,1);
}

int main()
{
	int a,b;
	memset(f,-1,sizeof f);
	while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b))
		printf(&quot;%d\n&quot;,dp(b)-dp(a-1));
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/HDU-4734">hdu4734</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_3d9a111a70-43.png" alt="43.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_50fd7d5070-44.png" alt="44.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/28/9969_5440e4d470-45.png" alt="45.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=10,M=4610;
int f[N][M];
int num[N];
int a,b;

int dfs(int pos,int val,bool limit)
{
	if(pos == 0) return val&gt;=0;
	if(val &lt; 0) return 0;
	if(!limit &amp;&amp; f[pos][val] != -1)
		return f[pos][val];
	
	int ans=0;
	int len=limit?num[pos]:9;
	for(int i=0;i&lt;=len;i++)
		ans+=dfs(pos-1,val-i*(1&lt;&lt;pos-1),limit &amp;&amp; i==len);
	if(!limit) f[pos][val]=ans;
	return ans;

}


int F(int n)
{
	int ans=0,len=0;
	while(n)
	{
		ans+=(n%10)*(1&lt;&lt;len);
		len++;
		n/=10;
	}
	return ans;
}

int dp(int n)//求解小于等于f(a)的数的个数 
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,F(a),1);
}

int main()
{
	int T,kas=1;
	cin&gt;&gt;T;
	memset(f,-1,sizeof f);
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		printf(&quot;Case #%d: %d\n&quot;,kas++,dp(b));
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1083/">acwing1081</a><br>
统计区间内一个数的B进制表示下恰好有k位为1的数的个数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=35;
int f[N][N];
int num[N];
int k,b;

int dfs(int pos,int cnt,bool limit)
{
    if(cnt &gt; k) return 0;
	if(pos == 0) return cnt==k;
	
	if(f[pos][cnt] != -1 &amp;&amp; !limit) 
		return f[pos][cnt];
	
	int len=limit?num[pos]:1;
	int ans=0;
	for(int i=0;i&lt;=min(len,1);i++)
		if(i) ans+=dfs(pos-1,cnt+1,limit&amp;&amp;i==len);
		else ans+=dfs(pos-1,cnt,limit&amp;&amp;i==len);

	if(!limit) f[pos][cnt]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n) num[++pos]=n%b,n/=b;
	
	return dfs(pos,0,1);
}

int main()
{
	int l,r;
	memset(f,-1,sizeof f);
	scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;r,&amp;k,&amp;b);
	
	printf(&quot;%d\n&quot;,dp(r)-dp(l-1));
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1084/">acwing1082</a><br>
统计区间内不下降数的个数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=15;
int f[N][10];
int num[N];

int dfs(int pos,int last,bool limit)
{
	if(pos ==0) return 1;
	if(f[pos][last] != -1 &amp;&amp; !limit)
		return f[pos][last];

	int ans=0;
	int len=limit?num[pos]:9;
	for(int i=0;i&lt;=len;i++)
	{
		if(i&lt;last) continue;
		ans+=dfs(pos-1,i,limit&amp;&amp;i==len);
	}
	
	if(!limit) f[pos][last]=ans;
	return ans;
	
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,1);
}

int main()
{
	int a,b;
	memset(f,-1,sizeof f);
	while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b))
		printf(&quot;%d\n&quot;,dp(b)-dp(a-1));
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P4127">P4127</a><br>
询问 [L,R] 中各位数字之和能整除原数的个数。1 ≤ L ≤ R ≤ 1e18</p>
<h4 id="思路">思路</h4>
<p>可以发现各位数之和最大只能是 9 * 18 = 162<br>
我们可以枚举这个和 sum<br>
然后去统计可以被 sum 整除，且数位和是 sum 的数。<br>
我们把状态定义为 f[dep][cur][mod]<br>
表示当前枚举第 dep 位，目前这个数的数位和是 cur，对<br>
sum 取模是 mod.<br>
cur = sum 且 mod = 0 的个数要统计进答案</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=20,M=170;
LL f[N][M][M];
int num[N];
LL a,b;
LL sum;

LL dfs(int pos,int val,int mod,bool limit)//val为当前各位数字之和 
{
	if(pos == 0) return val==sum &amp;&amp; mod==0;
	if(val &gt; sum) return 0;
	
	if(!limit &amp;&amp; f[pos][val][mod] != -1)
		return f[pos][val][mod];
	
	int len=limit?num[pos]:9;
	LL ans=0;
	for(int i=0;i&lt;=len;i++)
		ans+=dfs(pos-1,val+i,(mod*10+i)%sum,limit&amp;&amp;i==len);
	
	if(!limit) f[pos][val][mod]=ans;
	return ans;
}

LL dp(LL n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	LL res=0;
	for(int i=1;i&lt;=pos*9;i++)//枚举各位之和
	{
		memset(f,-1,sizeof f);
		sum=i;
		res+=dfs(pos,0,0,1);
	}
	
	return res;
}

int main()
{
	cin&gt;&gt;a&gt;&gt;b;
	cout&lt;&lt;dp(b)-dp(a-1)&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1085/">acwing1083</a><br>
求区间内任意相邻位上的数字之差的绝对值大于等于二的数的个数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=11;
int f[N][10];
int num[N];

int dfs(int pos,int val,bool lead,bool limit)
{
	if(pos == 0) return 1;
	if(!limit &amp;&amp; !lead &amp;&amp; f[pos][val] != -1)
		return f[pos][val];
	
	int len=limit?num[pos]:9;
	int ans=0;
	for(int i=0;i&lt;=len;i++)
	{
		if(lead || abs(i-val) &gt;= 2)//如果包含前导零不能让i与之做差，直接让i成为下一位即可
			ans+=dfs(pos-1,i,lead&amp;&amp;i==0,limit&amp;&amp;i==len);
	}
	
	if(!limit &amp;&amp; !lead) f[pos][val]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,-2,1,1);
}

int main()
{
	memset(f,-1,sizeof f);
	int a,b;
	cin&gt;&gt;a&gt;&gt;b;
	cout&lt;&lt;dp(b)-dp(a-1)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1086/">acwing1084</a><br>
求区间内各位数字之和mod N为0的数的个数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=11,M=110;
int f[N][M];
int num[N];
int a,b,mod;

int dfs(int pos,int val,bool limit)
{
	if(pos == 0) return val == 0;
	if(!limit &amp;&amp; f[pos][val] != -1)
		return f[pos][val];
	
	int len=limit?num[pos]:9;
	int ans=0;
	for(int i=0;i&lt;=len;i++)
		ans+=dfs(pos-1,(val+i)%mod,limit&amp;&amp;i==len);
	
	if(!limit) f[pos][val]=ans;
	return ans;
}

int dp(int n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,1);
}

int main()
{
	while(~scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;mod))
	{
		memset(f,-1,sizeof f);
		printf(&quot;%d\n&quot;,dp(b)-dp(a-1));
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/HDU-3709">hdu3709</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/29/9969_a954c17971-46.PNG" alt="46.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/29/9969_aca5ab8071-47.PNG" alt="47.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/29/9969_aeca18ec71-48.PNG" alt="48.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/29/9969_b0c16ca471-49.PNG" alt="49.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
typedef long long LL;
using namespace std;
const int N=20,M=2000;
LL f[N][N][M];
int num[N];

LL dfs(int pos,int val,int sum,bool limit)
{
	if(pos == 0) return sum==0;
	if(sum&lt;0) return 0;
	if(!limit &amp;&amp; f[pos][val][sum] != -1)
		return f[pos][val][sum];
	
	int len=limit?num[pos]:9;
	LL ans=0;
	for(int i=0;i&lt;=len;i++)
		ans+=dfs(pos-1,val,sum+(pos-val)*i,limit&amp;&amp;i==len);
	
	if(!limit) f[pos][val][sum]=ans;
	return ans;
}

LL dp(LL n)
{
	if(n&lt;0) return 0;
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	LL ans=0;
	for(int i=1;i&lt;=pos;i++)
		ans+=dfs(pos,i,0,1);
	return ans-pos+1;//pos次循环统计了pos次0，应减去多算的pos-1个0的出现次数
}

int main()
{
	int T;
	cin&gt;&gt;T;
	memset(f,-1,sizeof f);
	while(T--)
	{
		LL a,b;
		scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);
		printf(&quot;%lld\n&quot;,dp(b)-dp(a-1));
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1088/">hdu4507</a><br>
如果一个整数符合下面3个条件之一，那么我们说这个整数和7有关：<br>
整数中某一位是7<br>
整数的每一位加起来的和是7的整数倍<br>
这个整数是7的整数倍<br>
询问[L,R]中与7无关的数字的平方和，模1e9+7.1≤L≤R≤1e18</p>
<p>为了转移需要维护三个值：<br>
cnt 和 7 有关的数的个数<br>
sum 和 7 有关的数的和<br>
sqr 和 7 有关的数的平方和</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/29/9969_69658fe271-50.PNG" alt="50.PNG" loading="lazy"><br>
因此对于所有回溯上来的数x1,x2,x3..xn，你得知道与7无关的数的个数（对应n个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的和），<br>
与7有关的数之和（对应2d(x1+x2+...+xn），与7有关的数的平方和（对应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">x_1^2+x_2^2+...+x_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>）<br>
假设当前状态是 f，从 g 状态转移过来（dfs回溯上来）<br>
f.cnt += g.cnt<br>
f.sum += g.sum + d * g.cnt<br>
f.sqr += d * d * g.cnt + 2 * d * g.sum + g.sqr</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
typedef long long LL;
using namespace std;
const int N=20,mod=1e9+7;
struct Node
{
	LL cnt;
	LL sum;
	LL sqr;
}f[N][7][7];//分别表示数位，各位和%7，数本身%7 
int num[N];
LL ten[N];

Node dfs(int pos,int val,int sum,bool limit)
{
	if(pos == 0)
	{
		Node t;
		t.cnt= val&gt;0 &amp;&amp; sum&gt;0;
		t.sum=0;
		t.sqr=0;
		return t;
	}
	if(!limit &amp;&amp; f[pos][val][sum].cnt != -1)
		return f[pos][val][sum];
	
	int len=limit?num[pos]:9;
	Node ans;
	ans.cnt=ans.sum=ans.sqr=0;
	for(int i=0;i&lt;=len;i++)
	{
		if(i == 7) continue;
		LL d=i*ten[pos-1]%mod;
		Node t=dfs(pos-1,(val+i)%7,(sum*10+i)%7,limit&amp;&amp;i==len);
		ans.cnt=(ans.cnt+t.cnt)%mod;
		ans.sum=(ans.sum+t.sum+d*t.cnt%mod)%mod;
		ans.sqr=(ans.sqr+t.sqr+d*d%mod*t.cnt%mod+2*d%mod*t.sum%mod)%mod;
	}
	
	if(!limit) f[pos][val][sum]=ans;
	return ans;
}

int dp(LL n)
{
	int pos=0;
	while(n)
	{
		num[++pos]=n%10;
		n/=10;
	}
	
	return dfs(pos,0,0,1).sqr;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	memset(f,-1,sizeof f);
	ten[0]=1;
	for(int i=1;i&lt;N;i++)
		ten[i]=ten[i-1]*10%mod;

	while(T--)
	{
		LL a,b;
		scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);
		printf(&quot;%d\n&quot;,((dp(b)-dp(a-1))%mod+mod)%mod);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串复习（二）]]></title>
        <id>https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/</id>
        <link href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/">
        </link>
        <updated>2020-03-27T09:11:49.000Z</updated>
        <content type="html"><![CDATA[<h4 id="manacher">Manacher</h4>
<p>回文串:对于一个长度为 n 的字符串 str，如果它正着读和反着读一样，即 str[i] = str[n - i + 1] (1 &lt;= i &lt; n - i + 1),如 aba，acbbca 就是回文串，abc，abab 就不是回文串。</p>
<p>Manacher 算法可以求出以每个位置为中心，向两边能扩展的最长回文子串长度 p[i]，它的时间复杂度是 O(n) 的。<br>
注意到回文子串的长度可能是偶数， 如 abba，中心不是某个字符（中心是两个 b 之间的空隙），所以先要在相邻的<br>
字符中插入一个标识符，例如 #,这样例如 #a#b#b#a# 的中心就是 # 了。</p>
<p>我们用 abbabcba 来举例。<br>
先插入 # 得到 #a#b#b#a#b#c#b#a#。<br>
然后用 Manacher 可以得到如下的 p 数组。<br>
对于每个 p[i]，一定有 str[i + j] == str[i - j] (1 ≤ j &lt; p[i])<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_9f85dc7c62-36.PNG" alt="36.PNG" loading="lazy"></p>
<p>类比 Z 算法，我们也维护一个 mx 和 id，表示对于当前计算的所有 i，i + p[i] 的最大值是 mx，mx 对应的 i 记为id。<br>
当你现在开始计算 p[i] 时，默认 p[1..i-1] 都已经算出。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_ca02b89262-38.PNG" alt="38.PNG" loading="lazy"></p>
<h4 id="计算最长回文子串长度">计算最长回文子串长度</h4>
<p>以字符串&quot;cabbaf&quot;为例，将预处理后的新字符串&quot;#c#a#b#b#a#f#&quot;变成一个字符数组arr，定义一个辅助数组int[] p，p的长度与arr等长，p[i]表示以arr[i]字符为中心的最长回文半径，p[i]=1表示只有arr[i]字符本身是回文子串。</p>
<pre><code>i       0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i]  # c # a # b # b # a #  f  #
p[i]    1 2 1 2 1 2 5 2 1 2 1  2  1
</code></pre>
<p>我们来比对分下一下最长回文半径和原字符串之间的关系。在上面例子中，最长回文子串是&quot;#a#b#b#a#&quot;，它以arr[6]为中心，半径是5，其代表的原始字符串是&quot;abba&quot;，而&quot;abba&quot;的长度为4，可以通过5减去1得到，是字符串&quot;cabbaf&quot;中的最长回文子串，那么我们是不是可以得出最长回文半径和最长回文子串长度之间的关系？</p>
<p>让我们再多看几个例子，如&quot;aba&quot;，转换后是&quot;#a#b#a#&quot;，以字符'b'为中心的回文，半径是4，减1得到3，3是原字符串的最长回文子串长度。</p>
<p>再例如&quot;effe&quot;，转换后是&quot;#e#f#f#e#&quot;，以最中间的'#'为中心的回文，半径是5，减1得到4，4是原字符串的最长回文子串长度。</p>
<p>因此，最后我们得到最长回文半径和最长回文子串长度之间的关系：int maxLength = p[i]-1。maxLength表示最长回文子串长度。</p>
<h4 id="计算最长回文子串起始索引">计算最长回文子串起始索引</h4>
<p>知道了最长回文子串的长度，我们还需要知道它的起始索引值，这样才能截取出完整的最长回文子串。<br>
继续以第三步中的字符串&quot;cabbaf&quot;为例，p[6]=5，是最长半径，用6(i)减去最长半径5(p[i])得到1，而1恰好是最长回文子串&quot;abba&quot;的起始索引。<br>
我们再来看一个奇回文的例子。例如&quot;aba&quot;，转换后是&quot;#a#b#a#&quot;，p[3]=4，最长半径是4，i为3，用i减去4得到-1，数组下标越界了。<br>
在偶回文的情况下，可以满足i减最长半径，而奇回文却会下标越界，我们需要在转换后的字符串前面再加一个字符，解决下标越界的问题，不能是'#'，那就加个'$'字符吧，但是加过一个字符后，字符串的长度不是奇数了，只能在尾部再加一个不会重复出现的字符，比如'@'(也可不加，因为字符串结尾为'\0')，这样字符串的长度依旧是奇数了，满足前面第三部分的条件。</p>
<p>加多一个字符后，奇回文可以正常做减法了，偶回文呢？</p>
<pre><code>i       0 1 2 3 4 5 6 7 8 9 10 11 12 13
arr[i]  $ # c # a # b # b # a  #  f  #
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1
</code></pre>
<p>在补上字符'$'后，p[7]=5，用i减去最长半径，7-5=2，而理想的结果应该是1，那就再除以2吧，这样就能得到1了。而奇回文&quot;aba&quot;在用i减去最长半径后得到的是0，除以2后还是0，可以完美解决下标越界的问题。</p>
<p><code>结论：最长回文子串的起始索引int index = (i - p[i])/2。</code><br>
<a href="https://www.luogu.com.cn/problem/P3805">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=11000010;
char s[N];
charma[N&lt;&lt;1];
int p[N&lt;&lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i]&gt;mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	while(~scanf(&quot;%s&quot;,s))
	{
		int len=strlen(s);
		manacher(s,len);
		int ans=0;
		for(int i=0;i&lt;2*len+2;i++)
			ans=max(ans,p[i]-1);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://codeforces.ml/problemset/problem/17/E">Codeforces 17E</a><br>
给出一个字符串 s。 求 s 有多少对相交的回文子串。包含也算作相交。<br>
如 babb 一共有 6 对相交的回文子串：<br>
s[1..1] and s[1..3]<br>
s[1..3] and s[2..2]<br>
s[1..3] and s[3..3]<br>
s[1..3] and s[3..4]<br>
s[3..3] and s[3..4]<br>
s[3..4] and s[4..4]<br>
|s| ≤ 2·e6</p>
<p>正难则反<br>
统计不相交的回文子串对数。<br>
不相交的回文子串假设端点分别为 x1,y1,x2,y2<br>
那么一定有 x1 &lt;= y1 &lt; x2 &lt;= y2<br>
我们只要统计出以 i 为起点的回文串个数 st[i]，和以 i为终点的回文串个数 ed[i]。<br>
然后计算<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_4bb23d6462-39.PNG" alt="39.PNG" loading="lazy"><br>
在使用 manacher 算法的时候，对每个 i 都计算出了 p[i]<br>
那么我们就要把[i-p[i], i+p[i]] 这个极大回文子串对 st和 ed 的贡献算进去。<br>
对于 st: [i-p[i]+1, i] 这些点每个位置都要 +1<br>
对于 ed：[i, i+p[i]-1] 这些点每个位置都要 +1<br>
只需要通过差分转化为单点修改即可。<br>
最后用总的回文子串对数减去不相交的回文子串对数即是答案</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=2e6+10,mod=51123987;
char s[N];
int p[N&lt;&lt;1];
int n;
char ma[N&lt;&lt;1];
int l[N&lt;&lt;1],r[N&lt;&lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,s);
	manacher(s,n);
	n=n*2+2;
	
	int ans=0;
	for(int i=0;i&lt;n;i++)
	{
		l[i-p[i]+1]++,l[i+1]--;
		r[i]++,r[i+p[i]]--;
		ans=(ans+p[i]/2)%mod;
	}
	ans=(LL)ans*(ans-1)/2%mod;
	
	int sum=0;
	for(int i=1;i&lt;n;i++)
	{
		l[i]+=l[i-1];r[i]+=r[i-1];
		if(i&amp;1) continue;
		ans=(ans-(LL)sum*l[i]%mod+mod)%mod;
		sum=(sum+r[i])%mod;
	}
	printf(&quot;%d&quot;,ans);
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P4555">BZOJ 2565</a><br>
定义双回文串 T，满足存在 T = ab，其中 a 和 b 都是回文串。<br>
给定字符串 S，求一个 S 的最长的双回文子串 T。<br>
|S| ≤ 1e6</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_562e454c62-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG" loading="lazy"><br>
Lmax是一个点往左扩展，越靠右越可能长，所以做逆推；Rmax是一个点往右扩展，越靠左越可能长，所以做顺推。递推式子见代码。处理好之后扫一遍就出解了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int n;
int l[N*2],r[N*2],p[N*2];
char ma[N*2],a[N];

void manacher(char *s,int len)
{
    int k=0;
    ma[k++]='$';
    ma[k++]='#';
    for(int i=0;i&lt;len;i++)
    {
        ma[k++]=s[i];
        ma[k++]='#';
    }
    ma[k]=0;
    int mx=0,id=0;
    for(int i=0;i&lt;k;i++)
    {
        if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]] == ma[i-p[i]])
            p[i]++;
        if(i+p[i]&gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
        l[i+p[i]-1]=max(l[i+p[i]-1],p[i]-1);
        //cout&lt;&lt;l[i+p[i]-1]&lt;&lt;' '&lt;&lt;p[i]-1&lt;&lt;endl;
        r[i-p[i]+1]=max(r[i-p[i]+1],p[i]-1);
        //cout&lt;&lt;r[i-p[i]+1]&lt;&lt;' '&lt;&lt;p[i]-1&lt;&lt;endl;
    }
}

 
int main()
{
	scanf(&quot;%s&quot;,a);
	
	int n=strlen(a);
	manacher(a,n);
	n=n*2+2;
	
	for(int i=1;i&lt;n;i+=2) r[i]=max(r[i],r[i-2]-2);
	for(int i=n-1;i&gt;=1;i-=2) l[i]=max(l[i],l[i+2]-2);
	
	int ans=0;
	for(int i=1;i&lt;n;i++) 
		if(l[i] &amp;&amp; r[i])
			ans=max(ans,l[i]+r[i]);
	cout&lt;&lt;ans;
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P4324">bzoj4755</a><br>
有两个长度均为 N 的字符串 A 和 B。<br>
扭动的字符串 S(i,j,k) 定义为 A[i..j]+B[j..k] 若 A=’xyz’, B=‘uvw’, 则 S(1,2,3)=‘xyvw’<br>
定义扭动的回文串为如下情况中的一个；<br>
A 中的一个回文串<br>
B 中的一个回文串<br>
某一个回文的扭动字符串S(i,j,k)<br>
求最长的扭动回文串<br>
1≤N≤100000，字符串只含大写字母</p>
<blockquote></blockquote>
<p>样例：<br>
5<br>
ABCDE<br>
BAECB<br>
答案：<br>
5<br>
最长的扭动回文串是 S(2,3,5) = BCECB</p>
<p>对于前两种情况，我们只需要用 manacher 算法求出每个位置的回文扩展半径，然后取一个最大值即可。<br>
对于第三种情况，需要在两个字符串中各取一段拼起来。<br>
我们可以把答案字符串分解为 STS’<br>
其中 S’ 是 S 的反串，T 是回文串。</p>
<p>可以发现一定是 S 在一个串，TS’ 在另一个串；或者 ST 在一个串，S’在另一个串。<br>
且<code>T 一定是极大的回文子串。</code></p>
<p>那么我们只要枚举极大回文子串 T 即可。<br>
假设中心在 A 中，枚举中心 i。<br>
(1)假设A[i-p[i], i+p[i]] 是极大回文子串。<br>
枚举 A[i+p[i]+1..n] 的前缀和 B[1..i-p[i]] 的后缀最长能匹配上多少。</p>
<p>(2)假设B[i-p[i], i+p[i]] 是极大回文子串。<br>
枚举 A[1..i-p[i]-1] 的后缀 和 B[i + p[i]..n] 的前缀最长能匹配上多少。<br>
这两部分的最大值 * 2 + 极大回文子串的长度就是答案了。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef unsigned long long ULL;
const int N=100010,M=N&lt;&lt;1,P=131;
char a[N],b[N];
char ma[M];
int pa[M],pb[M];
int n;
ULL ha[N],hb[N],p[N];
int ans;

ULL getha(int l,int r)
{
	return ha[r]-ha[l-1]*p[r-l+1];
}

ULL gethb(int l,int r)
{
	return hb[l]-hb[r+1]*p[r-l+1];
}

void manacher(char *s,int len,int p[])
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=1;i&lt;=len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l++]=0;
	
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx &gt; i) p[i]=min(p[2*id-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}	
}

int search(int L,int R)
{
	int l=0,r=min(L,n-R+1);
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(getha(L-mid+1,L) == gethb(R,R+mid-1))
			l=mid;
		else 
			r=mid-1;
	}
	return l;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,a+1);
	scanf(&quot;%s&quot;,b+1);
	
	p[0]=1;
	for(int i=1;i&lt;=n;i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&lt;=n;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=n;i&gt;=1;i--)
		hb[i]=hb[i+1]*P+b[i];
	
	manacher(a,n,pa);
	manacher(b,n,pb);
	n=n*2+1;
	for(int i=1;i&lt;=n;i++) ans=max(ans,pa[i]-1);
	for(int i=1;i&lt;=n;i++) ans=max(ans,pb[i]-1);
	for(int i=1;i&lt;=n;i++)
	{
		int l=(i-pa[i])/2+1,r=(i+pa[i])/2-1;//下标从1开始
		if(l&lt;=r)
			ans=max(ans,pa[i]-1+search(l-1,r)*2);
	}
	for(int i=1;i&lt;=n;i++)
	{
		int l=(i-pb[i])/2+1,r=(i+pb[i])/2-1;
		if(l&lt;=r)
			ans=max(ans,pb[i]-1+search(l,r+1)*2);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/SP7586">SP7586</a><br>
求一个串中包含几个回文串<br>
用马拉车求出以每个字母为对称轴的回文串长度，因为一个回文串长度/2就是这个回文串包含的子回文串长度，所以最后统计一下即可<br>
<a href="https://paste.ubuntu.com/p/bg75xXjG4R/">代码</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3501">BZOJ 2084 Antisymmetry</a><br>
给定一个长度为 n 的01串，问有多少个子串满足翻转并取反后和原来一样。<br>
比如0101翻转并取反后还是和原来一样。</p>
<p>只要定义 0 = 1， 0 ≠ 0，1 ≠ 1 即可。跑一遍 Manacher 即可。<br>
以 0/1 扩展的 p[i] 一定是 0 （即没有奇数长度的合法子串）<br>
以 # 扩展的累加起来即可<br>
接下来我们来考虑如果我们确定了一个中心后，向外扩展出一个最大可能的反对称串，那么这个串中一定含有len/2个满足条件的串，其中len为串长，因为要想大的满足条件，则在里面的小串必须满足是反对称的</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=500010;
char s[N];
char ma[N&lt;&lt;1];
int p[N&lt;&lt;1];
int n;

void manacher(char *s,int len)
{
    int l=0;
    ma[l++]='$';
    ma[l++]='#';
    for(int i=0;i&lt;len;i++)
    {
        ma[l++]=s[i];
        ma[l++]='#';
    }
    ma[l]=0;
    int mx=0,id=0;
    for(int i=1;i&lt;l;i+=2)
    {
        if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]]-'0'+ma[i-p[i]]-'0'==1 || (ma[i+p[i]]==ma[i-p[i]] &amp;&amp; ma[i+p[i]]=='#'))
            p[i]++;
        if(i+p[i]&gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
    }
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,s);
    manacher(s,n);
    long long ans=0;
    for(int i=1;i&lt;n*2+2;i+=2)
    	ans+=p[i]/2;
	
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3790">BZOJ 3790</a><br>
母亲节就要到了，小 H 准备送给她一个特殊的项链。这个项链可以看作一个用小写字母组成的字符串，每个小写字母表示一种颜色。为了制作这个项链，小 H 购买了两个机器。第一个机器可以生成所有形式的回文串，第二个机器可以把两个回文串连接起来，而且第二个机器还有一个特殊的性质：假如一个字符串的后缀和一个字符串的前缀是完全相同的，那么可以将这个重复部分重叠。<br>
例如：aba和aca连接起来，可以生成串abaaca或 abaca。现在给出目标项链的样式，询问你需要使用第二个机器多少次才能生成这个特殊的项链。</p>
<blockquote></blockquote>
<p>样例：<br>
abcdcba （答案：0）<br>
abacada （答案：2）<br>
abcdef （答案：5）</p>
<p>题目的意思就是用尽可能少的回文子串去覆盖原串。<br>
我们可以先跑一遍 Manacher 算法得到每个位置的覆盖半径。<br>
问题转化为了有许多个区间 [i-p[i], i+p[i]]，要选出尽可能少的区间来覆盖 [1, n] 区间</p>
<p>贪心即可。<br>
对所有的区间按照左端点从小到大排序。<br>
每次都选右端点最远的那个区间。<br>
设当前覆盖到的右端点为 right。<br>
每次找出左端点在[1, right] 中的右端点的最大的那个线段，再做一次覆盖。<br>
时间复杂度 O(n log n)<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_83262ddc62-tempsnip.png" alt="tempsnip.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=50010,M=N&lt;&lt;1;
char s[N],ma[M];
int p[M];
struct Node
{
	int l,r;
	bool operator&lt;(const Node &amp;W) const
	{
		return l&lt;W.l;
	}
}e[M];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
		e[i].l=i-p[i]+1,e[i].r=i+p[i]-1;
	}
}

int main()
{
	while(~scanf(&quot;%s&quot;,s))
	{
		int n=strlen(s);
		manacher(s,n);
		
		n=n*2+1;
		sort(e+1,e+n+1);
		
		int st=1,j=1,ed=n;
		int res=0;
		
		while(st &lt; ed)
		{
			int r=0;
			while(j &lt;= n &amp;&amp; e[j].l &lt;= st)
				r=max(r,e[j].r),j++;
			
			st=r;
			res++;
		}
		printf(&quot;%d\n&quot;,res-1);
	}
}
</code></pre>
<h4 id="trie">trie</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_465a00d061-17.PNG" alt="17.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_568cd63061-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_58b69c0c61-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_830379da61-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_84e99b6c61-21.png" alt="21.png" loading="lazy"></p>
<pre><code>void insert(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-'a';
        if(!trie[p][k])
            trie[p][k]=++idx;
        p=trie[p][k];
    }
    cnt[p]=true;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_037d465861-22.png" alt="22.png" loading="lazy"></figure>
<pre><code>int query(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-'a';
        p=trie[p][k];
        if(!p)
            return 0;
    }
    return cnt[p];
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/837/">模板题</a></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_2cda862961-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_371889c861-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_40813ee261-25.png" alt="25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_6342628a61-26.png" alt="26.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_65f359bc61-27.png" alt="27.png" loading="lazy"></p>
<h4 id="例题">例题</h4>
<p><a href="https://vjudge.net/problem/POJ-2503">poj2503</a><br>
您刚从滑铁卢搬到大城市。 这里的人说的是一门不可理解的外语。 幸运的是，您有一本字典来帮助您理解它们。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ae53dcea61-28.png" alt="28.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;sstream&gt;
using namespace std;
const int N=1000010,M=26;
int trie[N][M];
int cnt[N],idx=1;
char word[N][15];

void insert(string str,int k)
{
	int len=str.size(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=str[i]-'a';
		if(!trie[p][ch])
			trie[p][ch]=++idx;
		p=trie[p][ch];
	}
	cnt[p]=k;
}

int query(string str)
{
	int len=str.size(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int k=str[i]-'a';
		p=trie[p][k];
		if(!p)
			return 0;
	}
	return cnt[p];
}

int main()
{
	string s,str;
	int k=1;
	while(getline(cin,s))
	{
		if(s.empty())
			break;
		stringstream ss(s);
		ss&gt;&gt;word[k]&gt;&gt;str;
		insert(str,k);
		k++;
	}
	
	while(cin&gt;&gt;s)
	{
		int k=query(s);
		if(k)
			cout&lt;&lt;word[k]&lt;&lt;endl;
		else 
			cout&lt;&lt;&quot;eh&quot;&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="">poj3630</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_360d81f861-29.png" alt="29.png" loading="lazy"><br>
给定一个电话号码列表，判断它是否一致，即没有号码是另一个号码的前缀。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ae1e7c4461-29.png" alt="29.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;sstream&gt;
using namespace std;
const int N=100010,M=10;
int trie[N][M];
bool cnt[N];
int idx;
int n;

bool insert(char *s)
{
	int p=1;
	int len=strlen(s);
	for(int i=0;i&lt;len;i++)
	{
		int k=s[i]-'0';
		if(!trie[p][k])
			trie[p][k]=++idx;
		else if(i == len-1)//字符串处理完毕，仍不空，说明该串是其它串的前缀 
			return true;
		p=trie[p][k];
		if(cnt[p])//其他串是该串前缀 
			return true;
	}
	cnt[p]=true;
	return false;
}

int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		idx=1;
		bool ans=false;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
		{
			char s[15];
			scanf(&quot;%s&quot;,s);
			if(ans)
				continue;
			if(insert(s))//不能立即结束，仍要读取n个串 
				ans=true;
		}
		if(ans)
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//有前缀输出NO 
		else
			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1251">hdu1251</a><br>
Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1f376a1261-30.png" alt="30.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=500005;
const int maxz=26;//不同字符个数，例如数字10，小写字母26
int trie[maxn][maxz];
int cnt[maxn];//计数器 
void insert(string s)//将字符串s插入到字典树中 
{
	int len=s.length(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=s[i]-'a';//转换成数字
		if(!trie[p][ch]) 
			trie[p][ch]=++tot;//记录下标 
		p=trie[p][ch];
		cnt[p]++;//统计有多少个单词经过 
	}
}

int query(string s)
{
	int len=s.length(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=s[i]-'a';//转换成数字
		p=trie[p][ch];
		if(!p)
			return 0;
	}
	return cnt[p];	
}

int main()
{	
	string s;
	memset(trie,0,sizeof(trie));
	memset(cnt,0,sizeof(cnt));
	tot=1;
	while(getline(cin,s))
	{
		if(!s.size())
			break;
		insert(s);
	}
	while(cin&gt;&gt;s)
		cout&lt;&lt;query(s)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>若反过来问，单词表中有多少单词是当前查询单词的前缀，只需统计查询时经过的end标记数量即可。</p>
<p><a href="https://vjudge.net/problem/POJ-2513">poj2513</a><br>
给你一堆木棍。 每个棍子的每个端点都带有某种颜色。是否可以将操纵杆沿一条直线对齐，以使触摸的端点的颜色具有相同的颜色？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_dcdfe70261-31.png" alt="31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_e6f7e0d261-32.png" alt="32.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=500010,M=26;
int trie[N][M];
int cnt[N];
int d[N];
int idx=1;
int color;
int p[N];

int find(int x)
{
	if(x != p[x])
		p[x]=find(p[x]);
	return p[x];
}

int insert(char *s)
{
	int len=strlen(s),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int k=s[i]-'a';
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	if(cnt[p])
		return cnt[p];
	else 
	{
	    cnt[p]=++color;
	    return cnt[p];
	}
}

int main()
{
	for(int i=1;i&lt;N;i++)
		p[i]=i;
	char a[15],b[15];
	while(~scanf(&quot;%s%s&quot;,a,b))
	{
		int i=insert(a);
		int j=insert(b);
		d[i]++;
		d[j]++;
		//cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;
		int pi=find(i);
		int pj=find(j);
		p[pi]=pj;
	}
	
	int s=find(1);
	int num=0;
	for(int i=1;i&lt;=color;i++)
	{
		if(d[i] % 2 == 1)
			num++;
		if(num &gt; 2 || find(i) != s)
 		{
 			puts(&quot;Impossible&quot;);
			return 0;
		}
 	}
	if(num == 0 || num == 2)
		puts(&quot;Possible&quot;);
	else 
		puts(&quot;Impossible&quot;);
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3764">poj3764</a><br>
给出n个节点的树，每条边有边权w。 • 请你找一条路径，使得这条路径上所有边权的异或和最大。<br>
• 数据范围<br>
• n &lt;= 100,000, 0 &lt; w &lt; 2^31</p>
<p>暴力的做法：<br>
• 枚举每个点当根<br>
• dfs整颗树，获得根到每个节点的路径异或和s[]<br>
• 时间复杂度O(n^2)</p>
<p>异或的性质<br>
x xor x = 0<br>
• 一个数异或两次会抵消掉。<br>
• x到y的路径异或和就等于s[x] xor s[y] !<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_9a3f466e61-33.png" alt="33.png" loading="lazy"><br>
这样只要任取一个点为根，dfs得到s[]数组后，枚举x， y即可，还是O(n^2)</p>
<p>现在的问题是，给定一个s[]数组，找两个元素，使得他<br>
们的异或和最大。<br>
• 给一个数x，在数组s中找一个数y使其和x的异或和最大。<br>
• 涉及二进制的题，我们可以选择按位来考虑。</p>
<p>假设x的二进制有31位，我们把它的二进制写出来，最高位称为第30位，最低位称为第0位。<br>
因为要让异或值最大，所以我们从高位开始考虑。<br>
• 如果x的第30位是1 —— if (x &gt;&gt; 30 &amp; 1)<br>
• 那我们一定希望y的第30位是0，这样异或之后的第30位 是1.<br>
• 否则就算第29～0位异或后都是1，也比2^30小。<br>
• 同理，如果x的第30位是0，我们希望y的第30位是1.</p>
<p>运用贪心的思想，假设现在枚举到x的第i位<br>
• if x第i位是1 我们要尽可能找第i位为0的y<br>
• if x第i位是0 我们要尽可能找第i位为1的y<br>
涉及前缀判断，采用trie</p>
<p>先把所有的数的二进制当作字符串，存进trie中。<br>
• 从高往低枚举二进制位时，设置一个指针p，一开始指向trie的根节点。<br>
• if x第i位是1 我们要尽可能找第i位为0的y 如果说明存在第i位为0的数，我们就让p往0节点走，答案中的第i位为1。<br>
• 如果不存在第i位为0的数，我们只能退而求其次，让p往1节点走，答案中的第i位为0.<br>
• if x第i位是0 我们要尽可能找第i位为1的y ， 同理</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010*31,M=N&lt;&lt;1;
int trie[N][2],tot=1;
int d[N];
int n;
int h[N],e[M],ne[M],w[M],idx;

void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j == fa)
			continue;
		d[j]=d[u]^w[i];
		dfs(j,u);
	}
}

void insert(int x)
{
	int p=1;
	for(int i=30;i&gt;=0;i--)
	{
		int u=x&gt;&gt;i&amp;1;
		if(!trie[p][u])
			trie[p][u]=++tot;
		p=trie[p][u];
	}
}

int query(int x)
{
	int p=1;
	int res=0;
	for(int i=30;i&gt;=0;i--)
	{
		int k=x&gt;&gt;i&amp;1;
		if(trie[p][!k])
		{
			res+=1&lt;&lt;i;
			p=trie[p][!k];
		}	
		else 
			p=trie[p][k];
	}
	return res;
}

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		memset(h,-1,sizeof h);
		memset(d,0,sizeof d);
		memset(trie,0,sizeof trie);
		idx=0;
		tot=1;
		for(int i=0;i&lt;n-1;i++)
		{
			int a,b,c;
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
			a++,b++;
			add(a,b,c);add(b,a,c);
		}
		dfs(1,-1);
		int res=0;
//		for(int i=1;i&lt;=n;i++)
//			cout&lt;&lt;d[i]&lt;&lt;' ';
		
		for(int i=1;i&lt;=n;i++)
		{
			insert(d[i]);
			res=max(res,query(d[i]));
		}
		printf(&quot;%d\n&quot;,res);
	}
	return 0;
}
</code></pre>
<h4 id="ac自动机">AC自动机</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_62b82fa863-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_661c7b4063-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_72245a5d63-4.png" alt="4.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_865c0f8863-5.png" alt="5.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_8d6beb0e63-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_9969b29c63-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_a53131a463-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_cbf0cdb863-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_cec6648a63-10.png" alt="10.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d9867a9063-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_af41834663-13.png" alt="13.png" loading="lazy"><br>
每个结点的26个指针都有指向<br>
匹配时判断后缀是不是单词，若为单词则也需要统计上<br>
<a href="https://www.acwing.com/problem/content/description/1284/">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=5e5+10,M=1e6+10;
int trie[N][26],cnt[N],idx;
char s[M];
int q[N],ne[N];
int n;

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-'a';
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;26;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;26;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	int res=0;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-'a';
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			res+=cnt[p];
			cnt[p]=0;
			p=ne[p];
		}
	}
	return res;
}

void print()
{
	for(int i=0;i&lt;idx;i++)
	{
		cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ne[i]&lt;&lt;&quot;: &quot;;
		for(int j=0;j&lt;26;j++)
			if(trie[i][j])
			    cout&lt;&lt;char(j+'a')&lt;&lt;' '&lt;&lt;trie[i][j]&lt;&lt;&quot;  &quot;;
		cout&lt;&lt;endl;
	}
	cout&lt;&lt;endl;
}

int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		memset(ne,0,sizeof ne);
		idx=0;
		scanf(&quot;%d&quot;,&amp;n);
		
		for(int i=0;i&lt;n;i++)
		{
			char str[55];
			scanf(&quot;%s&quot;,str);
			insert(str);
		}
		
		build();
		//print();
		scanf(&quot;%s&quot;,s);
		printf(&quot;%d\n&quot;,query(s));
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2896">hdu2896</a><br>
小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_a190a2ac63-14.png" alt="14.png" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1e5+10,M=10010;
int trie[N][128],idx;
char s[M];
int q[N],ne[N];
int n,m;
int ans[N],cnt;
int id[N];
int tot;

void insert(char *s,int i)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-32;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	id[p]=i;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;128;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;128;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	bool flag = false;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-32;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			if(id[p])
			{
				flag=true;
				ans[cnt++]=id[p];
				//cout&lt;&lt;&quot;---&quot;&lt;&lt;id[p]&lt;&lt;endl;
			}
			p=ne[p];
		}
	}
	return flag;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		char str[210];
		scanf(&quot;%s&quot;,str);
		insert(str,i);
	}
	
	build();

	scanf(&quot;%d&quot;,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s&quot;,s);
		cnt=0;
		if(query(s))
		{
			tot++;
			printf(&quot;web %d:&quot;,i);
			cnt=unique(ans,ans+cnt)-ans;
			sort(ans,ans+cnt);
			for(int i=0;i&lt;cnt;i++)
				printf(&quot; %d&quot;,ans[i]);
			puts(&quot;&quot;);
		}
	}
	
	printf(&quot;total: %d\n&quot;,tot);
	return 0;
}
</code></pre>
<p>1.本题不是计数，不需判重复，只需标记病毒编号为true，多次标记不影响最终答案<br>
2.多个主串，字典树下一次还要再查询，不能改变字典树<br>
附：ASCII表<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_8f7d399863-ASCII%E8%A1%A8.jpg" alt="ASCII表.jpg" loading="lazy"></p>
<p><a href="https://vjudge.net/problem/POJ-2778">poj2778</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_ce862d4c63-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d228a30863-16.png" alt="16.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d4f32f6863-17.png" alt="17.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_ec73a48863-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_eea68e4663-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_fd08f70863-20.png" alt="20.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=110,mod=100000;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n,m;
int q[N];
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
	matrix(int c[][N])
	{
		memcpy(m,c,sizeof m);
	}
};

int get(char c)
{
	switch(c)
	{
		case 'A' : return 0;
		case 'G' : return 1;
		case 'C' : return 2;
		case 'T' : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;	
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&lt;=idx;i++)
		for(int j=0;j&lt;=idx;j++)
			for(int k=0;k&lt;=idx;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&lt;=idx;i++)
		res.m[i][i]=1;
	while(k)
	{
		if(k &amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&gt;&gt;=1;
	}
	return res;
}

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;n;i++)
	{
		char str[15];
		scanf(&quot;%s&quot;,str);
		insert(str);
	}
	
	build();
	
	matrix g;
	for(int i=0;i&lt;=idx;i++)
	{
		if(cnt[i]) continue;
		for(int j=0;j&lt;4;j++)
		{
			int p=trie[i][j];
			if(!cnt[p])
				g.m[i][p]=(g.m[i][p]+1)%mod;
		}
	}
	
//	for(int i=0;i&lt;=idx;i++)
//	{
//		for(int j=0;j&lt;=idx;j++)
//			cout&lt;&lt;g.m[i][j]&lt;&lt;' ';
//		cout&lt;&lt;endl;
//	}
	
	g=qmi(g,m);
	int res=0;
	for(int i=0;i&lt;=idx;i++)
		res=(res+g.m[0][i])%mod;
	
	printf(&quot;%d&quot;,res);
	
	return 0;
}
</code></pre>
<p>最后的答案为什么是g.m[0][i]求和?<br>
矩阵g的n次幂表示构造长度为n的DNA序列的方案数（g的i次幂表示构造长度为n的DNA序列的方案数），类似离散数学中二元关系的复合运算，二元关系&lt;1,2&gt; ,&lt;2,3&gt; 复合一次可得到关系&lt;1,3&gt;</p>
<p>由于从根结点出发构造序列，且根结点idx为0.g.m[0][i]表示从根结点走i步的方案数，即从根节点开始构造长度为i的序列的方案数。</p>
<p><a href="https://www.acwing.com/problem/content/1055/">poj3691</a><br>
AC自动机+DP<br>
为每个结点构造失败指针的同时，检查其失败指针所指向的节点是否为危险节点，如果是的话也需要把当前节点标记为危险节点。<br>
所谓的危险节点，就是指以当前节点为结尾的字符串是某个病毒串，或者包含了某个病毒串。如果在bfs的同时进行这项操作的时候就非常方便，在构造完当前失败指针的同时检查其所指向的节点是否为危险节点。</p>
<p>根据危险DNA序列所建的字典树，我们用模拟的方式 ，从第一个字符开始构造， 依次递增，找到一个满足要求的字符串，在构造此字符串的同时，比较该字符串和输入要判断的序列S，若该位置i的字符和s[i]，相同，则表示，此位置的字符不需要改变，反则，需要把s[i]该为词字符，为一次改变操作.</p>
<p>状态表示：dp[i][j]，表示到达查找串第i个字符时，对应于AC自动机的j节点所需要的最小改变数。<br>
状态转移为dp[i][son[j]] = min( dp[i][son[j]], dp[i-1][j] + s[i-1]!=k )</p>
<p>读到i个字符时，对应于j状态（DP的过程要两重循环i和j），要转移到son[j]（j的子节点状态，在这里用k在[0,3]一重循环遍历所有可以转字符），如果第i个字符跟所要转移到的字符相同，则代价为0，因为不需要改变；否则代价为1，因为需要改变。</p>
<p>如果当前状态不可达，则不需要对其进行后续运算。</p>
<p>如果子节点为危险节点，则不可以进行转移，即不可以使用上面的状态方程。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n;
char s[N];
int f[N][N];
int q[N];

int get(char c)
{
	switch(c)
	{
		case 'A' : return 0;
		case 'G' : return 1;
		case 'C' : return 2;
		case 'T' : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

void print()
{
    for(int i=0;i&lt;=idx;i++)
    {
        cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ne[i]&lt;&lt;&quot;: &quot;;
        for(int j=0;j&lt;4;j++)
            if(trie[i][j])
                cout&lt;&lt;trie[i][j]&lt;&lt;' ';
        cout&lt;&lt;endl;
    }
}

int main()
{
	int kas=1;
	while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)
	{
		memset(trie,0,sizeof trie);
		memset(ne,0,sizeof ne);
		memset(cnt,0,sizeof cnt);
		idx=0;
		for(int i=0;i&lt;n;i++)
		{
			char str[25];
			scanf(&quot;%s&quot;,str);
			insert(str);
		}
		
		build();
		
		//print();
		
		scanf(&quot;%s&quot;,s+1);
		int len=strlen(s+1);
		
		memset(f,0x3f,sizeof f);
		f[0][0]=0;
		for(int i=1;i&lt;=len;i++)
			for(int j=0;j&lt;=idx;j++)
				for(int k=0;k&lt;4;k++)
				{
					int t=get(s[i]) != k;
					int p=trie[j][k];
					if(!cnt[p])
						f[i][p]=min(f[i][p],f[i-1][j]+ t);
				}
				
		int res=INF;
		for(int i=0;i&lt;=idx;i++)
			res=min(res,f[len][i]);
		
		if(res == INF)
			res=-1;
		printf(&quot;Case %d: %d\n&quot;,kas++,res);
	}
	return 0;
}
</code></pre>
<p>最后，循环dp[len][j]，即在读完最后一个字符后检查所有状态的最终值，取其最小。如果均不可达，则返回-1。<br>
类似题：求主串至少包含一个模式串的方案数，正难则反。<br>
<a href="https://paste.ubuntu.com/p/8cQmVfDpxH/">代码</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2243">hdu2233</a><br>
长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？<br>
比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为<br>
(2个) aa,ab,<br>
(26个)aaa,aab,aac...aaz,<br>
(26个)aba,abb,abc...abz,<br>
(25个)baa,caa,daa...zaa,<br>
(25个)bab,cab,dab...zab。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_e378c0a064-21.png" alt="21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_f3a3c3da64-22.png" alt="22.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_025f2e9e64-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_05abfa1e64-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_be3731ec64-25.png" alt="25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_c20f74aa64-26.png" alt="26.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_d039051e64-27.png" alt="27.png" loading="lazy"><br>
<a href="https://paste.ubuntu.com/p/vVvdmfW8dV/">代码</a><br>
若要求长度正好为L，原矩阵的L次幂即可<br>
长度不超过L，需要累加</p>
<p><a href="https://www.acwing.com/problem/content/1287/">acwing1285</a><br>
每次插入一个单词时把所有路径上的点都+1，每个单词的出现次数就是其结尾节点的fail树子树和。因为其fail指针指向的节点一定包含当前字符串。<br>
统计贡献时要从下往上按照拓扑排序加，<br>
<a href="https://paste.ubuntu.com/p/sxwbtsytTg/">代码</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3695">hdu3695</a><br>
给出 n 个模式串，给出一个长串 S，找出 S 中出现了几种模式串。注意模式串在 S 中正着出现和反着出现都算出<br>
现。S 可能有些段是压缩过的，格式为[tx]，t 是一个数字，x 是一个字母，代表有 t 个 x。把 a[3b]c 解压后会得到<br>
abbbc。<br>
n≤250，模式串的长度不超过1000，t≤5·1e6, 解压后的长串的长度不超过 5100000.</p>
<blockquote></blockquote>
<p>样例输入：<br>
3<br>
2<br>
AB DCB<br>
DACB<br>
3<br>
ABC CDE GHI<br>
ABCCDEFIHG<br>
4<br>
ABB ACDEE BBB FEEE<br>
A[2B]CD[4E]F<br>
样例输出：<br>
0<br>
3<br>
2</p>
<p>我们可以把这 n 个串插入 Trie 树，建成 AC 自动机。然后把解压后的 S 正着在 AC 自动机上跑一遍，再反着在<br>
AC 自动机上跑一遍，对于覆盖过的模式串，打一个标记。最后统计标记的总数即可</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=250010,M=5100010;
int trie[N][26],idx;
char s[M],tmp[M];
int ne[N];
int dar[N];
int n;
int q[N];

void insert(char *s,int k)
{
    int p=0;
    for(int i=0;s[i];i++)
    {
        int k=s[i]-'A';
        if(!trie[p][k])
        {
        	trie[p][k]=++idx;
        	memset(trie[idx],0,sizeof trie[idx]);
        	dar[idx]=0;
		}
        p=trie[p][k];
    }
   	dar[p]++;
}

void build()
{
    int hh=0,tt=-1;
    for(int i=0;i&lt;26;i++)
        if(trie[0][i])
        {
        	int t=trie[0][i];
        	q[++tt]=t;
        	ne[t]=0;
		}
    
    while(hh &lt;= tt)
    {
        int t=q[hh++];
        for(int i=0;i&lt;26;i++)
        {
            int p=trie[t][i];
            if(!p) trie[t][i]=trie[ne[t]][i];
            else 
            {
                ne[p]=trie[ne[t]][i];
                q[++tt]=p;
            }
        }
    }
}

int query(char *s,int type)
{
    int len=strlen(s);
    if(type)
        reverse(s,s+len);
    //cout&lt;&lt;&quot;---&quot;&lt;&lt;s&lt;&lt;endl;
    int res=0;
    for(int i=0,j=0;s[i];i++)
    {
        int k=s[i]-'A';
        j=trie[j][k];
        int p=j;
        while(p)
        {
        	if(dar[p])
        	{
        		res+=dar[p];
        		dar[p]=0;
			}
			else 
				break;
            p=ne[p];
        }
    }
    return res;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
    	memset(trie[0],0,sizeof trie[0]);
    	ne[0]=0;
    	dar[0]=0;
        idx=0;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
        {
            char str[1010];
            scanf(&quot;%s&quot;,str);
            insert(str,i);
        }
        
        build();
        
        scanf(&quot;%s&quot;,s);
        int l=0;
        for(int i=0;s[i];i++)
        {
            if(s[i] !='[')
                tmp[l++]=s[i];
            else
            {
                i++;
                int len=0;
                while(s[i] &gt;='0' &amp;&amp; s[i] &lt;='9')
                {
                    len=len*10+s[i]-'0';
                    i++;
                }
                for(int k=0;k&lt;len;k++)
                    tmp[l++]=s[i];
                i++;
            }
        }
        tmp[l]=0;
        
        printf(&quot;%d\n&quot;,query(tmp,0)+query(tmp,1));
    }
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4763">hdu4763</a><br>
给你一个字符串 S。<br>
请你把这个 S 划分成 EAEBE 的形式。<br>
其中 A 和 B 可以包含任意个（可以是0个）字符。<br>
求 E 的最大长度。字符串的长度之和不会超过1e6</p>
<blockquote></blockquote>
<p>Sample Input<br>
5<br>
xy<br>
abc<br>
aaa<br>
aaaaba<br>
aaxoaaaaa</p>
<blockquote></blockquote>
<p>Sample Output<br>
0<br>
0<br>
1<br>
1<br>
2</p>
<p>观察 EAEBE。<br>
首先要保证 E 既是 S 的前缀又是 S 的后缀。<br>
且去除掉前缀 E 和后缀 E 之后，中间剩下的还要出现一次 E。 对 S 跑一次扩展 KMP 中的 Z 算法。<br>
如果 i+Z[i]-1 == n ，就说明 S[i..n] 可以作为 E。<br>
那么就要求在 S[Z[i]+1..i-Z[i]] 中，还得存在一个 j 满足 Z[j] ≥ Z[i]</p>
<p>问题变成了先找 i+Z[i]-1 = n 的 符合条件的i<br>
然后在[Z[i]+1..i-Z[i]] 中，查询 Z 的最大值，如果比Z[i] 大，那么就可以把 Z[i] 作为答案。最后取最大值即可。<br>
查询区间最大值我们可以用线段树 / ST 表来维护。<br>
最后的时间复杂度都是 O(n log n)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单调队列优化dp]]></title>
        <id>https://caifxh.github.io/post/dan-diao-dui-lie-you-hua-dp/</id>
        <link href="https://caifxh.github.io/post/dan-diao-dui-lie-you-hua-dp/">
        </link>
        <updated>2020-03-27T08:58:09.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/1090/">acwing1088</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_76add7ca6f-34.PNG" alt="34.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_8d36e0fe6f-35.PNG" alt="35.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_8fa6f3ba6f-36.PNG" alt="36.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=2e6+10;
typedef long long LL;
int p[N],d[N];
LL s[N];
int q[N];
bool ans[N];
int n;

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;p[i],&amp;d[i]);
        p[i+n]=p[i];
        d[i+n]=d[i];
    }

    for(int i=1;i&lt;=n*2;i++) s[i]=s[i-1]+p[i]-d[i];

    int hh=0,tt=-1;
    for(int i=1;i&lt;=n*2;i++)//顺时针求长度为n的窗口内前缀和的最小值
    {
        if(hh &lt;= tt &amp;&amp; i - q[hh] &gt;= n) hh++;

        while(hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i])
            tt--;
        q[++tt]=i;
        if(i &gt;= n &amp;&amp; s[q[hh]] &gt;= s[i-n])
            ans[i-n+1]=true;
    }

    d[0]=d[n];
    for(int i=n*2;i&gt;=1;i--) s[i]=s[i+1]+p[i]-d[i-1];

    hh=0,tt=-1;
    for(int i=n*2;i&gt;=1;i--)//逆时针求长度为n的窗口内后缀和的最小值
    {
        if(hh &lt;= tt &amp;&amp; q[hh]-i &gt;= n) hh++;

        while(hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i])
            tt--;
        q[++tt]=i;
        if(i&lt;=n+1 &amp;&amp; s[q[hh]] &gt;= s[i+n])
            ans[i-1]=true;
    }

    for(int i=1;i&lt;=n;i++)
        if(ans[i]) puts(&quot;TAK&quot;);
        else puts(&quot;NIE&quot;);
    return 0;   
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1091/">acwing1089</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_85f4d2e66f-37.PNG" alt="37.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 2e5 + 10, INF = 0x3f3f3f3f;
int n, m;
int w[N], q[N];
int f[N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);

    int hh = 0, tt = 0;
    q[0]=0;
    for (int i = 1; i &lt;= n; i ++ )
    {
        if (i - q[hh] &gt; m) hh ++ ;
        f[i] = f[q[hh]] + w[i];
        while (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt -- ;
        q[ ++ tt] = i;
    }

    int res = INF;
    for (int i = n - m + 1; i &lt;= n; i ++ ) res = min(res, f[i]);
    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1092/">acwing1090</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_54a8eb906f-38.PNG" alt="38.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=50010,INF=0x3f3f3f3f;
int n,t;
int a[N];
int f[N];
int q[N];

bool check(int mid)
{
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
        if(hh &lt;= tt &amp;&amp; i - q[hh] &gt; mid+1) hh++;
        f[i]=f[q[hh]]+a[i];
        while(hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i])
            tt--;
        q[++tt]=i;
    }
    
    int res=INF;
    for(int i=n-mid;i&lt;=n;i++)
        res=min(res,f[i]);
    
    return res&lt;=t;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;t;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;a[i];

    int l=0,r=n;
    while(l &lt; r)
    {
        int mid=l+r&gt;&gt;1;
        if(check(mid))
            r=mid;
        else
            l=mid+1;
    }
    
    cout&lt;&lt;l&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1089/">acwing1087</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_0b8755dc6f-39.PNG" alt="39.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010;
LL f[N][2];
int n,k;
int e[N];
LL s[N];
int q[N];

int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;e[i];
        
    for(int i=1;i&lt;=n;i++)
    	s[i]=s[i-1]+e[i];
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
    	f[i][0]=max(f[i-1][0],f[i-1][1]);
    	if(hh &lt;= tt &amp;&amp; i-q[hh] &gt; k) hh++;
    	
    	f[i][1]=f[q[hh]][0]-s[q[hh]]+s[i];
    	while(hh &lt;= tt &amp;&amp; f[i][0]-s[i] &gt;= f[q[tt]][0] -s[q[tt]])
    		tt--;
    	q[++tt]=i;
	}
	
	cout&lt;&lt;max(f[n][0],f[n][1])&lt;&lt;endl;
	return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/27/9969_3893cee86f-40.PNG" alt="40.PNG" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010,INF=0x3f3f3f3f;
LL f[N];
int n,k;
int e[N];
LL s[N];
int q[N];

int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;e[i];
        
    for(int i=1;i&lt;=n;i++)
    	s[i]=s[i-1]+e[i];
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
    	if(hh &lt;= tt &amp;&amp; i-q[hh] &gt; k) hh++;
    	
    	f[i]=f[q[hh]-1]-s[q[hh]]+s[i];
    	while(hh &lt;= tt &amp;&amp; f[i-1]-s[i] &gt;= f[q[tt]-1] -s[q[tt]])
    		tt--;
    	q[++tt]=i;
	}
	
	LL res=-1e18;
	for(int i=n-k;i&lt;=n;i++)
	    res=max(res,f[i]);
	cout&lt;&lt;res&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1093/">acwing1091</a><br>
先用滑动窗口+单调队列求出每一行长度为k的连续序列中的最大值、最小值，<br>
存到rmin[i][j],rmax[i][j]两个数组里，<br>
再用相同的方法求这两个数组中每一列长度为k的连续序列的最大值、最小值存到cmin[i],cmax[i]中。<br>
遍历cmin,cmax得出答案。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int n,m,k;
int a[N][N];
int rmax[N][N],rmin[N][N];
int cmax[N],cmin[N];
int tmp[N];
int q[N];

void get(int a[],int b[],int len,int type)//0:最小值，1：最大值 
{
    int hh=0,tt=-1;
    for(int i=1;i&lt;=len;i++)
    {
        if(hh &lt;= tt &amp;&amp; i-q[hh] &gt;=k) hh++;
        while(hh &lt;= tt &amp;&amp;(type?a[q[tt]]&lt;=a[i]:a[q[tt]]&gt;=a[i]))
            tt--;
        q[++tt]=i;
        b[i]=a[q[hh]];
    }
}

int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf(&quot;%d&quot;,&amp;a[i][j]);

    for(int i=1;i&lt;=n;i++)
    {
        get(a[i],rmin[i],m,0);
        get(a[i],rmax[i],m,1);
    }

    int ans=INF;
    for(int i=k;i&lt;=m;i++)
    {
        for(int j=1;j&lt;=n;j++) tmp[j]=rmin[j][i];
        get(tmp,cmin,n,0);

        for(int j=1;j&lt;=n;j++) tmp[j]=rmax[j][i];
        get(tmp,cmax,n,1);

        for(int j=k;j&lt;=n;j++)
            ans=min(ans,cmax[j]-cmin[j]);
    }

    printf(&quot;%d\n&quot;,ans);

    return 0;   
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树状数组]]></title>
        <id>https://caifxh.github.io/post/shu-zhuang-shu-zu/</id>
        <link href="https://caifxh.github.io/post/shu-zhuang-shu-zu/">
        </link>
        <updated>2020-03-27T08:07:13.000Z</updated>
        <content type="html"><![CDATA[<h4 id="树状数组">树状数组</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_ea7daa625c-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_0f4727c45c-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_112b51965c-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_12d4d95e5c-4.png" alt="4.png" loading="lazy"><br>
sum[9]=c[9]+c[8];<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_14c27b045c-6.png" alt="6.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_3a25eb745c-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_43ddb14c5c-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_4f04036e5c-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_515eba325c-10.png" alt="10.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_9040bed05c-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_92bda3c65c-12.png" alt="12.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_94af6ee45c-13.png" alt="13.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_96e8e8165c-14.png" alt="14.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_b5133a945c-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_b7c387305c-16.png" alt="16.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_cbe5e53c5c-17.png" alt="17.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=10000;
int n,a[maxn],c[maxn],s[maxn];

int lowbit(int i)//c[i]的区间长度 
{
	return (-i)&amp;i;
}

void add(int i,int z)//a[i]加上z
{
	for(;i&lt;=n;i+=lowbit(i))//直接后继，即父亲i+=lowbit(i)
		c[i]+=z;	
} 

int sum(int i)//求前缀和a[1]..a[i] 
{
	int s=0;
	for(;i&gt;0;i-=lowbit(i))//直接前驱 i-=lowbit(i);
		s+=c[i];
	return s; 
}

int sum(int i,int j)//求区间和a[i]..a[j] 
{
	return sum(j)-sum(i-1); 
}

int main()
{
	memset(c,0,sizeof(c));
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;a[i];
		add(i,a[i]);//加入树状数组 
	} 
	int x1,x2;
	cin&gt;&gt;x1;
	cout&lt;&lt;sum(x1)&lt;&lt;endl;
	cin&gt;&gt;x1&gt;&gt;x2;
	cout&lt;&lt;sum(x1,x2)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_dbe5964e5c-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_fc9f24365c-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_ff208a885c-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_02536ad65c-21.png" alt="21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_050a62ac5c-22.png" alt="22.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=10000;
int n,a[maxn][maxn],c[maxn][maxn];//二维树状数组 

int lowbit(int i)//区间长度 
{
	return (-i)&amp;i;
}

void add(int x,int y,int z)//a[x][y]加上z
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		for(int j=y;j&lt;=n;j+=lowbit(j))
			c[i][j]+=z;
} 

int sum(int x,int y)//求左上角(1,1)到右下角(x,y)矩阵区间和 
{
	int s=0;
	for(int i=x;i&gt;0;i-=lowbit(i))
		for(int j=y;j&gt;0;j-=lowbit(j))
			s+=c[i][j];
	return s; 
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1); 
}

int main()
{
	for(int i=1;i&lt;=n;i++)
		memset(c[i],0,sizeof(c[i]));
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			cin&gt;&gt;a[i][j];
			add(i,j,a[i][j]);//加入树状数组 
		} 
	int x1,y1,x2,y2;
	cin&gt;&gt;x1&gt;&gt;y1;
	cout&lt;&lt;sum(x1,y1)&lt;&lt;endl;
	cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
	cout&lt;&lt;sum(x1,y1,x2,y2)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2352">poj2352</a><br>
统计x前面比它小的星星的个数。注意的是：给的点的坐标是从0开始的，树状数组下标为0的位置不可用，所以我们需要在输入x坐标时+1。</p>
<p>因为本题给出的数据就是已经按照y从小到大排好序的,也就是说，当前读到一个点的时候，当前点的y坐标肯定比已经读入的大，或者等于。就算是等于的话，也是x坐标比我当前点的x坐标小，所以我们每次只要算x坐标比我们小的就行了 。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_42b726085c-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_fef8cc6a5c-24.png" alt="24.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
#define maxn 32010
int ans[maxn],tr[maxn];//等级统计，每个值的数量 
int n;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x,int c)//将第i个元素增加val，其后继也要增加
{
	for(int i=x;i&lt;=maxn;i+=lowbit(i))//是x点的范围，注意不是星星的个数n 
		tr[i]+=c;//i的后继（父结点） 
}

int sum(int x)//前缀和 
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];//i的前驱
	return res;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int x,y;
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        x++;
        ans[sum(x)]++;
        add(x,1);//x的数量c[x]增1,若是统计小于等于x的数量，则先执行add操作再查询 
    }
    for(int i=0;i&lt;n;i++)
        printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
</code></pre>
<h4 id="树状数组求逆序对">树状数组求逆序对</h4>
<p>1）逆序数问题定义<br>
给一个1~n的排列，求满足i&lt;j且a[i]&gt;a[j]的二元组对数，比如[4,2,1,5,3]这个序列，满足条件的二元组为{&lt;4,2&gt;, &lt;4,1&gt;, &lt;4,3&gt;, &lt;2,1&gt;, &lt;5,3&gt;}，故逆序数是5</p>
<p>2）树状数组求逆序数的原理<br>
首先明确树状数组在此问题中维护信息是某个区间中数字出现的个数，sum(a[i])可求得[1, a[i]]的区间和，这恰好代表第i个数字前小于它的个数，，那么大于它的显然就有sum(n)-sum(a[i])个,然后将源数据按其原本顺序插入树状数组，第i个数字插入的方式为将树状数组的第a[i]位设为1，同时更新覆盖到它的父区间。</p>
<pre><code>for (int i = 1; i &lt;= n; i++) 
{
    ans += sum(n) - sum(a[i]);
    add(a[i], 1);
}
</code></pre>
<p>累加每步的结果后可得逆序数为5，用树状数组的好处在于add操作和sum的操作时间复杂度都为O(logn)，非常的巧妙</p>
<p><a href="https://vjudge.net/problem/POJ-3067">poj3067</a><br>
由于x是从小到大排序的，假设当前我们在处理第k条边，那么第1~k-1条边的x必然是小于（等于时候暂且不讨论）第k条边的 x 的，那么前k-1条边中，与第k条边相交的边的y值必然大于yk的，所以此时我们只需要求出在前k-1条边中有多少条边的y值在区间[yk, M]即可,也就是求yk的逆序数，M为西岸城市个数，即y的最大值。</p>
<p>所以就将问题转化成区间求和的问题，树状数组解决。当两条边的x相同时，我们记这两条边的y值分别为ya，yb（ya&lt;yb),我们先处理（x，ya），再处理（x，yb），原因很明显，因为当x相同时，这两条边是认为没有交点的，若先处理（x，yb），那么下次处理（x，ya）时，（x，ya）就会给（x，yb）增加一个逆序，也就是将这两条边做相交处理了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1010,M=1000010;
int tr[N];
int n,m,k;
struct Edge 
{
    int x, y;
    bool operator&lt; (const Edge &amp;W) const 
    {
    	if(x == W.x)
    		return y&lt;W.y;
    	else
    		return x&lt;W.x;
	}
}e[M];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x)//加1操作，参数省略
{
	for(int i=x;i&lt;=m;i+=lowbit(i))//y点有m个
		tr[i]++;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))
    	res+=tr[i];
    return res;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    for(int kase=1;kase&lt;=T;kase++)
	{
		memset(tr,0,sizeof tr);
	    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	    for(int i=1;i&lt;=k;i++)
			scanf(&quot;%d%d&quot;,&amp;e[i].x,&amp;e[i].y);
	    sort(e+1,e+k+1);
	    LL ans=0;
	    for(int i=1;i&lt;=k;i++)
		{
			ans+=sum(m)-sum(e[i].y);
			add(e[i].y);
	    }
	    printf(&quot;Test case %d: %lld\n&quot;,kase,ans);
	}
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/243/">acwing241</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_933d74f25c-25.PNG" alt="25.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N = 200010;
int n;
int a[N];
int tr[N];
int bigger[N], lower[N];

int lowbit(int x)
{
    return x &amp; -x;
}

void add(int x, int c)
{
    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++ )//从左向右扫
    {
        bigger[i] = sum(n) - sum(a[i]);//1~i-1有多少数大于y（y+1~n）
        lower[i] = sum(a[i]);//1~i-1有多少数小于y（1~y-1）
        add(a[i], 1);
    }

    memset(tr, 0, sizeof tr);
    LL res1 = 0, res2 = 0;
    for (int i = n; i; i -- )//从右向左扫
    {
        res1 += bigger[i] * (LL)(sum(n) - sum(a[i]));//i+1~n有多少数大于y
        res2 += lower[i] * (LL)(sum(a[i]));//i+1~n有多少数小于y
        add(a[i], 1);
    }

    printf(&quot;%lld %lld\n&quot;, res1, res2);

    return 0;
}
</code></pre>
<h4 id="拓展应用">拓展应用</h4>
<h4 id="1树状数组基本应用-单点修改-区间查询">1.树状数组基本应用. 单点修改 + 区间查询</h4>
<h4 id="2区间修改-单点查询">2.区间修改 + 单点查询</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_bad517fb5c-26.PNG" alt="26.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/248/">acwing242</a></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int a[N];
int n,m;
int tr[N];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x,int c)
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		tr[i]+=c;
}

int sum(int x)
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];
	return res;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		add(i,a[i]-a[i-1]);
	}
	
	while(m--)
	{
		char op[2];
		scanf(&quot;%s&quot;,op);
		if(*op == 'C')
		{
		    int l,r,d;
			scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;d);
			add(l,d);
			add(r+1,-d);
		}
		else
		{
		    int x;
		    scanf(&quot;%d&quot;,&amp;x);
			printf(&quot;%d\n&quot;,sum(x));
		}
	}
	return 0;
 } 
</code></pre>
<h4 id="3区间修改-区间查询">3.区间修改 + 区间查询</h4>
<p><a href="https://www.acwing.com/problem/content/244/">acwing243</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_297f0dc65c-27.PNG" alt="27.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_dbf7552a5c-28.PNG" alt="28.PNG" loading="lazy"></p>
<pre><code>//区间加
//区间和
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
const int N=100010;
int n,m;
int a[N];
LL tr1[N];//维护b[i]的前缀和
LL tr2[N];//维护b[i]*i的前缀和

int lowbit(int x)
{
    return x&amp;-x;
}

void add(LL tr[],int x,LL c)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

LL sum(LL tr[],int x)
{
    LL res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=tr[i];
    return res;
}

LL prefix_sum(int x)
{
    return sum(tr1,x)*(x+1)-sum(tr2,x);
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    for(int i=1;i&lt;=n;i++)
    {
        int b=a[i]-a[i-1];//最大为1e9
        add(tr1,i,b);
        add(tr2,i,(LL)i*b);
    }
    
    while(m--)
    {
        char op[2];
        int l,r,d;
        scanf(&quot;%s%d%d&quot;,op,&amp;l,&amp;r);
        if(*op == 'Q')
            printf(&quot;%lld\n&quot;,prefix_sum(r)-prefix_sum(l-1));
        else
        {
            scanf(&quot;%d&quot;,&amp;d);
            add(tr1,l,d);
            add(tr1,r+1,-d);
            add(tr2,l,l*d);
            add(tr2,r+1,(r+1)*-d);
        }
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/245/">acwing244</a><br>
我们发现,如果说第K头牛的前面有Ak头牛比它矮,那么它的身高Hk就是数值1 n中第Ak+1小的没有在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>H</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">H_{k+1},H_{k+2},…,H_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中出现过的数<br>
所以说,我们需要建立一个长度为n的01序列b,刚开始都是1,然后n到1倒序扫描每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,对于每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
执行查询和修改操作.<br>
也就是说这道题目的题意就是让我们,动态维护一个01序列,支持查询第k个1所在的位置,以及修改序列中的一个数值</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int h[N];
int n;
int tr[N];
int ans[N];

int lowbit(int x)
{
    return x&amp;-x;
}

void add(int x,int c)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))  
        res+=tr[i];
    return res;
}

int main()
{
    cin&gt;&gt;n;
    for(int i=2;i&lt;=n;i++)
        cin&gt;&gt;h[i];
        
    for(int i=1;i&lt;=n;i++)   
        tr[i]=lowbit(i);//相当于add(i,1);
    
    for(int i=n;i;i--)
    {
        int k=h[i]+1;
        int l=1,r=n;
        while(l&lt;r)
        {
            int mid=l+r&gt;&gt;1;
            if(sum(mid) &gt;= k)
                r=mid;
            else
                l=mid+1;
        }
        ans[i]=l;
        add(l,-1);
    }
    
    for(int i=1;i&lt;=n;i++)
        cout&lt;&lt;ans[i]&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-1195">poj1195</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_78e266ec5c-29.PNG" alt="29.PNG" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define maxn 1050
#define lowbit(x) (x)&amp;(-x)
int c[maxn][maxn],n;

void add(int x,int y,int z)//单点更新 
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        for(int j=y;j&lt;=n;j+=lowbit(j))
            c[i][j]+=z;
}

int sum(int x,int y)//区间和：左上角(1,1)到右下角(x,y)矩阵区间和 
{
    int s=0;
    for(int i=x;i&gt;0;i-=lowbit(i))
        for(int j=y;j&gt;0;j-=lowbit(j))
            s+=c[i][j];
    return s;
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1);
}

int main()
{
    int opt,x,y,a,l,b,r,t;
	while(scanf(&quot;%d&quot;,&amp;opt)!=EOF)
	{
		if(opt==3) break;
		if(opt==0)
		{
			scanf(&quot;%d&quot;,&amp;n);
    		memset(c,0,sizeof(c));
		}
		else if(opt==1)
		{
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;a);
            ++x;++y;
            add(x,y,a);
        }
        else
		{
            scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;b,&amp;r,&amp;t);
            ++l,++b,++r,++t;
            printf(&quot;%d\n&quot;,sum(l,b,r,t));
        }
	}
    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3321">poj3321</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_3d7817525c-30.png" alt="30.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_4079f47a5c-31.png" alt="31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_5ffe30ea5c-32.png" alt="32.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_4635be445c-33.png" alt="33.png" loading="lazy"></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=1e5+10;
int n,q;
int c[maxn];
int a[maxn];
int L[maxn],R[maxn];
int head[maxn];
int cnt;
int dfn;
struct edge{
    int u,v;
    int next;
}E[2*maxn];

void adde(int u,int v)
{
    E[++cnt].u=u;
    E[cnt].v=v;
    E[cnt].next=head[u];
    head[u]=cnt;
}

int lowbit(int x)
{
    return x&amp;(-x);
}

void add(int x,int v)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        c[i]+=v;
}

int sum(int x)
{
    int ans=0;
    for(int i=x;i;i-=lowbit(i))
    {
        ans+=c[i];
    }
    return ans;
}


void dfs(int u,int fa)
{
    L[u]=++dfn;
    for(int i=head[u];i;i=E[i].next)
    {
        int v=E[i].v;
        if(v==fa) continue;
        dfs(v,u);
    }
    R[u]=dfn;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int u,v;
    for(int i=1;i&lt;=n;i++)
    {
        c[i]=lowbit(i);
        a[i]=1;
    }
    for(int i=1;i&lt;n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        adde(u,v);
    }
    dfs(1,-1);
//	for(int i=1;i&lt;=n;i++)//测试dfs序列 
//    	printf(&quot;--%d %d\n&quot;,L[i],R[i]);
//  	printf(&quot;\n&quot;);	
    scanf(&quot;%d&quot;,&amp;q);
    char op[10];
    for(int i=1;i&lt;=q;i++)
    {
        scanf(&quot;%s%d&quot;,op,&amp;v);
        if(op[0]=='C')
        {
        	int j=L[v];
            if(a[j])//由于每个节点的dfn编号就是它的左值，所以直接修改左节点
                add(j,-1);
            else
                add(j,1);
            a[j]^=1;
        }
        else
        {
            int s1=sum(R[v]);
            int s2=sum(L[v]-1);
            printf(&quot;%d\n&quot;,s1-s2);
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>