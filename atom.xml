<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caifxh.github.io</id>
    <title>fxh</title>
    <updated>2020-04-09T04:05:44.364Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caifxh.github.io"/>
    <link rel="self" href="https://caifxh.github.io/atom.xml"/>
    <subtitle>菜</subtitle>
    <logo>https://caifxh.github.io/images/avatar.png</logo>
    <icon>https://caifxh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, fxh</rights>
    <entry>
        <title type="html"><![CDATA[四边形不等式]]></title>
        <id>https://caifxh.github.io/post/si-bian-xing-bu-deng-shi/</id>
        <link href="https://caifxh.github.io/post/si-bian-xing-bu-deng-shi/">
        </link>
        <updated>2020-04-09T04:05:10.000Z</updated>
        <content type="html"><![CDATA[<p>四边形不等式优化主要针对区间DP模型。<br>
转移方程形如：<br>
f[i][j] = min(f[i][k] + f[k + 1][j] + w(i, j))<br>
对于每个区间都要枚举 k<br>
时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)<br>
状态数已经定好了是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)，我们能想办法优化的部分就是把 O(n) 的转移优化到 O(1)<br>
这里就要用到四边形不等式优化。</p>
<p>对于 a &lt; b &lt; c &lt; d：<br>
如果有 f(a, c) + f(b, d) &lt;= f(b, c) + f(a, d) <strong>交叉 &lt;= 包含</strong><br>
我们就称 f 满足四边形不等式。</p>
<p>如果代价函数 w(i,j) 满足单调性和四边形不等式，那么 dp 函数 f(i,j) 也满足四边形不等式。<br>
定义 s(i,j) 为 f(i,j) 取得最优值对应的转移（即 k）<br>
如果 f(i,j) 满足四边形不等式，那么 s(i,j) 单调<br>
即s(i,j)≤s(i,j+1)≤s(i+1,j+1)</p>
<h4 id="应用背景">应用背景</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_a72071bc79-20.PNG" alt="20.PNG" loading="lazy"></figure>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_9d82d0e079-21.PNG" alt="21.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_c982acc479-22.PNG" alt="22.PNG" loading="lazy"></p>
<h4 id="四边形不等式定义和单调性定义">四边形不等式定义和单调性定义</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_22f1d33479-23.PNG" alt="23.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_70a44cae79-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_9708b8d079-25.PNG" alt="25.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=310,INF=0x3f3f3f3f;
int f[N][N];
int sum[N];
int s[N][N];
int n;

int main()
{
    cin&gt;&gt;n;

    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;sum[i];
        sum[i]+=sum[i-1];
        s[i][i]=i;
    }

    for(int len=2;len&lt;=n;len++)
    {
        for(int i=1;i+len-1&lt;=n;i++)
        {
            int j=i+len-1;
            f[i][j]=INF;
            for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)
                if(f[i][j] &gt; f[i][k]+f[k+1][j]+sum[j]-sum[i-1])
                {
                    f[i][j] = f[i][k]+f[k+1][j]+sum[j]-sum[i-1];
                    s[i][j]=k;
                }
        }
    }

    cout&lt;&lt;f[1][n]&lt;&lt;endl;

    return 0;
}

</code></pre>
<p><a href="https://www.acwing.com/problem/content/1070/">acwing1068</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_1733cf0c79-29.png" alt="29.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=210,INF=0x3f3f3f3f;
int f[N][N];
int g[N][N];
int w[N];
int sum[N];
int s[N][N];
int n;

int main()
{
    cin&gt;&gt;n;
    
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;w[i];
        w[n+i]=w[i];
    }
    
    for(int i=1;i&lt;=n*2;i++)
    {
        sum[i]=sum[i-1]+w[i];
        s[i][i]=i;
    }
    
    for(int len=2;len&lt;=n*2;len++)
    {
        for(int i=1;i+len-1&lt;=n*2;i++)
        {
            int j=i+len-1;
            f[i][j]=INF;
            for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)
                if(f[i][j] &gt; f[i][k]+f[k+1][j]+sum[j]-sum[i-1])
                {
                    f[i][j] = f[i][k]+f[k+1][j]+sum[j]-sum[i-1];
                    s[i][j]=k;
                }
                
            g[i][j]=max(g[i+1][j],g[i][j-1])+sum[j]-sum[i-1];
        }
    }
    
    int maxv=0;
    int minv=INF;
    for(int i=1;i&lt;=n;i++)
    {
        maxv=max(maxv,g[i][n+i-1]);
        minv=min(minv,f[i][n+i-1]);
    }
    
    cout&lt;&lt;minv&lt;&lt;endl&lt;&lt;maxv&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<h4 id="四边形不等式定理">四边形不等式定理</h4>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_ffe53f3c79-27.PNG" alt="27.PNG" loading="lazy"></figure>
<h4 id="一维线性dp的四边形不等式优化">一维线性DP的四边形不等式优化</h4>
<figure data-type="image" tabindex="3"><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_0a2e13bc79-28.PNG" alt="28.PNG" loading="lazy"></figure>
<p>比赛时，我们只要先写出暴力的 DP 然后打出 cost、dp、和决策数组，验证 cost、dp函数是否满足四边形不等式，<br>
以及决策是否具有单调性。</p>
<ul>
<li>拿到题目后，先判断w是否单调、是否满足四边形不等式，再使用四边形不等式优化DP。</li>
</ul>
<h4 id="最优二叉搜索树">最优二叉搜索树</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_f95a567879-31.PNG" alt="31.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_e9d4e4fc79-30.PNG" alt="30.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_13099f6679-32.PNG" alt="32.PNG" loading="lazy"><br>
题目给出的数列(val)是有序的，假设我们以i为根，1<sub>i-1就是左子树，i+1</sub>n就是右子树</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=260;
int w[N];
int sum[N];
int s[N][N];
int f[N][N];
int n;

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		for(int i=1;i&lt;=n;i++)
		{
			cin&gt;&gt;w[i];
			sum[i]=sum[i-1]+w[i];
			s[i][i]=i;
		}
		
		for(int len=1;len&lt;=n;len++)
		{
			for(int i=1;i+len-1&lt;=n;i++)
			{
				int j=i+len-1;
				f[i][j]=1e9;
				if(len == 1) f[i][j]=0;
				
				for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)
					if(f[i][j] &gt; f[i][k-1]+f[k+1][j]+sum[j]-sum[i-1]-w[k])
					{
						f[i][j] = f[i][k-1]+f[k+1][j]+sum[j]-sum[i-1]-w[k];
						s[i][j]=k;
					}
			}
		}
		
		cout&lt;&lt;f[1][n]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2829">hdu2829</a><br>
有 n 个火车站，第 i 个火车站有一个重要度 a[i]。<br>
你现在可以炸掉 m 条铁轨。这样铁轨就断成了 m + 1 段，每一段都有一个战略值，它等于这一段铁轨上的火车站两两的重要度乘积之和。请你最小化总的战略值之和。<br>
0 ≤ m &lt; n ≤ 1000</p>
<p>斜率优化：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_e9dadca879-33.PNG" alt="33.PNG" loading="lazy"><br>
那么，就有：dp[i][j] = min( dp[k][j-1] + w[k+1][i] )，j≤k&lt;i；<br>
方程的意义是：炸毁仓库k和仓库k+1之间的那段铁路（即第k段铁路），算出总价值，枚举k找到最小的。</p>
<p>那么如何计算w[k+1][i]呢？假设sum[i]=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mi>v</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{k=1}^{i}v[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.264274em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> ，那么就有：w[1][i] = w[1][k] + w[k+1][i] + (v[1]+v[2]+…+v[k]) × (v[k+1]+v[k+2]+…+v[i])= w[1][k] + w[k+1][i] + sum[k] × (sum[i]-sum[k])<br>
即w[k+1][i] = w[1][i] - w[1][k] - sum[k] × (sum[i]-sum[k])</p>
<p>我们把w[k+1][i]的计算式带入状态转移方程得到：<br>
dp[i][j] = min{ dp[k][j-1] + w[1][i] - w[1][k] - sum[k] × (sum[i]-sum[k]) }</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1010;
int f[N][N];
int s[N],w[N];
int q[N];
int n,m;

int getY(int i,int j,int k)
{
	return f[i-1][j]-w[j]+s[j]*s[j]-f[i-1][k]+w[k]-s[k]*s[k];
}

int getX(int i,int j)
{
	return s[i]-s[j];
}

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		if(!n &amp;&amp; !m) break;
		
		for(int i=1;i&lt;=n;i++)
		{
			int x;
			scanf(&quot;%d&quot;,&amp;x);
			s[i]=s[i-1]+x;
			w[i]=w[i-1]+s[i-1]*x;
			f[0][i]=w[i];
		}
		
		for(int i=1;i&lt;=m;i++)
		{
			int hh=0,tt=-1;
			q[++tt]=0;
			for(int j=1;j&lt;=n;j++)
			{
				while(hh &lt; tt &amp;&amp; getY(i,q[hh+1],q[hh]) &lt;= s[j]*getX(q[hh+1],q[hh]))
					hh++;
				int k=q[hh];
				f[i][j]=f[i-1][k]+w[j]-w[k]-s[k]*(s[j]-s[k]);
				
				while(hh &lt; tt &amp;&amp; getY(i,q[tt],q[tt-1])*getX(j,q[tt]) &gt;= getY(i,j,q[tt])*getX(q[tt],q[tt-1]))
					tt--;
				q[++tt]=j;
			}			
		}
		
		printf(&quot;%d\n&quot;,f[m][n]);
	}
	return 0;
}
</code></pre>
<p>四边形不等式：<br>
用 f[i][j] 来表示在前 j 个火车站中用了 i 个炸弹得到的最小的战略值总和。<br>
枚举上一次使用炸弹的位置 k，得到<br>
f[i][j] = min(f[i - 1][k] + w[k + 1][j])(i-1 &lt; k &lt; j)</p>
<p>w[i][j] = [i, j] 中两两乘积之和= [(a[i] + a[i + 1] + … + a[j])2 - (a[i]2 + a[i + 1]2 + … + a[j]2)] / 2<br>
可以验证它是满足单调性和四边形不等式的。<br>
因此这题可以用四边形不等式来优化。<br>
f[i][j] = min(f[i - 1][k] + w[k + 1][j])<br>
(s[i-1][j] &lt; k &lt; s[i+1][j])</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1010;
int f[N][N];
int a[N];
int w[N][N];
int p[N][N];
int n,m;

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		if(!n &amp;&amp; !m) break;
		
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		
		for(int i=1;i&lt;=n;i++)
		{
			int sum=0;
			w[i][i]=0;
			for(int j=i+1;j&lt;=n;j++)
			{
				sum+=a[j-1];
				w[i][j]=w[i][j-1]+sum*a[j];
			}
		}
		
		//      打表
// 		for(int i=1;i&lt;=n;i++) 
// 		{
// 		    for(int j=1;j&lt;=n;j++)
// 		        cout&lt;&lt;w[i][j]&lt;&lt;' ';
// 		    cout&lt;&lt;endl;
// 		}
		
		for(int i=0;i&lt;=n;i++)
		{
			f[0][i]=w[1][i];
			p[0][i]=0;
			p[i][n+1]=n;
		}
	
		
		for(int i=1;i&lt;=m;i++)
			for(int j=n;j&gt;=1;j--)
			{
				f[i][j]=1e9;
				for(int k=p[i-1][j];k&lt;=p[i][j+1];k++)
					if(f[i][j] &gt; f[i-1][k] + w[k+1][j])
					{
						f[i][j] = f[i-1][k] + w[k+1][j];
						p[i][j]=k;
					}
			}
		
		printf(&quot;%d\n&quot;,f[m][n]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斜率优化]]></title>
        <id>https://caifxh.github.io/post/xie-lu-you-hua/</id>
        <link href="https://caifxh.github.io/post/xie-lu-you-hua/">
        </link>
        <updated>2020-04-08T09:24:30.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_52e5180078-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_55ff749078-2.png" alt="2.png" loading="lazy"></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507">hdu3507</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_98db0db078-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_3be50fce78-4.PNG" alt="4.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_3db0a1a678-5.PNG" alt="5.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_6b0c654078-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_80a51b8678-7.PNG" alt="7.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_afd9578278-8.PNG" alt="8.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_d2b42cb478-9.PNG" alt="9.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e1bc29be78-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e3da236678-11.PNG" alt="11.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e70434fa78-12.PNG" alt="12.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_e8f70a9e78-13.PNG" alt="13.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=500010;
int f[N];
int s[N];
int q[N];
int n,m;

int getY(int i,int j)
{
	return f[i]+s[i]*s[i]-f[j]-s[j]*s[j];
}

int getX(int i,int j)
{
	return s[i]-s[j];
}

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		for(int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;s[i]);
			s[i]+=s[i-1];
		}
		
		int hh=0,tt=-1;
		q[++tt]=0;
		
		for(int i=1;i&lt;=n;i++)
		{
			while(hh&lt;tt &amp;&amp; getY(q[hh+1],q[hh]) &lt;= 2*s[i]*getX(q[hh+1],q[hh]))
				hh++;
			int j=q[hh];
			f[i]=f[j]+(s[i]-s[j])*(s[i]-s[j])+m;
			while(hh&lt;tt &amp;&amp; getY(q[tt],q[tt-1])*getX(i,q[tt]) &gt;= getY(i,q[tt])*getX(q[tt],q[tt-1]))
				tt--;
			q[++tt]=i;
		}
		
		printf(&quot;%d\n&quot;,f[n]);
	}
	return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/07/9969_b435e00678-14.png" alt="14.png" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/description/304/">acwing302</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int N=300010;
LL st[N],sc[N];
LL f[N];
int q[N];
int n,s;

LL getY(int i,int j)
{
    return f[i]-f[j];
}

LL getX(int i,int j)
{
    return sc[i]-sc[j];
}

int main()
{
    cin&gt;&gt;n&gt;&gt;s;
    
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lld%lld&quot;,&amp;st[i],&amp;sc[i]);
        st[i]+=st[i-1];
        sc[i]+=sc[i-1];
    }
    
    int hh=0,tt=-1;
    q[++tt]=0;
    for(int i=1;i&lt;=n;i++)
    {
        int l=hh,r=tt;
        while(l&lt;r)
        {
            int mid=l+r&gt;&gt;1;
            if(getY(q[mid+1],q[mid]) &gt;= (s+st[i])*getX(q[mid+1],q[mid])) r=mid;
            else l=mid+1;
        }
        
        int j=q[l];
        f[i]=f[j]-(s+st[i])*sc[j]+s*sc[n]+st[i]*sc[i];
        while(hh&lt;tt &amp;&amp; getY(q[tt],q[tt-1])*getX(i,q[tt]) &gt;= getY(i,q[tt])*getX(q[tt],q[tt-1]))
            tt--;
        q[++tt]=i;
    }
    
    cout&lt;&lt;f[n]&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/305/">acwing303</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_1bbe8e4e78-15.png" alt="15.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010,M=100010,P=110;
LL f[P][M];
LL d[N];
int t[M],a[M];
LL s[M];
int q[M];
int n,m,p;

LL getY(int i,int j,int k)
{
    return f[i-1][j]+s[j]-f[i-1][k]-s[k];
}

int getX(int i,int j)
{
    return i-j;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;
    
    for(int i=2;i&lt;=n;i++)
        cin&gt;&gt;d[i],d[i]+=d[i-1];
        
    for(int i=1;i&lt;=m;i++)
    {
        int h;
        cin&gt;&gt;h&gt;&gt;t[i];
        a[i]=t[i]-d[h];
    }
    
    sort(a+1,a+m+1);
    
    
    for(int i=1;i&lt;=m;i++) s[i]=s[i-1]+a[i];
    
    memset(f,0x3f,sizeof f);
    for(int i=0;i&lt;=p;i++) f[i][0]=0;
    
    for(int i=1;i&lt;=p;i++)
    {
        
        int hh=0,tt=-1;
        q[++tt]=0;
        
        for(int j=1;j&lt;=m;j++)
        {
            while(hh &lt; tt &amp;&amp; getY(i,q[hh+1],q[hh]) &lt;= (LL)a[j]*getX(q[hh+1],q[hh]))
                hh++;
            int k=q[hh];
            f[i][j]=f[i-1][k]+(LL)a[j]*(j-k)-(s[j]-s[k]);
            while(hh &lt; tt &amp;&amp; getY(i,q[tt],q[tt-1])*getX(j,q[tt]) &gt;= getY(i,j,q[tt])*getX(q[tt],q[tt-1]))
                tt--;
            q[++tt]=j;
        }
    }

    cout&lt;&lt;f[p][m]&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P2120">P2120</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_cc43d24e79-17.PNG" alt="17.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_e7b6cfb879-18.PNG" alt="18.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/08/9969_ea64c32879-19.PNG" alt="19.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=1000010;
LL f[N];
LL x[N],c[N],p[N];
LL sp[N],sxp[N];
int q[N];
int n;

LL getY(int i,int j)
{
	return f[i]+sxp[i]-f[j]-sxp[j];
}

LL getX(int i,int j)
{
	return sp[i]-sp[j];
}

int main()
{
	cin&gt;&gt;n;
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;x[i],&amp;p[i],&amp;c[i]);
		sp[i]=sp[i-1]+p[i];
		sxp[i]=sxp[i-1]+x[i]*p[i];
	}
	
	int hh=0,tt=-1;
	q[++tt]=0;
	
	for(int i=1;i&lt;=n;i++)
	{
		while(hh &lt; tt &amp;&amp; getY(q[hh+1],q[hh]) &lt;= x[i]*getX(q[hh+1],q[hh]))
			hh++;
		int j=q[hh];
		f[i]=f[j]+x[i]*(sp[i]-sp[j])-(sxp[i]-sxp[j])+c[i];
		while(hh &lt; tt &amp;&amp; getY(q[tt],q[tt-1])*getX(i,q[tt]) &gt;= getY(i,q[tt])*getX(q[tt],q[tt-1]))
			tt--;
		q[++tt]=i;
	}
	
	printf(&quot;%lld\n&quot;,f[n]);
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前缀和 差分]]></title>
        <id>https://caifxh.github.io/post/qian-zhui-he-chai-fen/</id>
        <link href="https://caifxh.github.io/post/qian-zhui-he-chai-fen/">
        </link>
        <updated>2020-04-07T16:42:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前缀和"><a href="https://www.acwing.com/problem/content/797/">前缀和</a></h3>
<p>给定一个序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>1</mn><mo>−</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[1-n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>。<br>
有很多次询问，每个询问形如:l r  询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的区间和。<br>
<code>每次询问的复杂度要求 O(1)</code><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/08/9969_9251f5104a-1.PNG" alt="1.PNG" loading="lazy"></p>
<h4 id="预处理时间复杂度on">预处理时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4>
<pre><code>for(int i=1;i&lt;=n;i++)
{
    scanf(&quot;%d&quot;,&amp;a[i]);
    s[i]=s[i-1]+a[i];
}
</code></pre>
<h4 id="alr的区间和-sr-sl-1"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的区间和: s[r]-s[l-1]</h4>
<h4 id="查询时间复杂度o1">查询时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4>
<pre><code>while(m--)
{
    int l,r;
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    printf(&quot;%d\n&quot;,s[r]-s[l-1]);
}
</code></pre>
<h2 id="ps前缀和下标从1开始"><code>PS:前缀和下标从1开始</code></h2>
<h3 id="区间加差分"><a href="https://www.acwing.com/problem/content/799/">区间加/差分</a></h3>
<p>给定一个序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>1</mn><mo>−</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[1-n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>(初值全为0)。<br>
有很多次操作，每个操作形如:l r  将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的每个值加上k。<br>
最后输出整个数组。复杂度要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/08/9969_bd972e544a-2.PNG" alt="2.PNG" loading="lazy"><br>
区间加[l,r]，实际上是发生了这两件事：<br>
a[l]比前一个元素多了k;<br>
a[r+1]比前一个元素少了k.<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/08/9969_065512be4a-4.PNG" alt="4.PNG" loading="lazy"><br>
我们用数组b表示刚刚的差值，<strong>b[i]=a[i]-a[i-1]</strong>.<br>
那么：区间加[𝒍,𝒓]，可以化为这两个操作： <strong>b[l]+=k; b[r+1]-=k;</strong></p>
<pre><code>void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}
</code></pre>
<p>因此，一次区间加只修改这两个元素； 最后利用b数组求出a数组(a数组为b数组的前缀和)，对b数组求一遍前缀和即为答案。</p>
<pre><code>for(int i=1;i&lt;=n;i++)
{
    b[i]+=b[i-1];
    printf(&quot;%d &quot;,b[i]);
}
</code></pre>
<p><code>PS:数组a初值为0，进行n次插入操作可得到数组a。</code></p>
<pre><code>for(int i=1;i&lt;=n;i++)
    scanf(&quot;%d&quot;,&amp;a[i]);
for(int i=1;i&lt;=n;i++)
    insert(i,i,a[i]);
</code></pre>
<h4 id="总结差分无需构造前缀和需构造">总结：差分无需构造，前缀和需构造</h4>
<p>通过上述的两个方法，我们能轻易地处理这两类问题：</p>
<ul>
<li>数组固定，然后大量询问；</li>
<li>大量做区间加，最后要你给出这个数组。</li>
</ul>
<h3 id="例题">例题</h3>
<p><a href="https://www.luogu.com.cn/problem/P2879">Luogu2879</a><br>
有好几头牛从１到n线性排列，每头牛的高度为h[i]现在告诉你这里面的牛的最大高 度为maxH,而且有r组关系，每组关系输入两个数字，假设为a和b,表示第a头牛能看到第b头牛，能看到的条件是a, b之间的其它牛的高度都严格小于min(h[a], h[b]),而 h[b] &gt;= h[a] 最后求所有牛的可能最高身高输出</p>
<h4 id="思路">思路：</h4>
<p>首先假设所有牛都是最高身高。 读入的约束信息需要去重，这个利用排序或者set可以解决。 可以发现对于每个位置h[i],假设它被覆盖了x次，最后答案就是h[i]-x. 如果出现了一对[l,r]，把区间(l,r)的数都-1就可以了。（注意区间开闭）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt; 
using namespace std;
const int N=10010;
int height[N];
set&lt;pair&lt;int,int&gt; &gt; S;

int main()
{
	int n,i,h,r;
	cin&gt;&gt;n&gt;&gt;i&gt;&gt;h&gt;&gt;r;
	height[1]=h;//差分数组 
	
	while(r--)
	{
		int a,b;
		cin&gt;&gt;a&gt;&gt;b;
		if(a&gt;b)
			swap(a,b);
		if(!S.count({a,b}))
		{
			S.insert({a,b});
			height[a+1]--;
			height[b]++;
		}
	}
	
	for(int i=1;i&lt;=n;i++)
	{
		height[i]+=height[i-1];
		cout&lt;&lt;height[i]&lt;&lt;endl;
	}
	return 0;
 } 
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3406">Luogu3406</a><br>
该铁路经过N个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好 ，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车 票。第i段铁路连接了城市i和城市i+1(1&lt;=i&lt;N)。如果搭乘的比较远，需要购买多张 车票。第i段铁路购买纸质单程票需要Ai博艾元。 虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了IC卡。对于第i段 铁路，需要花Ci博艾元的工本费购买一张IC卡，然后乘坐这段铁路一次就只要扣 Bi(Bi&lt;Ai)元。IC卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应 的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于 第i段铁路的IC卡，无法乘坐别的铁路的车。 Uim现在需要出差，要去M个城市，从城市P1出发分别按照P1,P2,P3...PM的顺序访 问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且 不会是同一个城市。 现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和 充值的总费用。</p>
<p>直接模拟每段铁路的覆盖即可</p>
<pre><code> #include&lt;iostream&gt;
using namespace std;
const int N=100010;
 int a[N];
 int b[N];//差分数组 
 typedef long long LL;
 
 int main()
 {
 	int n,m;
 	cin&gt;&gt;n&gt;&gt;m;
 	for(int i=1;i&lt;=m;i++)
 		cin&gt;&gt;a[i];
 	for(int i=1;i&lt;m;i++)
 	{
 		b[min(a[i],a[i+1])]++;
 		b[max(a[i],a[i+1])]--;
	 }
	 
	 for(int i=1;i&lt;=n;i++)
	 	b[i]+=b[i-1];
	
//	for(int i=1;i&lt;=n;i++)
//		cout&lt;&lt;&quot;--&quot;&lt;&lt;b[i]&lt;&lt;' ';
	
	LL sum=0;
	for(int i=1;i&lt;n;i++)
	{
		LL ai,bi,ci;
		cin&gt;&gt;ai&gt;&gt;bi&gt;&gt;ci;
		sum+=min(ai*b[i],ci+bi*b[i]);
	}
	
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
 }
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1083">Luogu1083</a></p>
<h4 id="思路1">思路1：</h4>
<p>利用差分数组存每天的教室使用情况，然后求前缀和，如果发现不符合要求，就从后往前撤回订单，直到每天都符合要求，那么我们撤回的最后一个（也就是最靠前的一个）即为ans</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int l[N],r[N],d[N];
int res=INF;

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;d[i],&amp;l[i],&amp;r[i]);
		b[l[i]]+=d[i];
		b[r[i]+1]-=d[i];
	}
	
	int j=m;//从后往前撤回订单，直至满足要求 
	int sum=0;
	for(int i=1;i&lt;=n;i++)
	{
		sum+=b[i];
		//cout&lt;&lt;sum&lt;&lt;' ';
		if(sum&gt;a[i])
		{
			//从后往前撤回 
			while(sum&gt;a[i])
			{
				b[l[j]]-=d[j];
				b[r[j]+1]+=d[j];
				if(i&gt;=l[j] &amp;&amp; i&lt;=r[j])
					sum-=d[j];
				j--;
			}
			res=min(res,j);
		}	
	}
	
	if(res==INF)
		cout&lt;&lt;&quot;0&quot;;
    else 
		cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl&lt;&lt;res+1&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="思路2">思路2：</h4>
<p>在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int s[N],t[N],d[N];

bool check(int x)//判断前x份订单能否全部满足 
{
	memset(b,0,sizeof b);
	for(int i=1;i&lt;=x;i++)
	{
		b[s[i]]+=d[i];
		b[t[i]+1]-=d[i];
	}

	for(int i=1;i&lt;=n;i++)
	{
		b[i]+=b[i-1];
		if(b[i]&gt;a[i])
			return false;
	}
	return true;
}

int main()
{
//	freopen(&quot;test.in.txt&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;d[i],&amp;s[i],&amp;t[i]);
	}
	if(check(m))
	{
		puts(&quot;0&quot;);
		return 0;
	}
	int l=0,r=m;//l取成0，防止无解情况 
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(check(mid))
			l=mid;
		else	
			r=mid-1;
	}
	cout&lt;&lt;-1&lt;&lt;endl;
	cout&lt;&lt;l+1&lt;&lt;endl;

    return 0;
}
</code></pre>
<h4 id="前缀和差分">前缀和+差分</h4>
<p><a href="https://www.luogu.com.cn/problem/P3948">luoguP3948</a></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=80010;
typedef long long LL;
LL b[N];
int sum[N];
int n,opt,minn,maxx,l,r,x,f;
LL mod;
char ch[5];

int main()
{
    scanf(&quot;%d%d%lld%d%d&quot;,&amp;n,&amp;opt,&amp;mod,&amp;minn,&amp;maxx);
    for(int j=1;j&lt;=opt;j++){
        scanf(&quot;%s%d%d%&quot;,&amp;ch,&amp;l,&amp;r);
        if(ch[0]=='A'){
            scanf(&quot;%d&quot;,&amp;x);
            b[l]+=x;
            b[r+1]-=x;
        }
        else{
            int ans=0;
			LL now=0;
            for(int i=1;i&lt;=r;i++){
                now+=b[i];
                if(i&gt;=l&amp;&amp;(now*i)%mod&gt;=minn&amp;&amp;(now*i)%mod&lt;=maxx)ans++;
            }
            printf(&quot;%d\n&quot;,ans);
        }
    }
    scanf(&quot;%d&quot;,&amp;f);
    for(int i=1;i&lt;=n;i++){
        b[i]+=b[i-1];
        if((b[i]*i)%mod&gt;=minn&amp;&amp;(b[i]*i)%mod&lt;=maxx)sum[i]=sum[i-1]+1;
        else sum[i]=sum[i-1];
    }
    for(int j=1;j&lt;=f;j++){
        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
        printf(&quot;%d\n&quot;,sum[r]-sum[l-1]);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单调数据结构]]></title>
        <id>https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/</id>
        <link href="https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/">
        </link>
        <updated>2020-04-07T16:41:48.000Z</updated>
        <content type="html"><![CDATA[<h4 id="单调栈">单调栈</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_93bac9686e-28.PNG" alt="28.PNG" loading="lazy"><br>
给定一个序列。对序列中的每个元素，求出它左侧的第一个小于它 的元素的位置。若没有这样的元素，输出0。</p>
<blockquote></blockquote>
<p>样例输入：<br>
4<br>
5 3 7 4<br>
样例输出：<br>
0 0 2 2</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_d560c46c6e-29.PNG" alt="29.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/832/">模板题1</a></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int stk[N],top;

int main()
{
    int n;
    cin&gt;&gt;n;
    while(n--)
    {
        int x;
        cin&gt;&gt;x;
        while(top&amp;&amp;stk[top]&gt;=x)
            top--;
        if(top)  
            cout&lt;&lt;stk[top]&lt;&lt;&quot; &quot;;
        else 
            cout&lt;&lt;-1&lt;&lt;&quot; &quot;;
        stk[++top]=x;
    }
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P5788">模板题2</a><br>
找出第 i 个元素之后第一个大于 ai的元素的下标<br>
分析：<br>
从后往前枚举，对于i&lt;j,若a[i]&gt;=a[j],则j不可能成为下标小于i的元素的答案。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=3e6+10;
int stk[N],top;
int n;
int a[N];
int ans[N];

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	
	for(int i=n;i&gt;=1;i--)
	{
		while(top &amp;&amp; a[stk[top]] &lt;= a[i]) top--;
		
		if(top) ans[i]=stk[top];
		else ans[i]=0;
		
		stk[++top]=i;
		
	}
	
	for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]);
	return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="https://vjudge.net/problem/POJ-2559">poj2559</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_b64b4e746e-30.PNG" alt="30.PNG" loading="lazy"><br>
首先考虑最大面积的矩形X的左右边界的性质：</p>
<p>设其左边界为L，右边界为R，则其高H = min{h[i] | L &lt;= i &lt;= R}</p>
<p>此时最大面积为 (R - L + 1) * H</p>
<p>若此时左边界的左边那个矩形的高度 h[L-1] &gt;= H<br>
则左边界可以向左拓展，则新的面积为：</p>
<p>(R - (L-1) + 1) * H &gt; 原面积</p>
<p>则与原假设条件冲突</p>
<p>故左边界左边的那个矩形的高度 :h[L-1] &lt; H<br>
同理右边界右边的那个矩形的高度： h[R+1] &lt; H</p>
<p>设H = h[i]</p>
<p>所以左边界L是满足h[j-1] &lt; h[i]的最大的j，即从i点向左遍历的第一个高度比i小的点的右边一个点</p>
<p>而右边界R是满足 h[j+1] &lt; h[i]的最小的j，即从i点向右遍历第一个高度比i小的点的左边一个点</p>
<p>所以我们可以利用单调栈的性质得到每个确定点，即确定高度的最大面积矩形的左右边界，然后枚举取最大即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N=100010;
int h[N];
int l[N],r[N];
int stk[N],top;
int n;

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)
	{
		top=0;
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;h[i]);
		
		for(int i=1;i&lt;=n;i++)//找出h[i]左边第一个小于h[i]的位置 
		{
			while(top &amp;&amp; h[stk[top]] &gt;= h[i]) 
				top--;
			
			if(top) l[i]=stk[top]+1;
			else l[i]=1;//表示左边没有比h[i]小的位置 
			
			stk[++top]=i;
		}
		
		top=0;
		for(int i=n;i&gt;=1;i--)//找出h[i]右边第一个小于h[i]的位置 
		{
			while(top &amp;&amp; h[stk[top]] &gt;= h[i])
				top--;
			if(top) r[i]=stk[top]-1;
			else r[i]=n;//表示右边没有比h[i]大的位置 
				
			stk[++top]=i; 
		}
		
		LL ans=0;
		for(int i=1;i&lt;=n;i++)
			ans=max(ans,(LL)h[i]*(r[i]-l[i]+1));
	
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1901">P1901</a><br>
对于一个新的信号塔:</p>
<ul>
<li>当他加入栈中时,会挡住之前比它低的塔的传播,同时 , 也会接受到比它低的塔的信号</li>
<li>所以将栈顶所有比它低的塔删除,(因为他们已经不能再传播给其他塔信号了),同时 , 新的塔接收到的能量加上 删掉的塔传播的能量</li>
<li>对于原有的高度比它高的信号塔,离此新的信号塔最近的(当前栈顶元素),会接受到新的塔的信号</li>
<li>再将此新的信号塔加入栈中,最后O(n)扫一遍后,输出最大值即可</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1e6+10;
int stk[N],top;
int sum[N];
int h[N],w[N];
int n;

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;h[i]&gt;&gt;w[i];
		
		while(top &amp;&amp; h[stk[top]] &lt;= h[i])
			sum[i]+=w[stk[top--]];
		sum[stk[top]]+=w[i];
		
		stk[++top]=i;
	}
	
	int ans=0;
	for(int i=1;i&lt;=n;i++)
		ans=max(ans,sum[i]);
	
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
<p><a href="">P1823</a><br>
先假设每个人身高不同，脑补一下走过整个队列。</p>
<ul>
<li>观察队伍中的一个人A。如果我们他后面找到了一个比他不知道高到哪里去了的B，A就不能与B后面的人谈笑风生了。</li>
<li>因此我们可以维护一个单调栈，记录我们已经找到过的高人，显然栈上的高人们按高度的降序排列，栈顶的人最矮。</li>
<li>当我们找到一个新的高人时，他可以向栈里比他矮的人传授人生经验，并让他们出栈。如果出栈之后栈非空，他还可以与栈顶的高人谈笑风生。然后我们再另请这位高明进栈。</li>
<li>我们还要考虑两个人身高相同的情况。我们可以在栈里存pair&lt;身高，人数&gt;并维护它。</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; PII;
#define x first
#define y second
typedef long long LL;
const int N=500010;
int h[N];
PII stk[N];
int top;
int n;

int main()
{
	cin&gt;&gt;n;
	LL ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;h[i]);
		
		PII p=make_pair(h[i],1);
		while(top &amp;&amp; stk[top].x &lt;= h[i])
		{
			if(stk[top].x == h[i]) 
				p.y+=stk[top].y;
			ans+=stk[top].y;
			top--;
		}
		
		if(top) ans++;
		stk[++top]=p;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
<h4 id="单调队列">单调队列</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_5111bd346e-31.PNG" alt="31.PNG" loading="lazy"></figure>
<p><a href="https://www.luogu.com.cn/problem/P1886">模板题</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_55f2d4966e-32.PNG" alt="32.PNG" loading="lazy"><br>
单调队列与普通队列不一样的地方就在于单调队列既可以从队首出队，也可以从队尾出队。<br>
那么我们应该怎样实现单调队列呢?<br>
就拿样例来谈谈，设以最小的为标准。</p>
<blockquote></blockquote>
<p>8 3<br>
1 3 -1 -3 5 3 6 7</p>
<p>下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。</p>
<ul>
<li>
<p>由于此时队中没有一个元素，我们直接令1进队。此时，q={1},p={1}。</p>
</li>
<li>
<p>现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q={1,3},p={1,2}</p>
</li>
<li>
<p>下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从队尾出队。同理，1从队尾出队。最后-1进队，此时q={-1},p={3}</p>
</li>
<li>
<p>出现-3，同上面分析，-1&gt;-3，-1从队尾出队,-3从队尾进队。q={-3}，p={4}。</p>
</li>
<li>
<p>出现5，因为5&gt;-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q={-3,5},p={4,5}</p>
</li>
<li>
<p>出现3。3先与队尾的5比较，3&lt;5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q={-3,3},p={4,6}</p>
</li>
<li>
<p>出现6。6与3比较，因为3&lt;6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从队首出队。此时，q={3,6},p={6,7}</p>
</li>
<li>
<p>出现7。队尾元素6小于7，7进队。此时，q={3,6,7},p={6,7,8}。</p>
</li>
</ul>
<p>那么，我们对单调队列的基本操作已经分析完毕。因为单调队列中元素大小单调递(增/减/自定义比较)，因此，队首元素必定是最值。按题意输出即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1000010;
int a[N];
int q[N];
int n,k;

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	
	int hh=0,tt=-1;
	
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
		
	for(int i=1;i&lt;=n;i++)//求滑动窗口最小值 
	{
		if(hh &lt;= tt &amp;&amp; i-k&gt;= q[hh]) hh++;
		while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &gt;= k)
			printf(&quot;%d &quot;,a[q[hh]]);
	}
	puts(&quot;&quot;);
	
	hh=0,tt=-1;
	for(int i=1;i&lt;=n;i++)
	{
		if(hh &lt;= tt &amp;&amp; i-k&gt;=q[hh]) hh++;
		while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &gt;= k)
			printf(&quot;%d &quot;,a[q[hh]]);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/137/">acwing135</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/25/9969_1ff2c8586e-33.PNG" alt="33.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 300010, INF = 0x3f3f3f3f;
int n, m;
int s[N];
int q[N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;s[i]), s[i] += s[i - 1];

    int res = -INF;
    int hh = 0, tt = -1;
    q[++tt]=0;//将s[0]入队
    for (int i = 1; i &lt;= n; i ++ )
    {
        if(hh&lt;=tt &amp;&amp; i-m &gt; q[hh]) hh++;
        res=max(res,s[i]-s[q[hh]]);
        while (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt -- ;
        q[ ++ tt] = i;
    }

    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度]]></title>
        <id>https://caifxh.github.io/post/gao-jing-du/</id>
        <link href="https://caifxh.github.io/post/gao-jing-du/">
        </link>
        <updated>2020-04-07T16:40:47.000Z</updated>
        <content type="html"><![CDATA[<h4 id="高精度加法">高精度加法</h4>
<p>当进行加法运算的数字较大时，受存储范围限制，无法使用int或longlong型变量进行存储。<br>
考虑到加法运算的本质，不妨将数字拆开来存储。<br>
对于一个超过变量存储数据范围的数字，可以将这个数字拆开，拆成一位一位的，或者是几位几位的存储到一个数组中， 用一个数组去表示一个数字</p>
<p>采用用顺序存储数据方式，会有一个问题：最高位进位变得很困难。<br>
最高位在num[0]，所以一旦有进位，需要将num[]数组中每一位都往后移，时间复杂度O(len)<br>
·倒序存储·：num[]数组从0到len-1依次存储整数个位到最高位。则最高位进位时，只需要num[len++]=t，t为最高位数字</p>
<p>进位：<br>
方法一：设一个变量t，记录当前进位<br>
边计算边进位和逐位相加不进位最后再统一进位效果是一样的如下，先进行一遍逐位相加。<br>
然后，从0开始遍历一遍ans.num[]，将本位大于9的部分进位给更高位。<br>
最后判断是否最高位有进位，有则ans.len++</p>
<p><a href="https://www.luogu.com.cn/problem/P1601">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=510;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum add(bignum a,bignum b)
{
	bignum c;
	c.len=max(a.len , b.len);
	for(int i=0;i&lt;c.len;i++) c.m[i]=a.m[i]+b.m[i];
	for(int i=0;i&lt;c.len;i++)
		if(c.m[i] &gt; 9)
		{
			c.m[i+1]+=1;
			c.m[i]-=10;
		}
	if(c.m[c.len]) c.len++;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	scanf(&quot;%s&quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&lt;len;i++)
		b.m[len-i-1]=s[i]-'0';
	bignum c=add(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="高精度减法">高精度减法</h4>
<ul>
<li>判断正负</li>
<li>基本和加法一模一样，只不过从进位变成退位</li>
<li>退位后更新结果长度<br>
<a href="https://www.luogu.com.cn/problem/P2142">模板题</a></li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=10100;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

int judge(bignum a,bignum b)
{
	if(a.len &gt; b.len) return 1;
	if(a.len &lt; b.len) return -1;
	for(int i=a.len-1;i&gt;=0;i--)
	{
		if(a.m[i] &gt; b.m[i]) return 1;
		if(a.m[i] &lt; b.m[i]) return -1;
	}
	return 0;
}

bignum Minus(bignum a,bignum b)
{
	if(judge(a,b) == -1)
	{
		printf(&quot;-&quot;);
		return Minus(b,a);
	}

	bignum c;
	c.len=a.len;
	for(int i=0;i&lt;c.len;i++) c.m[i]=a.m[i]-b.m[i];
	for(int i=0;i&lt;c.len;i++)
		if(c.m[i] &lt; 0)
		{
			c.m[i+1]-=1;
			c.m[i]+=10;
		}
	while(c.len &gt; 1 &amp;&amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	scanf(&quot;%s&quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&lt;len;i++)
		b.m[len-i-1]=s[i]-'0';
	bignum c=Minus(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="高精度乘法">高精度乘法</h4>
<h4 id="1高精低精">1.高精*低精</h4>
<p>将加法运算改为乘法运算即可。<br>
注意：</p>
<ul>
<li>进位的运算</li>
<li>最高位进位的处理，可能不止进一位<br>
<a href="https://www.acwing.com/problem/content/description/795/">模板题</a></li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	for(int i=0;i&lt;c.len;i++) c.m[i]=a.m[i]*b;
	for(int i=0;i&lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
		if(i == c.len-1 &amp;&amp; c.m[i+1]) c.len++;
	}

	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	int b;
	scanf(&quot;%d&quot;,&amp;b);

	bignum c=mul(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="2高精高精">2.高精*高精</h4>
<p>乘法竖式中，a.num[i]和b.num[j]相乘的结果，放在了ans.num[i+j]的位置。<br>
a,b都为正整数时，长度为a.len和b.len的数字相乘得到ans，则<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/17/9969_ff4d713467-43.PNG" alt="43.PNG" loading="lazy"><br>
模拟上例竖式运算过程即可<br>
{模板题](https://www.luogu.com.cn/problem/P1303}</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=4010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,bignum b)
{
	bignum c;
	c.len=a.len+b.len;
	for(int i=0;i&lt;a.len;i++)
		for(int j=0;j&lt;b.len;j++)
			c.m[i+j]+=a.m[i]*b.m[j];
	for(int i=0;i&lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
	}
	while(c.len &gt; 1 &amp;&amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	scanf(&quot;%s&quot;,s);
	b.len=len=strlen(s);
	for(int i=0;i&lt;len;i++)
		b.m[len-i-1]=s[i]-'0';
	bignum c=mul(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
<h4 id="高精度除法">高精度除法</h4>
<h4 id="1高精低精-2">1.高精/低精</h4>
<p>除法是从高位到低位进行运算的。使用一个临时变量来记录余数，注意细节<br>
<a href="https://www.acwing.com/problem/content/description/796/">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};
int t;

bignum Div(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	t=0;
	for(int i=c.len-1;i&gt;=0;i--)
	{
		t=t*10+a.m[i];
		c.m[i]=t/b;
		t%=b;
	}
	while(c.len &gt; 1 &amp;&amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&quot;%s&quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&lt;len;i++)
		a.m[len-i-1]=s[i]-'0';
	
	int b;
	scanf(&quot;%d&quot;,&amp;b);
	bignum c=Div(a,b);
	for(int i=c.len-1;i&gt;=0;i--)
		printf(&quot;%d&quot;,c.m[i]);
	puts(&quot;&quot;);
	printf(&quot;%d\n&quot;,t);

	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1255">数楼梯</a><br>
斐波那契递推<br>
<a href="https://paste.ubuntu.com/p/JKWpDTPXrj/">code</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树形dp]]></title>
        <id>https://caifxh.github.io/post/shu-xing-dp/</id>
        <link href="https://caifxh.github.io/post/shu-xing-dp/">
        </link>
        <updated>2020-04-06T03:53:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="树的重心">树的重心</h4>
<p>对于一棵 n 个节点的无根树，找到一个点 A，使得把树变成以<br>
该点为根的有根树时，最大子树的结点树最小。A 叫做重心。<br>
给定一棵树，找重心。<br>
求一下每个点子树的点数，然后对于每个点考虑一下他作为重心<br>
时候最大子树的大小是多少，和当前的重心进行比对就可以了。<br>
代码非常简单易懂。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace  std;
const int N=100010,M=N*2;
int h[N],e[M],ne[M],idx;
int ans=N;
bool st[N];
int cnt[N];
int n;
int poi;

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void dfs(int u,int fa)
{
    cnt[u]=1;
    int res=0;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        dfs(j,u);
        cnt[u]+=cnt[j];
        res=max(res,cnt[j]);
    }
    res=max(res,n-cnt[u]);

    if(res &lt; ans)
    {
        ans=res;
        poi=u;
    }
}

int main()
{
    
    memset(h,-1,sizeof h);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n-1;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
        add(b,a);
    }
    
    dfs(1,-1);
    
    cout&lt;&lt;ans&lt;&lt;endl;
    //cout&lt;&lt;poi&lt;&lt;endl;重心
    return 0;
}
</code></pre>
<h3 id="树的最长路径"><a href="https://www.acwing.com/problem/content/description/1074/">树的最长路径</a></h3>
<p>妨枚举直径在树上转弯的点。所以我们维护出到一个节点<br>
时向下的最长链和次长链，然后用二者加和来更新答案，同时更<br>
新父亲节点的最长链和次长链。<br>
f[i][0]表示根节点为i，向下所能到达的最长路径长度<br>
f[i][1]表示根节点为i，向下所能到达的次长路径长度</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=10010,M=N*2;
int h[N],e[M],ne[M],w[M],idx;
int n,m;
int ans;
int f[N][2];//0表示最长路径， 1表示次长路径

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v == fa)
            continue;
        dfs(v,u);
        if(f[v][0] + w[i] &gt; f[u][0])
        {
            f[u][1]=f[u][0];
            f[u][0]=f[v][0]+w[i];
        }
        else if(f[v][0] + w[i] &gt; f[u][1])
            f[u][1]=f[v][0]+w[i];
    }
    
    ans=max(ans,f[u][0]+f[u][1]);
}

int main()
{
    cin&gt;&gt;n;
    memset(h,-1,sizeof h);
    for(int i=0;i&lt;n-1;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
        add(b,a,c);
    }

    dfs(1,-1);

    cout&lt;&lt;ans&lt;&lt;endl;

    return 0;
}
</code></pre>
<h3 id="hdu2196"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2196">hdu2196</a></h3>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_8fd00bd859-5.png" alt="5.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_97f5be6659-6.png" alt="6.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9a64697c59-7.png" alt="7.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9cf7fd0c59-8.png" alt="8.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_a95f556859-9.png" alt="9.png" loading="lazy"><br>
f[i][0]表示根节点为i，向下所能到达的最长路径长度<br>
f[i][1]表示根节点为i，向下所能到达的次长路径长度<br>
f[i][2]表示根节点为i，向上所能到达的最长路径长度</p>
<p>（1）f[i][0]，f[i][1]的求法同树的直径<br>
（2）f[i][2]的求法分两种情况：<br>
①从父结点向上走的最长路径长度<br>
②从父节点向下走其他子树的最长路径长度（若父节点向下走的最长路径经过当前点，则向下走其他子树的最长路径长度为父节点向下走的次长路径长度；若不经过，则取父节点向下走的最长路径）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=10010,M=N*2;
int h[N],e[M],ne[M],w[M],idx;
int n;
int f[N][3]; // 0表示向下走的最大长度，1表示次大长度，2表示向上走的最大长度

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs_d(int u,int fa)
{
    int one=0,two=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        dfs_d(j,u);
        //cout&lt;&lt;u&lt;&lt;&quot;:&quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;
        int d=f[j][0]+w[i];
        if(d &gt; one) 
            two=one,one=d;
        else if(d &gt; two)
            two=d;
    }
    f[u][0]=one;
    f[u][1]=two;
}

void dfs_u(int u,int fa)//先更新后递归
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa) 
            continue;
        if(f[j][0] + w[i] == f[u][0])//父节点向下走的最长路径经过当前点
            f[j][2]=max(f[u][2],f[u][1])+w[i];
        else 
            f[j][2]=max(f[u][2],f[u][0])+w[i];//父节点向下走的最长路径不经过当前点
        dfs_u(j,u);
    }
}

int main()
{
    while(~scanf(&quot;%d&quot;,&amp;n))
    {
        memset(h,-1,sizeof h);
        memset(f,0,sizeof f);
        idx=0;
        
        for(int i=2;i&lt;=n;i++)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            add(i,a,b);
            add(a,i,b);
        }
        
        dfs_d(1,-1);//子节点更新父节点
        
        dfs_u(1,-1);//父节点更新子节点
        
        for(int i=1;i&lt;=n;i++)
            cout&lt;&lt;max(f[i][0],f[i][2])&lt;&lt;endl;
    }
    
    return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_87cfb6ac54-azdp.png" alt="azdp.png" loading="lazy"><br>
我们通常认为，树形DP的写法有两种：<br>
a.根到叶子: 不过这种动态规划在实际的问题中运用的不多。<br>
b.叶子到根: 既根的子节点传递有用的信息给根，完后根得出最优解的过程。这类的习题比较的多。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_9c10e58c54-1.png" alt="1.png" loading="lazy"><br>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1520">hdu1520</a></p>
<h4 id="最大独立集">最大独立集</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_cc54b78254-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_d8be803454-3.png" alt="3.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int N=6000+10;
int val[N],dp[N][2],fa[N],n;
vector&lt;int&gt;E[N];

void dfs(int u){
	dp[u][0]=0;
	dp[u][1]=val[u];
	for(int i=0;i&lt;E[u].size();i++){
		int v=E[u][i];
		dfs(v);
		dp[u][0]+=max(dp[v][1],dp[v][0]);
		dp[u][1]+=dp[v][0];
	}
}

int main(){
	while(~scanf(&quot;%d&quot;,&amp;n)){
		for(int i=1;i&lt;=n;i++){
			scanf(&quot;%d&quot;,&amp;val[i]);
			E[i].clear();
			fa[i]=-1;
		}
		while(1){
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
	        if(a==0&amp;&amp;b==0) break;
	        E[b].push_back(a);
	        fa[a]=b;
		}
	    int rt=1;
	    while(fa[rt]!=-1) rt=fa[rt];
	    dfs(rt);
	    printf(&quot;%d\n&quot;,max(dp[rt][1],dp[rt][0]));
    }
    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=3398">poj3398</a></p>
<h4 id="最小支配集">最小支配集</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_0583dd4659-1.png" alt="1.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9030541459-2.png" alt="2.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_a03cff4259-3.png" alt="3.png" loading="lazy"> <img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_b3418f3659-4.png" alt="4.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int n;
vector&lt;int&gt; E[maxn];
int dp[maxn][3];

void dfs(int u,int fa)
{
    dp[u][0]=1; //加上自身为服务器,选择当前结点 
    dp[u][1]=0;//不选当前结点，选其父节点 
    dp[u][2]=maxn;//选一个子节点 
    int k=E[u].size();
    for(int i=0;i&lt;k;i++)
    {
        int v=E[u][i];
        if(v==fa) continue;
        dfs(v,u);
        dp[u][0]+=min(dp[v][0],dp[v][1]);
        dp[u][1]+=dp[v][2];
    }
    for(int i=0;i&lt;k;i++)
    {
        int v=E[u][i];
        if(v==fa)  continue;
        dp[u][2]=min(dp[u][2],dp[u][1]-dp[v][2]+dp[v][0]);
    }
}

int main()
{
    int u,v;
    while(scanf(&quot;%d&quot;,&amp;n))
    {
        for(int i=1;i&lt;=n;i++)
            E[i].clear();
        for(int i=1;i&lt;n;i++)
        {
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            E[u].push_back(v);
            E[v].push_back(u);
        }
        dfs(1,0);
		printf(&quot;%d\n&quot;,min(dp[1][0],dp[1][2])); 
		int t;
		scanf(&quot;%d&quot;,&amp;t);
		if(t == -1)
			break;
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1079/#">acwing1077</a><br>
题目说的很清楚，用最少的点覆盖所有的点。题目给出的是个树,所以可以用动态规划来解决。<br>
给出如下定义：<br>
f[u][0]表示 u不放看守 ,且u点被父节点监视,<br>
易得在这类情况下子节点可以自己放守卫或者在子节点上放守卫。<br>
由于有多个子节点，为使得所有子节点都被看守，<br>
所以每个节点的最小值累加求和<br>
f[u][0] = ∑(min(f[j][1] , f[j][2]))</p>
<p>f[u][2]表示u放看守,<br>
既然u已经放上了看守，说明子节点必然已经被看到，<br>
因此对于所有子节点可自己放守卫，可被父节点监视，可被子节点监视<br>
f[u][2] = ∑min(min(f[j][0],f[j][1]),f[j][2])+w[u]</p>
<p>f[u][1]表示 u不放看守 ,且u点被一个儿子监视,<br>
首先我们可以枚举当前哪一颗子结点监视u，其余节点可自己放守卫或在子节点放守卫，<br>
f[u][1]=min(f[u][1],f[j][2]+∑min(f[k][2],f[k][1])),j为当前监视u的结点，k为除了j之外u其他的子节点<br>
而f[u][0]=∑(min(f[j][1] , f[j][2]))<br>
则f[u][1]=min(f[u][1],f[j][2]+f[u][0] - min(f[j][2],f[j][1]))</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1510;

int n;
int h[N], w[N], e[N], ne[N], idx;
int f[N][3];
int fa[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    f[u][2] = w[u];

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        f[u][0] += min(f[j][1], f[j][2]);
        f[u][2] += min(min(f[j][0], f[j][1]), f[j][2]);
    }

    f[u][1] = 1e9;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        f[u][1] = min(f[u][1], f[u][0] + f[j][2] - min(f[j][1], f[j][2]));
    }
}

int main()
{
    cin &gt;&gt; n;

    memset(h, -1, sizeof h);
    memset(fa,-1,sizeof fa);
    for (int i = 1; i &lt;= n; i ++ )
    {
        int id, cost, cnt;
        cin &gt;&gt; id &gt;&gt; cost &gt;&gt; cnt;
        w[id] = cost;
        while (cnt -- )
        {
            int ver;
            cin &gt;&gt; ver;
            add(id, ver);
            fa[ver]=id;
        }
    }

    int root = 1;
    while (fa[root] != -1) root =fa[root] ;

    dfs(root);

    cout &lt;&lt; min(f[root][1], f[root][2]) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2412">hdu2412</a></p>
<h4 id="最大独立集唯一性判断">最大独立集+唯一性判断</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_2ff74c5054-4.png" alt="4.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_3ad95a6454-5.png" alt="5.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_5315ab5054-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_6272ec5c54-7.png" alt="7.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int N=200+10;
int dp[N][2],f[N][2],n;
vector&lt;int&gt;E[N];

void dfs(int u){
   	dp[u][0]=0;
	dp[u][1]=1;
	for(int i=0;i&lt;E[u].size();i++){
		int v=E[u][i];
		dfs(v);
		if(dp[v][0]==dp[v][1]){
			dp[u][0]+=dp[v][0];
			f[u][0]=0;
		}else if(dp[v][0]&gt;dp[v][1]){
			dp[u][0]+=dp[v][0];
			if(!f[v][0]) f[u][0]=0;
		}
		else{
			dp[u][0]+=dp[v][1];
			if(!f[v][1]) f[u][0]=0;
		}
		dp[u][1]+=dp[v][0];
		if(!f[v][0]) f[u][1]=0;
	}
}

int main(){
	int n,k;
	string s1,s2;
	map&lt;string,int&gt;mp;
	while(cin&gt;&gt;n&amp;&amp;n){//n为0时结束 
		mp.clear();
		for(int i=0;i&lt;=n;i++)//尽量不要使用memset清0的办法，尽管也可以用 
			E[i].clear();
		memset(f,1,sizeof(f));
		k=1;
		cin&gt;&gt;s1;
		mp[s1]=k++;
		E[0].push_back(mp[s1]);//增加超根 
		for(int i=1;i&lt;=n-1;i++){
			cin&gt;&gt;s1&gt;&gt;s2;
			if(mp[s1]==0)
				mp[s1]=k++;
			if(mp[s2]==0)
				mp[s2]=k++;
			E[mp[s2]].push_back(mp[s1]);
		}
	    dfs(0);
	    printf(&quot;%d &quot;,dp[0][0]);
	    if(f[0][0])
	    	printf(&quot;Yes\n&quot;);
		else
			printf(&quot;No\n&quot;);	
    }
    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=1463">poj1463</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_06bf19b654-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_2d62973254-9.png" alt="9.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int N=1500+10;
int val[N],dp[N][2],fa[N],n;
vector&lt;int&gt;E[N];

void dfs(int u){
	dp[u][0]=0;
	dp[u][1]=1;
	for(int i=0;i&lt;E[u].size();i++){
		int v=E[u][i];
		dfs(v);
		dp[u][1]+=min(dp[v][1],dp[v][0]);
		dp[u][0]+=dp[v][1];
	}
}

int main(){
	while(~scanf(&quot;%d&quot;,&amp;n)){
		for(int i=0;i&lt;n;i++)//编号从0开始 
			E[i].clear();
		memset(fa,-1,sizeof(fa));
		memset(dp,0,sizeof(dp));
		for(int i=0;i&lt;n;i++){
			int a,b,m;
			scanf(&quot;%d:(%d)&quot;,&amp;a,&amp;m);//注意读入 
	        while(m--)
	        {
	        	scanf(&quot;%d&quot;,&amp;b);
	        	E[a].push_back(b);
	        	fa[b]=a;
			}
		}
	    int rt=0;//编号从0开始
	    while(fa[rt]!=-1) rt=fa[rt];
	    dfs(rt);
	    printf(&quot;%d\n&quot;,min(dp[rt][1],dp[rt][0]));
    }
    return 0;
}
</code></pre>
<h4 id="背包类树形dp">背包类树形dp</h4>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1561">hdu1561</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_e427e85a54-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/22/9969_e76dea7854-12.png" alt="12.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/26/9969_8e4c463458-19.PNG" alt="19.PNG" loading="lazy"><br>
加上虚根一共m+1个结点</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 210,M=N*2;
int n, m;
int w[N];
int h[N], e[M], ne[M], idx;
int f[N][N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int son=e[i];
        dfs(son);
        for (int j = m ; j &gt;= 0; j -- )
            for (int k = 0; k &lt;= j; k ++ )
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }

    for (int j = m+1; j &gt;= 1; j -- ) f[u][j] = f[u][j - 1] + w[u];
    for (int j = 0; j &lt; 1; j ++ ) f[u][j] = 0;
}

int main()
{
    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n)
    {
    	memset(h, -1, sizeof h);
    	memset(f,0,sizeof f);
    	idx=0;
	    for (int i = 1; i &lt;= n; i ++ )
	    {
	    	int a,b;
	    	cin&gt;&gt;a&gt;&gt;b;
	    	if(!a)
	    		add(0,i);
	    	else 
	    		add(a,i);
	    	w[i]=b;
	    }
	
	    dfs(0);
	
	    cout &lt;&lt; f[0][m+1]&lt;&lt; endl;
	}

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/288/">acwing286</a><br>
同背包类树形dp</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 310;

int n, m;
int h[N], e[N], ne[N], idx;
int w[N];
int f[N][N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int son = e[i];
        dfs(son);

        for (int j = m - 1; j &gt;= 0; j -- )
            for (int k = 0; k &lt;= j; k ++ )
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }

    for (int i = m; i&gt;=1; i -- ) f[u][i] = f[u][i - 1] + w[u];
    for(int i=0;i&lt;1;i++) f[u][i]=0;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;

    memset(h, -1, sizeof h);
    for (int i = 1; i &lt;= n; i ++ )
    {
        int p;
        cin &gt;&gt; p &gt;&gt; w[i];
        add(p, i);
    }

    m ++ ;
    dfs(0);

    cout &lt;&lt; f[0][m] &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1077/">acwing1075</a><br>
如果x和y可以互相转化，就连接一条无向边，最后得到的图其实是一个森林，每棵树都是无根树，其实就是要求，整个森林中两个连通的点的最远距离（这里边权都是1），和在无根树中求两点最远距离是一样的，不过这题的特殊性，可以更方便点<br>
对于任意一条边，必有x&lt;y，在树中，x就应该为y的双亲（因为y的约数和是唯一的，但x可能是很多个数的约数和，这正好对应树的关系，双亲唯一，孩子不定）。而dp思想照样是找出每个节点到叶子的最大值m1和次大值m2，再两者相加的dp[rt]，而整个树中的最大值，就是扫描全部节点，找到最大的dp[rt]<br>
由于这题，每个节点的双亲是可以记录下来的，所以dp的时候不用递归，而写成递推式，直接从叶往上递推，<br>
还有一个重要的时候就是怎么找出约数和，数据比较大，应该尽量避免多余的判断，用筛法求约数和则是一个不错的方法</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int N=50010;
int f[N][2];
int sum[N];
 
int main()
{
   cin&gt;&gt;n;
   
   for(int i=1;i&lt;=n;i++)
		for(int j=2*i;j&lt;=n;j+=i)//求约数和 
			sum[j]+=i;
	
	for(int i=n;i&gt;=1;i--)
	{
		if(sum[i]&lt;i)//判断是否符合条件，注意审题。
		{
			if(f[i][0]+1&gt;f[sum[i]][0])
			{
				f[sum[i]][1]=f[sum[i]][0];
				f[sum[i]][0]=f[i][0]+1;
			}
			else if(f[i][0]+1&gt;f[sum[i]][1])
				f[sum[i]][1]=f[i][0]+1;
		} 
	}
	int ans=0;
	for(int i=1;i&lt;=n;i++)
		ans=max(f[i][0]+f[i][1],ans);
	cout&lt;&lt;ans&lt;&lt;endl;
	
   return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1076/">acwing1074</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/26/9969_ab1a78b058-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/26/9969_b31a9ed258-21.PNG" alt="21.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110, M = N * 2;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int f[N][N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int father)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        if (e[i] == father) continue;
        dfs(e[i], u);
        for (int j = m; j&gt;=0; j -- )
            for (int k = 0; k &lt; j; k ++ )
                f[u][j] = max(f[u][j], f[u][j - k - 1] + f[e[i]][k] + w[i]);
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; n - 1; i ++ )
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        add(a, b, c), add(b, a, c);
    }

    dfs(1, -1);

    printf(&quot;%d\n&quot;, f[1][m]);

    return 0;
}
</code></pre>
<h4 id="左儿子右兄弟">左儿子右兄弟</h4>
<p><a href="http://poj.org/problem?id=2486">POJ2486</a><br>
题目大意：一个叫Wshxzt的可爱的女孩子被HX大叔带到了一棵苹果树边。众所周知，苹<br>
果树是一个树形的结构，在节点处长有苹果）。现在我们知道Wshxzt是个苹果控，她只要访问到一个节点，就一定会吃光这个节点所有的苹果。当然一个节点的苹果只能吃一次。HX大叔为了防止Wshxzt长胖，限制她只能走K（1 ≤ K ≤ 200）步，从一个节点走到另<br>
一个相邻的节点是所谓走一步。Wshxzt从节点1开始。树上的节点有N（1 ≤ N ≤ 100）<br>
个，你需要计算Wshxzt最多能吃到多少苹果。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_166db48459-001.png" alt="001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_2201b2aa59-002.png" alt="002.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_367c7b2059-003.png" alt="003.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_3952b18e59-004.png" alt="004.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=110,M=N*2;
int n,m,cnt;
//dp[u][j][0]表示以u为根的树经过j步没有回到点u得到的最值
//dp[u][j][1]表示以u为根的树经过j步回到点u得到的最值 
int dp[N][M][2],val[N],head[N];
 
struct edge{
	int v,next;
}e[M];
 
void init(){
	memset(head,-1,sizeof(head));
	memset(dp,0,sizeof(dp));
	cnt=0;
}
 
void add(int u,int v){
	e[cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt++;
}
 
void dfs(int u,int fa){
	for(int i=0;i&lt;=m;i++)//不论走多少步，均初始化为 
		dp[u][i][0]=dp[u][i][1]=val[u];
	for(int i=head[u];~i;i=e[i].next){
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		for(int j=m;j&gt;=1;j--){//树形背包 
			for(int k=1;k&lt;=j;k++){
				dp[u][j][0]=max(dp[u][j][0],dp[u][j-k][1]+dp[v][k-1][0]);
				if(k&gt;=2) dp[u][j][0]=max(dp[u][j][0],dp[u][j-k][0]+dp[v][k-2][1]);
				if(k&gt;=2) dp[u][j][1]=max(dp[u][j][1],dp[u][j-k][1]+dp[v][k-2][1]);
			}
		}
	}
}
 
int main(){
	int u,v;
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){
		init();
		for(int i=1;i&lt;=n;++i)
			scanf(&quot;%d&quot;,&amp;val[i]);
		for(int i=1;i&lt;n;++i){
			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
			add(u,v);
			add(v,u);
		}
		dfs(1,-1);
		printf(&quot;%d\n&quot;,max(dp[1][m][0],dp[1][m][1]));
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/UVA12186">uva12186</a><br>
一个老板和n个员工组成树状结构，每个员工都有自己的唯一上司，老板的编号为0，员工1~n，工人们打算签署一个志愿书给老板，但无法跨级，当一个中级员工（非是工人的员工）的直属下属中不小于T%的人签字时，他也会签字并且递给他的直属上司，问：要让老板收到请愿书至少需要多少个工人签字。<br>
注意：这里要求的是最底层工人（即叶子结点）的最少个数。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_9266e0c059-0001.png" alt="0001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/27/9969_73948b9259-0002.png" alt="0002.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;

using namespace std;
const int N=100010;
vector&lt;int&gt; E[N];
int n,T;

int dfs(int u)
{
	if(E[u].size() == 0)
		return 1;
	vector&lt;int&gt; res;
    for(int i=0;i&lt;E[u].size();i++)
    {
    	int j=E[u][i];
    	int t=dfs(j);
    	res.push_back(t);
	}
	
	sort(res.begin(),res.end());
	int k=E[u].size();
	int c=(k*T-1)/100+1;
	int ans=0;
	for(int i=0;i&lt;c;i++)
		ans+=res[i];

	return ans;
}

int main()
{
    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;T)&amp;&amp;n){
        for(int i=0;i&lt;=n;i++)
			E[i].clear();
        for(int i=1;i&lt;=n;i++)
        {
            int u;
            scanf(&quot;%d&quot;,&amp;u);
            E[u].push_back(i);
        }
        printf(&quot;%d\n&quot;,dfs(0));
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LCA]]></title>
        <id>https://caifxh.github.io/post/lca/</id>
        <link href="https://caifxh.github.io/post/lca/">
        </link>
        <updated>2020-04-06T03:50:22.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ebac8e3a56-0001.png" alt="0001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_f3642cbe56-0002.png" alt="0002.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_01286f7256-0003.png" alt="0003.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_0e8b262856-0004.png" alt="0004.png" loading="lazy"></p>
<h4 id="暴力">暴力</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_25639d9456-0005.png" alt="0005.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_285eb8e456-0006.png" alt="0006.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_3b0b44da56-0007.png" alt="0007.png" loading="lazy"><br>
<a href="http://poj.org/problem?id=1330">poj1330</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_634786a256-01.png" alt="01.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
const int maxn=10010;
int fa[maxn];
bool flag[maxn];

int LCA(int u,int v)
{
    if(u==v)
    	return u;
	flag[u]=1;
	while(fa[u]!=u)//u向上走到根 
	{
		u=fa[u];
		flag[u]=1;
	}
	if(flag[v]) 
		return v;
	while(fa[v]!=v)//v向上走
	{
		v=fa[v];
		if(flag[v])
			return v;
	}
	return 0;   	
}

int main()
{
	int n,u,v,T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
		{
			fa[i]=i;
			flag[i]=0;
		} 
		for(int i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
			fa[v]=u;
		}
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		printf(&quot;%d\n&quot;,LCA(u,v));
	}
	return 0;
}
</code></pre>
<h4 id="树上倍增">树上倍增</h4>
<p>用树上倍增法求LCA的时间复杂度为O((n+m)logn)。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_e1ee9b0856-02.png" alt="02.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_040ed6bc56-04.png" alt="04.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_073739f656-05.png" alt="05.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_0c3d228a56-06.png" alt="06.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_21a1fd3a56-07.png" alt="07.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_2e88049056-08.png" alt="08.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_3e3f101856-09.png" alt="09.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_4e5cc82856-10.png" alt="10.png" loading="lazy"></p>
<h4 id="步骤">步骤</h4>
<p>1.建立一个空队列，并将根节点入队，同时存储根节点的深度<br>
2.取出队头，遍历其所有出边。由于存储的时候是按照无向图存储，因此要进行深度判定，对于连接到它父亲节点的边，直接continue即可。记当前路径的另一端节点为y，处理出y的d、f两个数组的值，然后将y入队。<br>
3.重复第2步，直到队列为空<br>
以上部分是树上倍增法的预处理，也是比较通用的对于树上倍增的预处理，时间复杂度O(nlogn)<br>
。接下来是求LCA的核心部分。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_182d302457-00000.PNG" alt="00000.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/1174/">acwing1172</a></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 40010, M = N * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][16];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k &lt;= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 15; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 15; k &gt;= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    int root = 0;
    memset(h, -1, sizeof h);

    for (int i = 0; i &lt; n; i ++ )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        if (b == -1) root = a;
        else add(a, b), add(b, a);
    }

    bfs(root);

    scanf(&quot;%d&quot;, &amp;m);
    while (m -- )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        int p = lca(a, b);
        if (p == a) puts(&quot;1&quot;);
        else if (p == b) puts(&quot;2&quot;);
        else puts(&quot;0&quot;);
    }

    return 0;
}
</code></pre>
<h4 id="离线tarjan">离线tarjan</h4>
<p>Tarjan算法求LCA的本质是用并查集对向上标记法进行优化，是一种离线算法，时间复杂度O(n+m)。<br>
在深度优先遍历的任意时刻，树中结点分为三类：<br>
1.已经访问完毕并且回溯的结点，在这些结点上标记一个整数2.<br>
2，已经开始递归，但尚未回溯的点。这些结点就是当前正在访问的结点，x以及x的祖先。在这些结点上标记一个整数1.<br>
3.尚未访问的绩点。这些结点没有标记。<br>
对于正在访问的结点x，它到根节点的路劲已经标记为1.若y是已经访问完毕并且回溯的节点，则LCA（x，y）就是从y向上走到根，第一个遇到的标记为1的节点。<br>
可以利用并查集进行优化，当一个结点获得整数2的标记时，把它所在的集合合并到它的父节点所在的集合中（合并时它的父节点标记一定为1，且单独构成一个集合）。<br>
此时扫描与x相关的所有询问，若询问的另一个点y的标记为2，就知道l该孙文的回答应该是y所在并查集中的代表元素。<br>
这样，Tarjan算法求LCA的步骤就很明了了：</p>
<p>1.从根节点开始进行dfs<br>
2.将当前节点标记为1<br>
3.遍历当前节点的所有出边；若当前边的终点还没有访问过，则访问它，访问过后将该节点合并到当前节点的集合中；<br>
4.遍历与当前节点相关的所有询问；若当前询问的另一个节点的标记为2，则该询问的答案即为另一个节点所在集合的代表元素<br>
5.将当前节点标记为2</p>
<p><a href="https://www.acwing.com/problem/content/1173/">acwing1171</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
const int N=10010,M=N*2;
int h[N],e[M],ne[M],w[M],idx;
int n,m;
typedef pair&lt;int,int&gt; PII;
#define x firsst
#define y second
vector&lt;PII&gt; query[N];//first存储查询的另外一个点，second存查询编号
int res[M];
int st[N];
int p[N];
int dist[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}


void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        dist[j]=dist[u]+w[i];
        dfs(j,u);
    }
}

void tarjan(int u)
{
    st[u]=1;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])
        {
            tarjan(j);
            p[j]=u;
        }
    }
    
    for(int i=0;i&lt;query[u].size();i++)
    {
        int y=query[u][i].first,id=query[u][i].second;
        if(st[y] == 2)
        {
            int anc=find(y);
            res[id]=dist[u]+dist[y]-dist[anc]*2;
        }
    }
    st[u]=2;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    
    for(int i=0;i&lt;n-1;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
        add(b,a,c);
    }
    
    for(int i=0;i&lt;m;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(a != b)
        {
            query[a].push_back({b,i});
            query[b].push_back({a,i});
        }
    }
    
    for(int i=1;i&lt;=n;i++)
        p[i]=i;
    
    dfs(1,-1);
    
    tarjan(1);
    
    for(int i=0;i&lt;m;i++)
        cout&lt;&lt;res[i]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="lca求次小生成树">lca求次小生成树</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ee11055656-13.PNG" alt="13.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_0fa2ff0856-2.png" alt="2.png" loading="lazy"><br>
我们假设一条路径是由三段构造而成.是三段,不是就三个点.a-&gt;c,c-&gt;b,b-&gt;a(转自秦同学题解)<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_a07e83ee56-14.PNG" alt="14.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_a8d7c74856-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_cb3cbf6e56-16.PNG" alt="16.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ceafad0056-17.PNG" alt="17.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 300010, INF = 0x3f3f3f3f;

int n, m;
struct Edge
{
    int a, b, w;
    bool used;
    bool operator&lt; (const Edge &amp;t) const
    {
        return w &lt; t.w;
    }
}edge[M];
int p[N];
int h[N], e[M], w[M], ne[M], idx;
int depth[N], fa[N][17], d1[N][17], d2[N][17];
int q[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

LL kruskal()
{
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;
    sort(edge, edge + m);
    LL res = 0;
    for (int i = 0; i &lt; m; i ++ )
    {
        int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w;
        if (a != b)
        {
            p[a] = b;
            res += w;
            add(edge[i].a, edge[i].b, w), add(edge[i].b, edge[i].a, w);
            edge[i].used=true;
        }
    }

    return res;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    q[0] = 1;
    int hh = 0, tt = 0;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                d1[j][0] = w[i], d2[j][0] = -INF;
                for (int k = 1; k &lt;= 16; k ++ )
                {
                    int anc = fa[j][k - 1];
                    fa[j][k] = fa[anc][k - 1];
                    int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]};
                    d1[j][k] = d2[j][k] = -INF;
                    for (int u = 0; u &lt; 4; u ++ )
                    {
                        int d = distance[u];
                        if (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;
                        else if (d &lt; d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;
                    }
                }
            }
        }
    }
}

int lca(int a, int b, int w)
{
    static int distance[N * 2];
    int cnt = 0;
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 16; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
        {
            distance[cnt ++ ] = d1[a][k];
            distance[cnt ++ ] = d2[a][k];
            a = fa[a][k];
        }
    if (a != b)
    {
        for (int k = 16; k &gt;= 0; k -- )
            if (fa[a][k] != fa[b][k])
            {
                distance[cnt ++ ] = d1[a][k];
                distance[cnt ++ ] = d2[a][k];
                distance[cnt ++ ] = d1[b][k];
                distance[cnt ++ ] = d2[b][k];
                a = fa[a][k], b = fa[b][k];
            }
        distance[cnt ++ ] = d1[a][0];
        distance[cnt ++ ] = d1[b][0];
    }

    int dist1 = -INF, dist2 = -INF;
    for (int i = 0; i &lt; cnt; i ++ )
    {
        int d = distance[i];
        if (d &gt; dist1) dist2 = dist1, dist1 = d;
        else if (d &lt; dist1 &amp;&amp; d &gt; dist2) dist2 = d;
    }

    if (w != dist1) 
        return w - dist1;
    return w - dist2;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; m; i ++ )
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        edge[i] = {a, b, c};
    }

    LL sum = kruskal();
    
    bfs();

    LL res = 1e18;
    for (int i = 0; i &lt; m; i ++ )
        if (!edge[i].used)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            res = min(res, sum + lca(a, b, w));
        }
    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[状态机]]></title>
        <id>https://caifxh.github.io/post/zhuang-tai-ji/</id>
        <link href="https://caifxh.github.io/post/zhuang-tai-ji/">
        </link>
        <updated>2020-04-05T04:04:31.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/1051/">acwing1049</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_6f0c7d4276-33.PNG" alt="33.PNG" loading="lazy"><br>
不合法状态按照问题的性质初始化为INF(求最小值)/-(求最大值)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100010,INF=0x3f3f3f3f;
int w[N];
int f[N][2];

int main()
{
    int t;
    cin&gt;&gt;t;
    while(t--)
    {
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;w[i]);
        
        f[0][0]=0,f[0][1]=-INF;
        for(int i=1;i&lt;=n;i++)
        {
            f[i][0]=max(f[i-1][0],f[i-1][1]);
            f[i][1]=f[i-1][0]+w[i];
        }
        printf(&quot;%d\n&quot;,max(f[n][0],f[n][1]));
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1059/">acwing1057</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/04/9969_1479fc8076-29.PNG" alt="29.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_f409bd6e76-31.PNG" alt="31.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100010,M=110;
int w[N];
int f[N][M][2];

int main()
{
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;w[i];
    memset(f,-0x3f,sizeof f);
    for(int i=0;i&lt;=n;i++) f[i][0][0]=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=k;j++)
        {
            f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i]);
            f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0]-w[i]);
        }
    int res=0;
    for(int i=0;i&lt;=k;i++)
        res=max(res,f[n][i][0]);
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1060/">acwing1058</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_0cd946fa76-32.PNG" alt="32.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100010, INF = 0x3f3f3f3f;

int n;
int w[N];
int f[N][3];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);

    f[0][0] = f[0][1] = -INF, f[0][2] = 0;
    for (int i = 1; i &lt;= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]);
        f[i][1] = f[i - 1][0] + w[i];
        f[i][2] = max(f[i - 1][2], f[i - 1][1]);
    }

    printf(&quot;%d\n&quot;, max(f[n][1], f[n][2]));

    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3401">poj3401</a><br>
最近，lxhgww沉迷于股票，经过几天的研究，他发现了一些规律的模式。<br>
他预测未来T天的股票市场。 在第i天，您可以以APi的价格购买一只股票或卖出一只股票以获得BPi。<br>
还有其他一些限制，即在第一天就可以购买最多ASi股票，最多可以卖出BSi股票。两个交易日的间隔应大于W天。 也就是说，假设您在第i天进行了交易（<strong>任何买卖股票都被视为一项交易</strong>），那么下一个交易日必须在第（i + W + 1）天或更晚的时间进行。而且，任何时候最多只能拥有MaxP股票。<br>
在第一天之前，lxhgww已经拥有无限的资金，但是没有股票，当然，他希望从股市中赚到尽可能多的钱。 所以问题来了，他最多只能赚多少钱？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_d66ad1ba76-34.png" alt="34.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_f1520dcc76-35.PNG" alt="35.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_4584aa0276-36.png" alt="36.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_79e2bd3476-37.png" alt="37.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_7d04775a76-38.PNG" alt="38.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_d9bc776276-40.PNG" alt="40.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/05/9969_dd41f1f076-39.png" alt="39.png" loading="lazy"><br>
动态规划方程：<br>
1.不买不卖。dp[i][j]=max(dp[i-1][j],dp[i][j]);<br>
2.买一些股票。dp[i][j]=max(dp[i-1][k]-(j-k)*ap[i]);(0&lt;=k&lt;=j&lt;=Maxp)<br>
3.卖一些股票。dp[i][j]=max(dp[i-1][k]+(k-j)*bp[i]);(0&lt;=j&lt;=k&lt;=Maxp)<br>
注意：<br>
1.把所有未定义的状态都设置为-INF，1~w+1天得初始化，因为这些天不能有前面的状态推出来，初始化为对应购买多少股票所减去的钱数，因为一开始只有买，不能卖。<br>
2.循环的递减还是递增问题，跟当前要访问的状态有关。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=2010;
int f[N][N];
int ap[N],bp[N];//买入价格，卖出价格 
int as[N],bs[N];//买入限制，卖出限制
int q[N];
int n,m,w;

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;w);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d%d%d%d&quot;,&amp;ap[i],&amp;bp[i],&amp;as[i],&amp;bs[i]);
    
        memset(f,-0x3f,sizeof f);
        f[0][0]=0;
        for(int i=1;i&lt;=w+1;i++)
            for(int j=0;j&lt;=as[i];j++)
                f[i][j]=-j*ap[i];
        
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=0;j&lt;=m;j++)
                f[i][j]=max(f[i][j],f[i-1][j]);//没有交易
            if(i &lt;= w+1) continue;
            int hh=0,tt=-1;
            for(int j=0;j&lt;=m;j++)
            {
                if(hh &lt;= tt &amp;&amp; j-as[i] &gt; q[hh]) 
                    hh++;
                
                while(hh&lt;=tt &amp;&amp; f[i-w-1][j]+j*ap[i] &gt;= f[i-w-1][q[tt]]+q[tt]*ap[i])
                    tt--;
                q[++tt]=j;
                f[i][j]=max(f[i][j],f[i-w-1][q[hh]]+q[hh]*ap[i]-j*ap[i]);//买入 
             } 
             
            hh=0,tt=-1;
            for(int j=m;j&gt;=0;j--)
            {
                if(hh &lt;= tt &amp;&amp; j+bs[i] &lt; q[hh]) 
                    hh++;
                
                while(hh&lt;=tt &amp;&amp; f[i-w-1][j]+j*bp[i] &gt;= f[i-w-1][q[tt]]+q[tt]*bp[i])
                    tt--;
                q[++tt]=j;
                f[i][j]=max(f[i][j],f[i-w-1][q[hh]]+q[hh]*bp[i]-j*bp[i]);//卖出 
             } 
        }
        printf(&quot;%d\n&quot;,f[n][0]);
    }
    return 0;
 } 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[欧拉路径]]></title>
        <id>https://caifxh.github.io/post/ou-la-lu-jing/</id>
        <link href="https://caifxh.github.io/post/ou-la-lu-jing/">
        </link>
        <updated>2020-04-04T15:37:39.000Z</updated>
        <content type="html"><![CDATA[<h4 id="欧拉路">欧拉路</h4>
<p>通过图（无向图或有向图）中所有边一次且仅一次行遍图中所有顶点的通路称为欧拉通路，通过图中所有边一次且仅一次行遍所有顶点的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_eebc2c825a-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_025de6545a-3.PNG" alt="3.PNG" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_06e3a60e5a-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_0436e9d05a-5.PNG" alt="5.PNG" loading="lazy"><br>
(注意：这里说有向图连通，说的是有向图是弱连通图。即把有向图中的边变成无向边，只要该图连通，那么原有向图即是弱连通图。实际中可用并查集判断是否弱连通)<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_bfab780c5a-6.PNG" alt="6.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_0be375da5a-7.PNG" alt="7.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/29/9969_c5661c205a-8.PNG" alt="8.PNG" loading="lazy"></p>
<p>• 欧拉回路的求解方法主要有两种：</p>
<ul>
<li>DFS搜索</li>
<li>Fleury算法</li>
</ul>
<p>用 DFS 搜索思想求解欧拉回路的思路为：</p>
<ul>
<li>利用欧拉定理判断出一个图存在欧拉通路或欧拉回路。</li>
<li>选择一个正确的起始顶点，用 DFS 算法遍历所有的边（每条边<br>
只遍历一次），遇到走不通就回退。 • 在搜索前进方向上将遍历过的边按顺序记录下来。</li>
<li>这组边的排列就组成了一条欧拉通路或欧拉回路。</li>
</ul>
<h4 id="例题">例题</h4>
<p>给定 n 张骨牌，每张骨牌有左右两个点数（从 1 到 6）。问能不能<br>
通过交换骨牌的顺序和交换左右两个点数，使得任意两个相邻骨牌的<br>
相邻段为相等的数字。<br>
原始： (1 2)(2 4)(2 4)(6 4)(2 1)<br>
重排后： (4 2)(2 1)(1 2)(2 4)(4 6)</p>
<p>本题可以转化成欧拉回路或欧拉通路的求解问题。</p>
<ul>
<li>首先要构造一个图？</li>
<li>每张骨牌当一个点？</li>
<li>如何解决交换骨牌内部两个点数？</li>
</ul>
<p>图建好之后，先判断是否存在欧拉通路或欧拉回路。<br>
总结：存在 ➔ 选择正确的起点 ➔ 6 ➔ 开始 DFS</p>
<p><a href="https://www.acwing.com/problem/content/1125/">acwing1123</a><br>
我们将这个图看成有向图，对于每输入一组数据加两条有向边，需要每条边都至少走一遍<br>
我们先回想一下存在有向图的欧拉路径的充分必要条件</p>
<ul>
<li>所有点的入度都等于出度</li>
<li>除了两个点以外的点入度等于出度，</li>
</ul>
<p>这两个点一个 入度 = 出度 + 1，另一个 入度 = 出度 - 1<br>
因此，我们考虑每加一条边，每个点的入度和出度都加1<br>
所以，每个点的入度都一定等于出度,符合上述的第一条<br>
故这个图存在欧拉路径，并且可以选任意点为起点<br>
所以我们只需统计所有的边的长度总和，跟据20km/h 算出时间即可</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    double x1, y1, x2, y2;
    cin &gt;&gt; x1 &gt;&gt; y1;

    double sum = 0;
    while (cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)
    {
        double dx = x1 - x2;
        double dy = y1 - y2;
        sum += sqrt(dx * dx + dy * dy) * 2;
    }

    int minutes = round(sum / 1000 / 20 * 60);
    int hours = minutes / 60;
    minutes %= 60;

    printf(&quot;%d:%02d\n&quot;, hours, minutes);

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1126/">acwing1124</a></p>
<p>无向图的欧拉路径&amp;欧拉回路裸题</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=510;
int n=500,m;
int g[N][N];
int ans[1100];
int cnt;
int d[N];

void dfs(int u)
{
    for(int i=1;i&lt;=n;i++)//从小到大枚举，字典序最小
    {
        if(g[u][i])
        {
            g[u][i]--,g[i][u]--;
            dfs(i);
        }
    }
    
    ans[cnt++]=u;
}

int main()
{
    cin&gt;&gt;m;
    
    int l=500,r=1;
    while(m--)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        l=min(l,min(a,b));
        r=max(r,max(a,b));
        g[a][b]++,g[b][a]++;
        d[a]++,d[b]++;
    }
    
    int start=l;
    for(int i=l;i&lt;=r;i++)
    {
        if(d[i] % 2)
        {
            start=i;
            break;
        }
    }
    
    dfs(start);//欧拉回路从哪开始都可以搜，欧拉路要从奇点开始
    
    for(int i=cnt-1;i&gt;=0;i--)//逆序输出
        printf(&quot;%d\n&quot;,ans[i]);
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1187/">acwing1185</a><br>
有向图，首尾连单词，可用DFS和并查集判断连通性</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 26, L = 1005;
int n, cnt, g[N][N], in[N], out[N];
char s[L];

void dfs(int u) {
    for (int i = 0; i &lt; 26; i++) {
        if(g[u][i]) {
            cnt++;
            g[u][i] --;
            dfs(i);
        }
    }
}
int main() {
    int T; scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        cnt = 0;
        memset(g, 0, sizeof g);
        memset(in, 0, sizeof in);
        memset(out, 0, sizeof out);
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 0; i &lt; n; i++) {
            scanf(&quot;%s&quot;, s);
            int u = s[0] - 'a', v = s[strlen(s) - 1] - 'a';
            g[u][v]++;
            out[u]++, in[v]++;
        }

        bool ok = true;
        int s = 0, t = 0;
        for (int i = 0; i &lt; 26; i++) {
            if(in[i] != out[i]) {
                if(in[i] == out[i] + 1) t ++;
                else if(in[i] + 1 == out[i]) s++;
                else { ok = false; break; }
            }
        }


        if(!(!s &amp;&amp; !t || (s == 1 &amp;&amp; t == 1))) ok = false;

        s = 0;
        while(!out[s]) s++;
        for (int i = 0; i &lt; 26; i++)
            if(in[i] + 1 == out[i]) { s = i; break; }

        dfs(s);

        if(cnt &lt; n) ok = false;
        puts(ok ? &quot;Ordering is possible.&quot; : &quot;The door cannot be opened.&quot;);
    }
    return 0;
}
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=30;
int n;
int din[N], dout[N], p[N];
bool st[N];


int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        memset(din,0,sizeof din);
        memset(dout,0,sizeof dout);
        memset(st,0,sizeof st);
        for(int i=0;i&lt;26;i++)
            p[i]=i;
        
        for(int i=0;i&lt;n;i++)
        {
            char str[1010];
            scanf(&quot;%s&quot;,str);
            int len=strlen(str);
            int a=str[0]-'a',b=str[len-1]-'a';
            st[a]=st[b]=true;
            dout[a]++,din[b]++;
            p[find(a)]=find(b);
        }
        
        int start=0,end=0;
        bool success=true;
        for(int i=0;i&lt;26;i++)
            if(din[i] != dout[i])
            {
                if(din[i] == dout[i] + 1)
                    end++;
                else if(din[i] + 1 == dout[i])
                    start++;
                else
                {
                    success=false;
                    break;
                }
            }
            
        if(!(!start &amp;&amp; !end ||start == 1 &amp;&amp; end == 1))
            success=false;
        int rep = -1;
        for (int i = 0; i &lt; 26; i ++ )
            if (st[i])
            {
                if (rep == -1) rep = find(i);
                else if (rep != find(i))
                {
                    success = false;
                    break;
                }
            }

        if (success) puts(&quot;Ordering is possible.&quot;);
        else puts(&quot;The door cannot be opened.&quot;);

    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[扩展KMP]]></title>
        <id>https://caifxh.github.io/post/kuo-zhan-kmp/</id>
        <link href="https://caifxh.github.io/post/kuo-zhan-kmp/">
        </link>
        <updated>2020-04-03T08:16:45.000Z</updated>
        <content type="html"><![CDATA[<h4 id="z算法">Z算法</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ca07496a60-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_f6f54a1c60-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_33dfcb7e60-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_3623ccf060-4.png" alt="4.png" loading="lazy"><br>
r[5] = 7<br>
r[6] = 7<br>
l[5] = 5<br>
l[6] = 5<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_5abceae260-5.png" alt="5.png" loading="lazy"><br>
对于 Z[2] 我们需要暴力计算。<br>
也就是暴力计算 S[1..|S|] 和 S[2..|S|] 的最长公共前缀。<br>
如果 Z[2] &gt; 0, 那么 r = r[2], l = l[2] = 2<br>
如果 Z[2] = 0, 那么 r = r[2] = 0, l = l[2] = 0</p>
<p>我们的目标就是用已有的 Z[2], Z[3], ..., Z[k-1]，来推<br>
出 Z[k].<br>
假设 k = 121, Z[2..120] 已经知道了<br>
r[120] = 130, l[120] = 100<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_884cb29e60-6.png" alt="6.png" loading="lazy"><br>
划分成[l,i-1],[i,r]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_cfa5d35a60-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_37ddc43260-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_61fb79d060-9.PNG" alt="9.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_83939b3660-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_121af6c460-11.png" alt="11.png" loading="lazy"><br>
蓝色部分一定不相等，否则说明z-box可以右移</p>
<p>第一步：<br>
初始化 Z[]，暴力计算 Z[2]</p>
<pre><code>for(int i = 1;i &lt;= n;i ++) z[i] = 0;
int l, r;
while(str[1 + z[2]] == str[2 + z[2]]) z[2] ++; 
l = 2, r = 2+ z[2]-1;
</code></pre>
<p>第二步：<br>
枚举 i，分三种情况依次计算 Z[i]</p>
<pre><code>for(int i = 3;i &lt;= n;i ++)
{
    if(i &gt; r)
    {
        while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
        l = i, r = i + z[i] - 1;
    }
    else
    {
        if(z[i - l + 1] &lt; r - i + 1) z[i] = z[i - l + 1];
        else
        {
            z[i] = r - i;
            while(str[1 + z[i]] == str[i + z[i]]) z[i] ++; 
            l = i, r = i + z[i] - 1; 
        }
    } 
}
</code></pre>
<h4 id="时间复杂度是-on-的">时间复杂度是 O(n) 的</h4>
<h4 id="扩展kmp">扩展KMP</h4>
<p>给定两个字符串 S 和 T（长度分别为 n 和 m）<br>
定义 extend[i] 为 S[i..n] 与 T 的最长公共前缀的长度。<br>
求出 extend 数组<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_e93cf15860-12.PNG" alt="12.PNG" loading="lazy"><br>
如果 S = T，那么 extend 数组就是 Z 数组。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_fe0303ca60-13.PNG" alt="13.PNG" loading="lazy"></p>
<p>假设现在遍历到了 S[i]，且 S[1], S[2],…, S[i-1]都已经算出<br>
与 Z 算法类似，设置两个变量 l 和 r，r 表示能和 T 匹<br>
配到的最右边的位置，l 为 r 对应的起始位置。<br>
也就是 S[l .. r] = T[1.. r-l+1]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1677f3ac60-14.PNG" alt="14.PNG" loading="lazy"></p>
<p>S[i] 对应的是 T[i-l+1]<br>
现在要计算的是 S[i..n] 与 T 的最长公共前缀<br>
注意到此时 S[i..r] = T[i-l+1 .. r-l+1]<br>
所以我们可以先对 T 求一遍 Z 数组，然后考察一下 Z[i-l+1]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_7411db9460-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_a95260c660-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_de7d174760-16.png" alt="16.png" loading="lazy"></p>
<pre><code>void calc_Z(char *str) 
{
	int n = strlen(str + 1);
	for(int i = 1; i &lt;= n; i ++) z[i] = 0;
	z[1] = n;
	int l, r = 0;
	for(int i = 2; i &lt;= n; i ++) 
	{
		if(i &gt; r) 
		{
			while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
			l = i, r = i + z[i] - 1;
		} else 
		{
			if(z[i - l + 1] &lt; r - i + 1) z[i] = z[i - l + 1];
			else 
			{
				z[i] = r - i + 1;
				while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
				l = i, r = i + z[i] - 1;
			}
		}
	}
}
</code></pre>
<pre><code>void calc_extend(char *S, char *T) 
{
	calc_Z(T);
	int l, r = 0;
	int n = strlen(S + 1);
	int m = strlen(T + 1);
	for (int i = 1; i &lt;= n; i ++) 
	{
		if (i &gt; r) 
		{
			while (i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp;
			        S[i + ext[i]] == T[1 + ext[i]]) ext[i] ++;
			l = i, r = i + ext[i] - 1;
		}
		else 
		{
			if (i + z[i - l + 1] - 1 &lt; r) ext[i] = z[i - l + 1];
			else 
			{
				ext[i] = r - i + 1;
				while (i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp; S[i +ext[i]] == T[1 + ext[i]]) 
					ext[i] ++;
				l = i, r = i + ext[i] - 1;
			}
		}
	}
}
</code></pre>
<h4 id="例题">例题</h4>
<p>题意：给你n个字符串，求这n个字符串的最长公共子串</p>
<p><a href="https://vjudge.net/problem/HDU-4333">hdu4333</a><br>
给一个 L 位数的正整数 N，每次可以把这个数的最后一位移到最前面来，得到一个新的数。<br>
总共最多可以得到 n 个数，重复的只算一次。<br>
问这些数中，等于 n 的，小于 n的，大于 n 的数分别有几个。<br>
L ≤ 1e5</p>
<blockquote></blockquote>
<p>样例：<br>
341 （答案： 1 1 1）</p>
<p>我们只需要把这个数复制两遍，然后只考虑长度为 n 的子串。这些子串就是移动过程中产生的数。<br>
如何和原数 N 做比较呢</p>
<p>假设现在的数是 S[i .. i+L-1], N 是 S[1..L]<br>
我们只要求出他们的最长公共前缀 x，如果 x = n 说明这两个数相等。<br>
否则，比较 S[x] 和 S[i+x-1] 的大小，就可以确定他们的大小关系。<br>
求 x ，就是扩展 KMP 中的 Z 算法。x = min(n, Z[i])</p>
<p>最后一步去重。对 N 跑一次 KMP<br>
如果 L-next[L] 是 L 的约数，那么 L-next[L] 是 N 的最小循环节。否则 N 的 最小循环节是 L。<br>
对循环节内的情况枚举一遍即可,或除以最小循环节个数。<br>
时间复杂度 O(L)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=200010;
char str[N];
int ne[N];
int z[N];

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    for(int kas=1;kas&lt;=T;kas++)
    {
        scanf(&quot;%s&quot;,str+1);
        
        int len=strlen(str+1);
        for(int i=2,j=0;i&lt;=len;i++)
        {
            while(j &amp;&amp; str[i] != str[j+1])
                j=ne[j];
            if(str[i] == str[j+1])
                j++;
            ne[i]=j;
        }
        
        for(int i=1;i&lt;=len;i++)
            str[i+len]=str[i];
        str[len*2+1]='\0';
        memset(z,0,sizeof z);
        z[1]=len*2;
        int l,r=0;
        
        for(int i=2;i&lt;=len*2;i++)
        {
            if(i&gt;r)
            {
                while(str[1+z[i]] == str[i+z[i]])
                    z[i]++;
                l=i,r=i+z[i]-1;
            }
            else 
            {
                if(z[i-l+1] &lt; r-i+1)
                    z[i]=z[i-l+1];
                else 
                {
                    z[i]=r-i;
                    while(str[1+z[i]] == str[i+z[i]])
                        z[i]++;
                    l=i,r=i+z[i]-1;
                }
            }
        }
        
        int gre=0,eql=0,les=0;
        for(int i=1;i&lt;=len;i++)
        {
            if(z[i] &gt;= len)
                eql++;
            else if(str[1+z[i]] &gt; str[i+z[i]])
                les++;
            else gre++;
        }
        
        int t;
        if(len%(len-ne[len]) == 0)
            t=len/(len-ne[len]);//循环节个数 
        else 
            t=1;
        printf(&quot;Case %d: %d %d %d\n&quot;,kas,les/t,eql/t,gre/t);
    }
}
</code></pre>
<p>对循环节内的情况枚举<a href="https://paste.ubuntu.com/p/HrvmzSySDv/">代码</a></p>
<p><a href="https://vjudge.net/problem/POJ-3376">poj3376</a><br>
给你 n 个字符串 m[1], m[2], …, m[n]。 求 S = m[i]m[j] （1 &lt;= i,j &lt;= n）是回文串的数量。<br>
n 个字符串的长度之和不超过 2·1e6</p>
<blockquote></blockquote>
<p>样例输入：<br>
3a<br>
ab<br>
ba<br>
答案：5（aa,aba,aba,abba,baab)</p>
<p>考虑什么情况下 i 和 j 拼起来会是回文串。</p>
<ul>
<li>
<p>i的长度小于j，那么i一定是j的反串的前缀，且j的反串剩下的后缀是回文串</p>
</li>
<li>
<p>i的长度等于j，那么i等于j的反串</p>
</li>
<li>
<p>i的长度大于j，那么j的反串一定是i的前缀，且i串剩下的后缀是回文串</p>
</li>
</ul>
<p>我们可以将这n个字符串插入trie，每个节点要维护两个值：<br>
value1. 到当前节点的字符串个数；value2.当前节点后面的回文子串个数</p>
<p>我们用每个字符串的反串去trie上查找，要构成回文串有以下情况：</p>
<ul>
<li>
<p>1.此反串是其他串的前缀，那么组合回文串的数量就要加上value2</p>
</li>
<li>
<p>2.此反串的前缀是某些字符串，且反串剩下的后缀是回文串，那么组合回文串的数量要加上value1</p>
</li>
<li>
<p>3.2的特例：此反串的前缀是某些字符串，且反串剩下的后缀为空，同样要加上value1，这种情况可以和2一起处理</p>
</li>
</ul>
<p>留下的问题就是一个字符串的所有后缀中，哪些是回文串。<br>
对于串 S，我们先求出正串 S 对反串 T 的 extend[i]<br>
那么对于每个 i，如果 S[i..n] 和 T 的最长公共前缀等于<br>
S[i..n] 的长度，说明 S[i..n] 是一个回文串。<br>
因此整道题就在线性的时间复杂度内解决了。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=2e6+10;
int trie[N][26],tot=1;
int n;
char s[N],t[N];
int len[N];
int slen;
int z[N],ext[N];
bool flag[2][N];
int bg[N],ed[N];
typedef long long LL;
struct Node
{
	int v1,v2;
}cnt[N];

void get_z(char *s)
{
	int n=strlen(s+1);
	for(int i=1;i&lt;=n;i++) z[i]=0;
	z[1]=n;
	int l,r=0;
	for(int i=2;i&lt;=n;i++)
	{
		if(i&gt;r)
		{
			while(s[1+z[i]] == s[i+z[i]])
				z[i]++;
			l=i,r=i+z[i]-1;
		}
		else
		{
			if(z[i-l+1] &lt; r-i+1)
				z[i]=z[i-l+1];
			else
			{
				z[i]=r-i;
				while(s[1+z[i]] == s[i+z[i]])
					z[i]++;
				l=i,r=i+z[i]-1;
			}
		}
	}
}

void exkmp(int type,char *s,char *t)
{
	get_z(t);
	int n=strlen(s+1);
	int m=strlen(t+1);
	for(int i=1;i&lt;=n;i++)
		ext[i]=0;
	int l,r=0;
	for(int i=1;i&lt;=n;i++)
	{
		if(i&gt;r)
		{
			while(i+ext[i] &lt;=n &amp;&amp; 1+ext[i] &lt;=m &amp;&amp;
			s[i+ext[i]] == t[1+ext[i]])
				ext[i]++;
			l=i,r=i+ext[i]-1;
		}
		else
		{
			if(z[i-l+1] &lt; r-i+1)
				ext[i]=z[i-l+1];
			else
			{
				ext[i]=r-i+1;
				while(i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp; 
				s[i+ext[i]] == t[1+ext[i]])
					ext[i]++;
				l=i,r=i+ext[i]-1;
			}
		}
	}

	for(int i=1;i&lt;=n;i++)
	{
		//cout&lt;&lt;&quot;---&quot;&lt;&lt;ext[i]&lt;&lt;endl;
		if(ext[i] == n-i+1)
			flag[type][i+slen]=true;//s[i...n]为回文串
	}
}

void insert(int k)
{
	int p=1;
	for(int i=bg[k];i&lt;=ed[k];i++)
	{
		cnt[p].v2+=flag[0][i];
		int ch=s[i]-'a';
		if(!trie[p][ch])
			trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	cnt[p].v1++;
}

void print(int k)
{
	int p=1;
	for(int i=bg[k];i&lt;=ed[k];i++)
	{
		int ch=s[i]-'a';
		p=trie[p][ch];
		cout&lt;&lt;&quot;---&quot;&lt;&lt;cnt[p].v2&lt;&lt;' '&lt;&lt;cnt[p].v1&lt;&lt;endl;
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;len[i]);
		scanf(&quot;%s&quot;,s+1+slen);
		for(int j=1;j&lt;=len[i];j++)
			t[slen+j]=s[slen+len[i]+1-j];
		t[slen+len[i]+1]='\0';
		exkmp(0,s+slen,t+slen);
		exkmp(1,t+slen,s+slen);

		bg[i]=slen+1;
		slen+=len[i];
		ed[i]=slen;

		insert(i);
		//print(i);
	}

	LL ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		int p=1;
		bool f=true;
		for(int j=ed[i];j&gt;=bg[i];j--)//用反串去trie上匹配
		{
			int k=s[j]-'a';
			if(!trie[p][k])
			{
				f=false;
				break;
			}
			else
				p=trie[p][k];
			if(flag[1][bg[i]+ed[i]-j+1] || j == bg[i])
				ans+=cnt[p].v1;
		}
		if(f)
			ans+=cnt[p].v2;
	}

	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>