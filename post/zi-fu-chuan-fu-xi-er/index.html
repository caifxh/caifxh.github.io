<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    字符串复习（二） | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1588691348423">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1588691348423" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            字符串复习（二）
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-03-27</time>
                            
                                <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-error">
                            #字符串
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <h4 id="manacher">Manacher</h4>
<p>回文串:对于一个长度为 n 的字符串 str，如果它正着读和反着读一样，即 str[i] = str[n - i + 1] (1 &lt;= i &lt; n - i + 1),如 aba，acbbca 就是回文串，abc，abab 就不是回文串。</p>
<p>Manacher 算法可以求出以每个位置为中心，向两边能扩展的最长回文子串长度 p[i]，它的时间复杂度是 O(n) 的。<br>
注意到回文子串的长度可能是偶数， 如 abba，中心不是某个字符（中心是两个 b 之间的空隙），所以先要在相邻的<br>
字符中插入一个标识符，例如 #,这样例如 #a#b#b#a# 的中心就是 # 了。</p>
<p>我们用 abbabcba 来举例。<br>
先插入 # 得到 #a#b#b#a#b#c#b#a#。<br>
然后用 Manacher 可以得到如下的 p 数组。<br>
对于每个 p[i]，一定有 str[i + j] == str[i - j] (1 ≤ j &lt; p[i])<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_9f85dc7c62-36.PNG" alt="36.PNG" loading="lazy"></p>
<p>类比 Z 算法，我们也维护一个 mx 和 id，表示对于当前计算的所有 i，i + p[i] 的最大值是 mx，mx 对应的 i 记为id。<br>
当你现在开始计算 p[i] 时，默认 p[1..i-1] 都已经算出。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/09/9969_ca02b89262-38.PNG" alt="38.PNG" loading="lazy"></p>
<h4 id="计算最长回文子串长度">计算最长回文子串长度</h4>
<p>以字符串&quot;cabbaf&quot;为例，将预处理后的新字符串&quot;#c#a#b#b#a#f#&quot;变成一个字符数组arr，定义一个辅助数组int[] p，p的长度与arr等长，p[i]表示以arr[i]字符为中心的最长回文半径，p[i]=1表示只有arr[i]字符本身是回文子串。</p>
<pre><code>i       0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i]  # c # a # b # b # a #  f  #
p[i]    1 2 1 2 1 2 5 2 1 2 1  2  1
</code></pre>
<p>我们来比对分下一下最长回文半径和原字符串之间的关系。在上面例子中，最长回文子串是&quot;#a#b#b#a#&quot;，它以arr[6]为中心，半径是5，其代表的原始字符串是&quot;abba&quot;，而&quot;abba&quot;的长度为4，可以通过5减去1得到，是字符串&quot;cabbaf&quot;中的最长回文子串，那么我们是不是可以得出最长回文半径和最长回文子串长度之间的关系？</p>
<p>让我们再多看几个例子，如&quot;aba&quot;，转换后是&quot;#a#b#a#&quot;，以字符'b'为中心的回文，半径是4，减1得到3，3是原字符串的最长回文子串长度。</p>
<p>再例如&quot;effe&quot;，转换后是&quot;#e#f#f#e#&quot;，以最中间的'#'为中心的回文，半径是5，减1得到4，4是原字符串的最长回文子串长度。</p>
<p>因此，最后我们得到最长回文半径和最长回文子串长度之间的关系：int maxLength = p[i]-1。maxLength表示最长回文子串长度。</p>
<h4 id="计算最长回文子串起始索引">计算最长回文子串起始索引</h4>
<p>知道了最长回文子串的长度，我们还需要知道它的起始索引值，这样才能截取出完整的最长回文子串。<br>
继续以第三步中的字符串&quot;cabbaf&quot;为例，p[6]=5，是最长半径，用6(i)减去最长半径5(p[i])得到1，而1恰好是最长回文子串&quot;abba&quot;的起始索引。<br>
我们再来看一个奇回文的例子。例如&quot;aba&quot;，转换后是&quot;#a#b#a#&quot;，p[3]=4，最长半径是4，i为3，用i减去4得到-1，数组下标越界了。<br>
在偶回文的情况下，可以满足i减最长半径，而奇回文却会下标越界，我们需要在转换后的字符串前面再加一个字符，解决下标越界的问题，不能是'#'，那就加个'$'字符吧，但是加过一个字符后，字符串的长度不是奇数了，只能在尾部再加一个不会重复出现的字符，比如'@'(也可不加，因为字符串结尾为'\0')，这样字符串的长度依旧是奇数了，满足前面第三部分的条件。</p>
<p>加多一个字符后，奇回文可以正常做减法了，偶回文呢？</p>
<pre><code>i       0 1 2 3 4 5 6 7 8 9 10 11 12 13
arr[i]  $ # c # a # b # b # a  #  f  #
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1
</code></pre>
<p>在补上字符'$'后，p[7]=5，用i减去最长半径，7-5=2，而理想的结果应该是1，那就再除以2吧，这样就能得到1了。而奇回文&quot;aba&quot;在用i减去最长半径后得到的是0，除以2后还是0，可以完美解决下标越界的问题。</p>
<p><code>结论：最长回文子串的起始索引int index = (i - p[i])/2。</code><br>
<a href="https://www.luogu.com.cn/problem/P3805">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=11000010;
char s[N];
charma[N&lt;&lt;1];
int p[N&lt;&lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i]&gt;mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	while(~scanf(&quot;%s&quot;,s))
	{
		int len=strlen(s);
		manacher(s,len);
		int ans=0;
		for(int i=0;i&lt;2*len+2;i++)
			ans=max(ans,p[i]-1);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://codeforces.ml/problemset/problem/17/E">Codeforces 17E</a><br>
给出一个字符串 s。 求 s 有多少对相交的回文子串。包含也算作相交。<br>
如 babb 一共有 6 对相交的回文子串：<br>
s[1..1] and s[1..3]<br>
s[1..3] and s[2..2]<br>
s[1..3] and s[3..3]<br>
s[1..3] and s[3..4]<br>
s[3..3] and s[3..4]<br>
s[3..4] and s[4..4]<br>
|s| ≤ 2·e6</p>
<p>正难则反<br>
统计不相交的回文子串对数。<br>
不相交的回文子串假设端点分别为 x1,y1,x2,y2<br>
那么一定有 x1 &lt;= y1 &lt; x2 &lt;= y2<br>
我们只要统计出以 i 为起点的回文串个数 st[i]，和以 i为终点的回文串个数 ed[i]。<br>
然后计算<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_4bb23d6462-39.PNG" alt="39.PNG" loading="lazy"><br>
在使用 manacher 算法的时候，对每个 i 都计算出了 p[i]<br>
那么我们就要把[i-p[i], i+p[i]] 这个极大回文子串对 st和 ed 的贡献算进去。<br>
对于 st: [i-p[i]+1, i] 这些点每个位置都要 +1<br>
对于 ed：[i, i+p[i]-1] 这些点每个位置都要 +1<br>
只需要通过差分转化为单点修改即可。<br>
最后用总的回文子串对数减去不相交的回文子串对数即是答案</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=2e6+10,mod=51123987;
char s[N];
int p[N&lt;&lt;1];
int n;
char ma[N&lt;&lt;1];
int l[N&lt;&lt;1],r[N&lt;&lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,s);
	manacher(s,n);
	n=n*2+2;
	
	int ans=0;
	for(int i=0;i&lt;n;i++)
	{
		l[i-p[i]+1]++,l[i+1]--;
		r[i]++,r[i+p[i]]--;
		ans=(ans+p[i]/2)%mod;
	}
	ans=(LL)ans*(ans-1)/2%mod;
	
	int sum=0;
	for(int i=1;i&lt;n;i++)
	{
		l[i]+=l[i-1];r[i]+=r[i-1];
		if(i&amp;1) continue;
		ans=(ans-(LL)sum*l[i]%mod+mod)%mod;
		sum=(sum+r[i])%mod;
	}
	printf(&quot;%d&quot;,ans);
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P4555">BZOJ 2565</a><br>
定义双回文串 T，满足存在 T = ab，其中 a 和 b 都是回文串。<br>
给定字符串 S，求一个 S 的最长的双回文子串 T。<br>
|S| ≤ 1e6</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_562e454c62-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG" loading="lazy"><br>
Lmax是一个点往左扩展，越靠右越可能长，所以做逆推；Rmax是一个点往右扩展，越靠左越可能长，所以做顺推。递推式子见代码。处理好之后扫一遍就出解了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int n;
int l[N*2],r[N*2],p[N*2];
char ma[N*2],a[N];

void manacher(char *s,int len)
{
    int k=0;
    ma[k++]='$';
    ma[k++]='#';
    for(int i=0;i&lt;len;i++)
    {
        ma[k++]=s[i];
        ma[k++]='#';
    }
    ma[k]=0;
    int mx=0,id=0;
    for(int i=0;i&lt;k;i++)
    {
        if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]] == ma[i-p[i]])
            p[i]++;
        if(i+p[i]&gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
        l[i+p[i]-1]=max(l[i+p[i]-1],p[i]-1);
        //cout&lt;&lt;l[i+p[i]-1]&lt;&lt;' '&lt;&lt;p[i]-1&lt;&lt;endl;
        r[i-p[i]+1]=max(r[i-p[i]+1],p[i]-1);
        //cout&lt;&lt;r[i-p[i]+1]&lt;&lt;' '&lt;&lt;p[i]-1&lt;&lt;endl;
    }
}

 
int main()
{
	scanf(&quot;%s&quot;,a);
	
	int n=strlen(a);
	manacher(a,n);
	n=n*2+2;
	
	for(int i=1;i&lt;n;i+=2) r[i]=max(r[i],r[i-2]-2);
	for(int i=n-1;i&gt;=1;i-=2) l[i]=max(l[i],l[i+2]-2);
	
	int ans=0;
	for(int i=1;i&lt;n;i++) 
		if(l[i] &amp;&amp; r[i])
			ans=max(ans,l[i]+r[i]);
	cout&lt;&lt;ans;
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P4324">bzoj4755</a><br>
有两个长度均为 N 的字符串 A 和 B。<br>
扭动的字符串 S(i,j,k) 定义为 A[i..j]+B[j..k] 若 A=’xyz’, B=‘uvw’, 则 S(1,2,3)=‘xyvw’<br>
定义扭动的回文串为如下情况中的一个；<br>
A 中的一个回文串<br>
B 中的一个回文串<br>
某一个回文的扭动字符串S(i,j,k)<br>
求最长的扭动回文串<br>
1≤N≤100000，字符串只含大写字母</p>
<blockquote></blockquote>
<p>样例：<br>
5<br>
ABCDE<br>
BAECB<br>
答案：<br>
5<br>
最长的扭动回文串是 S(2,3,5) = BCECB</p>
<p>对于前两种情况，我们只需要用 manacher 算法求出每个位置的回文扩展半径，然后取一个最大值即可。<br>
对于第三种情况，需要在两个字符串中各取一段拼起来。<br>
我们可以把答案字符串分解为 STS’<br>
其中 S’ 是 S 的反串，T 是回文串。</p>
<p>可以发现一定是 S 在一个串，TS’ 在另一个串；或者 ST 在一个串，S’在另一个串。<br>
且<code>T 一定是极大的回文子串。</code></p>
<p>那么我们只要枚举极大回文子串 T 即可。<br>
假设中心在 A 中，枚举中心 i。<br>
(1)假设A[i-p[i], i+p[i]] 是极大回文子串。<br>
枚举 A[i+p[i]+1..n] 的前缀和 B[1..i-p[i]] 的后缀最长能匹配上多少。</p>
<p>(2)假设B[i-p[i], i+p[i]] 是极大回文子串。<br>
枚举 A[1..i-p[i]-1] 的后缀 和 B[i + p[i]..n] 的前缀最长能匹配上多少。<br>
这两部分的最大值 * 2 + 极大回文子串的长度就是答案了。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef unsigned long long ULL;
const int N=100010,M=N&lt;&lt;1,P=131;
char a[N],b[N];
char ma[M];
int pa[M],pb[M];
int n;
ULL ha[N],hb[N],p[N];
int ans;

ULL getha(int l,int r)
{
	return ha[r]-ha[l-1]*p[r-l+1];
}

ULL gethb(int l,int r)
{
	return hb[l]-hb[r+1]*p[r-l+1];
}

void manacher(char *s,int len,int p[])
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=1;i&lt;=len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l++]=0;
	
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx &gt; i) p[i]=min(p[2*id-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}	
}

int search(int L,int R)
{
	int l=0,r=min(L,n-R+1);
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(getha(L-mid+1,L) == gethb(R,R+mid-1))
			l=mid;
		else 
			r=mid-1;
	}
	return l;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,a+1);
	scanf(&quot;%s&quot;,b+1);
	
	p[0]=1;
	for(int i=1;i&lt;=n;i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&lt;=n;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=n;i&gt;=1;i--)
		hb[i]=hb[i+1]*P+b[i];
	
	manacher(a,n,pa);
	manacher(b,n,pb);
	n=n*2+1;
	for(int i=1;i&lt;=n;i++) ans=max(ans,pa[i]-1);
	for(int i=1;i&lt;=n;i++) ans=max(ans,pb[i]-1);
	for(int i=1;i&lt;=n;i++)
	{
		int l=(i-pa[i])/2+1,r=(i+pa[i])/2-1;//下标从1开始
		if(l&lt;=r)
			ans=max(ans,pa[i]-1+search(l-1,r)*2);
	}
	for(int i=1;i&lt;=n;i++)
	{
		int l=(i-pb[i])/2+1,r=(i+pb[i])/2-1;
		if(l&lt;=r)
			ans=max(ans,pb[i]-1+search(l,r+1)*2);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/SP7586">SP7586</a><br>
求一个串中包含几个回文串<br>
用马拉车求出以每个字母为对称轴的回文串长度，因为一个回文串长度/2就是这个回文串包含的子回文串长度，所以最后统计一下即可<br>
<a href="https://paste.ubuntu.com/p/bg75xXjG4R/">代码</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3501">BZOJ 2084 Antisymmetry</a><br>
给定一个长度为 n 的01串，问有多少个子串满足翻转并取反后和原来一样。<br>
比如0101翻转并取反后还是和原来一样。</p>
<p>只要定义 0 = 1， 0 ≠ 0，1 ≠ 1 即可。跑一遍 Manacher 即可。<br>
以 0/1 扩展的 p[i] 一定是 0 （即没有奇数长度的合法子串）<br>
以 # 扩展的累加起来即可<br>
接下来我们来考虑如果我们确定了一个中心后，向外扩展出一个最大可能的反对称串，那么这个串中一定含有len/2个满足条件的串，其中len为串长，因为要想大的满足条件，则在里面的小串必须满足是反对称的</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=500010;
char s[N];
char ma[N&lt;&lt;1];
int p[N&lt;&lt;1];
int n;

void manacher(char *s,int len)
{
    int l=0;
    ma[l++]='$';
    ma[l++]='#';
    for(int i=0;i&lt;len;i++)
    {
        ma[l++]=s[i];
        ma[l++]='#';
    }
    ma[l]=0;
    int mx=0,id=0;
    for(int i=1;i&lt;l;i+=2)
    {
        if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]]-'0'+ma[i-p[i]]-'0'==1 || (ma[i+p[i]]==ma[i-p[i]] &amp;&amp; ma[i+p[i]]=='#'))
            p[i]++;
        if(i+p[i]&gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
    }
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%s&quot;,s);
    manacher(s,n);
    long long ans=0;
    for(int i=1;i&lt;n*2+2;i+=2)
    	ans+=p[i]/2;
	
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3790">BZOJ 3790</a><br>
母亲节就要到了，小 H 准备送给她一个特殊的项链。这个项链可以看作一个用小写字母组成的字符串，每个小写字母表示一种颜色。为了制作这个项链，小 H 购买了两个机器。第一个机器可以生成所有形式的回文串，第二个机器可以把两个回文串连接起来，而且第二个机器还有一个特殊的性质：假如一个字符串的后缀和一个字符串的前缀是完全相同的，那么可以将这个重复部分重叠。<br>
例如：aba和aca连接起来，可以生成串abaaca或 abaca。现在给出目标项链的样式，询问你需要使用第二个机器多少次才能生成这个特殊的项链。</p>
<blockquote></blockquote>
<p>样例：<br>
abcdcba （答案：0）<br>
abacada （答案：2）<br>
abcdef （答案：5）</p>
<p>题目的意思就是用尽可能少的回文子串去覆盖原串。<br>
我们可以先跑一遍 Manacher 算法得到每个位置的覆盖半径。<br>
问题转化为了有许多个区间 [i-p[i], i+p[i]]，要选出尽可能少的区间来覆盖 [1, n] 区间</p>
<p>贪心即可。<br>
对所有的区间按照左端点从小到大排序。<br>
每次都选右端点最远的那个区间。<br>
设当前覆盖到的右端点为 right。<br>
每次找出左端点在[1, right] 中的右端点的最大的那个线段，再做一次覆盖。<br>
时间复杂度 O(n log n)<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/10/9969_83262ddc62-tempsnip.png" alt="tempsnip.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=50010,M=N&lt;&lt;1;
char s[N],ma[M];
int p[M];
struct Node
{
	int l,r;
	bool operator&lt;(const Node &amp;W) const
	{
		return l&lt;W.l;
	}
}e[M];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]='$';
	ma[l++]='#';
	for(int i=0;i&lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]='#';
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&lt;l;i++)
	{
		if(mx&gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i] &gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
		e[i].l=i-p[i]+1,e[i].r=i+p[i]-1;
	}
}

int main()
{
	while(~scanf(&quot;%s&quot;,s))
	{
		int n=strlen(s);
		manacher(s,n);
		
		n=n*2+1;
		sort(e+1,e+n+1);
		
		int st=1,j=1,ed=n;
		int res=0;
		
		while(st &lt; ed)
		{
			int r=0;
			while(j &lt;= n &amp;&amp; e[j].l &lt;= st)
				r=max(r,e[j].r),j++;
			
			st=r;
			res++;
		}
		printf(&quot;%d\n&quot;,res-1);
	}
}
</code></pre>
<h4 id="trie">trie</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_465a00d061-17.PNG" alt="17.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_568cd63061-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_58b69c0c61-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_830379da61-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_84e99b6c61-21.png" alt="21.png" loading="lazy"></p>
<pre><code>void insert(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-'a';
        if(!trie[p][k])
            trie[p][k]=++idx;
        p=trie[p][k];
    }
    cnt[p]=true;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_037d465861-22.png" alt="22.png" loading="lazy"></figure>
<pre><code>int query(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-'a';
        p=trie[p][k];
        if(!p)
            return 0;
    }
    return cnt[p];
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/837/">模板题</a></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_2cda862961-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_371889c861-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_40813ee261-25.png" alt="25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_6342628a61-26.png" alt="26.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_65f359bc61-27.png" alt="27.png" loading="lazy"></p>
<h4 id="例题">例题</h4>
<p><a href="https://vjudge.net/problem/POJ-2503">poj2503</a><br>
您刚从滑铁卢搬到大城市。 这里的人说的是一门不可理解的外语。 幸运的是，您有一本字典来帮助您理解它们。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ae53dcea61-28.png" alt="28.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;sstream&gt;
using namespace std;
const int N=1000010,M=26;
int trie[N][M];
int cnt[N],idx=1;
char word[N][15];

void insert(string str,int k)
{
	int len=str.size(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=str[i]-'a';
		if(!trie[p][ch])
			trie[p][ch]=++idx;
		p=trie[p][ch];
	}
	cnt[p]=k;
}

int query(string str)
{
	int len=str.size(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int k=str[i]-'a';
		p=trie[p][k];
		if(!p)
			return 0;
	}
	return cnt[p];
}

int main()
{
	string s,str;
	int k=1;
	while(getline(cin,s))
	{
		if(s.empty())
			break;
		stringstream ss(s);
		ss&gt;&gt;word[k]&gt;&gt;str;
		insert(str,k);
		k++;
	}
	
	while(cin&gt;&gt;s)
	{
		int k=query(s);
		if(k)
			cout&lt;&lt;word[k]&lt;&lt;endl;
		else 
			cout&lt;&lt;&quot;eh&quot;&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="">poj3630</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_360d81f861-29.png" alt="29.png" loading="lazy"><br>
给定一个电话号码列表，判断它是否一致，即没有号码是另一个号码的前缀。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ae1e7c4461-29.png" alt="29.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;sstream&gt;
using namespace std;
const int N=100010,M=10;
int trie[N][M];
bool cnt[N];
int idx;
int n;

bool insert(char *s)
{
	int p=1;
	int len=strlen(s);
	for(int i=0;i&lt;len;i++)
	{
		int k=s[i]-'0';
		if(!trie[p][k])
			trie[p][k]=++idx;
		else if(i == len-1)//字符串处理完毕，仍不空，说明该串是其它串的前缀 
			return true;
		p=trie[p][k];
		if(cnt[p])//其他串是该串前缀 
			return true;
	}
	cnt[p]=true;
	return false;
}

int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		idx=1;
		bool ans=false;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
		{
			char s[15];
			scanf(&quot;%s&quot;,s);
			if(ans)
				continue;
			if(insert(s))//不能立即结束，仍要读取n个串 
				ans=true;
		}
		if(ans)
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//有前缀输出NO 
		else
			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1251">hdu1251</a><br>
Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1f376a1261-30.png" alt="30.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=500005;
const int maxz=26;//不同字符个数，例如数字10，小写字母26
int trie[maxn][maxz];
int cnt[maxn];//计数器 
void insert(string s)//将字符串s插入到字典树中 
{
	int len=s.length(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=s[i]-'a';//转换成数字
		if(!trie[p][ch]) 
			trie[p][ch]=++tot;//记录下标 
		p=trie[p][ch];
		cnt[p]++;//统计有多少个单词经过 
	}
}

int query(string s)
{
	int len=s.length(),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int ch=s[i]-'a';//转换成数字
		p=trie[p][ch];
		if(!p)
			return 0;
	}
	return cnt[p];	
}

int main()
{	
	string s;
	memset(trie,0,sizeof(trie));
	memset(cnt,0,sizeof(cnt));
	tot=1;
	while(getline(cin,s))
	{
		if(!s.size())
			break;
		insert(s);
	}
	while(cin&gt;&gt;s)
		cout&lt;&lt;query(s)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>若反过来问，单词表中有多少单词是当前查询单词的前缀，只需统计查询时经过的end标记数量即可。</p>
<p><a href="https://vjudge.net/problem/POJ-2513">poj2513</a><br>
给你一堆木棍。 每个棍子的每个端点都带有某种颜色。是否可以将操纵杆沿一条直线对齐，以使触摸的端点的颜色具有相同的颜色？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_dcdfe70261-31.png" alt="31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_e6f7e0d261-32.png" alt="32.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=500010,M=26;
int trie[N][M];
int cnt[N];
int d[N];
int idx=1;
int color;
int p[N];

int find(int x)
{
	if(x != p[x])
		p[x]=find(p[x]);
	return p[x];
}

int insert(char *s)
{
	int len=strlen(s),p=1;
	for(int i=0;i&lt;len;i++)
	{
		int k=s[i]-'a';
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	if(cnt[p])
		return cnt[p];
	else 
	{
	    cnt[p]=++color;
	    return cnt[p];
	}
}

int main()
{
	for(int i=1;i&lt;N;i++)
		p[i]=i;
	char a[15],b[15];
	while(~scanf(&quot;%s%s&quot;,a,b))
	{
		int i=insert(a);
		int j=insert(b);
		d[i]++;
		d[j]++;
		//cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;
		int pi=find(i);
		int pj=find(j);
		p[pi]=pj;
	}
	
	int s=find(1);
	int num=0;
	for(int i=1;i&lt;=color;i++)
	{
		if(d[i] % 2 == 1)
			num++;
		if(num &gt; 2 || find(i) != s)
 		{
 			puts(&quot;Impossible&quot;);
			return 0;
		}
 	}
	if(num == 0 || num == 2)
		puts(&quot;Possible&quot;);
	else 
		puts(&quot;Impossible&quot;);
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3764">poj3764</a><br>
给出n个节点的树，每条边有边权w。 • 请你找一条路径，使得这条路径上所有边权的异或和最大。<br>
• 数据范围<br>
• n &lt;= 100,000, 0 &lt; w &lt; 2^31</p>
<p>暴力的做法：<br>
• 枚举每个点当根<br>
• dfs整颗树，获得根到每个节点的路径异或和s[]<br>
• 时间复杂度O(n^2)</p>
<p>异或的性质<br>
x xor x = 0<br>
• 一个数异或两次会抵消掉。<br>
• x到y的路径异或和就等于s[x] xor s[y] !<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_9a3f466e61-33.png" alt="33.png" loading="lazy"><br>
这样只要任取一个点为根，dfs得到s[]数组后，枚举x， y即可，还是O(n^2)</p>
<p>现在的问题是，给定一个s[]数组，找两个元素，使得他<br>
们的异或和最大。<br>
• 给一个数x，在数组s中找一个数y使其和x的异或和最大。<br>
• 涉及二进制的题，我们可以选择按位来考虑。</p>
<p>假设x的二进制有31位，我们把它的二进制写出来，最高位称为第30位，最低位称为第0位。<br>
因为要让异或值最大，所以我们从高位开始考虑。<br>
• 如果x的第30位是1 —— if (x &gt;&gt; 30 &amp; 1)<br>
• 那我们一定希望y的第30位是0，这样异或之后的第30位 是1.<br>
• 否则就算第29～0位异或后都是1，也比2^30小。<br>
• 同理，如果x的第30位是0，我们希望y的第30位是1.</p>
<p>运用贪心的思想，假设现在枚举到x的第i位<br>
• if x第i位是1 我们要尽可能找第i位为0的y<br>
• if x第i位是0 我们要尽可能找第i位为1的y<br>
涉及前缀判断，采用trie</p>
<p>先把所有的数的二进制当作字符串，存进trie中。<br>
• 从高往低枚举二进制位时，设置一个指针p，一开始指向trie的根节点。<br>
• if x第i位是1 我们要尽可能找第i位为0的y 如果说明存在第i位为0的数，我们就让p往0节点走，答案中的第i位为1。<br>
• 如果不存在第i位为0的数，我们只能退而求其次，让p往1节点走，答案中的第i位为0.<br>
• if x第i位是0 我们要尽可能找第i位为1的y ， 同理</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010*31,M=N&lt;&lt;1;
int trie[N][2],tot=1;
int d[N];
int n;
int h[N],e[M],ne[M],w[M],idx;

void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j == fa)
			continue;
		d[j]=d[u]^w[i];
		dfs(j,u);
	}
}

void insert(int x)
{
	int p=1;
	for(int i=30;i&gt;=0;i--)
	{
		int u=x&gt;&gt;i&amp;1;
		if(!trie[p][u])
			trie[p][u]=++tot;
		p=trie[p][u];
	}
}

int query(int x)
{
	int p=1;
	int res=0;
	for(int i=30;i&gt;=0;i--)
	{
		int k=x&gt;&gt;i&amp;1;
		if(trie[p][!k])
		{
			res+=1&lt;&lt;i;
			p=trie[p][!k];
		}	
		else 
			p=trie[p][k];
	}
	return res;
}

int main()
{
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		memset(h,-1,sizeof h);
		memset(d,0,sizeof d);
		memset(trie,0,sizeof trie);
		idx=0;
		tot=1;
		for(int i=0;i&lt;n-1;i++)
		{
			int a,b,c;
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
			a++,b++;
			add(a,b,c);add(b,a,c);
		}
		dfs(1,-1);
		int res=0;
//		for(int i=1;i&lt;=n;i++)
//			cout&lt;&lt;d[i]&lt;&lt;' ';
		
		for(int i=1;i&lt;=n;i++)
		{
			insert(d[i]);
			res=max(res,query(d[i]));
		}
		printf(&quot;%d\n&quot;,res);
	}
	return 0;
}
</code></pre>
<h4 id="ac自动机">AC自动机</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_62b82fa863-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_661c7b4063-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_72245a5d63-4.png" alt="4.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_865c0f8863-5.png" alt="5.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_8d6beb0e63-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_9969b29c63-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_a53131a463-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_cbf0cdb863-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_cec6648a63-10.png" alt="10.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d9867a9063-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_af41834663-13.png" alt="13.png" loading="lazy"><br>
每个结点的26个指针都有指向<br>
匹配时判断后缀是不是单词，若为单词则也需要统计上<br>
<a href="https://www.acwing.com/problem/content/description/1284/">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=5e5+10,M=1e6+10;
int trie[N][26],cnt[N],idx;
char s[M];
int q[N],ne[N];
int n;

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-'a';
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;26;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;26;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	int res=0;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-'a';
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			res+=cnt[p];
			cnt[p]=0;
			p=ne[p];
		}
	}
	return res;
}

void print()
{
	for(int i=0;i&lt;idx;i++)
	{
		cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ne[i]&lt;&lt;&quot;: &quot;;
		for(int j=0;j&lt;26;j++)
			if(trie[i][j])
			    cout&lt;&lt;char(j+'a')&lt;&lt;' '&lt;&lt;trie[i][j]&lt;&lt;&quot;  &quot;;
		cout&lt;&lt;endl;
	}
	cout&lt;&lt;endl;
}

int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		memset(ne,0,sizeof ne);
		idx=0;
		scanf(&quot;%d&quot;,&amp;n);
		
		for(int i=0;i&lt;n;i++)
		{
			char str[55];
			scanf(&quot;%s&quot;,str);
			insert(str);
		}
		
		build();
		//print();
		scanf(&quot;%s&quot;,s);
		printf(&quot;%d\n&quot;,query(s));
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2896">hdu2896</a><br>
小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_a190a2ac63-14.png" alt="14.png" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1e5+10,M=10010;
int trie[N][128],idx;
char s[M];
int q[N],ne[N];
int n,m;
int ans[N],cnt;
int id[N];
int tot;

void insert(char *s,int i)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-32;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	id[p]=i;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;128;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;128;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	bool flag = false;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-32;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			if(id[p])
			{
				flag=true;
				ans[cnt++]=id[p];
				//cout&lt;&lt;&quot;---&quot;&lt;&lt;id[p]&lt;&lt;endl;
			}
			p=ne[p];
		}
	}
	return flag;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		char str[210];
		scanf(&quot;%s&quot;,str);
		insert(str,i);
	}
	
	build();

	scanf(&quot;%d&quot;,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s&quot;,s);
		cnt=0;
		if(query(s))
		{
			tot++;
			printf(&quot;web %d:&quot;,i);
			cnt=unique(ans,ans+cnt)-ans;
			sort(ans,ans+cnt);
			for(int i=0;i&lt;cnt;i++)
				printf(&quot; %d&quot;,ans[i]);
			puts(&quot;&quot;);
		}
	}
	
	printf(&quot;total: %d\n&quot;,tot);
	return 0;
}
</code></pre>
<p>1.本题不是计数，不需判重复，只需标记病毒编号为true，多次标记不影响最终答案<br>
2.多个主串，字典树下一次还要再查询，不能改变字典树<br>
附：ASCII表<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_8f7d399863-ASCII%E8%A1%A8.jpg" alt="ASCII表.jpg" loading="lazy"></p>
<p><a href="https://vjudge.net/problem/POJ-2778">poj2778</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_ce862d4c63-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d228a30863-16.png" alt="16.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_d4f32f6863-17.png" alt="17.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_ec73a48863-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_eea68e4663-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_fd08f70863-20.png" alt="20.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int N=110,mod=100000;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n,m;
int q[N];
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
	matrix(int c[][N])
	{
		memcpy(m,c,sizeof m);
	}
};

int get(char c)
{
	switch(c)
	{
		case 'A' : return 0;
		case 'G' : return 1;
		case 'C' : return 2;
		case 'T' : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;	
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&lt;=idx;i++)
		for(int j=0;j&lt;=idx;j++)
			for(int k=0;k&lt;=idx;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&lt;=idx;i++)
		res.m[i][i]=1;
	while(k)
	{
		if(k &amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&gt;&gt;=1;
	}
	return res;
}

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;n;i++)
	{
		char str[15];
		scanf(&quot;%s&quot;,str);
		insert(str);
	}
	
	build();
	
	matrix g;
	for(int i=0;i&lt;=idx;i++)
	{
		if(cnt[i]) continue;
		for(int j=0;j&lt;4;j++)
		{
			int p=trie[i][j];
			if(!cnt[p])
				g.m[i][p]=(g.m[i][p]+1)%mod;
		}
	}
	
//	for(int i=0;i&lt;=idx;i++)
//	{
//		for(int j=0;j&lt;=idx;j++)
//			cout&lt;&lt;g.m[i][j]&lt;&lt;' ';
//		cout&lt;&lt;endl;
//	}
	
	g=qmi(g,m);
	int res=0;
	for(int i=0;i&lt;=idx;i++)
		res=(res+g.m[0][i])%mod;
	
	printf(&quot;%d&quot;,res);
	
	return 0;
}
</code></pre>
<p>最后的答案为什么是g.m[0][i]求和?<br>
矩阵g的n次幂表示构造长度为n的DNA序列的方案数（g的i次幂表示构造长度为n的DNA序列的方案数），类似离散数学中二元关系的复合运算，二元关系&lt;1,2&gt; ,&lt;2,3&gt; 复合一次可得到关系&lt;1,3&gt;</p>
<p>由于从根结点出发构造序列，且根结点idx为0.g.m[0][i]表示从根结点走i步的方案数，即从根节点开始构造长度为i的序列的方案数。</p>
<p><a href="https://www.acwing.com/problem/content/1055/">poj3691</a><br>
AC自动机+DP<br>
为每个结点构造失败指针的同时，检查其失败指针所指向的节点是否为危险节点，如果是的话也需要把当前节点标记为危险节点。<br>
所谓的危险节点，就是指以当前节点为结尾的字符串是某个病毒串，或者包含了某个病毒串。如果在bfs的同时进行这项操作的时候就非常方便，在构造完当前失败指针的同时检查其所指向的节点是否为危险节点。</p>
<p>根据危险DNA序列所建的字典树，我们用模拟的方式 ，从第一个字符开始构造， 依次递增，找到一个满足要求的字符串，在构造此字符串的同时，比较该字符串和输入要判断的序列S，若该位置i的字符和s[i]，相同，则表示，此位置的字符不需要改变，反则，需要把s[i]该为词字符，为一次改变操作.</p>
<p>状态表示：dp[i][j]，表示到达查找串第i个字符时，对应于AC自动机的j节点所需要的最小改变数。<br>
状态转移为dp[i][son[j]] = min( dp[i][son[j]], dp[i-1][j] + s[i-1]!=k )</p>
<p>读到i个字符时，对应于j状态（DP的过程要两重循环i和j），要转移到son[j]（j的子节点状态，在这里用k在[0,3]一重循环遍历所有可以转字符），如果第i个字符跟所要转移到的字符相同，则代价为0，因为不需要改变；否则代价为1，因为需要改变。</p>
<p>如果当前状态不可达，则不需要对其进行后续运算。</p>
<p>如果子节点为危险节点，则不可以进行转移，即不可以使用上面的状态方程。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n;
char s[N];
int f[N][N];
int q[N];

int get(char c)
{
	switch(c)
	{
		case 'A' : return 0;
		case 'G' : return 1;
		case 'C' : return 2;
		case 'T' : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

void print()
{
    for(int i=0;i&lt;=idx;i++)
    {
        cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ne[i]&lt;&lt;&quot;: &quot;;
        for(int j=0;j&lt;4;j++)
            if(trie[i][j])
                cout&lt;&lt;trie[i][j]&lt;&lt;' ';
        cout&lt;&lt;endl;
    }
}

int main()
{
	int kas=1;
	while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)
	{
		memset(trie,0,sizeof trie);
		memset(ne,0,sizeof ne);
		memset(cnt,0,sizeof cnt);
		idx=0;
		for(int i=0;i&lt;n;i++)
		{
			char str[25];
			scanf(&quot;%s&quot;,str);
			insert(str);
		}
		
		build();
		
		//print();
		
		scanf(&quot;%s&quot;,s+1);
		int len=strlen(s+1);
		
		memset(f,0x3f,sizeof f);
		f[0][0]=0;
		for(int i=1;i&lt;=len;i++)
			for(int j=0;j&lt;=idx;j++)
				for(int k=0;k&lt;4;k++)
				{
					int t=get(s[i]) != k;
					int p=trie[j][k];
					if(!cnt[p])
						f[i][p]=min(f[i][p],f[i-1][j]+ t);
				}
				
		int res=INF;
		for(int i=0;i&lt;=idx;i++)
			res=min(res,f[len][i]);
		
		if(res == INF)
			res=-1;
		printf(&quot;Case %d: %d\n&quot;,kas++,res);
	}
	return 0;
}
</code></pre>
<p>最后，循环dp[len][j]，即在读完最后一个字符后检查所有状态的最终值，取其最小。如果均不可达，则返回-1。<br>
类似题：求主串至少包含一个模式串的方案数，正难则反。<br>
<a href="https://paste.ubuntu.com/p/8cQmVfDpxH/">代码</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2243">hdu2233</a><br>
长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？<br>
比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为<br>
(2个) aa,ab,<br>
(26个)aaa,aab,aac...aaz,<br>
(26个)aba,abb,abc...abz,<br>
(25个)baa,caa,daa...zaa,<br>
(25个)bab,cab,dab...zab。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_e378c0a064-21.png" alt="21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_f3a3c3da64-22.png" alt="22.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_025f2e9e64-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_05abfa1e64-24.png" alt="24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_be3731ec64-25.png" alt="25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_c20f74aa64-26.png" alt="26.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/12/9969_d039051e64-27.png" alt="27.png" loading="lazy"><br>
<a href="https://paste.ubuntu.com/p/vVvdmfW8dV/">代码</a><br>
若要求长度正好为L，原矩阵的L次幂即可<br>
长度不超过L，需要累加</p>
<p><a href="https://www.acwing.com/problem/content/1287/">acwing1285</a><br>
每次插入一个单词时把所有路径上的点都+1，每个单词的出现次数就是其结尾节点的fail树子树和。因为其fail指针指向的节点一定包含当前字符串。<br>
统计贡献时要从下往上按照拓扑排序加，<br>
<a href="https://paste.ubuntu.com/p/sxwbtsytTg/">代码</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3695">hdu3695</a><br>
给出 n 个模式串，给出一个长串 S，找出 S 中出现了几种模式串。注意模式串在 S 中正着出现和反着出现都算出<br>
现。S 可能有些段是压缩过的，格式为[tx]，t 是一个数字，x 是一个字母，代表有 t 个 x。把 a[3b]c 解压后会得到<br>
abbbc。<br>
n≤250，模式串的长度不超过1000，t≤5·1e6, 解压后的长串的长度不超过 5100000.</p>
<blockquote></blockquote>
<p>样例输入：<br>
3<br>
2<br>
AB DCB<br>
DACB<br>
3<br>
ABC CDE GHI<br>
ABCCDEFIHG<br>
4<br>
ABB ACDEE BBB FEEE<br>
A[2B]CD[4E]F<br>
样例输出：<br>
0<br>
3<br>
2</p>
<p>我们可以把这 n 个串插入 Trie 树，建成 AC 自动机。然后把解压后的 S 正着在 AC 自动机上跑一遍，再反着在<br>
AC 自动机上跑一遍，对于覆盖过的模式串，打一个标记。最后统计标记的总数即可</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=250010,M=5100010;
int trie[N][26],idx;
char s[M],tmp[M];
int ne[N];
int dar[N];
int n;
int q[N];

void insert(char *s,int k)
{
    int p=0;
    for(int i=0;s[i];i++)
    {
        int k=s[i]-'A';
        if(!trie[p][k])
        {
        	trie[p][k]=++idx;
        	memset(trie[idx],0,sizeof trie[idx]);
        	dar[idx]=0;
		}
        p=trie[p][k];
    }
   	dar[p]++;
}

void build()
{
    int hh=0,tt=-1;
    for(int i=0;i&lt;26;i++)
        if(trie[0][i])
        {
        	int t=trie[0][i];
        	q[++tt]=t;
        	ne[t]=0;
		}
    
    while(hh &lt;= tt)
    {
        int t=q[hh++];
        for(int i=0;i&lt;26;i++)
        {
            int p=trie[t][i];
            if(!p) trie[t][i]=trie[ne[t]][i];
            else 
            {
                ne[p]=trie[ne[t]][i];
                q[++tt]=p;
            }
        }
    }
}

int query(char *s,int type)
{
    int len=strlen(s);
    if(type)
        reverse(s,s+len);
    //cout&lt;&lt;&quot;---&quot;&lt;&lt;s&lt;&lt;endl;
    int res=0;
    for(int i=0,j=0;s[i];i++)
    {
        int k=s[i]-'A';
        j=trie[j][k];
        int p=j;
        while(p)
        {
        	if(dar[p])
        	{
        		res+=dar[p];
        		dar[p]=0;
			}
			else 
				break;
            p=ne[p];
        }
    }
    return res;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
    	memset(trie[0],0,sizeof trie[0]);
    	ne[0]=0;
    	dar[0]=0;
        idx=0;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
        {
            char str[1010];
            scanf(&quot;%s&quot;,str);
            insert(str,i);
        }
        
        build();
        
        scanf(&quot;%s&quot;,s);
        int l=0;
        for(int i=0;s[i];i++)
        {
            if(s[i] !='[')
                tmp[l++]=s[i];
            else
            {
                i++;
                int len=0;
                while(s[i] &gt;='0' &amp;&amp; s[i] &lt;='9')
                {
                    len=len*10+s[i]-'0';
                    i++;
                }
                for(int k=0;k&lt;len;k++)
                    tmp[l++]=s[i];
                i++;
            }
        }
        tmp[l]=0;
        
        printf(&quot;%d\n&quot;,query(tmp,0)+query(tmp,1));
    }
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4763">hdu4763</a><br>
给你一个字符串 S。<br>
请你把这个 S 划分成 EAEBE 的形式。<br>
其中 A 和 B 可以包含任意个（可以是0个）字符。<br>
求 E 的最大长度。字符串的长度之和不会超过1e6</p>
<blockquote></blockquote>
<p>Sample Input<br>
5<br>
xy<br>
abc<br>
aaa<br>
aaaaba<br>
aaxoaaaaa</p>
<blockquote></blockquote>
<p>Sample Output<br>
0<br>
0<br>
1<br>
1<br>
2</p>
<p>观察 EAEBE。<br>
首先要保证 E 既是 S 的前缀又是 S 的后缀。<br>
且去除掉前缀 E 和后缀 E 之后，中间剩下的还要出现一次 E。 对 S 跑一次扩展 KMP 中的 Z 算法。<br>
如果 i+Z[i]-1 == n ，就说明 S[i..n] 可以作为 E。<br>
那么就要求在 S[Z[i]+1..i-Z[i]] 中，还得存在一个 j 满足 Z[j] ≥ Z[i]</p>
<p>问题变成了先找 i+Z[i]-1 = n 的 符合条件的i<br>
然后在[Z[i]+1..i-Z[i]] 中，查询 Z 的最大值，如果比Z[i] 大，那么就可以把 Z[i] 作为答案。最后取最大值即可。<br>
查询区间最大值我们可以用线段树 / ST 表来维护。<br>
最后的时间复杂度都是 O(n log n)</p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://caifxh.github.io/post/dan-diao-dui-lie-you-hua-dp/">
                                <h3 class="post-title">
                                    单调队列优化dp
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#manacher">Manacher</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6">计算最长回文子串长度</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E8%B5%B7%E5%A7%8B%E7%B4%A2%E5%BC%95">计算最长回文子串起始索引</a></li>
<li><a href="#trie">trie</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
<li><a href="#ac%E8%87%AA%E5%8A%A8%E6%9C%BA">AC自动机</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>