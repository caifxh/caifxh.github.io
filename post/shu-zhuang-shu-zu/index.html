<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    树状数组 | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1586059488314">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1586059488314" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            树状数组
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-03-27</time>
                            
                                <a href="https://caifxh.github.io/tag/DuNwWZ602/" class="post-tag i-tag
                            i-tag-info">
                            #高级数据结构
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <h4 id="树状数组">树状数组</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_ea7daa625c-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_0f4727c45c-2.png" alt="2.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_112b51965c-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_12d4d95e5c-4.png" alt="4.png" loading="lazy"><br>
sum[9]=c[9]+c[8];<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_14c27b045c-6.png" alt="6.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_3a25eb745c-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_43ddb14c5c-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_4f04036e5c-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_515eba325c-10.png" alt="10.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_9040bed05c-11.png" alt="11.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_92bda3c65c-12.png" alt="12.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_94af6ee45c-13.png" alt="13.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_96e8e8165c-14.png" alt="14.png" loading="lazy"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_b5133a945c-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_b7c387305c-16.png" alt="16.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_cbe5e53c5c-17.png" alt="17.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=10000;
int n,a[maxn],c[maxn],s[maxn];

int lowbit(int i)//c[i]的区间长度 
{
	return (-i)&amp;i;
}

void add(int i,int z)//a[i]加上z
{
	for(;i&lt;=n;i+=lowbit(i))//直接后继，即父亲i+=lowbit(i)
		c[i]+=z;	
} 

int sum(int i)//求前缀和a[1]..a[i] 
{
	int s=0;
	for(;i&gt;0;i-=lowbit(i))//直接前驱 i-=lowbit(i);
		s+=c[i];
	return s; 
}

int sum(int i,int j)//求区间和a[i]..a[j] 
{
	return sum(j)-sum(i-1); 
}

int main()
{
	memset(c,0,sizeof(c));
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;a[i];
		add(i,a[i]);//加入树状数组 
	} 
	int x1,x2;
	cin&gt;&gt;x1;
	cout&lt;&lt;sum(x1)&lt;&lt;endl;
	cin&gt;&gt;x1&gt;&gt;x2;
	cout&lt;&lt;sum(x1,x2)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_dbe5964e5c-18.png" alt="18.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_fc9f24365c-19.png" alt="19.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_ff208a885c-20.png" alt="20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_02536ad65c-21.png" alt="21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_050a62ac5c-22.png" alt="22.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=10000;
int n,a[maxn][maxn],c[maxn][maxn];//二维树状数组 

int lowbit(int i)//区间长度 
{
	return (-i)&amp;i;
}

void add(int x,int y,int z)//a[x][y]加上z
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		for(int j=y;j&lt;=n;j+=lowbit(j))
			c[i][j]+=z;
} 

int sum(int x,int y)//求左上角(1,1)到右下角(x,y)矩阵区间和 
{
	int s=0;
	for(int i=x;i&gt;0;i-=lowbit(i))
		for(int j=y;j&gt;0;j-=lowbit(j))
			s+=c[i][j];
	return s; 
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1); 
}

int main()
{
	for(int i=1;i&lt;=n;i++)
		memset(c[i],0,sizeof(c[i]));
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			cin&gt;&gt;a[i][j];
			add(i,j,a[i][j]);//加入树状数组 
		} 
	int x1,y1,x2,y2;
	cin&gt;&gt;x1&gt;&gt;y1;
	cout&lt;&lt;sum(x1,y1)&lt;&lt;endl;
	cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
	cout&lt;&lt;sum(x1,y1,x2,y2)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2352">poj2352</a><br>
统计x前面比它小的星星的个数。注意的是：给的点的坐标是从0开始的，树状数组下标为0的位置不可用，所以我们需要在输入x坐标时+1。</p>
<p>因为本题给出的数据就是已经按照y从小到大排好序的,也就是说，当前读到一个点的时候，当前点的y坐标肯定比已经读入的大，或者等于。就算是等于的话，也是x坐标比我当前点的x坐标小，所以我们每次只要算x坐标比我们小的就行了 。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_42b726085c-23.png" alt="23.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_fef8cc6a5c-24.png" alt="24.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
#define maxn 32010
int ans[maxn],tr[maxn];//等级统计，每个值的数量 
int n;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x,int c)//将第i个元素增加val，其后继也要增加
{
	for(int i=x;i&lt;=maxn;i+=lowbit(i))//是x点的范围，注意不是星星的个数n 
		tr[i]+=c;//i的后继（父结点） 
}

int sum(int x)//前缀和 
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];//i的前驱
	return res;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int x,y;
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        x++;
        ans[sum(x)]++;
        add(x,1);//x的数量c[x]增1,若是统计小于等于x的数量，则先执行add操作再查询 
    }
    for(int i=0;i&lt;n;i++)
        printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
</code></pre>
<h4 id="树状数组求逆序对">树状数组求逆序对</h4>
<p>1）逆序数问题定义<br>
给一个1~n的排列，求满足i&lt;j且a[i]&gt;a[j]的二元组对数，比如[4,2,1,5,3]这个序列，满足条件的二元组为{&lt;4,2&gt;, &lt;4,1&gt;, &lt;4,3&gt;, &lt;2,1&gt;, &lt;5,3&gt;}，故逆序数是5</p>
<p>2）树状数组求逆序数的原理<br>
首先明确树状数组在此问题中维护信息是某个区间中数字出现的个数，sum(a[i])可求得[1, a[i]]的区间和，这恰好代表第i个数字前小于它的个数，，那么大于它的显然就有sum(n)-sum(a[i])个,然后将源数据按其原本顺序插入树状数组，第i个数字插入的方式为将树状数组的第a[i]位设为1，同时更新覆盖到它的父区间。</p>
<pre><code>for (int i = 1; i &lt;= n; i++) 
{
    ans += sum(n) - sum(a[i]);
    add(a[i], 1);
}
</code></pre>
<p>累加每步的结果后可得逆序数为5，用树状数组的好处在于add操作和sum的操作时间复杂度都为O(logn)，非常的巧妙</p>
<p><a href="https://vjudge.net/problem/POJ-3067">poj3067</a><br>
由于x是从小到大排序的，假设当前我们在处理第k条边，那么第1~k-1条边的x必然是小于（等于时候暂且不讨论）第k条边的 x 的，那么前k-1条边中，与第k条边相交的边的y值必然大于yk的，所以此时我们只需要求出在前k-1条边中有多少条边的y值在区间[yk, M]即可,也就是求yk的逆序数，M为西岸城市个数，即y的最大值。</p>
<p>所以就将问题转化成区间求和的问题，树状数组解决。当两条边的x相同时，我们记这两条边的y值分别为ya，yb（ya&lt;yb),我们先处理（x，ya），再处理（x，yb），原因很明显，因为当x相同时，这两条边是认为没有交点的，若先处理（x，yb），那么下次处理（x，ya）时，（x，ya）就会给（x，yb）增加一个逆序，也就是将这两条边做相交处理了。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1010,M=1000010;
int tr[N];
int n,m,k;
struct Edge 
{
    int x, y;
    bool operator&lt; (const Edge &amp;W) const 
    {
    	if(x == W.x)
    		return y&lt;W.y;
    	else
    		return x&lt;W.x;
	}
}e[M];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x)//加1操作，参数省略
{
	for(int i=x;i&lt;=m;i+=lowbit(i))//y点有m个
		tr[i]++;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))
    	res+=tr[i];
    return res;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    for(int kase=1;kase&lt;=T;kase++)
	{
		memset(tr,0,sizeof tr);
	    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	    for(int i=1;i&lt;=k;i++)
			scanf(&quot;%d%d&quot;,&amp;e[i].x,&amp;e[i].y);
	    sort(e+1,e+k+1);
	    LL ans=0;
	    for(int i=1;i&lt;=k;i++)
		{
			ans+=sum(m)-sum(e[i].y);
			add(e[i].y);
	    }
	    printf(&quot;Test case %d: %lld\n&quot;,kase,ans);
	}
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/243/">acwing241</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_933d74f25c-25.PNG" alt="25.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N = 200010;
int n;
int a[N];
int tr[N];
int bigger[N], lower[N];

int lowbit(int x)
{
    return x &amp; -x;
}

void add(int x, int c)
{
    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++ )//从左向右扫
    {
        bigger[i] = sum(n) - sum(a[i]);//1~i-1有多少数大于y（y+1~n）
        lower[i] = sum(a[i]);//1~i-1有多少数小于y（1~y-1）
        add(a[i], 1);
    }

    memset(tr, 0, sizeof tr);
    LL res1 = 0, res2 = 0;
    for (int i = n; i; i -- )//从右向左扫
    {
        res1 += bigger[i] * (LL)(sum(n) - sum(a[i]));//i+1~n有多少数大于y
        res2 += lower[i] * (LL)(sum(a[i]));//i+1~n有多少数小于y
        add(a[i], 1);
    }

    printf(&quot;%lld %lld\n&quot;, res1, res2);

    return 0;
}
</code></pre>
<h4 id="拓展应用">拓展应用</h4>
<h4 id="1树状数组基本应用-单点修改-区间查询">1.树状数组基本应用. 单点修改 + 区间查询</h4>
<h4 id="2区间修改-单点查询">2.区间修改 + 单点查询</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_bad517fb5c-26.PNG" alt="26.PNG" loading="lazy"><br>
<a href="https://www.acwing.com/problem/content/248/">acwing242</a></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int a[N];
int n,m;
int tr[N];
typedef long long LL;

int lowbit(int x)
{
	return x&amp;-x;
}

void add(int x,int c)
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		tr[i]+=c;
}

int sum(int x)
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=tr[i];
	return res;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		add(i,a[i]-a[i-1]);
	}
	
	while(m--)
	{
		char op[2];
		scanf(&quot;%s&quot;,op);
		if(*op == 'C')
		{
		    int l,r,d;
			scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;d);
			add(l,d);
			add(r+1,-d);
		}
		else
		{
		    int x;
		    scanf(&quot;%d&quot;,&amp;x);
			printf(&quot;%d\n&quot;,sum(x));
		}
	}
	return 0;
 } 
</code></pre>
<h4 id="3区间修改-区间查询">3.区间修改 + 区间查询</h4>
<p><a href="https://www.acwing.com/problem/content/244/">acwing243</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/02/9969_297f0dc65c-27.PNG" alt="27.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_dbf7552a5c-28.PNG" alt="28.PNG" loading="lazy"></p>
<pre><code>//区间加
//区间和
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
const int N=100010;
int n,m;
int a[N];
LL tr1[N];//维护b[i]的前缀和
LL tr2[N];//维护b[i]*i的前缀和

int lowbit(int x)
{
    return x&amp;-x;
}

void add(LL tr[],int x,LL c)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

LL sum(LL tr[],int x)
{
    LL res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=tr[i];
    return res;
}

LL prefix_sum(int x)
{
    return sum(tr1,x)*(x+1)-sum(tr2,x);
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    for(int i=1;i&lt;=n;i++)
    {
        int b=a[i]-a[i-1];//最大为1e9
        add(tr1,i,b);
        add(tr2,i,(LL)i*b);
    }
    
    while(m--)
    {
        char op[2];
        int l,r,d;
        scanf(&quot;%s%d%d&quot;,op,&amp;l,&amp;r);
        if(*op == 'Q')
            printf(&quot;%lld\n&quot;,prefix_sum(r)-prefix_sum(l-1));
        else
        {
            scanf(&quot;%d&quot;,&amp;d);
            add(tr1,l,d);
            add(tr1,r+1,-d);
            add(tr2,l,l*d);
            add(tr2,r+1,(r+1)*-d);
        }
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/245/">acwing244</a><br>
我们发现,如果说第K头牛的前面有Ak头牛比它矮,那么它的身高Hk就是数值1 n中第Ak+1小的没有在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>H</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">H_{k+1},H_{k+2},…,H_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中出现过的数<br>
所以说,我们需要建立一个长度为n的01序列b,刚开始都是1,然后n到1倒序扫描每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,对于每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
执行查询和修改操作.<br>
也就是说这道题目的题意就是让我们,动态维护一个01序列,支持查询第k个1所在的位置,以及修改序列中的一个数值</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=100010;
int h[N];
int n;
int tr[N];
int ans[N];

int lowbit(int x)
{
    return x&amp;-x;
}

void add(int x,int c)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        tr[i]+=c;
}

int sum(int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))  
        res+=tr[i];
    return res;
}

int main()
{
    cin&gt;&gt;n;
    for(int i=2;i&lt;=n;i++)
        cin&gt;&gt;h[i];
        
    for(int i=1;i&lt;=n;i++)   
        tr[i]=lowbit(i);//相当于add(i,1);
    
    for(int i=n;i;i--)
    {
        int k=h[i]+1;
        int l=1,r=n;
        while(l&lt;r)
        {
            int mid=l+r&gt;&gt;1;
            if(sum(mid) &gt;= k)
                r=mid;
            else
                l=mid+1;
        }
        ans[i]=l;
        add(l,-1);
    }
    
    for(int i=1;i&lt;=n;i++)
        cout&lt;&lt;ans[i]&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-1195">poj1195</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_78e266ec5c-29.PNG" alt="29.PNG" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define maxn 1050
#define lowbit(x) (x)&amp;(-x)
int c[maxn][maxn],n;

void add(int x,int y,int z)//单点更新 
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        for(int j=y;j&lt;=n;j+=lowbit(j))
            c[i][j]+=z;
}

int sum(int x,int y)//区间和：左上角(1,1)到右下角(x,y)矩阵区间和 
{
    int s=0;
    for(int i=x;i&gt;0;i-=lowbit(i))
        for(int j=y;j&gt;0;j-=lowbit(j))
            s+=c[i][j];
    return s;
}

int sum(int x1,int y1,int x2,int y2)//求左上角(x1,y1)到右下角(x2,y2)子矩阵区间和 
{
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1);
}

int main()
{
    int opt,x,y,a,l,b,r,t;
	while(scanf(&quot;%d&quot;,&amp;opt)!=EOF)
	{
		if(opt==3) break;
		if(opt==0)
		{
			scanf(&quot;%d&quot;,&amp;n);
    		memset(c,0,sizeof(c));
		}
		else if(opt==1)
		{
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;a);
            ++x;++y;
            add(x,y,a);
        }
        else
		{
            scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;b,&amp;r,&amp;t);
            ++l,++b,++r,++t;
            printf(&quot;%d\n&quot;,sum(l,b,r,t));
        }
	}
    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-3321">poj3321</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_3d7817525c-30.png" alt="30.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_4079f47a5c-31.png" alt="31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_5ffe30ea5c-32.png" alt="32.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/03/9969_4635be445c-33.png" alt="33.png" loading="lazy"></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=1e5+10;
int n,q;
int c[maxn];
int a[maxn];
int L[maxn],R[maxn];
int head[maxn];
int cnt;
int dfn;
struct edge{
    int u,v;
    int next;
}E[2*maxn];

void adde(int u,int v)
{
    E[++cnt].u=u;
    E[cnt].v=v;
    E[cnt].next=head[u];
    head[u]=cnt;
}

int lowbit(int x)
{
    return x&amp;(-x);
}

void add(int x,int v)
{
    for(int i=x;i&lt;=n;i+=lowbit(i))
        c[i]+=v;
}

int sum(int x)
{
    int ans=0;
    for(int i=x;i;i-=lowbit(i))
    {
        ans+=c[i];
    }
    return ans;
}


void dfs(int u,int fa)
{
    L[u]=++dfn;
    for(int i=head[u];i;i=E[i].next)
    {
        int v=E[i].v;
        if(v==fa) continue;
        dfs(v,u);
    }
    R[u]=dfn;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int u,v;
    for(int i=1;i&lt;=n;i++)
    {
        c[i]=lowbit(i);
        a[i]=1;
    }
    for(int i=1;i&lt;n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        adde(u,v);
    }
    dfs(1,-1);
//	for(int i=1;i&lt;=n;i++)//测试dfs序列 
//    	printf(&quot;--%d %d\n&quot;,L[i],R[i]);
//  	printf(&quot;\n&quot;);	
    scanf(&quot;%d&quot;,&amp;q);
    char op[10];
    for(int i=1;i&lt;=q;i++)
    {
        scanf(&quot;%s%d&quot;,op,&amp;v);
        if(op[0]=='C')
        {
        	int j=L[v];
            if(a[j])//由于每个节点的dfn编号就是它的左值，所以直接修改左节点
                add(j,-1);
            else
                add(j,1);
            a[j]^=1;
        }
        else
        {
            int s1=sum(R[v]);
            int s2=sum(L[v]-1);
            printf(&quot;%d\n&quot;,s1-s2);
        }
    }
    return 0;
}
</code></pre>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://caifxh.github.io/post/shu-lun/">
                                <h3 class="post-title">
                                    数论
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组</a></li>
<li><a href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9">树状数组求逆序对</a></li>
<li><a href="#%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8">拓展应用</a></li>
<li><a href="#1%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8-%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9-%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">1.树状数组基本应用. 单点修改 + 区间查询</a></li>
<li><a href="#2%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">2.区间修改 + 单点查询</a></li>
<li><a href="#3%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">3.区间修改 + 区间查询</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>