<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    无向图/有向图的连通性复习 | fxh&#39;blog
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1594530304239">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1594530304239" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh&#39;blog
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            无向图/有向图的连通性复习
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-04-01</time>
                            
                                <a href="https://caifxh.github.io/tag/-P-78lMopw/" class="post-tag i-tag
                            i-tag-other_3">
                            #图论
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <h4 id="相关概念">相关概念</h4>
<h4 id="1无向图">1.无向图</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_e9d8ce8650-%E5%9B%BE%E7%89%871.png" alt="图片1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_30fd91a250-%E5%9B%BE%E7%89%872.png" alt="图片2.png" loading="lazy"></p>
<h4 id="2有向图">2.有向图</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_68b062be50-%E5%9B%BE%E7%89%874.png" alt="图片4.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_75791d1050-%E5%9B%BE%E7%89%875.png" alt="图片5.png" loading="lazy"></p>
<h4 id="3割点和桥">3.割点和桥</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_97f43b7250-%E5%9B%BE%E7%89%876.png" alt="图片6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_9a82923050-%E5%9B%BE%E7%89%877.png" alt="图片7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_b95a655250-%E5%9B%BE%E7%89%878.png" alt="图片8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_bbf3de2450-%E5%9B%BE%E7%89%879.png" alt="图片9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_4cf211d450-%E5%9B%BE%E7%89%8710.png" alt="图片10.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_6a3d954c50-%E5%9B%BE%E7%89%8712.png" alt="图片12.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_836f7e0450-%E5%9B%BE%E7%89%8713.png" alt="图片13.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_aff6e25c51-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_c688d7f051-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_997fdc8e50-%E5%9B%BE%E7%89%8714.png" alt="图片14.png" loading="lazy"></p>
<h4 id="4tarjan算法">4.tarjan算法</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_0ed9e31a50-%E5%9B%BE%E7%89%8717.png" alt="图片17.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_16c7513450-%E5%9B%BE%E7%89%8718.png" alt="图片18.png" loading="lazy"></p>
<h4 id="41无向图的桥">4.1无向图的桥</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_3364dd5250-%E5%9B%BE%E7%89%8719.png" alt="图片19.png" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&gt;dfn[u])
				cout&lt;&lt;u&lt;&lt;&quot;—&quot;&lt;&lt;v&lt;&lt;&quot;是桥&quot;&lt;&lt;endl; 
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
				tarjan(1,0);
	}
	return 0;
}
</code></pre>
<h4 id="42无向图的割点">4.2无向图的割点</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_9b23cd3650-%E5%9B%BE%E7%89%8720.png" alt="图片20.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_36cbb05e50-%E5%9B%BE%E7%89%8721.png" alt="图片21.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_3fabda8c50-%E5%9B%BE%E7%89%8722.png" alt="图片22.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt,root;
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	int count=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&gt;=dfn[u])
			{
				count++;
				if(u!=root||count&gt;1)
					cout&lt;&lt;u&lt;&lt;&quot;是割点&quot;&lt;&lt;endl; 
			}	
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i,0);
			 } 
	}
	return 0;
}
</code></pre>
<h4 id="有向图的强连通分量scc">有向图的强连通分量（SCC）</h4>
<figure data-type="image" tabindex="2"><img src="https://cdn.acwing.com/media/article/image/2020/02/16/9969_91ef325650-%E5%9B%BE%E7%89%8723.png" alt="图片23.png" loading="lazy"></figure>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
stack&lt;int&gt;s;
bool ins[maxn];
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		cout&lt;&lt;&quot;连通分量：&quot;;
		do
		{
			v=s.top();
			s.pop();
			cout&lt;&lt;v&lt;&lt;&quot; &quot;;
			ins[v]=false;
		}while(v!=u);
		cout&lt;&lt;endl;
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(ins,0,sizeof(ins));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
	}
	return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="http://poj.org/problem?id=1144">poj1144</a><br>
求割点数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=105;
int n,root;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn*maxn];

int low[maxn],dfn[maxn],num;
bool cut[maxn];
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	dfn[u]=low[u]=++num;
	int flag=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]&gt;=dfn[u])
			{
				flag++;
				if(u!=root||flag&gt;1)//u不是根或者u是根但至少有两个子结点
					cut[u]=true; 			
			}
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(cut,false,sizeof(cut));
	cnt=num=0;
}

int main()
{ 
	while(cin&gt;&gt;n&amp;&amp;n)
	{
		init(); 
		int u,v;
		while(cin&gt;&gt;u&amp;&amp;u)
		{
			while(1)
			{
				char c=getchar();
				if(c=='\n')
					break;
				cin&gt;&gt;v;
				add(u,v);
				add(v,u);
			}
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i);
			}
		int ans=0;
		for(int i=1;i&lt;=n;i++)
			if(cut[i])
				ans++;
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=3532">poj3352</a><br>
最少加几条边，才能使无向图变成边双连通图。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_65ccf7c051-%E5%9B%BE%E7%89%8724.png" alt="图片24.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_8fec68a651-%E5%9B%BE%E7%89%8725.png" alt="图片25.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_92f0d99251-%E5%9B%BE%E7%89%8726.png" alt="图片26.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&lt;&lt;1];

int low[maxn],dfn[maxn],degree[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(degree,0,sizeof(degree));
	cnt=num=0;
}

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
			add(v,u);
		}
		tarjan(1,-1);
		for(int u=1;u&lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(low[u]!=low[v])
					degree[low[u]]++;
			}
		int leaf=0;
		for(int i=1;i&lt;=n;i++)
			if(degree[i]==1)
				leaf++;
		cout&lt;&lt;(leaf+1)/2&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p>换种写法：(可求得所有点双连通分量)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=5010,M=200010;
int h[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
int d[N];
bool is_bridge[M];
int id[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u,int fa)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        if(!dfn[j])
        {
            tarjan(j,u);
            low[u]=min(low[u],low[j]);
            if(dfn[u] &lt; low[j])
                is_bridge[i]=is_bridge[i^1]=true;
        }
        else
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++dcc_cnt;
        int y;
        do{
            y=stk[top--];
            id[y]=dcc_cnt;
        }while(y != u);
    }
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        add(a,b);
        add(b,a);
    }
    
    tarjan(1,-1);
    
    for(int i=0;i&lt;idx;i++)
        if(is_bridge[i])
            d[id[e[i]]]++;
            
    int cnt=0;
    for(int i=1;i&lt;=dcc_cnt;i++)
        if(d[i] == 1)
            cnt++;
    cout&lt;&lt;(cnt+1)/2&lt;&lt;endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_056f276c51-%E5%9B%BE%E7%89%8728.png" alt="图片28.png" loading="lazy"></figure>
<blockquote></blockquote>
<p><a href="http://poj.org/problem?id=2553">poj2553</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_d26602d651-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG" loading="lazy"><br>
求解强连通分量，缩点，计算缩点的出度，统计出度为0的顶点。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5af107cc51-%E5%9B%BE%E7%89%8729.png" alt="图片29.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;stack&gt;
using namespace std;
const int maxn=5050;
int n,m;
bool ins[maxn];//标记是否在栈内 
int head[maxn],id[maxn],dout[maxn];
int low[maxn],dfn[maxn];
stack&lt;int&gt; s;
int cnt,num,scc_cnt;
struct Egde
{
	int to,next;
}e[maxn*maxn];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(ins,false,sizeof(ins));
	memset(dout,0,sizeof(dout));
	memset(id,0,sizeof(id));
	cnt=num=0;
	scc_cnt=0;
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		++scc_cnt;
		do
		{
			v=s.top();
			s.pop();
			id[v]=scc_cnt;
			ins[v]=false;
		}while(v!=u);
	}
}

int main()
{
	while((cin&gt;&gt;n)&amp;&amp;n)
	{
		cin&gt;&gt;m;
		init();
		while(m--)
		{
			int u,v;
			cin&gt;&gt;u&gt;&gt;v;
			add(u,v);
		}
		for(int i=1;i&lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
		for(int u=1;u&lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(id[u]!=id[v])
					dout[id[u]]++; 
			}
		int flag=1;
		for(int i=1;i&lt;=n;i++)
		{
			if(!dout[id[i]])
			{
				if(flag)
					flag=0;
				else
					cout&lt;&lt;&quot; &quot;;
				cout&lt;&lt;i;
			}		
		}
		cout&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=1236">poj1236</a>/<a href="https://www.acwing.com/problem/content/369/">acwing367</a><br>
至少添加几条边，使得有向图为强连通图<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5b172a9851-%E5%9B%BE%E7%89%8730.png" alt="图片30.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5e7c024451-%E5%9B%BE%E7%89%8731.png" alt="图片31.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_1f7d3e4051-%E5%9B%BE%E7%89%8732.png" alt="图片32.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=110,M=N*N;
int n;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N];
int stk[N],top;
bool in_stk[N];
int scc_cnt,timestamp;
int id[N];
int dout[N],din[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    in_stk[u]=true;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(in_stk[j])
            low[u]=min(low[u],dfn[j]);
    }   
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            //cout&lt;&lt;y&lt;&lt;' ';
            in_stk[y]=false;
            id[y]=scc_cnt;
        }while(y != u);
        //cout&lt;&lt;endl;
    }
}

int main()
{
    cin&gt;&gt;n;
    memset(h,-1,sizeof h);
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        while(cin&gt;&gt; x &amp;&amp; x)
            add(i,x);
    }
        
    
    for(int i=1;i&lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
    
    // for(int i=1;i&lt;=n;i++)
    // {
    //     cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;id[i]&lt;&lt;endl;
    // }
    for(int i=1;i&lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                dout[a]++;
                din[b]++;
            }
        }
     
    int a=0,b=0;  
    for(int i=1;i&lt;=scc_cnt;i++)
    {
        if(!din[i])
            a++;
        if(!dout[i])
            b++;
    }
    
    cout&lt;&lt;a&lt;&lt;endl;
    if(scc_cnt == 1)
        cout&lt;&lt;0&lt;&lt;endl;
    else
        cout&lt;&lt;max(a,b)&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1176/">acwing1174</a><br>
（1）若采用暴力求解，先建反图，判断从每个点出发能否到达所有点。时间复杂度：$O(n(n+m))<br>
（2）若为拓扑图，则只需判断出度为0的点，若出度为0的点大于1个，则答案为0，若出度为0的点为1，则答案为1.<br>
先求出所有强连通分量，然后缩点，判断出度为0的分量，答案为该分量里的点的数目。</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010, M = 50010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, cnt[N];//强连通分量编号，每个分量里点的数目
int dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            cnt[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b);
    }

    for (int i = 1; i &lt;= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 1; i &lt;= n; i ++ )
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b) dout[a] ++ ;
        }

    int zeros = 0, sum = 0;
    for (int i = 1; i &lt;= scc_cnt; i ++ )
        if (!dout[i])
        {
            zeros ++ ;
            sum += cnt[i];
            if (zeros &gt; 1)
            {
                sum = 0;
                break;
            }
        }

    printf(&quot;%d\n&quot;, sum);

    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1177/">acwing1175</a><br>
求最大半连通子图的结点数和最大半连通子图数。<br>
(1)对于任何一个强连通分量（tarjan），一定是半连通分量。<br>
(2)缩点，建图得到一个有向无环图（拓扑图），求拓扑图上的最长链（最长链包含的结点数即为最大半连通子图的结点数）。缩完点之后的图中出现了重边怎么办,那就会使方案数莫名增多.所以对于缩完点后的图还要判重边<br>
(3)最长链的条数即为最大半连通子图数。<br>
求最长链采用dp，跑最长路,我们只需要找出一条点权最大的路径就行了，不限制点的个数。<br>
所以首先对这个图进行tarjan缩点，并记录下每个连通块的大小，和每个点所在的连通块。<br>
缩点之后，会发现这个图变成了一个dag（有向无环图），我们要对这个dag求出最长链的大小和个数。<br>
因为这个图是无环的，所以我们可以按照拓扑序进行DP</p>
<h4 id="tarjan缩点后的点的标号顺序是逆拓扑序所以不需要对新图进行拓扑排序">Tarjan缩点后的点的标号顺序是逆拓扑序，所以不需要对新图进行拓扑排序</h4>
<p>状态表示: f[i]表示到第i个连通块的最长链大小，g[i]表示个数。<br>
很容易就想到了转移的方法：<br>
1.{g[i]=g[i]+g[j]}(条件：f[j]+number[i]==f[i])<br>
2.{g[i]=g[j],f[i]=f[j]+number[i]}(条件：f[j]+number[i]&gt;f[i])。<br>
按照这个转移状态就可以啦。<br>
总结：强连通分量+缩点+去重+DAGdp</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;unordered_set&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100010,M=2000010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m,mod;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N],g[N];
typedef pair&lt;int,int&gt; PII;
int stk[N],top;
bool ins[N];
typedef long long LL;

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]++;
        }while(y != u);
    }
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    unordered_set&lt;LL&gt; S;//(u,v)-&gt;u*1000000+v
    for(int i=1;i&lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            LL hash=a*1000000ll+b;
            if(a != b &amp;&amp; !S.count(hash))
            {
                add(hs,a,b);
                S.insert(hash);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
        if (!f[i])//代表它是入度为0的点 
        {
            f[i] = Size[i];
            g[i] = 1;
        }
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
                g[k]=g[i];
            }
            else if(f[k] == f[i] + Size[k])
                g[k]=(g[k]+g[i])%mod;
        }
    }
    
    int maxf=0,sum=0;
    for(int i=1;i&lt;=scc_cnt;i++)
        if(f[i]&gt;maxf)
        {
            maxf=f[i];
            sum=g[i];
        }
        else if(f[i] == maxf)
            sum=(sum+g[i])%mod;
    
    cout&lt;&lt;maxf&lt;&lt;endl;
    cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
    
}
</code></pre>
<p>补一个缩点的模板<a href="https://www.luogu.com.cn/problem/P3387">缩点</a>`</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=10010,M=200010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N];
int stk[N],top;
bool ins[N];
int p[N];//点权 

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]+=p[y];
        }while(y != u);
    }
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    	cin&gt;&gt;p[i];
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    for(int i=1;i&lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                add(hs,a,b);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
    	if(!f[i])
    	{
    		f[i]=Size[i];
		}
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
            }
        }
    }
    
    int maxf=0;
    for(int i=1;i&lt;=scc_cnt;i++)
  		maxf=max(maxf,f[i]);
    cout&lt;&lt;maxf&lt;&lt;endl;
    return 0;
    
}
</code></pre>
<p>再补一个DAGdp的简单题<a href="https://www.luogu.com.cn/problem/P1137">P1137</a></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=100000+15;
int n,m,idx;
int head[maxn],din[maxn],dp[maxn];
struct EDGE
{
    int to;
	int next;
}edge[maxn&lt;&lt;2];
int q[maxn],hh,tt=-1;

void add(int x,int y)
{
    edge[++idx].next=head[x];
    edge[idx].to=y;
    head[x]=idx;
}

void topsort()
{
    
    for (int i=1;i&lt;=n;i++)
	    if (din[i]==0) 
			q[++tt]=i;
			
    while (hh&lt;=tt)
    {
        int t=q[hh++];
        for (int i=head[t];i;i=edge[i].next)
        {
            int v=edge[i].to;
            din[v]--;
            if (din[v]==0)
            	q[++tt]=v;
        }
    }
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        add(u,v);
        din[v]++;
    }
    
    topsort();
    
    for (int i=1;i&lt;=n;i++)
    {
        int u=q[i-1];
        if(!dp[u])
        	dp[u]=1;
        for (int j=head[u];j;j=edge[j].next)
        {
            int v=edge[j].to;
            dp[v]=max(dp[v],dp[u]+1);
        }
    }
    for (int i=1;i&lt;=n;i++)
    	printf(&quot;%d\n&quot;,dp[i]);
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1185/">acwing1183</a><br>
题意：求删除一个点后，图中最多有多少个连通块。</p>
<pre><code>/*
1.统计连通块数量
2.枚举每一个连通块删除割点后所得的最大连通块数ans
3.ans+cnt-1即为答案
*/
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=10010,M=30010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int ans;
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &gt;= dfn[u])
            {
                cnt++;
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }

    if(u != root &amp;&amp; cnt)//不是根节点，还要加上父节点的那一块连通分量
        cnt++;
    ans=max(ans,cnt);//每一个连通块删除割点后所得的最大连通块数ans
}

int main()
{
    while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n)
    {
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(low,0,sizeof low);
        idx=timestamp=0;
        ans=0;

        while(m--)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            add(a,b);
            add(b,a);
        }

        int cnt=0;
        for(root=0;root&lt;n;root++)
            if(!dfn[root])
            {
                cnt++;//连通块数
                tarjan(root);
            }
        
        cout&lt;&lt;ans+cnt-1&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/398/">acwing396</a><br>
题意：<br>
就是有很多个点，在某个时候一个点将会塌陷，你要建造一些点，使任意一点塌陷时其他点都能成功逃脱<br>
情况一：当前连通块内没有一个割点<br>
那么此时至少要建立两个点，使得在任意一点坍塌时能顺利逃脱，那么此时要建立的点的个数就是2，<br>
而方案数则是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">C_n^2 = \frac{n(n−1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,n为点数<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_5e45159651-111.PNG" alt="111.PNG" loading="lazy"><br>
情况二：当前连通块中有一个割点<br>
此时在当前点双连通分量中非割点位置任意选取一个顶点建立1个出口即可，方案数为；cnt-1（cnt为当前连通分量中点数）<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/17/9969_f1256c0851-222.PNG" alt="222.PNG" loading="lazy"><br>
情况三：当前连通块中中有一个割点以上，无需设置出口（一个割点时已设置出口，且各个v-dcc连通，无论删去任意一个出口or割点or普通点，都可保证剩下点可成功逃离）</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 1010, M = 1010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
vector&lt;int&gt; dcc[N];
bool cut[N];
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    if(u == root &amp;&amp; h[u] == -1)
    {
        dcc_cnt++;
        dcc[dcc_cnt].push_back(u);
        return;
    }
    
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &gt;= dfn[u])
            {
                cnt++;
                if(u != root || cnt &gt;1)
                    cut[u]=true;
                ++dcc_cnt;
                int y;
                do{
                    y=stk[top--];
                    dcc[dcc_cnt].push_back(y);
                }while(y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }
}

int main()
{
    int kase=1;
    while(cin&gt;&gt;m &amp;&amp; m)
    {
        for(int i=1;i&lt;=dcc_cnt;i++)
            dcc[i].clear();
        idx=n=timestamp=top=dcc_cnt=0;
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(cut,0,sizeof cut);
        
        while(m--)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            n=max(n,a),n=max(n,b);
            add(a,b);
            add(b,a);
        }
        
        for(root = 1; root &lt;= n; root ++)
        {
            if(!dfn[root])
                tarjan(root);
        }
        
        int res=0;
        ULL num=1;
        for(int i=1;i&lt;=dcc_cnt;i++)
        {
            int cnt=0;//统计当前v-dcc中割点的数量
            for(int j=0;j&lt;dcc[i].size();j++)
                if(cut[dcc[i][j]])
                    cnt++;
            
            if(cnt == 0)
            {
                if(dcc[i].size()&gt;1)
                    res+=2,num*=dcc[i].size()*(dcc[i].size()-1)/2;
                else 
                    res++;//孤立点
            }
            else if (cnt == 1)
            {
                res++,num*=dcc[i].size()-1;
            }
        }
         printf(&quot;Case %d: %d %llu\n&quot;, kase++, res, num);
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/370/">acwing368</a><br>
图片转自<a href="https://www.acwing.com/user/myspace/index/11971/">@xxh</a>的题解<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/18/9969_55ff82da52-cf30.PNG" alt="cf30.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/18/9969_6544d1be52-cf31.PNG" alt="cf31.PNG" loading="lazy"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 600010;

int n, m;
int h[N], hs[N], e[M], ne[M], w[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, size[N];
int dist[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    for (int i = 1; i &lt;= n; i ++ ) add(h, 0, i, 1);

    while (m -- )
    {
        int t, a, b;
        scanf(&quot;%d%d%d&quot;, &amp;t, &amp;a, &amp;b);
        if (t == 1) add(h, b, a, 0), add(h, a, b, 0);
        else if (t == 2) add(h, a, b, 1);
        else if (t == 3) add(h, b, a, 0);
        else if (t == 4) add(h, b, a, 1);
        else add(h, a, b, 0);
    }

    tarjan(0);//从超级源点可到所有点

    bool success = true;
    for (int i = 0; i &lt;= n; i ++ )
    {
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a == b)
            {
                if (w[j] &gt; 0)//只要任意一个SCc里有边权大于0的边，则存在正环
                {
                    success = false;
                    break;
                }
            }
            else 
                add(hs, a, b, w[j]);
        }
        if (!success) 
            break;
    }

    if (!success) puts(&quot;-1&quot;);
    else
    {
        for (int i = scc_cnt; i; i -- )
        {
            //入度为0的点dist为0
            for (int j = hs[i]; ~j; j = ne[j])
            {
                int k = e[j];
                dist[k] = max(dist[k], dist[i] + w[j]);
            }
        }

        LL res = 0;
        for (int i = 1; i &lt;= scc_cnt; i ++ ) 
            res += (LL)dist[i] * size[i];

        printf(&quot;%lld\n&quot;, res);
    }

    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3627">P3627</a><br>
题意：<br>
在有向图中找一条路径，使得经过的点的点权和最大（每个点可以经过多次，但只有一次对答案的贡献<br>
思路：<br>
首先看见可以重复走路径，那么就想到其实这些路口可以构成一个个强连通分量（因为只要我们能到达一个强连通分量其中某一个点，那么我们就能到达这个强连通分量的其余所有点，根据贪心策略，这样得到的答案保证更优）。那就很容易想到缩点加最长路。<br>
缩点+spfa最长路<a href="https://paste.ubuntu.com/p/ftjQ8xspVv/">code</a></p>
<p>推荐博客：<br>
https://blog.csdn.net/acmmmm/article/details/16361033<br>
https://blog.csdn.net/sentimental_dog/article/details/53790582</p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://caifxh.github.io/post/qiu-zu-he-shu/">
                                <h3 class="post-title">
                                    求组合数
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">相关概念</a></li>
<li><a href="#1%E6%97%A0%E5%90%91%E5%9B%BE">1.无向图</a></li>
<li><a href="#2%E6%9C%89%E5%90%91%E5%9B%BE">2.有向图</a></li>
<li><a href="#3%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5">3.割点和桥</a></li>
<li><a href="#4tarjan%E7%AE%97%E6%B3%95">4.tarjan算法</a></li>
<li><a href="#41%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E6%A1%A5">4.1无向图的桥</a></li>
<li><a href="#42%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9">4.2无向图的割点</a></li>
<li><a href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8Fscc">有向图的强连通分量（SCC）</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
<li><a href="#tarjan%E7%BC%A9%E7%82%B9%E5%90%8E%E7%9A%84%E7%82%B9%E7%9A%84%E6%A0%87%E5%8F%B7%E9%A1%BA%E5%BA%8F%E6%98%AF%E9%80%86%E6%8B%93%E6%89%91%E5%BA%8F%E6%89%80%E4%BB%A5%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AF%B9%E6%96%B0%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">Tarjan缩点后的点的标号顺序是逆拓扑序，所以不需要对新图进行拓扑排序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>