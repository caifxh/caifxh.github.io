<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gridea</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/css/mdui.min.css">
    <link rel="stylesheet" href="media/css/post.css">
    <link rel="stylesheet" href="media/live2d/css/live2d.css" />
    
</head>
<body class=" mdui-appbar-with-toolbar  mdui-theme-primary-pink mdui-theme-accent-pink">
<header class="mdui-toolbar mdui-color-pink mdui-appbar-fixed mdui-appbar-scroll-toolbar-hide" style="z-index: 1000">
    <a href="javascript:;" mdui-drawer="{target: '#left-drawer',overlay:true}" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
    <span class="mdui-typo-title">Gridea</span>
    <div class="mdui-toolbar-spacer"></div>
<!--    <a href="javascript:history.go(0);" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
    <a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">more_vert</i></a>
</header>

<div class="mdui-drawer mdui-color-white mdui-drawer-full-height mdui-drawer-close" id="left-drawer">
    <ul class="mdui-list">
        <li class="mdui-subheader">菜单</li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/" class="mdui-list-item-content">首页</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/archives" class="mdui-list-item-content">归档</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/tags" class="mdui-list-item-content">标签</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/post/about" class="mdui-list-item-content">关于</a>
        </li>
        
    </ul>
</div>

<div id="content" class="site-content">
    <div id="primary" class="content-area">
        <main id="main" class="site-main" role="main">
            <article id="post-1270" class="post-1270 post type-post status-publish format-standard hentry category-90 category-129 tag-149">
                <header class="entry-header">
                    <h1 class="entry-title">树上差分</h1>
                    <p class="entry-census">发布于 2020-04-03</p>
                    <hr>
                </header>
                <div class="neko">
                    <h4 id="树上差分">树上差分</h4>
<p>树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。这就是树上差分的基本操作。<br>
树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs遍历求出差分数组的前缀和，就可以达到降低复杂度的目的。<br>
需要知道的树的性质:</p>
<ul>
<li>树上任意两个点的路径唯一.</li>
<li>任何子节点的父亲节点唯一.(可以认为根节点是没有父亲的)</li>
</ul>
<p>类比于差分数组,树上差分利用的思想也是前缀和思想.(在这里应该是子树和思想.<br>
当我们记录树上节点被经过的次数,记录某条边被经过的次数的时候.<br>
如果每次强制dfs去标记的话,时间复杂度将高到爆炸!<br>
因此我们引入了树上差分!<br>
与树上差分在一起的使用的是DFS，因为在回溯的时候,我们可以计算出子树的大小.</p>
<p>定义数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cnt_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为节点i被经过的次数.</p>
<h4 id="1点的差分">1.点的差分</h4>
<p>例如,我们从 s--&gt;t ,求这条路径上的点被经过的次数.<br>
很明显的,我们需要找到他们的LCA,(因为这个点是中转点啊<br>
我们需要让cnt[s]++,让cnt[t]++，而让他们的cnt[lca]--，cnt[faher(lca)]--;<br>
如图，绿色的数字代表经过次数.<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_d18e82ce56-0001.jfif" alt="0001.jfif" loading="lazy"><br>
根据刚刚所讲,我们的标记应该是这样的↓<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ea290ba656-00002.jfif" alt="00002.jfif" loading="lazy"><br>
考虑：我们搜索到s,向上回溯.<br>
下面以u表示当前节点,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>o</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">son_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表i的儿子节点.(如果一些son不给出下标,即代表当前节点u的儿子<br>
每个u统计它的子树大小,顺着路径标起来.(即cnt[u]+=cnt[son])<br>
我们会发现第一次从s回溯到它们的LCA时候,cnt[LCA]+=cnt[son[LCA]]<br>
此时cnt[LCA]=0! &quot;不是LCA会被经过一次嘛,为什么是0!&quot;<br>
别急,我们继续搜另一边.<br>
继续：我们搜索到t,向上回溯.<br>
依旧统计每个u的子树大小cnt[u]+=cnt[son]<br>
再度回到LCA 依旧 是cnt[LCA]+=cnt[son[LCA]]<br>
这个时候 cnt[LCA]=1 这就达到了我们要的效果。<br>
担忧： 万一我们再从LCA向上回溯的时候使得其父亲节点的子树和为1怎么办?<br>
这样我们不就使得其父亲节点被经过了一次? 因此我们需要在cnt[faher(lca)]--<br>
这样就达到了标记我们路径上的点的要求!</p>
<p>模板题：<a href="https://www.luogu.com.cn/problem/P3128">luoguP3128</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=50010,M=N*2;
int h[N],e[M],ne[M],idx;
int n,m;
int dep[N];
int q[N];
int fa[N][16];
int p[N];

void add(int a,int b)
{
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

void bfs()
{
	memset(dep,0x3f,sizeof dep);
	dep[0]=0,dep[1]=1;
	int hh=0,tt=0;
	q[0]=1;
	while(hh &lt;= tt)
	{
		int t=q[hh++];
		for(int i=h[t];~i;i=ne[i])
		{
			int j=e[i];
			if(dep[j] &gt; dep[t] +1)
			{
				dep[j] = dep[t] + 1;
				q[++tt]=j;
				fa[j][0]=t;
				for(int k=1;k&lt;=15;k++)
					fa[j][k]=fa[fa[j][k-1]][k-1];
			}
		}
	}
}

int lca(int a,int b)
{
	if(dep[a] &lt; dep[b])
		swap(a,b);
	for(int  k=15;k&gt;=0;k--)
		if(dep[fa[a][k]] &gt;= dep[b])
			a=fa[a][k];
		
	if(a == b)
		return a;
	for(int k=15;k&gt;=0;k--)
		if(fa[a][k] != fa[b][k])
		{
			a=fa[a][k];
			b=fa[b][k];
		}
		
	return fa[a][0]; 
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j != fa)
		{
			dfs(j,u);
			p[u]+=p[j];
		}
	}
}

int main()
{
	//cout&lt;&lt;log2(50000)&lt;&lt;endl;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(h,-1,sizeof h);
	for(int i=0;i&lt;n-1;i++)
	{
		int u,v;
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		add(u,v);
		add(v,u);
	}
	
	bfs();
	
	while(m--)
	{
		int a,b;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		int anc=lca(a,b);
		p[a]++,p[b]++,p[anc]--,p[fa[anc][0]]--;
	}
	
	dfs(1,-1);
	
	int res=0;
	for(int i=1;i&lt;=n;i++)	
		res=max(res,p[i]);
	printf(&quot;%d\n&quot;,res);
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3258">luoguP3258</a><br>
很明显,这是一道点差分.但是不同的是,我们需要在每个位置”中转“一下.<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/25/9969_b6e9f1f457-5.PNG" alt="5.PNG" loading="lazy"><br>
即会重复经过除了起点和终点外的点。<br>
还要注意的是,当我们到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 这一位置的时候,小熊会吃饭 ,即在这里不会有糖果吃. 所以这个位置的经过次数也需要减一<br>
只放个主函数，其他都是模板。。。</p>
<pre><code>int main()
{
	//cout&lt;&lt;log2(300000)&lt;&lt;endl;
	scanf(&quot;%d&quot;,&amp;n);
	memset(h,-1,sizeof h);
	for(int i=1;i&lt;=n;i++)	
		scanf(&quot;%d&quot;,&amp;w[i]);
	for(int i=0;i&lt;n-1;i++)
	{
		int u,v;
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		add(u,v);
		add(v,u);
	}
	
	bfs();
	
	for(int i=1;i&lt;n;i++)
	{
		int a=w[i],b=w[i+1];
		int anc=lca(a,b);
		p[a]++,p[b]++,p[anc]--,p[fa[anc][0]]--;
	}
	
	dfs(1,-1);
	
	for(int i=2;i&lt;=n;i++)
		p[w[i]]--;

	for(int i=1;i&lt;=n;i++)	
		printf(&quot;%d\n&quot;,p[i]);
	return 0;
}
</code></pre>
<h4 id="2边的差分">2.边的差分</h4>
<p>我们对边进行差分需要把边塞给点,但是,这里的标记并不是同点差分一样.<br>
把边塞给点的话,是塞给这条边所连的深度较深的节点. (即塞给儿子节点<br>
红色边为需要经过的边,绿色的数字代表经过次数<br>
正常的话,我们的图是这样的.↓<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_dfda95b556-003.jfif" alt="003.jfif" loading="lazy"><br>
但是由于我们把边塞给了点,因此我们的图应该是这样的↓<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_f1ac4d5056-004.jfif" alt="004.jfif" loading="lazy"><br>
但是根据我们点差分的标记方式来看的话显然是行不通的,<br>
这样的话我们会经过father[LCA]--&gt; LCA这一路径.<br>
因此考虑如何标记我们的点,来达到经过红色边的情况<br>
聪明的你一定想到了,这样来标记<br>
cnt[s]+=1， cnt[t]+=1 ，cnt[LCA]-=2<br>
这样回溯的话,我们即可只经过图中红色边啦!</p>
<p><a href="https://www.acwing.com/problem/content/description/354/">acwing352</a><br>
“主要边” 构成一棵树，而一条 “附加边” 必然会和其两端的 LCA 形成环，<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_ec0765e257-00001.png" alt="00001.png" loading="lazy"><br>
那么，每一条主要边存在三种情况：<br>
1、没有被任何环覆盖<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_fa4fc41e57-00002.png" alt="00002.png" loading="lazy"><br>
2、只被一个环给覆盖<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_06f800e757-00003.png" alt="00003.png" loading="lazy"><br>
3、被2个及以上的环覆盖<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/24/9969_11af308657-00004.png" alt="00004.png" loading="lazy"></p>
<ul>
<li>
<p>对于第一种情况，我们切掉一条“主要边”后其实已经将整张图切成了两部分，但根据题意，还要再切掉一条“附加边”，很显然，随便切哪条都可以，因此此时的方案数即为“附加边”的个数 M。</p>
</li>
<li>
<p>对于第二种情况，我们切掉一条“主要边”后，由于它是在一个环中，所以只能切掉它所在环中的唯一一条“附加边”，因此此时的方案数为 1。</p>
</li>
<li>
<p>对于第三种情况，由于“主要边”存在于2个及以上的环中，因此切掉它之后会使覆盖它的其中两个环合并成一个新环，而我们知道要将一个环切开（此时只有把环切断才能将整张图切开）必须要切两刀，但我们只能再切一刀，所以我们无论如何都不能切开整张图了，因此此时的方案数为 0。</p>
</li>
</ul>
<p>分类讨论完了，我们该怎么去统计每条边被环覆盖的次数呢？<br>
我们就可以用树上差分来做。<br>
与它父亲节点之间的边被环覆盖的次数。</p>
<blockquote>
<p>最后，根据加法原理，我们只要依次统计每条主要边能产生的方案贡献，累加起来即可。</p>
</blockquote>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010, M = N * 2;
int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][17];
int p[N];
int q[N];
int ans;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    q[0] = 1;

    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k &lt;= 16; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 16; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 16; k &gt;= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != fa)
        {
            dfs(j, u);
            p[u]+=p[j];
        }
            
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; n - 1; i ++ )//主要边 
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b), add(b, a);
    }

    bfs();

    for (int i = 0; i &lt; m; i ++ )//附加边 
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        int anc = lca(a, b);
        p[a] ++, p[b] ++, p[anc] -= 2;
    }
    dfs(1, -1);
    
    for(int i=2;i&lt;=n;i++)//边的差分特判根结点 
    {
    	if(!p[i])
    		ans+=m;
    	if(p[i] == 1)
    		ans++;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
    	

    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P2680">luoguP</a><br>
读完题,我们发现,这是一道边差分的题.<br>
为了使得最长的路径最短,我们自然地想到二分答案<br>
简单分析 于是建完边我们先dfs一遍预处理出根节点到每个节点的距离.并把边权塞给点。<br>
预处理距离的话只需要再在dfs中加入一句即可,然后我们可以计算出每条航道间的距离<br>
我们需要将被经过次数最多,且边权最大的边删去.<br>
这样能使我们所用总时间最大值尽可能小<br>
要求最大值最小? 很明显,我们想到了二分答案.<br>
那么如何将二分答案转移到树上呢?<br>
不妨考虑二分最终所有请求的最大树上距离,最后只需判断是否能够通过删掉一条边的边权,最终能否达到这个最大距离即可,样就将一个求解问题转化为了判定问题</p>
<h4 id="解法">解法</h4>
<blockquote></blockquote>
<p>既然想到了二分答案,那我们就二分路径的长度.(即工作时间.<br>
如果一些路径长度大于当前二分的mid,我们就需要记录这些路径上的边其被经过次数.<br>
(比mid小的路径一定已经合法,我们可以在mid时间内完成任务.)<br>
假设路径长度大于mid的有num个<br>
(我们找到被这些路径共同经过的最大的边权,删去它,使得这些路径长度都小于mid,那么这个mid就是合法的.</p>
<h4 id="小细节">小细节</h4>
<p>我们可以通过排序得到最大的路径长度,如果这条最长的路径减去被经过次数&lt;=mid,那这个mid就是合法的,我们就可以去寻找更优解.</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const int N = 300010, M = N * 2;
int n, m;
int h[N], e[M],w[M], ne[M], idx;
int depth[N], fa[N][19];
int p[N];
int q[N];
int ans;
int dist[N];
struct Node
{
	int x,y,anc,dis;
	bool operator&lt; (const Node &amp;W) const 
	{
		return dis &gt; W.dis;
	}
}query[N];
int edge[N];


void add(int a, int b,int c)
{
    e[idx] = b, w[idx]=c, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    q[0] = 1;

    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                dist[j]=dist[t]+w[i];
                edge[j]=w[i];
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k &lt;= 18; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 18; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 18; k &gt;= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != fa)
        {
            dfs(j, u);
            p[u]+=p[j];
        }  
    }
}

bool check(int mid)
{
	memset(p,0,sizeof p);
	int num=0,maxd=0;
	for(int i=0;i&lt;m;i++)
	{
		if(query[i].dis &lt;= mid)
			continue;
		p[query[i].x]++;
		p[query[i].y]++;
		p[query[i].anc]-=2;
		num++;
	}
	
	dfs(1,-1);
	
	for(int i=2;i&lt;=n;i++)
		if(p[i] == num)
			maxd=max(maxd,edge[i]);
	
	if(query[0].dis - maxd &lt;= mid)
		return true;
	return false;
}

int main()
{
	//cout&lt;&lt;log2(300000)&lt;&lt;endl;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; n - 1; i ++ )//主要边 
    {
        int a, b,c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b,&amp;c);
        add(a, b,c), add(b, a,c);
    }

    bfs();
	
	int l=0,r=0;
    for (int i = 0; i &lt; m; i ++ )//附加边 
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        int anc = lca(a, b);
        int d=dist[a]+dist[b]-2*dist[anc];
        query[i]={a,b,anc,d};
        r=max(r,d);
    }
    
    sort(query,query+m);
    
    while(l&lt;r)
    {
    	int mid=l+r&gt;&gt;1;
    	if(check(mid))
    		r=mid;
    	else 
    		l=mid+1;
	}
	
	cout&lt;&lt;l&lt;&lt;endl;
	return 0;

}
</code></pre>

                </div>
            </article>
        </main>
    </div>
    <div class="doc-footer-nav mdui-color-theme">
        <div class="mdui-container">
            <div class="mdui-row">
                
                <a href="https://caifxh.github.io/post/er-fen-tu/" class="mdui-ripple mdui-color-theme mdui-col-xs-2 mdui-col-sm-6 doc-footer-nav-left">
                    <div class="doc-footer-nav-text">
                        <i class="mdui-icon material-icons">arrow_back</i>
                        <span class="doc-footer-nav-direction mdui-hidden-xs-down">上一篇文章</span>
                        <div class="doc-footer-nav-chapter mdui-hidden-xs-down">二分图</div>
                    </div>
                </a>
                
                
                <a href="https://caifxh.github.io/post/niu-ke-han-jia-di-yi-chang/" class="mdui-ripple mdui-color-theme mdui-col-xs-10 mdui-col-sm-6 doc-footer-nav-right">
                    <div class="doc-footer-nav-text">
                        <i class="mdui-icon material-icons">arrow_forward</i>
                        <span class="doc-footer-nav-direction">下一篇文章</span>
                        <div class="doc-footer-nav-chapter">牛客寒假第一场</div>
                    </div>
                </a>
                
            </div>
        </div>
    </div>
    <br>
    
    <div class="comment"></div>
</div>
<footer class="mdui-container footer ">
    <div class="head_card-offset"></div>
    <div class="mdui-row mdui-row-gapless">
        <div class="k-container">
            <img width="100%" src="/media/img/skirt.png">
        </div>
    </div>

    <div class="site-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
</footer>
<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script>
    var message_Path = '/media/live2d/';//资源目录，如果目录不对请更改
    var talkAPI = "";//如果有类似图灵机器人的聊天接口请填写接口路径
</script>
<!--<script src="/media/js/jquery-3.3.1.min.js"></script>-->
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/js/message.js"></script>

</body>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/js/mdui.min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    $('.comment').bind('DOMNodeInserted',()=>{
        $('.comment').unbind()

        $('.vbtn').addClass(' mdui-btn mdui-color-theme-accent mdui-ripple')
    })

    let valine = new Valine({
        el: '.comment',
        
        
        
        path: window.location.pathname,
        pageSize: 30,
        avatar:'mm',
        notify:true
    })
</script>
</html>
