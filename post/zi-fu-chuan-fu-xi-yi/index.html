<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    字符串复习（一） | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1588691348423">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1588691348423" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            字符串复习（一）
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-03-26</time>
                            
                                <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-warning">
                            #字符串
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <h4 id="哈希表">哈希表</h4>
<p>如果要储存和使用线性表（1，75，324，43，1353，90，46）一般情况下我们会使用一个数组 A[1..7] 来顺序存储这些数。<br>
但是这样的存储结构会给查询算法带来 O(n) 的时间开销。<br>
对 A 排序，使用二分查询法，时间复杂度变为 O(log n)也可以用空间换时间的做法，用数组 A[1..1353] 来表示每个数是否出现，查找的时间复杂度变为 O(1)，但是空间上的开销变得巨大。</p>
<p>优化上一种做法，建立一个哈希函数 h(key) = key % 23.(1, 75, 324, 43, 1353, 90) -&gt; (1, 6, 2, 20, 19, 21, 0)<br>
我们只要用一个 A[0..22] 数组就可以快速的查询每个数是否出现。<br>
这种线性表的结构就称为哈希表（Hash Table）。</p>
<p>可以看出，哈希表的基本原理是用一个下标范围比较大的数组 A 来存储元素。<br>
设计一个函数 h，对于要存储的线性表的每个元素 node，取一个关键字 key，算出函数值 h(key) 然后把这个值作为下标，用 A[h(key)] 来存储 node。<br>
最常见的 h 就是模函数，也就是选定一个 m，令 h(key) =key % m.</p>
<p>但是有一个问题，可能存在两个 key: k1, k2 使得h(k1)=h(k2)，这时也称产生了“冲突”。<br>
解决冲突有很多种办法：<br>
1.开放寻址法<br>
2.拉链法：可以让 A 的每个元素都存一个链表，对于<br>
h(k1)=h(k2)，我们可以让这两个 node 都接在 A[h(k1)]<br>
的链表上</p>
<p>假设我们使用第二种方法解决冲突。<br>
对于插入元素(node, key)：</p>
<ul>
<li>计算 h(key)，把 node 插入 A[h(key)] 链表。</li>
</ul>
<p>对于查询元素(node, key)：</p>
<ul>
<li>计算 h(key)，如果 A[h(key)] 为空，说明 node 不存在。<br>
否则遍历 A[h(key)] 链表，寻找 node。</li>
</ul>
<p><a href="https://www.acwing.com/problem/content/842/">模板题</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=100003;
int h[N],e[N],ne[N],idx;

void insert(int x)
{
    int k=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}

bool find(int x)
{
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i])
    {
        if(e[i]==x)
            return true;
    }
    return false;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    memset(h,-1,sizeof(h));
    while(n--)
    {
        char op[2];
        int x;
        scanf(&quot;%s%d&quot;,op,&amp;x);

        if(*op=='I')
            insert(x);
        else
        {
            if(find(x))
                puts(&quot;Yes&quot;);
            else
                puts(&quot;No&quot;);
        }
    }
    return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p>已知 X[1..4] 是 [-T, T] 中的整数，求出满足方程AX[1]+BX[2]+CX[3]+DX[4] = P的解有多少组？<br>
|P|≤1e9，|A|,|B|,|C|,|D|≤1e4，T≤500</p>
<p>最直观的方法枚举 X[1..4], 时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)<br>
适当优化，枚举了X[1..3] 之后，实际上 X[4] 已经确定了，时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)<br>
继续优化，采用 meet in the middle 策略：<br>
一边枚举 X[1], X[2]<br>
一边枚举 X[4], X[3]<br>
然后看有哪些方案可以组成方程的解</p>
<p>枚举 X[1], X[2], 然后算出 P-AX[1]-BX[2],把这个值存入一个哈希表，注意要统计次数。<br>
这一步时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)<br>
然后枚举 X[3], X[4], 算出 CX[3]+DX[4],去哈希表里查找这个值出现了几次。<br>
把次数加进答案，这一步时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)<br>
因此总的时间复杂度是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</p>
<h4 id="字符串哈希">字符串哈希</h4>
<p>假设有 n 个长度为 L 的字符串，问其中最多有几个字符串是相等的。<br>
直接比较两个长度为 L 的字符串是否相等时间复杂度是O(L) 的。<br>
因此需要枚举 O(n2) 对字符串进行比较，时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi>L</mi></mrow><annotation encoding="application/x-tex">n^2L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">L</span></span></span></span>)<br>
如果我们把每个字符串都用一个哈希函数映射成一个整数。<br>
问题就变成了查找一个序列的众数。<br>
时间复杂度变为了 O(nL)</p>
<p>一个设计良好的字符串哈希函数可以让我们先用 O(L) 的时间复杂度预处理，之后每次获取这个字符串的一个子串的哈希值都只要 O(1) 的时间。</p>
<p>BKDRHash 的基本思想就是把一个字符串当做一个 k 进制数来处理</p>
<p>假设字符串 s 的下标从 1 开始，长度为 n</p>
<pre><code>ha[0] = 0;
    for (int i = 1;i &lt;= n;i ++)
        ha[i] = (ha[i - 1] * P + str[i]) % M;
</code></pre>
<p>我们知道 ha[i] 就是 s[1..i] 的 BKDRHash<br>
那么现在询问 s[x..y] 的 BKDRHash ，<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/05/9969_37911bd05e-5.png" alt="5.png" loading="lazy"><br>
因此我们预处理出 ha 数组和 k 的幂次，每次询问 s[x..y]的哈希值，只要 O(1) 的时间。</p>
<h4 id="经验值k131m264">经验值，k=131，M=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></h4>
<p><a href="https://www.acwing.com/problem/content/843/">模板题</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 100010, P = 131;
int n, m;
char str[N];
ULL h[N], p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    scanf(&quot;%s&quot;, str + 1);

    p[0] = 1;
    for (int i = 1; i &lt;= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);

        if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);
        else puts(&quot;No&quot;);
    }

    return 0;
}
</code></pre>
<h4 id="例题-2">例题</h4>
<p><a href="https://www.acwing.com/problem/content/description/162/">acwing160</a><br>
核心问题就是：<br>
给定两个字符串 A，B。求出 A 的每个后缀子串和 B 的最长公共前缀。<br>
标准做法是扩展 KMP，时间复杂度线性。<br>
我们来用 Hash 试试看</p>
<p>前面已经提到，我们可以用 O(n)预处理 O(1)处理出一个子串的哈希值。<br>
求字符串 A[i..n] 与字符串 B[1..m] 的最长公共前缀？<br>
二分长度 mid<br>
计算出 A[i..i+mid-1] 和 B[1..mid] 的哈希值，比较是否相等。<br>
因此时间复杂度是 O(nlog n) 的</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 200010, P = 131;
int n, m,q;
char a[N];
char b[N];
ULL ha[N],hb[N],p[N];
int cnt[N];

ULL get(ULL h[],int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m,&amp;q);
    scanf(&quot;%s&quot;, a + 1);
    scanf(&quot;%s&quot;,b+1);

    p[0] = 1;
    for(int i=1;i&lt;=max(n,m);i++)
        p[i]=p[i-1]*P;
    for(int i=1;i&lt;=n;i++)
        ha[i]=ha[i-1]*P+a[i];
    for(int i=1;i&lt;=m;i++)
        hb[i]=hb[i-1]*P+b[i];
    
    for(int i=1;i&lt;=n;i++)
    {
        int l=0,r=min(m,n-i+1);

        while(l&lt;r)
        {
            int mid=l+r+1&gt;&gt;1;
            if(get(ha,i,i+mid-1) == get(hb,1,mid))
                l=mid;
            else
                r=mid-1;
        }
        cnt[l]++;
    }
    while(q--)
    {
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        printf(&quot;%d\n&quot;,cnt[x]);
    }

    return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2774">poj2774</a><br>
给出两个字符串 S 和 T，求它们的最长公共子串。|S|, |T| ≤ 1e5</p>
<h4 id="思路">思路</h4>
<p>原始的 DP 做法（最长公共子序列），时间复杂度 O(n^2)<br>
我们可以二分答案 len。然后计算 S 和 T 中所有长度为 len 的子串的哈希值。<br>
这一步是 O(n) 的。<br>
然后比较 S 的哈希值集合中和 T 的哈希值集合中有没有相同的元素。<br>
可以再通过一步哈希找相同的值。这样总共仍然是 O(n)。<br>
总的时间复杂度就是 O(n log n)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100010,P=131;
char a[N],b[N];
typedef unsigned long long ULL;
ULL ha[N],hb[N],p[N];
vector&lt;ULL&gt; v;
int la,lb;

ULL get(ULL h[],int l,int r)
{
	return h[r]-h[l-1]*p[r-l+1];
}

bool check(int mid)
{
	v.clear();
	for(int i=mid;i&lt;=la;i++)
		v.push_back(get(ha,i-mid+1,i));
	
	sort(v.begin(),v.end());
	for(int i=mid;i&lt;=lb;i++)
	{
		ULL t=get(hb,i-mid+1,i);
		if(binary_search(v.begin(),v.end(),t))
			return true;
	}
	return false;
}

int main()
{
	scanf(&quot;%s%s&quot;,a+1,b+1);
	la=strlen(a+1);
	lb=strlen(b+1);
	
	p[0]=1;
	for(int i=1;i&lt;=max(la,lb);i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&lt;=la;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=1;i&lt;=lb;i++)
		hb[i]=hb[i-1]*P+b[i];
		
	int l=0,r=1e5;
	while(l&lt;r)
	{
		int mid=l+r+1&gt;&gt;1;
		if(check(mid))
			l=mid;
		else
			r=mid-1;
	}
	printf(&quot;%d\n&quot;,l);
	return 0;
}
</code></pre>
<p>也可手写哈希表：<a href="https://paste.ubuntu.com/p/GdxThx6SK6/">代码</a></p>
<p><a href="https://vjudge.net/problem/CodeForces-580E">Codeforces 580E</a><br>
给出一个数字串，现在有两种操作：<br>
1: l r d: 将[l,r] 中的所有数字都改为 d<br>
2: l r d：询问[l,r]这个子串的周期是否为 d。 1 &lt;= n &lt;= 1e5<br>
首先思考对于一个字符串 S，如何判断它的周期是不是 d？<br>
比如串 ababab 的周期是 2 串 abcabc 的周期是 3 串 abcde 的周期是 5<br>
假设 S 的长度为 n。<br>
只要判断 <code>S[1..n-d+1] 和 S[d+1..n]</code>是否相等即可。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_fd5afb5c5f-6.png" alt="6.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_b6f72f365e-7.png" alt="7.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define lc u&lt;&lt;1
#define rc u&lt;&lt;1|1
int n,m,k;
const int N=100010,P=131,mod=1e9+7;
char s[N];
typedef long long LL;
struct Node
{
	int l,r;
	int tag;
	LL key;
}tr[N&lt;&lt;2];
LL h[N],p[N];//p[i]表示p的i次方，h[i]表示连续i个1的字符串的hash值

void pushup(int u,int k)
{
	tr[u].key=((tr[lc].key*p[k])%mod+tr[rc].key)%mod;
}

void pushdown(int u)
{
	if(tr[u].tag)
	{
		int mid=tr[u].l+tr[u].r&gt;&gt;1,l=tr[u].l,r=tr[u].r;
		tr[lc].key=(tr[u].tag*h[mid-l+1])%mod;
		tr[lc].tag=tr[u].tag;
		tr[rc].key=(tr[u].tag*h[r-mid])%mod;
		tr[rc].tag=tr[u].tag;
		tr[u].tag=0;
	}
}

void build(int u,int l,int r)
{
	if(l == r)
	{
		tr[u]={l,r,0,s[l]-'0'+1};
		return;
	}
	tr[u]={l,r};
	int mid=l+r&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u,r-mid);
}

void modify(int u,int l,int r,int d)
{
	if(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)
	{
		tr[u].key=(d*h[tr[u].r-tr[u].l+1])%mod;
		//cout&lt;&lt;&quot;-----&quot;&lt;&lt;u&lt;&lt;' '&lt;&lt;tr[u].key&lt;&lt;endl;
		tr[u].tag=d;
		return;
	}
	pushdown(u);
	int mid=tr[u].l+tr[u].r&gt;&gt;1;
	if(l &lt;= mid)
		modify(lc,l,r,d);
	if(r &gt; mid)
		modify(rc,l,r,d);
	pushup(u,tr[u].r-mid);
}

int query(int u,int l,int r)
{
	if(tr[u].l == l &amp;&amp; tr[u].r == r)
		return tr[u].key;
	pushdown(u);
	int mid=tr[u].l+tr[u].r&gt;&gt;1;
	if(r&lt;=mid)
		return query(lc,l,r);
	else if(l&gt;mid)
		return query(rc,l,r);
	else 
		return (query(lc,l,mid)*p[r-mid]%mod+query(rc,mid+1,r))%mod;
}

void print(int u)
{
	if(tr[u].key)
	{
		cout&lt;&lt;&quot;--&quot;&lt;&lt;u&lt;&lt;' '&lt;&lt;tr[u].l&lt;&lt;' '&lt;&lt;tr[u].r&lt;&lt;' '&lt;&lt;tr[u].key&lt;&lt;endl;
		print(lc);
		print(rc);
	}
}

int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	scanf(&quot;%s&quot;,s+1);
	
	p[0]=1;
	for(int i=1;i&lt;=n;i++)
	{
		h[i]=(h[i-1]*P%mod+1)%mod;
		p[i]=p[i-1]*P%mod;
	}

	build(1,1,n);
	
	m+=k;
	while(m--)
	{
		int t,l,r,d;
		scanf(&quot;%d%d%d%d&quot;,&amp;t,&amp;l,&amp;r,&amp;d);
		if(t == 1)
			modify(1,l,r,d+1);//加一处理，防止d为0
		else
		{
			if(d == r - l + 1)
			{
                printf(&quot;YES\n&quot;);
                continue;
            }
			if(query(1,l,r-d) == query(1,l+d,r))
				puts(&quot;YES&quot;);
			else
				puts(&quot;NO&quot;);
		}
		//print(1);
	}
	return 0;
}
</code></pre>
<p>坑：第75组数组卡无符号64位自动溢出的hash,防ull溢出的解决方法是取模</p>
<p><a href="https://www.luogu.com.cn/problem/CF955D">Codeforces 955D</a><br>
给出两个字符串 S 和 T。你需要在 S 中选出两个不相交的长度为 k 的子串，使得他们拼起来之后包含 T。<br>
|T| ≤ 2k ≤ |S| ≤ 5·1e5</p>
<blockquote></blockquote>
<p>样例： （答案：Yes 1 5）<br>
7 4 3<br>
baabaab<br>
aaaa</p>
<h4 id="kmp">KMP</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_14fe85145f-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_8d1e51a05f-9.png" alt="9.png" loading="lazy"><br>
我们用形式化的语言来进行描述。<br>
假设现在 T[s+1..s+k] 和 P[1..k] 匹配上了。<br>
此时 T[s+k+1] != P[k+1]。<br>
朴素的做法是：回到 T[s + 2] 和 P[1] 重新开始比较。<br>
KMP算法：找到一个最大的 x，使得 T[s+1..s+k] 的后 x个字符，和 P 的前 x 个字符相同。<br>
这部分就是能匹配上的，我们可以不用逐个判断。</p>
<p>又注意到 T[s+1..s+k] = P[1..k]<br>
那么我们要求的就是一个最大的 x，满足 P[1..k] 的前 x个字符等于它的后 x 个字符。当然 x 要小于 k。<br>
这个 x 记为 next[k]</p>
<p>对于 P = ababaca<br>
我们可以计算出next数组：<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_c35dcbf05f-10.PNG" alt="10.PNG" loading="lazy"><br>
有了 next 数组，现在如何匹配两个字符串呢？</p>
<pre><code>for (int i = 1, j = 0; i &lt;= m; i ++ )
{
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == n)
    {
        printf(&quot;%d &quot;, i - n);
        j = ne[j];
    }
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_18d2562c5f-11.png" alt="11.png" loading="lazy"><br>
讲过如何匹配之后，我们还要会高效计算 next 数组。<br>
计算 next 数组的过程就是拿 P 和 P 自己匹配的过程。<br>
只不过要在匹配的过程中，记录每个位置下指针指向的位置，作为 next 数组。</p>
<pre><code>for (int i = 2, j = 0; i &lt;= n; i ++ )
{
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}
</code></pre>
<h4 id="kmp算法复杂度">KMP算法复杂度</h4>
<p>时间复杂度：O(n)<br>
空间复杂度：O(n)</p>
<h4 id="例题-3">例题</h4>
<p><a href="">poj2406</a><br>
给一个字符串 S，求 S 的一个最短的循环节 e，使得 S 可以写成 eee…eee （共|S|/|e|个 e）<br>
输出 |S|/|e| 的最大值。|S| ≤ 1e6</p>
<blockquote></blockquote>
<p>样例：<br>
abcd （答案：1）<br>
aaaa （答案：4）<br>
ababab （答案：3）</p>
<p>假设这个字符串的长度为 len<br>
如果 len 可以被 len-next[len] 整除，那么我们就可以说len-next[len] 是那个循环节的长度。<br>
因为 next[len] 就表示: S[1..next[len]] = S[next[len] + 1..len]<br>
可以证明满足这一条性质的字符串具有长度为 len-next[len] 的循环周期<br>
否则答案就是 1 了。<br>
因为如果存在一个长度为 d 的循环节，那一定满足：<br>
S[1..len-d+1] == S[d + 1 .. len]<br>
但是现在循环节的长度只能是 len-next[len],如果它不是 len 的因子，那就没有可能了。<br>
时间复杂度 O(n)</p>
<blockquote></blockquote>
<p>定理：假设S的长度为len，则S存在最小循环节，循环节的长度L为len-next[len]，子串为S[0…len-next[len]-1]。<br>
（1）如果len可以被len - next[len]整除，则表明字符串S可以完全由循环节循环组成，循环周期T=len/L。<br>
（2）如果不能，说明还需要再添加几个字母才能补全。需要补的个数是循环个数L-len%L=L-(len-L)%L=L-next[len]%L，L=len-next[len]。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1e6+10;
char s[N];
int ne[N];
int n;

int main()
{
	while(scanf(&quot;%s&quot;,s+1))
	{
		if(s[1] == '.')
			break;
		
		n=strlen(s+1);
		for(int i=2,j=0;i&lt;=n;i++)
		{
			while(j &amp;&amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		int t=n-ne[n];
		if(n%t == 0)
			cout&lt;&lt;n/t&lt;&lt;endl;
		else
			cout&lt;&lt;1&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2752">poj2752</a><br>
给定一个字符串 S，求出 S 中所有的既是前缀又是后缀的子串。输出 i 代表 S[1..i]|S| ≤ 400000</p>
<blockquote></blockquote>
<p>样例：<br>
ababcababababcabab（答案：2 4 9 18）<br>
aaaaa（答案：1 2 3 4 5）</p>
<p>求出 next 数组。<br>
答案就是 len, next[len], next[next[len]], …<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_2ee67d465f-12.png" alt="12.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=4e5+10;
char s[N];
int ne[N];
int ans[N];

int main()
{
	while(~scanf(&quot;%s&quot;,s+1))
	{
		int n=strlen(s+1);
		for(int i=2,j=0;i&lt;=n;i++)
		{
			while(j &amp;&amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
	
		int t=ne[n],cnt=0;
		while(t)
		{
			ans[cnt++]=t;
			t=ne[t];
		}
		
		for(int i=cnt-1;i&gt;=0;i--)
			printf(&quot;%d &quot;,ans[i]);
		printf(&quot;%d\n&quot;,n);

	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2594">hdu2594</a><br>
求出最长的既是 s1 的前缀又是 s2 的后缀的子串。</p>
<blockquote></blockquote>
<p>样例：<br>
riemann<br>
marjorie<br>
答案：rie</p>
<p>只要把两个串拼起来，中间用一个分隔符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">,</mo><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">,s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>s2,令len=strlen(s1$s2),则next[len]即为答案<br>
也可不加分隔符，枚举 len, next[len], next[next[len]] ......找到小于 min(|s1|, |s2|) 的最大值即可。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=50010*2;//数组开两倍!
char s1[N],s2[N];
int ne[N];

int main()
{
	while(~scanf(&quot;%s%s&quot;,s1+1,s2+1))
	{
		strcat(s1+1,&quot;$&quot;);
		strcat(s1+1,s2+1);
		int n=strlen(s1+1);
		for(int i=2,j=0;i&lt;=n;i++)
		{
			while(j &amp;&amp; s1[i] != s1[j+1])
				j=ne[j];
			if(s1[i] == s1[j+1])
				j++;
			ne[i]=j;
		}
		
		int ans=ne[n];
		s1[ans+1]='\0';
		if(ans == 0)
			printf(&quot;0\n&quot;);
		else 
			printf(&quot;%s %d\n&quot;,s1+1,ans);
	}
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/CF526D">Codeforces 526D</a><br>
给出一个字符串 s，判断其每个前缀是否可以表示成ABAB…ABA 的形式（A 和 B 都可以为空， 但是必须满足 A 有 k+1 个，B 有 k 个）<br>
|s|, k ≤ 1e6</p>
<blockquote></blockquote>
<p>输入<br>
7 2<br>
bcabcab<br>
输出<br>
0000011<br>
长度为 6 的前缀，可以取 A=“”,B=“bca”<br>
长度为 7 的前缀，可以取 A=“b”, B=“ca”</p>
<p>对于前缀 P，我们可以把 P 拆成 SSSS…ST，其中 T 是 S的前缀。<br>
这样就可以用 KMP 来做了。<br>
首先 i-next[i] 就是S[1..i] 这一段的最小循环节的长度，<br>
记为 e。<br>
可以发现 e 的倍数 je 也是循环节。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/06/9969_15c32c7e5f-13.png" alt="13.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=1e6+10;
char s[N];
int n,k;
int ne[N];

bool check(int i,int cir)
{
	int up=i/k/cir;
	int down=ceil((i/(k+1)+1)/(1.0*cir));
	return up&gt;=down || (i % (k+1) == 0 &amp;&amp; (i / (k+1)) % cir == 0);
}

int main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k))
	{
		scanf(&quot;%s&quot;,s+1);
		
		int len=strlen(s+1);
		for(int i=2,j=0;i&lt;=len;i++)
		{
			while(j &amp;&amp; s[i] != s[j+1])
				j=ne[j];
			
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		for(int i=1;i&lt;=n;i++)
		{
			int cir=i-ne[i];
			printf(&quot;%d&quot;,check(i,cir));
		}
	}
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1054/">acwing</a><br>
首先我们用KMP求出 T 的 next数组。<br>
利用 next数组在长文本中匹配模板串 T的过程：如果下一个字母不匹配，需要一直沿着next指针找：j = next[j]，直到下一个字符匹配或者next指针指向开头为止。<br>
然后我们会发现，假设我们已经匹配完长文本的前个字母，则剩下部分的匹配过程，只跟next指针的位置有关，因此我们可以用二维数组来表示当前状态的方案数：<br>
f[i][j]表示匹配完前 i 个字母时，next指针在 j 时的方案总数。<br>
状态转移：对于每个状态f[i][j]，我们从'a'-'z'枚举下一个字母，然后求出对应的next指针，假设是，则将f[i][j]的方案总数累加到f[i+1][u]。<br>
转移过程中需要注意，因为密码中不能存在 T，所以next指针要避免转移到 T的最后一个字母。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt; 
using namespace std;
const int N=55,mod=1e9+7;
int f[N][N];
int edge[N][26];
char p[N];
int ne[N];
int n;


int main()
{
    cin&gt;&gt;n&gt;&gt;p+1;
    int m=strlen(p+1);
    
    for(int i=2,j=0;i&lt;=m;i++)
    {
        while(j &amp;&amp; p[i] != p[j+1])
            j=ne[j];
        if(p[i] == p[j+1])
            j++;
        ne[i]=j;
    }
    
    for(int i=0;i&lt;m;i++)
        for(char k='a';k&lt;='z';k++)
        {
            int j=i;//已匹配了前i个字母
            while(j &amp;&amp; p[j+1] != k)
                j=ne[j];
            if(p[j+1] == k)
                j++;
            edge[i][k-'a']=j;
        }
        
    f[0][0]=1;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m;j++)
            for(char k='a';k&lt;='z';k++)
            {
                int u=edge[j][k-'a'];
                f[i+1][u]=(f[i+1][u]+f[i][j])%mod;
            }
            
    int res = 0;
    for (int i = 0; i &lt; m; i ++ ) res = (res + f[n][i]) % mod;

    cout &lt;&lt; res &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3193">luoguP3193</a><br>
设f(i,j)表示以准考证号为基准递推，准考证号匹配到第i位，不吉利数字匹配到第j位时（即准考证的后j位等于不吉利数字的前j位），不出现不吉利数字的字符串数量。。</p>
<p>那怎么转移？<br>
既然要以考号为基准递推，就要考虑一位考号对下一位的影响。</p>
<p>而考号是可以随便写的，那我们就要考虑10种数字了。</p>
<p>对于一个新数字new，有以下几种情况：<br>
1.new<br>
与不吉利数字的j+1位匹配，dp(i+1,j+1)的答案数+dp(i,j)<br>
2.上述两者不匹配。</p>
<p>不匹配怎么办？这个不匹配的new一定没有贡献了？<br>
当然不一定。<br>
怎么讲呢，举个例子吧，不吉利数字是12212112。然后你的准考证号枚举到第9位时，前面8位已经枚举成了11112212。可以发现已经匹配了不吉利数字的前5位，现在要匹配第6位。<br>
如果第9位枚举1，那它就匹配了，dp(9,6)+=dp(8,5)。如果第9位枚举2，那它就不匹配。但是会发现，存在 与当前已匹配的不吉利数字的后缀相同 的前缀，可以匹配上这个2！<br>
上一个位置就是不吉利数字的第2位。<br>
它的下一位，第3位2，刚好可以匹配枚举的第9位！<br>
所以此时最多能匹配不吉利数字的前3位，有转移dp(9,3)+=dp(8,5)。</p>
<p>我们只需要沿着不吉利数字的失配指针往前走，找到第一个下一位与new匹配的位置就可以了。<br>
为什么不用考虑再往前的下一位可以匹配new的位置？<br>
因为这是递推，从前往后每一种状态都会被考虑，所以在考虑匹配后面的位之前，前面的位已经匹配好更前面的情况了。</p>
<p>比如不吉利数字1221221211。你目前枚举的准考证号前8位是12212212，现在你要枚举第9<br>
位。很明显当枚举2时，通过找不吉利数字中 后缀相同的前缀，可知dp(8,8)可以转移到dp(9,6)。<br>
但是我们发现也可以转移到dp(9,3)诶！</p>
<p>事实上，在这之前dp(8,5)已经转移到dp(9,3)过了。而dp(8,5)表示什么？它表示准考证号枚举8位，后5位与不吉利数字的前5位匹配上。<br>
dp(8,8)同理，表示准考证号枚举前8位，后8位与不吉利数字的前8位匹配上。<br>
这样直观看起来没什么答案关联。但是仔细考虑以下，不吉利数字的第8位的失配指针指向第5位。</p>
<p>这说明什么？<br>
不吉利数字的前8位中，前5位等于后5位！<br>
<code>匹配5位的情况包含匹配8位的情况！（因为你匹配了8位，根据上推论可知也算在匹配了5位的情况中）</code><br>
这就是别人博客中此题题解经常提到的计数方案会包含的问题。</p>
<p>其实按照AC自动机的构造方式，如果一个点没有字符为new的儿子边的话，它会建出一条对应的虚拟儿子边和点，儿子点上存的是沿着失配指针往回走的上一个实际存在这条字符边所指向的儿子。<br>
当然这题m很小，不吉利数字串自己匹配自己的复杂度很小，可以直接暴力跑失配指针找第一个。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_8bab9de460-00002.PNG" alt="00002.PNG" loading="lazy"><br>
其中g(i,j)表示当前匹配到i个字符，添加一个字符变成匹配为j个字符的方案数。<br>
不吉利数字已经知道了，g数组可以预处理出来（KMP）。</p>
<p>然后我们惊奇地发现n≤1e9，不让你循环推，直接就想到矩阵快速幂优化了。<br>
观察一下转移方程，发现dp[i+1][?]总是由dp[i][?]推来，而且i还是n这个级别的。</p>
<p>又发现每次实际上都是乘一个固定的矩阵g，也就是说整个dp数组的某一位的值其实都是通过一些g数组乘过来的。<br>
所以可以把dp数组直接当成g数组自己乘自己。</p>
<p>比如说，g(4,2)=4。<br>
表示有4种转移情况可以让 与不吉利数字的前4位匹配的情况 在准考证号增加1位后 与不吉利数字的前2位匹配。<br>
所以dp(x+1,2)=dp(x,4)∗g(4,2)=dp(x,4)∗4</p>
<p>而dp(x,4)又是哪来的？<br>
它是通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span>dp(x−1,i)∗g(i,4)转移过来的。</p>
<p>所以一直往前推到x=0，发现dp值的n次转移都只跟转移矩阵g有关，是否与不吉利数字完全匹配等情况可以在弄g数组时就处理掉，即g数组只考虑不吉利数字被匹配0~m−1位的情况，不让它转移到j位都被匹配的情况。<br>
所以就是对g矩阵做快速幂，求它的n次方。</p>
<p>时间复杂度O(log(n)∗m^3)</p>
<h4 id="为什么答案是g0ifor-i-0~m-1">为什么答案是g(0,i)，for i 0~m-1</h4>
<p>考虑g(i,j)的意义。如果g矩阵自己对自己连续进行k次转移（不进行快速幂而循环推），g(i,j)就表示：在进行k次转移前 准考证号匹配不吉利数字的前i位时，准考证号增加k个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。这是矩阵转移的基本概念。</p>
<p>所以进行n次转移后，g(i,j)就表示一开始准考证号匹配不吉利数字的前i位时，准考证号增加n个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。</p>
<p>我们需要取全局情况的答案，而这是很显然的。开始时准考证号匹配不吉利数字的前0位（准考证号还一位都没枚举），所以i为0；而由于已经定义过g数组只考虑不吉利数字被匹配 0~m−1位的情况，所以j在这个区间取任意值，g(0,j)都是答案的一部分。把它们都算上就是答案。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=25;
char p[N];
int n,m,mod;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
};
int ne[N];

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&lt;m;i++)
		for(int j=0;j&lt;m;j++)
			for(int k=0;k&lt;m;k++)
				res.m[i][j]=(res.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return res;
}

int main() 
{
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;mod);
	scanf(&quot;%s&quot;, p+1);
	
	matrix g;
	for(int i=2,j=0;i&lt;=m;i++)
	{
		while(j &amp;&amp; p[i] != p[j+1])
			j=ne[j];
		if(p[i] == p[j+1])
			j++;
		ne[i]=j;
	}
	
	for(int i=0;i&lt;m;i++)
		for(int k=0;k&lt;10;k++)
		{
			int j=i;
			while(j &amp;&amp; p[j+1]-'0' != k)
				j=ne[j];
			if(p[j+1]-'0' == k)
				j++;
			if(j&lt;m)	g.m[i][j]=(g.m[i][j]+1)%mod;
		}
	
	matrix a;
	for(int i=0;i&lt;m;i++)
		a.m[i][i]=1;
	
	while(n)
	{
		if(n &amp; 1) a=mul(a,g);
		g=mul(g,g);
		n&gt;&gt;=1;
	}
//	
//	for(int i=0;i&lt;m;i++)
//	{
//		for(int j=0;j&lt;m;j++)
//			cout&lt;&lt;a.m[i][j]&lt;&lt;' ';
//		cout&lt;&lt;endl;
//	}
	
	int ans = 0;
	for(int i = 0; i &lt; m; ++i)
		ans = (ans + a.m[0][i]) % mod;
	
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1d8bea8860-00001.PNG" alt="00001.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/11/9969_3048880e63-3.png" alt="3.png" loading="lazy"></p>
<h4 id="z算法">Z算法</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_ca07496a60-1.PNG" alt="1.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_f6f54a1c60-2.PNG" alt="2.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_33dfcb7e60-3.png" alt="3.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_3623ccf060-4.png" alt="4.png" loading="lazy"><br>
r[5] = 7<br>
r[6] = 7<br>
l[5] = 5<br>
l[6] = 5<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_5abceae260-5.png" alt="5.png" loading="lazy"><br>
对于 Z[2] 我们需要暴力计算。<br>
也就是暴力计算 S[1..|S|] 和 S[2..|S|] 的最长公共前缀。<br>
如果 Z[2] &gt; 0, 那么 r = r[2], l = l[2] = 2<br>
如果 Z[2] = 0, 那么 r = r[2] = 0, l = l[2] = 0</p>
<p>我们的目标就是用已有的 Z[2], Z[3], ..., Z[k-1]，来推<br>
出 Z[k].<br>
假设 k = 121, Z[2..120] 已经知道了<br>
r[120] = 130, l[120] = 100<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_884cb29e60-6.png" alt="6.png" loading="lazy"><br>
划分成[l,i-1],[i,r]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_cfa5d35a60-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_37ddc43260-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_61fb79d060-9.PNG" alt="9.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_83939b3660-10.PNG" alt="10.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_121af6c460-11.png" alt="11.png" loading="lazy"><br>
蓝色部分一定不相等，否则说明z-box可以右移</p>
<p>第一步：<br>
初始化 Z[]，暴力计算 Z[2]</p>
<pre><code>for(int i = 1;i &lt;= n;i ++) z[i] = 0;
int l, r;
while(str[1 + z[2]] == str[2 + z[2]]) z[2] ++; 
l = 2, r = 2+ z[2]-1;
</code></pre>
<p>第二步：<br>
枚举 i，分三种情况依次计算 Z[i]</p>
<pre><code>for(int i = 3;i &lt;= n;i ++)
{
    if(i &gt; r)
    {
        while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
        l = i, r = i + z[i] - 1;
    }
    else
    {
        if(z[i - l + 1] &lt; r - i + 1) z[i] = z[i - l + 1];
        else
        {
            z[i] = r - i;
            while(str[1 + z[i]] == str[i + z[i]]) z[i] ++; 
            l = i, r = i + z[i] - 1; 
        }
    } 
}
</code></pre>
<h4 id="时间复杂度是-on-的">时间复杂度是 O(n) 的</h4>
<h4 id="扩展kmp">扩展KMP</h4>
<p>给定两个字符串 S 和 T（长度分别为 n 和 m）<br>
定义 extend[i] 为 S[i..n] 与 T 的最长公共前缀的长度。<br>
求出 extend 数组<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_e93cf15860-12.PNG" alt="12.PNG" loading="lazy"><br>
如果 S = T，那么 extend 数组就是 Z 数组。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_fe0303ca60-13.PNG" alt="13.PNG" loading="lazy"></p>
<p>假设现在遍历到了 S[i]，且 S[1], S[2],…, S[i-1]都已经算出<br>
与 Z 算法类似，设置两个变量 l 和 r，r 表示能和 T 匹<br>
配到的最右边的位置，l 为 r 对应的起始位置。<br>
也就是 S[l .. r] = T[1.. r-l+1]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_1677f3ac60-14.PNG" alt="14.PNG" loading="lazy"></p>
<p>S[i] 对应的是 T[i-l+1]<br>
现在要计算的是 S[i..n] 与 T 的最长公共前缀<br>
注意到此时 S[i..r] = T[i-l+1 .. r-l+1]<br>
所以我们可以先对 T 求一遍 Z 数组，然后考察一下 Z[i-l+1]<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_7411db9460-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_a95260c660-15.png" alt="15.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/08/9969_de7d174760-16.png" alt="16.png" loading="lazy"></p>
<pre><code>void calc_Z(char *str) 
{
	int n = strlen(str + 1);
	for(int i = 1; i &lt;= n; i ++) z[i] = 0;
	z[1] = n;
	int l, r = 0;
	for(int i = 2; i &lt;= n; i ++) 
	{
		if(i &gt; r) 
		{
			while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
			l = i, r = i + z[i] - 1;
		} else 
		{
			if(z[i - l + 1] &lt; r - i + 1) z[i] = z[i - l + 1];
			else 
			{
				z[i] = r - i + 1;
				while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
				l = i, r = i + z[i] - 1;
			}
		}
	}
}
</code></pre>
<pre><code>void calc_extend(char *S, char *T) 
{
	calc_Z(T);
	int l, r = 0;
	int n = strlen(S + 1);
	int m = strlen(T + 1);
	for (int i = 1; i &lt;= n; i ++) 
	{
		if (i &gt; r) 
		{
			while (i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp;
			        S[i + ext[i]] == T[1 + ext[i]]) ext[i] ++;
			l = i, r = i + ext[i] - 1;
		}
		else 
		{
			if (i + z[i - l + 1] - 1 &lt; r) ext[i] = z[i - l + 1];
			else 
			{
				ext[i] = r - i + 1;
				while (i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp; S[i +ext[i]] == T[1 + ext[i]]) 
					ext[i] ++;
				l = i, r = i + ext[i] - 1;
			}
		}
	}
}
</code></pre>
<h4 id="例题-4">例题</h4>
<p>题意：给你n个字符串，求这n个字符串的最长公共子串</p>
<p><a href="https://vjudge.net/problem/HDU-4333">hdu4333</a><br>
给一个 L 位数的正整数 N，每次可以把这个数的最后一位移到最前面来，得到一个新的数。<br>
总共最多可以得到 n 个数，重复的只算一次。<br>
问这些数中，等于 n 的，小于 n的，大于 n 的数分别有几个。<br>
L ≤ 1e5</p>
<blockquote></blockquote>
<p>样例：<br>
341 （答案： 1 1 1）</p>
<p>我们只需要把这个数复制两遍，然后只考虑长度为 n 的子串。这些子串就是移动过程中产生的数。<br>
如何和原数 N 做比较呢</p>
<p>假设现在的数是 S[i .. i+L-1], N 是 S[1..L]<br>
我们只要求出他们的最长公共前缀 x，如果 x = n 说明这两个数相等。<br>
否则，比较 S[x] 和 S[i+x-1] 的大小，就可以确定他们的大小关系。<br>
求 x ，就是扩展 KMP 中的 Z 算法。x = min(n, Z[i])</p>
<p>最后一步去重。对 N 跑一次 KMP<br>
如果 L-next[L] 是 L 的约数，那么 L-next[L] 是 N 的最小循环节。否则 N 的 最小循环节是 L。<br>
对循环节内的情况枚举一遍即可,或除以最小循环节个数。<br>
时间复杂度 O(L)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=200010;
char str[N];
int ne[N];
int z[N];

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    for(int kas=1;kas&lt;=T;kas++)
    {
        scanf(&quot;%s&quot;,str+1);
        
        int len=strlen(str+1);
        for(int i=2,j=0;i&lt;=len;i++)
        {
            while(j &amp;&amp; str[i] != str[j+1])
                j=ne[j];
            if(str[i] == str[j+1])
                j++;
            ne[i]=j;
        }
        
        for(int i=1;i&lt;=len;i++)
            str[i+len]=str[i];
        str[len*2+1]='\0';
        memset(z,0,sizeof z);
        z[1]=len*2;
        int l,r=0;
        
        for(int i=2;i&lt;=len*2;i++)
        {
            if(i&gt;r)
            {
                while(str[1+z[i]] == str[i+z[i]])
                    z[i]++;
                l=i,r=i+z[i]-1;
            }
            else 
            {
                if(z[i-l+1] &lt; r-i+1)
                    z[i]=z[i-l+1];
                else 
                {
                    z[i]=r-i;
                    while(str[1+z[i]] == str[i+z[i]])
                        z[i]++;
                    l=i,r=i+z[i]-1;
                }
            }
        }
        
        int gre=0,eql=0,les=0;
        for(int i=1;i&lt;=len;i++)
        {
            if(z[i] &gt;= len)
                eql++;
            else if(str[1+z[i]] &gt; str[i+z[i]])
                les++;
            else gre++;
        }
        
        int t;
        if(len%(len-ne[len]) == 0)
            t=len/(len-ne[len]);//循环节个数 
        else 
            t=1;
        printf(&quot;Case %d: %d %d %d\n&quot;,kas,les/t,eql/t,gre/t);
    }
}
</code></pre>
<p>对循环节内的情况枚举<a href="https://paste.ubuntu.com/p/HrvmzSySDv/">代码</a></p>
<p><a href="https://vjudge.net/problem/POJ-3376">poj3376</a><br>
给你 n 个字符串 m[1], m[2], …, m[n]。 求 S = m[i]m[j] （1 &lt;= i,j &lt;= n）是回文串的数量。<br>
n 个字符串的长度之和不超过 2·1e6</p>
<blockquote></blockquote>
<p>样例输入：<br>
3a<br>
ab<br>
ba<br>
答案：5（aa,aba,aba,abba,baab)</p>
<p>考虑什么情况下 i 和 j 拼起来会是回文串。</p>
<ul>
<li>
<p>i的长度小于j，那么i一定是j的反串的前缀，且j的反串剩下的后缀是回文串</p>
</li>
<li>
<p>i的长度等于j，那么i等于j的反串</p>
</li>
<li>
<p>i的长度大于j，那么j的反串一定是i的前缀，且i串剩下的后缀是回文串</p>
</li>
</ul>
<p>我们可以将这n个字符串插入trie，每个节点要维护两个值：<br>
value1. 到当前节点的字符串个数；value2.当前节点后面的回文子串个数</p>
<p>我们用每个字符串的反串去trie上查找，要构成回文串有以下情况：</p>
<ul>
<li>
<p>1.此反串是其他串的前缀，那么组合回文串的数量就要加上value2</p>
</li>
<li>
<p>2.此反串的前缀是某些字符串，且反串剩下的后缀是回文串，那么组合回文串的数量要加上value1</p>
</li>
<li>
<p>3.2的特例：此反串的前缀是某些字符串，且反串剩下的后缀为空，同样要加上value1，这种情况可以和2一起处理</p>
</li>
</ul>
<p>留下的问题就是一个字符串的所有后缀中，哪些是回文串。<br>
对于串 S，我们先求出正串 S 对反串 T 的 extend[i]<br>
那么对于每个 i，如果 S[i..n] 和 T 的最长公共前缀等于<br>
S[i..n] 的长度，说明 S[i..n] 是一个回文串。<br>
因此整道题就在线性的时间复杂度内解决了。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=2e6+10;
int trie[N][26],tot=1;
int n;
char s[N],t[N];
int len[N];
int slen;
int z[N],ext[N];
bool flag[2][N];
int bg[N],ed[N];
typedef long long LL;
struct Node
{
	int v1,v2;
}cnt[N];

void get_z(char *s)
{
	int n=strlen(s+1);
	for(int i=1;i&lt;=n;i++) z[i]=0;
	z[1]=n;
	int l,r=0;
	for(int i=2;i&lt;=n;i++)
	{
		if(i&gt;r)
		{
			while(s[1+z[i]] == s[i+z[i]])
				z[i]++;
			l=i,r=i+z[i]-1;
		}
		else
		{
			if(z[i-l+1] &lt; r-i+1)
				z[i]=z[i-l+1];
			else
			{
				z[i]=r-i;
				while(s[1+z[i]] == s[i+z[i]])
					z[i]++;
				l=i,r=i+z[i]-1;
			}
		}
	}
}

void exkmp(int type,char *s,char *t)
{
	get_z(t);
	int n=strlen(s+1);
	int m=strlen(t+1);
	for(int i=1;i&lt;=n;i++)
		ext[i]=0;
	int l,r=0;
	for(int i=1;i&lt;=n;i++)
	{
		if(i&gt;r)
		{
			while(i+ext[i] &lt;=n &amp;&amp; 1+ext[i] &lt;=m &amp;&amp;
			s[i+ext[i]] == t[1+ext[i]])
				ext[i]++;
			l=i,r=i+ext[i]-1;
		}
		else
		{
			if(z[i-l+1] &lt; r-i+1)
				ext[i]=z[i-l+1];
			else
			{
				ext[i]=r-i+1;
				while(i + ext[i] &lt;= n &amp;&amp; 1 + ext[i] &lt;= m &amp;&amp; 
				s[i+ext[i]] == t[1+ext[i]])
					ext[i]++;
				l=i,r=i+ext[i]-1;
			}
		}
	}

	for(int i=1;i&lt;=n;i++)
	{
		//cout&lt;&lt;&quot;---&quot;&lt;&lt;ext[i]&lt;&lt;endl;
		if(ext[i] == n-i+1)
			flag[type][i+slen]=true;//s[i...n]为回文串
	}
}

void insert(int k)
{
	int p=1;
	for(int i=bg[k];i&lt;=ed[k];i++)
	{
		cnt[p].v2+=flag[0][i];
		int ch=s[i]-'a';
		if(!trie[p][ch])
			trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	cnt[p].v1++;
}

void print(int k)
{
	int p=1;
	for(int i=bg[k];i&lt;=ed[k];i++)
	{
		int ch=s[i]-'a';
		p=trie[p][ch];
		cout&lt;&lt;&quot;---&quot;&lt;&lt;cnt[p].v2&lt;&lt;' '&lt;&lt;cnt[p].v1&lt;&lt;endl;
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;len[i]);
		scanf(&quot;%s&quot;,s+1+slen);
		for(int j=1;j&lt;=len[i];j++)
			t[slen+j]=s[slen+len[i]+1-j];
		t[slen+len[i]+1]='\0';
		exkmp(0,s+slen,t+slen);
		exkmp(1,t+slen,s+slen);

		bg[i]=slen+1;
		slen+=len[i];
		ed[i]=slen;

		insert(i);
		//print(i);
	}

	LL ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		int p=1;
		bool f=true;
		for(int j=ed[i];j&gt;=bg[i];j--)//用反串去trie上匹配
		{
			int k=s[j]-'a';
			if(!trie[p][k])
			{
				f=false;
				break;
			}
			else
				p=trie[p][k];
			if(flag[1][bg[i]+ed[i]-j+1] || j == bg[i])
				ans+=cnt[p].v1;
		}
		if(f)
			ans+=cnt[p].v2;
	}

	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>

                                </div>
                    </article>
                    <!--  -->
                    
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C">字符串哈希</a></li>
<li><a href="#%E7%BB%8F%E9%AA%8C%E5%80%BCk131m264">经验值，k=131，M=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-2">例题</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="#kmp">KMP</a></li>
<li><a href="#kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6">KMP算法复杂度</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-3">例题</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AD%94%E6%A1%88%E6%98%AFg0ifor-i-0~m-1">为什么答案是g(0,i)，for i 0~m-1</a></li>
<li><a href="#z%E7%AE%97%E6%B3%95">Z算法</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF-on-%E7%9A%84">时间复杂度是 O(n) 的</a></li>
<li><a href="#%E6%89%A9%E5%B1%95kmp">扩展KMP</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-4">例题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>