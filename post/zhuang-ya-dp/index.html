<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    状压dp | fxh&#39;blog
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1594530227970">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1594530227970" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh&#39;blog
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            状压dp
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-04-01</time>
                            
                                <a href="https://caifxh.github.io/tag/Iu6lDT60Hd/" class="post-tag i-tag
                            i-tag-info">
                            #DP
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <h3 id="棋盘类基于连通性状压dp">棋盘类（基于连通性）状压dp</h3>
<h4 id="1十字型">1.十字型</h4>
<p><a href="https://www.acwing.com/problem/content/329/">玉米田</a></p>
<h4 id="输入样例">输入样例：</h4>
<pre><code>2 3
1 1 1
0 1 0
</code></pre>
<h4 id="输出样例">输出样例：</h4>
<pre><code>9
</code></pre>
<p>用二进制数来描述一行中方格的状态，1表示种玉米，0表示不种玉米<br>
样例第一行有以下5种种玉米的方案<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/12/9969_861e7ce04d-101.PNG" alt="101.PNG" loading="lazy"><br>
根据题意，把每一行的状态用二进制的数表示，0代表不在这块放牛，1表示在这一块放牛。首先很容易看到，每一行的状态要符合牧场的硬件条件，即牛必须放在能放牧的方格上。这样就能排除一些状态。另外，牛与牛之间不能相邻，这样就要求每一行中不能存在两个相邻的1，这样也能排除很多状态。然后就是根据上一行的状态转移到当前行的状态的问题了。必须符合不能有两个1在同一列（两只牛也不能竖着相邻）的条件。这样也能去掉一些状态。然后，上一行的所有符合条件的状态的总的方案数就是当前行该状态的方案数。</p>
<p>（1）初始化所有合法状态，即找没有相邻1的二进制数。用state[]存储合法状态<br>
（2）枚举不同合法状态之间的转移关系，只要a&amp;b == 0,状态a就可转到b<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_730aad4a74-51.png" alt="51.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;bitset&gt;
using namespace std;
const int N=15,M=1&lt;&lt;12,mod=1e8;
int f[N][M];
int g[N];
int n,m;
vector&lt;int&gt; state;
vector&lt;int&gt; head[M];

bool check(int state)//判断相邻两列
{
    if(state &amp; state&lt;&lt;1)
        return false;
    return true;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;m;j++)
        {
            int x;
            cin&gt;&gt;x;//若x为1，表示玉米田不可用
            g[i]+=!x&lt;&lt;(m-1-j);
        }

    for(int i=0;i&lt;1&lt;&lt;m;i++)
        if(check(i))
            state.push_back(i);//所有合法状态
    
    f[0][0]=1;//边界
    for(int i=1;i&lt;=n+1;i++)//枚举到第n+1行，省略求和
        for(int a=0;a&lt;state.size();a++)//第i行状态为a，i-1行状态为b
            for(int b=0;b&lt;state.size();b++)
            {
                if((g[i] &amp; state[a]) == 0 &amp;&amp; (state[a] &amp; state[b]) == 0) //不与上一行冲突，且不能在地图上0的地方种玉米
                    f[i][a]=(f[i][a]+f[i-1][b])%mod;
                }
    
    cout&lt;&lt;f[n+1][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/294/">炮兵阵地</a><br>
状态：f[i][j][k],已经摆完前i行，第i行状态是j，第i-1行状态是k的摆放方案<br>
属性： max<br>
划分依据，<br>
第i行状态不仅和第i-1行状态有关，还和第i-2行状态有关,所有f[i][j][k]第i行状态是j，第i-1行状态是k，依据i-2行状态来划分。<br>
a表示第i行状态，b表示第i-1行状态，c表示第i-2行状态<br>
要求：<br>
（1）每行的意大利炮不能相互攻击到，((a &amp; b) || (a &amp; c) || (a &amp; b))==0<br>
（2）意大利炮只能放在平地上,(g[i] &amp; a )||(g[i-1] &amp; b),无需判断g[i-2]行，若g[i-2]行意大利炮放到了山地上属于不合法状态，一定为0<br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_8df3199474-52.png" alt="52.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/02/9969_923b747474-53.png" alt="53.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
const int N=110,M=1&lt;&lt;10;//n的范围远大于m的范围，以列作为枚举的状态
int g[N];
int cnt[M];//状态对应的1的个数
vector&lt;int&gt; state;
int n,m;
int f[2][M][M];//f[i,j,k] 第i行状态是j，第i-1行状态是k

bool check(int state)
{
    if((state &amp; state&lt;&lt;1) || (state &amp; state&lt;&lt;2))
        return false;
    return true;
}

int count(int state)
{
    int res=0;
    for(int i=0;i&lt;m;i++)
        if(state&gt;&gt;i &amp;1)
            res++;
    return res;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;m;j++)
        {
            char c;
            cin&gt;&gt;c;
            if(c == 'H')
                g[i]+=1&lt;&lt;(m-1-j);
        }
        
    for(int i=0;i&lt;1&lt;&lt;m;i++)
    {
        if(check(i))
        {
            state.push_back(i);
            cnt[i]=count(i);
        }
    }
    //f[i,j,k] 已经摆完前i行，第i行状态是j，第i-1行状态是k
    for(int i=1;i&lt;=n+2;i++)
        for(int j=0;j&lt;state.size();j++)
            for(int k=0;k&lt;state.size();k++)
                for(int u=0;u&lt;state.size();u++)
                {
                    int a=state[j],b=state[k],c=state[u];//a表示第i行状态，b表示第i-1行状态，c表示第i-2行状态
                    if((a &amp; b) || (a &amp; c) || (a &amp; b))//相邻两行不能相互攻击到
                        continue;
                    if((g[i] &amp; a )||(g[i-1] &amp; b))//意大利炮不能放山地上
                        continue;
                    f[i&amp;1][a][b]=max(f[i&amp;1][a][b],f[i-1&amp;1][b][c]+cnt[a]);
                }
                
    cout&lt;&lt;f[n+2&amp;1][0][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="2井字型">2.井字型</h4>
<p><a href="https://www.acwing.com/problem/content/1066/">骑士</a><br>
状态：f[i][j][k],已经摆完前i行，第i行摆放状态是j（二进制位为1表示摆放，0表示不摆），已经摆了k个<br>
属性：count<br>
状态划分：<br>
要求：国王不能左右相邻，不能上下相邻，不能对角相邻，第i行状态为a，i-1行状态为b<br>
（1）每行内部不能有两个1相邻,（预处理）<br>
（2）第i行和第i-1行状态不能相互攻击到，(a &amp; b) == 0 ,a|b不能有两个相邻的1</p>
<pre><code>//第i行状态只跟第i-1行状态有关
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
const int N=12,M=1&lt;&lt;10,K=110;
typedef long long LL;
LL f[N][M][K];
vector&lt;int&gt; state;
int cnt[M];//每个状态对应1的数目
int n,m;

bool check(int state)
{
    for(int i=0;i&lt;n;i++)
    {
        if((state&gt;&gt;i &amp;1) &amp;&amp; (state&gt;&gt;i+1 &amp;1))
            return false;
    }
    return true;
}

int count(int state)
{
    int res=0;
    for(int i=0;i&lt;n;i++)    
        res+=state&gt;&gt;i &amp;1;
    return res;
}

int main()
{
    
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=0;i&lt;1&lt;&lt;n;i++)//如果满足左右互不相邻，则存储当前状态
        if(check(i))
        {
            state.push_back(i);
            cnt[i]=count(i);
        }
    //cout&lt;&lt;state.size()&lt;&lt;endl;
    f[0][0][0]=1;
    for(int i=1;i&lt;=n+1;i++)
        for(int a=0;a&lt;state.size();a++) 
            for(int k=0;k&lt;=m;k++)
                for(int b=0;b&lt;state.size();b++)
                {
                    int sa=state[a],sb=state[b];//sa表示第i行状态,sb表示第i-1行状态
                    if((sa &amp; sb) == 0 &amp;&amp; check(sa|sb))
                    {
                        int c=cnt[sa];
                        //cout&lt;&lt;sa&lt;&lt;' '&lt;&lt;sb&lt;&lt;' '&lt;&lt;k&lt;&lt;' '&lt;&lt;c&lt;&lt;endl;
                        if(k&gt;=c)
                            f[i][sa][k]+=f[i-1][sb][k-c];
                    }
                }
    
    cout&lt;&lt;f[n+1][0][m]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="3插头型">3.插头型</h4>
<p><a href="https://www.acwing.com/problem/content/293/">蒙德里安的梦想</a><br>
考虑决策——骨牌的放法：横着 或者 竖着。</p>
<p>如果横着：<br>
需要两个连续的空位，并且上一行的这两个位置也得已经被覆盖。</p>
<p>如果竖着：<br>
(a) 上一行对应的位置是空的，我们把那个空填上。<br>
(b) 上一行对应的位置是被覆盖的，那么我们把这一行的位置设为空，表示下一行的对应位置必须竖放，填上这块空白</p>
<p>状态表示：f[i][j],表示第i行的形态为j时的摆放方案数量<br>
j是用十进制记录的m位二进制数，其中第k（0&lt;=k&lt;m）位为1表示第k列是一个竖着的1*2的长方形的上面一半。</p>
<blockquote>
<p>记第i-1行状态为k，第i行状态为j<br>
k能转移到j，当且仅当：<br>
(1)j和k执行按位与为0，保证每个数字1下必须是0，才得以补全1<em>2的长方形<br>
(2)j和k执行按位或的结果，连续的0必须是偶数。这些0表示若干横着的1</em>2长方形，奇数个0无法满足这种摆放形态。</p>
</blockquote>
<h4 id="可以预处理出02m-1内所有满足连续的0必须是偶数的整数">可以预处理出[0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>-1]内所有满足连续的0必须是偶数的整数</h4>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 12, M = 1 &lt;&lt; N;
int st[M];
long long f[N][M];

int main()
{
    int n, m;
    while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n)
    {

        for (int i = 0; i &lt; 1 &lt;&lt; m; i ++)
        {
            int cnt = 0;// cnt 为当前已经存在多少个连续的0
            st[i] = true;
            for (int j = 0; j &lt; m; j ++)
                if (i &gt;&gt; j &amp; 1)
                {
                    if (cnt &amp; 1) //当前位为1，上一段连续为0的位置已结束
                        st[i] = false; 
                    cnt = 0;
                }
                else cnt ++;
            if (cnt &amp; 1) st[i] = false; // 扫完后要判断一下最后一段有多少个连续的0
        }
    
        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for (int i = 1; i &lt;= n; i ++)
            for (int j = 0; j &lt; 1 &lt;&lt; m; j ++)
                for (int k = 0; k &lt; 1 &lt;&lt; m; k ++)
                    if ((j &amp; k) == 0 &amp;&amp; (st[j | k])) 
                    // j &amp; k == 0 表示 i 行和 i-1 行不能同时捅出来
                    // st[j | k] == 1 表示 在 i 列状态 j， i - 1 列状态 k 的情况下（连续的0必须有偶数个）是合法的.
                        f[i][j] += f[i - 1][k];      
        cout &lt;&lt; f[n][0] &lt;&lt; endl;
    }
    return 0;
}

</code></pre>
<blockquote></blockquote>
<h3 id="集合类每个元素是否在集合里面状压dp">集合类（每个元素是否在集合里面）状压dp</h3>
<p><a href="https://www.acwing.com/problem/content/93/">最短Hamilton路径</a><br>
给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。<br>
状态表示：dp[i][j] ：所有从0走到j，走过的所有点的状态是i的最短路径<br>
状态划分：<br>
dp[i][j]表示所有从0走到j，当前已经走过点的为i的集合。所以这个状态转移方程就是找一个中间点k，将已经走过点的集合i中去除掉j（表示j不在经过的点的集合中），然后再加上从k到j的权值。问题在于如何表达已经走过点的集合i，其实很简单，假如走过0,1,4这三个点，我们用二进制10011就可以表示，2,3没走过所以是0。<br>
那么走过点的集合i中去除掉点j也很容易表示i - (1 &lt;&lt; j)，比方说i是{0,1,4}，j是1，那么i = 10011，(1 &lt;&lt; j) = 10，i - (1 &lt;&lt; j) = 10001<br>
那么问题的答案就应该是dp[01....111][n-1]，表示0~n-1都走过，且当前移动到n-1这个点。<br>
下时间复杂度：<br>
n为20的时候，外层循环(1&lt;&lt;20)，内层循环20，所以整体时间复杂度O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi mathvariant="normal">∗</mi><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">20∗2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">∗</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>)，这比O(n∗n!)快多了</p>
<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 20, M = 1 &lt;&lt; N;

int n;
int w[N][N];
int f[M][N];

int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i ++ )
        for (int j = 0; j &lt; n; j ++ )
            cin &gt;&gt; w[i][j];

    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;//第一个点是不需要任何费用的
    /*
    注意循环顺序
    如果反过来写，不能保证在f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j])中右边的状态在左边的状态之前被计算出来。
    */
    for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//i代表着是一个方案集合，其中每一个位置1和0，代表着这个点经过还是没有经过
        for (int j = 0; j &lt; n; j ++ )//枚举当前到了哪一个点
            if (i &gt;&gt; j &amp; 1)//如果i集合中第j位是1，也就是到达过这个点
                for (int k = 0; k &lt; n; k ++ )//枚举到达j的点k
                    if (i &gt;&gt; k &amp; 1)
                        f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]);

    cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1];

    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=2288">poj2288</a><br>
题意：<br>
给出n个点，m条边的无向图，给出每个点的点权，求点权和最小的哈密顿路径，相邻两个点要加上点权的乘积，形成环要加上环上的点权<br>
这题先占个坑，以后补。。。。</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1074">hdu1074</a><br>
题意：<br>
给了n个家庭作业，然后给了每个家庭作业的完成期限和花费的实践，如果完成时间超过了期限，那么就要扣除分数，然后让你找出一个最优方案使扣除的分数最少，当存在多种方案时，输出字典序最小的那种，因为题意已经说了家庭作业的名字是按照字典序从小到大输入的，所以处理起来就好多了。</p>
<h4 id="思路">思路</h4>
<p>在引出正解前，我们从DFS开始引入，如果这题用DFS来写，想必大家都有思路，很好理解。因为每个作业要么写，要么不写，因此开个布尔数组搜就行了，而且这题n &lt;= 15;仔细想来，加点剪枝还是可以过的没准。<br>
如果我们把布尔数组看成一个二进制位，进行状态压缩，很明显可以知道，最多只有2的15次方位的1二进制大小的状态。因此可以用2进制所对应的10进制来表示状态，这就是状态压缩。<br>
状态表示:dp[i]记录完成作业状态为i时的最少损失的分数。<br>
状态划分：<br>
1.状态a能做第i号作业的条件是a中作业i尚未完成，即a&amp;i=0。<br>
2.若有两个状态dp[a],dp[b]都能到达dp[i],那么选择能使到达i扣分小的那一条路径，若分数相同，转入3<br>
3.这两种状态扣的分数相同，那么选择字典序小的，由于作业按字典序输入，故即dp[i].pre = min(a,b);<br>
最后dp[2^n-1]即为最少扣分，课程安排可递归的输出</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;bitset&gt;
using namespace std;
const int N=20,M=1&lt;&lt;15;
const int INF=0x3f3f3f3f;
struct
{
    char sbj[110];
	int deadline;
	int fintime;
}w[N];
int dp[M];//dp[i]表示当前写作业状态是i的情况下被扣分的最小值 
int pre[M];//记录前驱 
int day[M];//记录当前写作业状态是i的情况下已经过了多少天 
int n;

void print_path(int state)
{
    if(state==0)return;
    int t=0;
    for(int i=0;i&lt;n;i++)
      if( (state&amp;(1&lt;&lt;i))!=0 &amp;&amp; (pre[state]&amp;(1&lt;&lt;i))==0 )
      {
          t=i;
          break;//按字典序最小输出，由于输入时已按字典序输入，找到第一个满足的break 
      }
    print_path(pre[state]);
    cout&lt;&lt;w[t].sbj&lt;&lt;endl;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=0;i&lt;n;i++)
          scanf(&quot;%s%d%d&quot;,&amp;w[i].sbj,&amp;w[i].deadline,&amp;w[i].fintime);
        memset(dp,0x3f,sizeof dp);
        memset(day,0,sizeof day); 
        dp[0]=0;//当前还未做作业时被扣分为0 
        for(int i=0;i&lt;1&lt;&lt;n;i++)
        {
        	//cout&lt;&lt;(bitset&lt;3&gt;(i))&lt;&lt;&quot; : &quot;&lt;&lt;endl;
            for(int j=0;j&lt;n;j++)
            {
                if(i&amp;(1&lt;&lt;j))continue;//第j位为1，表示第j位上的作业已完成，continue 
                int today=0;
//                for(int k=0;k&lt;n;k++)
//                  if(i&amp;(1&lt;&lt;k))
//                     today+=w[k].fintime;
//                today+=w[j].fintime;
				today=day[i]+w[j].fintime;//today表示今天是第几天 
				int score=0; 
                if(today&gt;w[j].deadline) 
					score=today-w[j].deadline;//完成日期与截止日期的差值 ，若差值&lt;0,则不需扣分 
                if(dp[i|(1&lt;&lt;j)]&gt;dp[i]+score)
                {
                    dp[i|(1&lt;&lt;j)]=dp[i]+score;
                    day[i|1&lt;&lt;j]=day[i]+w[j].fintime;
                    //cout&lt;&lt;&quot;--&quot;&lt;&lt;(bitset&lt;3&gt;(i|(1&lt;&lt;j)))&lt;&lt;' '&lt;&lt;dp[i|(1&lt;&lt;j)]&lt;&lt;endl;
                    pre[i|(1&lt;&lt;j)]=i;
                }
            }
            //cout&lt;&lt;endl;
        }
        printf(&quot;%d\n&quot;,dp[(1&lt;&lt;n)-1]);
        print_path((1&lt;&lt;n)-1);
    }
    return 0;
}
</code></pre>
<h4 id="旅行商问题tsp">旅行商问题(TSP)，</h4>
<p><img src="https://cdn.acwing.com/media/article/image/2020/02/13/9969_0b0799de4e-lxs.PNG" alt="lxs.PNG" loading="lazy"><br>
TSP问题是NP难度的，没有多项式时间的高效算法。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_1125f75e4e-2221.png" alt="2221.png" loading="lazy"><br>
假设最短的TSP路径是path=（v0-&gt;v1-&gt;v2-&gt;v3-&gt;v4-&gt;v0）</p>
<h4 id="那么pathv0-v1v1-v2-v3-v0">那么path=(v0-&gt;v1)+(v1-&gt;v2-&gt;v3-&gt;v0)</h4>
<h4 id="所以问题转变为求经过所有城市的最短回路-从某个城市回到起点的最短路径">所以问题转变为：求经过所有城市的最短回路-&gt;从某个城市回到起点的最短路径</h4>
<p>DP状态：假设已经访问过的城市集合是S（已访问为1，未访问为0），当前所在城市是u，用dp[S][u]表示从u出发访问剩余的所有城市最后回到<strong>起点</strong>的路径费用总和的最小值。<br>
状态转移方程：<br>
dp[S][u]=min(dp[S∪{v}][v]+dist(u,v)|v∉S}<br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/13/9969_63474b444e-%E5%9B%BE%E7%89%872.png" alt="图片2.png" loading="lazy"></p>
<h4 id="临界条件如果递推的话是起点递归的话是终点">临界条件如果递推的话是起点，递归的话是终点</h4>
<pre><code>#include&lt;cstring&gt;//递推，输出路径 
#include&lt;bitset&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=0x3f3f3f3f;
int dp[1&lt;&lt;15][15];//dp[S][u]:S表示已经过的节点，从u出发走完所有剩余顶点回到起点的最短距离
int g[15][15];
int path[1&lt;&lt;15][15];//最优路径
int n,m; //n个节点，m条边

void Init()
{
    memset(dp,0x3f,sizeof(dp));
    memset(g,0x3f,sizeof(g));
    memset(path,-1,sizeof(path));
}

void Traveling()//计算dp[S][u]
{
    dp[(1&lt;&lt;n)-1][0]=0;//注意：1&lt;&lt;n一定要加括号 
	for(int S=(1&lt;&lt;n)-2;S&gt;=0;S--)
        for(int u=0;u&lt;n;u++)
            for(int v=0;v&lt;n;v++)
			{//u可以等于0,起点0可看做已访问（从起点0出发回到起点0） 
            	if((u!=0&amp;&amp;!(S&gt;&gt;u&amp;1))||g[u][v]==INF) continue;，//若 u!=0，则u必须已访问 
				if(!(S&gt;&gt;v&amp;1)&amp;&amp;dp[S][u]&gt;dp[S|1&lt;&lt;v][v]+g[u][v])
                {
                    dp[S][u]=dp[S|1&lt;&lt;v][v]+g[u][v];
                    cout&lt;&lt;&quot;S=&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;\t   u=&quot;&lt;&lt;u&lt;&lt;&quot;\tv=&quot;&lt;&lt;v&lt;&lt;&quot;\tdp[&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;][&quot;&lt;&lt;u&lt;&lt;&quot;]=&quot;;
					cout&lt;&lt;&quot;dp[&quot;&lt;&lt;(bitset&lt;5&gt;(S|1&lt;&lt;v))&lt;&lt;&quot;][&quot;&lt;&lt;v&lt;&lt;&quot;]+&quot;&lt;&lt;g[u][v]&lt;&lt;&quot;=&quot;&lt;&lt;dp[S][u]&lt;&lt;endl;
                    path[S][u]=v;//记录后继节点
                }
        	}
}

void print(int S,int u)//打印路径
{
    if(S==(1&lt;&lt;n)-1) return;
    int v=path[S][u];//u的后继v
    cout&lt;&lt;&quot;---&gt;&quot;&lt;&lt;v;
	print(S|1&lt;&lt;v,v);//将v加入已走过的节点集合，再从v出发
}

int main()
{
	int u,v,w;//u,v代表城市，w代表u和v城市之间路的长度
    cin&gt;&gt;n&gt;&gt;m;
    Init();
    for(int i=0;i&lt;m;i++)
    {
       cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
       //g[u][v]=g[v][u]=w;//无向图 
       g[u][v]=w;//有向图 
    }
    Traveling();
    cout&lt;&lt;&quot;最短路径: &quot;&lt;&lt;0;
    print(0,0);
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;最短路径长度:&quot;&lt;&lt;dp[0][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_2800cfd84e-115.PNG" alt="115.PNG" loading="lazy"></figure>
<pre><code>#include&lt;cstring&gt;//记忆化递归，输出路径 
#include&lt;bitset&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=0x3f3f3f3f;
int dp[1&lt;&lt;15][15];//dp[S][u]:S表示已经过的节点，从u出发走完所有剩余顶点回到起点的最短距离
int g[15][15];
int path[1&lt;&lt;15][15];//最优路径
int n,m; //n个节点，m条边

void Init()
{
    memset(dp,-1,sizeof(dp));
    memset(g,0x3f,sizeof(g));
    memset(path,-1,sizeof(path));
}

int Traveling(int S,int u)//计算dp[S][u],记忆化递归 
{
    if(dp[S][u]&gt;=0)
    	return dp[S][u];
	if(S==(1&lt;&lt;n)-1&amp;&amp;u==0)
		return dp[S][u]=0;//递归结束条件
    int ans=INF;
	for(int v=0;v&lt;n;v++)
		if(!(S&gt;&gt;v&amp;1)&amp;&amp;g[u][v]!=INF)
		{
			int tmp=Traveling(S|1&lt;&lt;v,v)+g[u][v];
			if(ans&gt;tmp)
			{
				ans=tmp;
				cout&lt;&lt;&quot;S=&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;\t   u=&quot;&lt;&lt;u&lt;&lt;&quot;\tv=&quot;&lt;&lt;v&lt;&lt;&quot;\tdp[&quot;&lt;&lt;(bitset&lt;5&gt;(S))&lt;&lt;&quot;][&quot;&lt;&lt;u&lt;&lt;&quot;]=&quot;;
				cout&lt;&lt;&quot;dp[&quot;&lt;&lt;(bitset&lt;5&gt;(S|1&lt;&lt;v))&lt;&lt;&quot;][&quot;&lt;&lt;v&lt;&lt;&quot;]+&quot;&lt;&lt;g[u][v]&lt;&lt;&quot;=&quot;&lt;&lt;ans&lt;&lt;endl;
				path[S][u]=v;//记录后继节点
			}		
		}
    return dp[S][u]=ans;
}

void print(int S,int u)//打印路径
{
    if(S==(1&lt;&lt;n)-1) return;
    int v=path[S][u];//u的后继v
    cout&lt;&lt;&quot;---&gt;&quot;&lt;&lt;v;
	print(S|1&lt;&lt;v,v);//将v加入已走过的节点集合，再从v出发
}

int main()
{
	int u,v,w;//u,v代表城市，w代表u和v城市之间路的长度
    cin&gt;&gt;n&gt;&gt;m;
    Init();
    for(int i=0;i&lt;m;i++)
    {
       cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
       //g[u][v]=g[v][u]=w;
       g[u][v]=w;
    }
    Traveling(0,0);
    cout&lt;&lt;&quot;最短路径: &quot;&lt;&lt;0;
    print(0,0);
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;最短路径长度:&quot;&lt;&lt;dp[0][0]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="例题">例题</h4>
<p><a href="http://poj.org/problem?id=3311">poj3311</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_c0342f484e-poj.png" alt="poj.png" loading="lazy"></p>
<h4 id="思路-2">思路</h4>
<p>由于题中明确说了两个城市间的直接可达路径（即不经过其它城市结点）不一定是最短路径，所以需要借助邻接矩阵首先求出任意两个城市间的最短距离（因为这里的点可以多次遍历，并没有次数限制，所以才能用floyd的，如果有次数限制x的话，就不能用floyd预处理，而应该用x进制的状态压缩了）。这一步骤使用Floyd最短路径算法即可。然后，在此基础上来求出遍历各个城市后回到出发点的最短路径的距离，即求解TSP问题。</p>
<pre><code>//求走过所有点并回到原点的最短路,可以走一个点多次.
//因为可以走一个点多次，所以，可以先求出每两个点之间的最短路，然后用经典的旅行商问题的状态压缩DP做法。
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=12,M=1&lt;&lt;11,INF=0x3f3f3f3f;
int n;
int g[N][N];
int dp[M][N];

void Init()
{
    memset(dp,-1,sizeof(dp));
    memset(g,0x3f,sizeof(g));
}

void floyd()
{
    for(int k=0;k&lt;n;k++)
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
}

int Tsp(int S,int u)//计算dp[S][u],记忆化递归 
{
	if(dp[S][u]&gt;=0)
    	return dp[S][u];
	if(S==(1&lt;&lt;n)-1&amp;&amp;u==0)//递归结束条件
		return dp[S][u]=0;
    int ans=INF;
	for(int v=0;v&lt;n;v++)
		if(!(S&gt;&gt;v&amp;1)&amp;&amp;g[u][v]!=INF)
			ans=min(ans,Tsp(S|1&lt;&lt;v,v)+g[u][v]);
    return dp[S][u]=ans;
}

int main()
{
    while(~scanf(&quot;%d&quot;,&amp;n),n)
    {
        n++;//源点0加上 
		Init();
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                scanf(&quot;%d&quot;,&amp;g[i][j]);
        floyd();
        printf(&quot;%d\n&quot;,Tsp(0,0));
    }
    return 0;
}
</code></pre>
<p>递推</p>
<pre><code>//求走过所有点并回到原点的最短路,可以走一个点多次.
//因为可以走一个点多次，所以，可以先求出每两个点之间的最短路，然后用经典的旅行商问题的状态压缩DP做法。
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=12,M=1&lt;&lt;11,INF=0x3f3f3f3f;
int n;
int g[N][N];
int dp[M][N];

void Init()
{
    memset(dp,0x3f,sizeof(dp));//递推时初始化为INF，记忆化递归初始化为-1 
    memset(g,0x3f,sizeof(g));
}

void floyd()
{
    for(int k=0;k&lt;n;k++)
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
}

void Tsp()//计算dp[S][u]
{
    dp[(1&lt;&lt;n)-1][0]=0;//注意：1&lt;&lt;n一定要加括号 
	for(int S=(1&lt;&lt;n)-2;S&gt;=0;S--)
        for(int u=0;u&lt;n;u++)
            for(int v=0;v&lt;n;v++)
			{
            	if((u!=0&amp;&amp;!(S&gt;&gt;u&amp;1))||g[u][v]==INF) continue;//可以加约束条件，不加状态多 
				if(!(S&gt;&gt;v&amp;1))
                    dp[S][u]=min(dp[S][u],dp[S|1&lt;&lt;v][v]+g[u][v]);
        	}
}

int main()
{
    while(~scanf(&quot;%d&quot;,&amp;n),n)
    {
        n++;//加上源点 
		Init();
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                scanf(&quot;%d&quot;,&amp;g[i][j]);
        floyd();
		Tsp();
        printf(&quot;%d\n&quot;,dp[0][0]);
    }
    return 0;
}
</code></pre>
<p><a href="http://poj.org/problem?id=2686">poj2686</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_9fa870324f-2686.png" alt="2686.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_ae8bd9ea4f-268.png" alt="268.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_ce1e0b0c4f-2681.png" alt="2681.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_d30d5e064f-2688.png" alt="2688.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_59ec7a564f-26888.png" alt="26888.png26882.png " loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_8ec6bde04f-26882.png" alt="26882.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=10,M=35,INF=0x3f3f3f3f;
int n,m,p,a,b;
int t[N];
int g[M][M];
double dp[1&lt;&lt;8][M];//d[S][u],所用车票状态是S,从起点走到点u所需的最短时间 

int main()
{
	while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;a&gt;&gt;b &amp;&amp; n)
	{
		for(int i=0;i&lt;n;i++)
			cin&gt;&gt;t[i];
		memset(g,0x3f,sizeof g);
		while(p--)
		{
			int a,b,c;
			cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a][b]=g[b][a]=c;
		}
		//memset(dp,0x3f,sizeof(dp));//double不可以memset 
	    for(int i=0;i&lt;1&lt;&lt;n;i++)
	    	fill(dp[i]+1,dp[i]+m+1,INF);
	//	for(int i=0;i&lt;1&lt;&lt;n;i++)
	//		for(int j=1;j&lt;=m;j++)
	//			dp[i][j]=INF;
		dp[(1&lt;&lt;n)-1][a]=0;
		double ans=INF;
		for(int S=(1&lt;&lt;n)-1;S&gt;=0;S--)//状态 
		{
			for(int u=1;u&lt;=m;u++)//城市 
				for(int i=0;i&lt;n;i++)//车票 
					if(S&gt;&gt;i &amp; 1)
						for(int v=1;v&lt;=m;v++)//城市 
							if(g[u][v] != INF)
								dp[S-(1&lt;&lt;i)][v]=min(dp[S-(1&lt;&lt;i)][v],dp[S][u]+g[u][v]/(double)t[i]);
			ans=min(ans,dp[S][b]);
		}
							
		if(ans == INF)
			puts(&quot;Impossible&quot;);
		else
			printf(&quot;%.3f\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3001">hdu3001</a><br>
题意：<br>
ACMer 想要游玩n个城市，告诉我们每个城市间的旅行费用，并且要求每个城市最多走两遍！问最小花费是多少<br>
本题n=10，数据很小，但是由于每个城市可以走两遍，可能的路线就变成了(2n)!,所以不能暴力<br>
用状压dp，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>3</mn><mi>n</mi></msup><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(3^{n}n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_a79d1b884f-3001.png" alt="3001.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_c0dd19cc4f-30012.png" alt="30012.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/02/14/9969_caa8c2f84f-30013.png" alt="30013.png" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=15,M=60000,INF=0x3f3f3f3f;
int n,m;
int bit[12]={0,1,3,9,27,81,243,729,2187,6561,19683,59049};//三进制每位为1时对应十进制，如第3位是1，(100)3=9 
int tri[M][N];//dp[S][j]状态S的第j位是多少
int dp[M][N];
int g[N][N];

int main()
{
	//cout&lt;&lt;pow(3,10)&lt;&lt;endl;
	for(int i=0;i&lt;59050;i++)//预处理所有合法状态 
	{
		int t=i;
		for(int j=1;j&lt;=10;j++)
		{
			tri[i][j]=t%3;//预处理当前状态S下每个顶点的访问次数 
			t/=3;
			if(!t)
				break;
		}
	}
	
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) 
	{
		int ans=INF;
		memset(g,0x3f,sizeof g);
		memset(dp,0x3f,sizeof dp);
		
		while(m--)
		{
			int a,b,c;
			cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a][b]=g[b][a]=min(g[a][b],c);
		}
		
		for(int i=1;i&lt;=n;i++)
			dp[bit[i]][i]=0;//每个顶点都可以作为起点，初始化状态为tri[i]时，从i出发最小费用为0
		
		for(int S=0;S&lt;bit[n+1];S++)
		{
			bool visit_all=true;//标记所有的城市都遍历1次以上 
			for(int u=1;u&lt;=n;u++)
			{
				if(tri[S][u] == 0)//u点没被访问 
				{
					visit_all=false;//当前状态不能访问所有顶点至少一次 
					continue; 
				}
				for(int v=1;v&lt;=n;v++)
				{
					if(tri[S][v] == 0)//v点未访问
						continue;
					if(g[u][v] != INF)
						dp[S][u]=min(dp[S][u],dp[S-bit[u]][v]+g[u][v]);//u从S中减去 
				}
			}
			if(visit_all)//所有的城市都遍历1次以上
				for(int u=1;u&lt;=n;u++)
					ans=min(ans,dp[S][u]);
		}
			
		if(ans == INF)
			puts(&quot;-1&quot;);
		else
			cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4628">hdu4628</a><br>
有一个长度不超过 16 的字符串。<br>
每次你可以从中删除一个子序列，但是要求这个子序列是回文的。<br>
问最少删除几次可以把这个字符串删光。<br>
样例：<br>
2<br>
aa （1次）<br>
abb （2次）</p>
<p>每次可以选择一个子序列，而子序列是可以用二进制来表示的。<br>
用一个 n 位的二进制数 s 来表示，如果第 i 位是 1，则表示第 i 个数在这个子序列中。<br>
由此衍生出：用 f[s] 来表示把 s 这个子序列删完的最小步数。<br>
答案自然就是 f[(1 &lt;&lt; n) - 1]</p>
<p>一个显然的想法，可以把 s 分成两个不相交的集合 x 和 y， 即 x ∩ y = ∅，x ∪ y = s<br>
f[s] = min(f[s], f[s-x] + 1) (x 是回文子串）<br>
如何判断x是s的子集？<br>
x|s == s</p>
<p>直接枚举 x 和 y 的时间复杂度是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)，对于每个状态都有枚举2^n,总时间复杂度是O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">4^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)，无法承受。</p>
<p>注意到 x 和 y 都是 s 的子集。<br>
所有集合的子集个数之和的级别是 O(3^n)<br>
就是说一个集合,有n个元素,2<sup>n个子集,把这2</sup>n个子集的所有子集数相加就是3^n<br>
证明可以对每个集合考虑贡献，二项式定理<br>
空集的子集只有一个——它本身.即C(n,0)×2<sup>0个.有一个元素的子集有C(n,1)=n个,它们分别有2</sup>1=2个子集.共C(n,1)×2<sup>1个.有两个元素的子集有C(n,2)个,它们分别有2</sup>2=4个子集.共C(n,2)×2^2个...<br>
我们只要枚举 s 的子集 x，那么 y 自然就是 s - x</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=20,M=1&lt;&lt;16;
char s[N];
int f[M];
bool st[M];
int n;

bool check(int x)
{
    char str[20];
    int tot=0;
    for(int i=0;i&lt;n;i++)
        if(x&gt;&gt;i &amp; 1) str[tot++]=s[i];
    
    for(int i=0;i&lt;tot/2;i++)
        if(str[i] != str[tot-1-i])
            return 0;
    
    return 1;
}

void init()
{
    memset(st,0,sizeof st);
    for(int i=0;i&lt;1&lt;&lt;n;i++)
        if(check(i))
            st[i]=true;
}

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        scanf(&quot;%s&quot;,s);
        n=strlen(s);
        init();
        
        memset(f,0x3f,sizeof f);
        f[0]=0;
        for(int i=0;i&lt;1&lt;&lt;n;i++)
            for(int j=i;j;j=(j-1)&amp;i)
                if(st[j]) f[i]=min(f[i],f[i-j]+1);
        
        printf(&quot;%d\n&quot;,f[(1&lt;&lt;n)-1]);
    }
    return 0;
}
</code></pre>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6149">hdu6149</a><br>
给定一张 N 个点 M 条边的无向图，其中有 K 个点被标记为高点，剩下的 (N-K) 个点是低点。<br>
图中的山谷定义为三元组 &lt;X,Y,Z&gt;，满足X和Y之间有边，Y与 Z之间也有边，同时X和Z是高点，Y是低点。<br>
问这个图中最多有几个山谷（一个点只能出现在一个山谷中）N ≤ 30, K ≤ min(N,15)</p>
<p>高点最多只有 15 个。<br>
可以考虑用状态压缩，s 表示高点的使用状态。<br>
低点排成一个长度为 n-k 的序列。<br>
f[i][s] 表示前 i 个低点，使用过的高点的状态为 s 的情况下，组成的山谷的最大可能值。</p>
<p>转移 f[i][s] 的时候，取出第 i+1 个低点。<br>
枚举不在 s 中的两个高点 p 和 q.<br>
检查 p 和 q 和第 i+1 个低点能否配对。<br>
如果可以，那么就可以用 f[i][s] + 1 去更新<br>
f[i + 1][s | (1 &lt;&lt; p) | (1 &lt;&lt; q)]<br>
答案就是 max{ f[n-k][i] | 0 ≤ i &lt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> }</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef pair&lt;int,int&gt; PII;
const int N=35,M=1&lt;&lt;15;
int f[N][M];
int g[N][N];
int n,m,k;
int high[N],low[N];
bool st[N];
vector&lt;PII&gt; trans[N];
int tot;

void init()
{
	for(int i=1;i&lt;=n;i++)
		if(!st[i])
			low[++tot]=i;
	
	for(int i=1;i&lt;=tot;i++)
	{
		trans[i].clear();
		for(int p=0;p&lt;k;p++)
			if(g[low[i]][high[p]])
				for(int q=p+1;q&lt;k;q++)
					if(g[low[i]][high[q]])
						trans[i].push_back(make_pair(p,q));							
	}
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		memset(g,0,sizeof g);
		memset(st,0,sizeof st);
		memset(f,0,sizeof f);
		tot=0;
		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
		for(int i=0;i&lt;m;i++)
		{
			int x,y;
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			g[x][y]=g[y][x]=1;
		}
		
		for(int i=0;i&lt;k;i++)
		{
			scanf(&quot;%d&quot;,&amp;high[i]);
			st[high[i]]=true;
		}
		
		init();
		
		for(int i=1;i&lt;=tot;i++)
		{
			for(int s=0;s&lt;1&lt;&lt;k;s++)
				f[i][s]=f[i-1][s];//不选第i个点
			
			for(int s=0;s&lt;1&lt;&lt;k;s++)
			{
				for(int j=0;j&lt;trans[i].size();j++)
				{
					int x=trans[i][j].first;
					int y=trans[i][j].second;
					if(s&gt;&gt;x &amp; 1) continue;
					if(s&gt;&gt;y &amp; 1) continue;
					f[i][s|(1&lt;&lt;x)|(1&lt;&lt;y)]=max(f[i][s|(1&lt;&lt;x)|(1&lt;&lt;y)],f[i-1][s]+1);//选第i个点
				}
			}
		}
			
		int ans=0;
		for(int i=0;i&lt;1&lt;&lt;k;i++)
			ans=max(ans,f[tot][i]);
		
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/526/">acwing524</a><br>
数据范围非常小，可以考虑状态压缩DP。 设 f[s] 表示清除掉 s 集合中的猪花费的最小步数。<br>
思考转移。<br>
在已有的 s 集合基础上，再选择一条抛物线使得它经过 t集合的点。<br>
那么就可以用 f[s] + 1 去更新 f[s | t]</p>
<p>三点确定一条抛物线。<br>
而三点之中必须有一个原点，因此只要两个点就能确定一条抛物线。<br>
因此我们可以枚举 s 集合以外的任意两个点，算出经过这两个点的抛物线，枚举所有的点看是否落在抛物线上，得到抛<br>
物线经过的点集 t。<br>
f[s | t] = min(f[s | t], f[s] + 1);</p>
<p>经过点 i 和 j 的抛物线经过的点集 t[i][j] 可以预处理。时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)<br>
之后 DP 枚举每个集合，对每个集合都要枚举两个点。<br>
时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</p>
<p>预处理：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>[</mo><mi>i</mi><msup><mo>]</mo><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>y</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ax[i]^2 + bx[i] = y[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>[</mo><mi>j</mi><msup><mo>]</mo><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>y</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ax[j]^2 + bx[j] = y[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span><br>
解二元一次方程组，得到 a 和 b。<br>
如果 a &gt;= 0，不符合题意，t[i][j] = 0<br>
否则对每个点判断一下是否落在这条抛物线上，如果第 k 个点落在抛物线上，<br>
t[i][j] |= (1 &lt;&lt; (k - 1));</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=20,M=1&lt;&lt;18;
const double eps=1e-8;
double x[N],y[N];
int path[N][N];
int f[M];
int n,m;

int cmp(double a,double b)
{
	if(fabs(a-b) &lt; eps) return 0;
	else return a&lt;b? -1 : 1;
}

void init()
{
	for(int i=0;i&lt;n;i++)
	{
	    path[i][i] |= 1&lt;&lt;i;
	    
		for(int j=i+1;j&lt;n;j++)
		{
			if(!cmp(x[i],x[j])) continue;
			
			double a=(y[i]/x[i]-y[j]/x[j])/(x[i]-x[j]);
			if(cmp(a,0) &gt;= 0) continue;
			double b=y[i]/x[i]-a*x[i];
			
			for(int k=0;k&lt;n;k++)
				if(!cmp(a*x[k]*x[k]+b*x[k],y[k])) path[i][j]|=1&lt;&lt;k;
		}
	}
}

int main()
{
	int T;
	cin&gt;&gt;T;
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for(int i=0;i&lt;n;i++)
			scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]);
		memset(path,0,sizeof path);
		
		init();
		
		memset(f,0x3f,sizeof f);
		f[0]=0;
		for(int s=0;s&lt;1&lt;&lt;n;s++)
			for(int i=0;i&lt;n;i++)
				if(!(s&gt;&gt;i &amp; 1))
				{
					for(int j=i;j&lt;n;j++)//记得处理只射一只猪的情况(i == j)
					{
					    if(!(s&gt;&gt;j &amp; 1))
							f[s|path[i][j]] = min(f[s|path[i][j]],f[s]+1);
					}
					break;
					//对于我们枚举的每一个状态i，我们找到它正数第一只没射掉的猪进行转移后break。
                    //因为如果我们转移了第一只后面的没射的猪，到时候还要回头来将第一只猪射掉。
                    //所以后面的没射的猪的转移其实是多余的，射完第一只猪后按顺序接着往后射就可以了。
				}
						
		printf(&quot;%d\n&quot;,f[(1&lt;&lt;n)-1]);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/531/">acwing529</a><br>
简化版题目：<br>
给定一个 n 个点 m 条边的图，请你求出一个有根树，满足每个点的深度和它到父节点的边权乘积之和最小。<br>
n ≤ 12，m ≤ 1000</p>
<p>考虑到点数只有12个，可以考虑状态压缩 DP。 用 s 表示当前加入的点集。<br>
为了方便转移，我们不记录根是谁，而是直接去考虑深度。<br>
也就是用 f[i][s] 表示当前的点集是 s，最深的点为 i。<br>
然后我们去枚举 s 的补集的子集 t，把 t 都作为第 i+1 层加入 s。</p>
<p>我们不用去考虑 t 里的点在这颗树中是否真的是第 i+1层<br>
因为如果不是的话只可能小于i+1层，答案会更小。<br>
那么一定存在一种转移顺序，考虑到这种更优的情况，也就是先把这个点加入 s 集合。<br>
例如，如果第j层中用到的某条边(a, b)应该在比j小的层，假设a是S中的点，b是第j层的点，则在枚举S + {b}时会得到更小的花费。</p>
<p>具体的操作是：<br>
对于 s，枚举 t（s 的补集的子集），检查 t 里的点是否都和 s 里的点有连边，处理出每个点到 s 里的点的最短边。<br>
设这些最短边边权之和为 v。<br>
那么 f[i][s | t] = min(f[i][s | t], f[i - 1][s] + (i - 1) * v)</p>
<p>时间复杂度分析：<br>
s 一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个，s 的补集的子集一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">3^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个。<br>
处理 t 里的每个点到 s 里的点的最短边，预处理时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)<br>
验证 t 是否可行，时间复杂度 O(n)。<br>
转移时对每个深度都要更新一次，时间复杂度O(n)<br>
总时间复杂度就是 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><msup><mn>2</mn><mi>n</mi></msup><mo>+</mo><mi>n</mi><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n^22^n + n3^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)，即 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n3^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using namespace std;
const int N=15,M=1&lt;&lt;12,INF=0x3f3f3f3f;
int f[M][N];
int g[N][N];
int dist[M][N];
int n,m;

void init()
{
    memset(dist,0x3f,sizeof dist);

    for(int s=0;s&lt;1&lt;&lt;n;s++)//集合s 
        for(int i=0;i&lt;n;i++)
            if(!(s&gt;&gt;i &amp; 1))//枚举不在集合s中的点i 
                for(int j=0;j&lt;n;j++)
                    if(s&gt;&gt;j &amp; 1)//预处理出i到集合s的最短距离 
                        dist[s][i]=min(dist[s][i],g[i][j]);
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    memset(g,0x3f,sizeof g);
    while(m--)
    {
        int a,b,c;
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        a--,b--;
        g[a][b]=g[b][a]=min(g[a][b],c);
    }

    init();

    memset(f,0x3f,sizeof f);
    for(int i=0;i&lt;n;i++) f[1&lt;&lt;i][1]=0;

    for(int s=0;s&lt;1&lt;&lt;n;s++)//集合s 
    {
        int c=(1&lt;&lt;n)-1-s;
        for(int t=c;t;t=(t-1)&amp;c)//集合s的补集t 
        {
            int sum=0;
            for(int i=0;i&lt;n;i++)
                if(t&gt;&gt;i &amp; 1)
                {
                    sum+=dist[s][i];
                    if(sum &gt;= INF) break;
                }   

            if(sum &lt; INF)
                for(int i=1;i&lt;=n;i++)
                    f[s|t][i]=min(f[s|t][i],f[s][i-1]+(i-1)*sum);
        }
    }

    int ans=INF;
    for(int i=1;i&lt;=n;i++)
        ans=min(ans,f[(1&lt;&lt;n)-1][i]);

    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://caifxh.github.io/post/wu-xiang-tu-you-xiang-tu-de-lian-tong-xing-fu-xi/">
                                <h3 class="post-title">
                                    无向图/有向图的连通性复习
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%A3%8B%E7%9B%98%E7%B1%BB%E5%9F%BA%E4%BA%8E%E8%BF%9E%E9%80%9A%E6%80%A7%E7%8A%B6%E5%8E%8Bdp">棋盘类（基于连通性）状压dp</a>
<ul>
<li><a href="#1%E5%8D%81%E5%AD%97%E5%9E%8B">1.十字型</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B">输出样例：</a></li>
<li><a href="#2%E4%BA%95%E5%AD%97%E5%9E%8B">2.井字型</a></li>
<li><a href="#3%E6%8F%92%E5%A4%B4%E5%9E%8B">3.插头型</a></li>
<li><a href="#%E5%8F%AF%E4%BB%A5%E9%A2%84%E5%A4%84%E7%90%86%E5%87%BA02m-1%E5%86%85%E6%89%80%E6%9C%89%E6%BB%A1%E8%B6%B3%E8%BF%9E%E7%BB%AD%E7%9A%840%E5%BF%85%E9%A1%BB%E6%98%AF%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0">可以预处理出[0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>-1]内所有满足连续的0必须是偶数的整数</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88%E7%B1%BB%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E9%9B%86%E5%90%88%E9%87%8C%E9%9D%A2%E7%8A%B6%E5%8E%8Bdp">集合类（每个元素是否在集合里面）状压dp</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="#%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98tsp">旅行商问题(TSP)，</a></li>
<li><a href="#%E9%82%A3%E4%B9%88pathv0-v1v1-v2-v3-v0">那么path=(v0-&gt;v1)+(v1-&gt;v2-&gt;v3-&gt;v0)</a></li>
<li><a href="#%E6%89%80%E4%BB%A5%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%B1%82%E7%BB%8F%E8%BF%87%E6%89%80%E6%9C%89%E5%9F%8E%E5%B8%82%E7%9A%84%E6%9C%80%E7%9F%AD%E5%9B%9E%E8%B7%AF-%E4%BB%8E%E6%9F%90%E4%B8%AA%E5%9F%8E%E5%B8%82%E5%9B%9E%E5%88%B0%E8%B5%B7%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">所以问题转变为：求经过所有城市的最短回路-&gt;从某个城市回到起点的最短路径</a></li>
<li><a href="#%E4%B8%B4%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%A6%82%E6%9E%9C%E9%80%92%E6%8E%A8%E7%9A%84%E8%AF%9D%E6%98%AF%E8%B5%B7%E7%82%B9%E9%80%92%E5%BD%92%E7%9A%84%E8%AF%9D%E6%98%AF%E7%BB%88%E7%82%B9">临界条件如果递推的话是起点，递归的话是终点</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>