<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    线性dp | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1588691348423">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1588691348423" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            线性dp
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-03-26</time>
                            
                                <a href="https://caifxh.github.io/tag/hLQFdtGuD/" class="post-tag i-tag
                            i-tag-error">
                            #DP
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_063efe606b-34.png" alt="34.png" loading="lazy"></figure>
<h4 id="多阶段决策问题">多阶段决策问题</h4>
<p>有一类活动的过程，可以分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效。<br>
当然，各个阶段的决策的选取不是任意确定的，它依赖于当前的状态，又会影响以后的发展。</p>
<p>当各个阶段决策决定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。<br>
这种把一个问题看做是一个前后关联、具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为<code>多阶段决策问题</code>。</p>
<p>各个阶段采取的决策， 一般来说是与阶段有关的。<br>
决策依赖于当前的状态，又随即引起状态的转移。<br>
一个决策序列就是在变化的状态中产生出来的。<br>
称这种解决多阶段决策最优化的过程为<code>动态规划（DP）</code>。</p>
<p>动态规划（Dynamic Programming）程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。<br>
由于各种问题的性质不同，确定最优解的条件也互不相同，因此不存在一种万能的动态规划算法可以解决各类最优化问题。</p>
<p>常见的 DP 类型有：<br>
线性模型<br>
区间 DP<br>
背包 DP<br>
数位 DP<br>
状态压缩 DP<br>
树状 DP</p>
<p>常见的 DP 优化方法有：<br>
滚动数组优化<br>
矩阵乘法优化<br>
斜率优化<br>
四边形不等式优化<br>
决策单调性优化<br>
数据结构优化</p>
<h4 id="动态规划的基本概念">动态规划的基本概念</h4>
<p>1.阶段和阶段变量<br>
将问题的全过程恰当地分成若干个相互联系的阶段。<br>
阶段的划分一般根据时间和空间的自然特征去划分。<br>
阶段的划分要便于把问题转化成多阶段决策问题。</p>
<p>2.状态和状态变量<br>
通常一个阶段包含若干状态。<br>
状态可由变量来描述。</p>
<p>3.决策、决策变量和决策允许集合。<br>
在对问题的处理中作出的每种选择性的行动就是决策。<br>
即从该阶段的每一个状态出发， 通过一次选择性的行动转移至下一阶段的相应状态。<br>
一个实际问题可能需要有多次决策和多个决策点，在每一个阶段的每一个状态中都需要有一次决策，<br>
决策也可以用变量来描述，称这种变量为决策变量。<br>
在实际问题中，决策变量的取值往往限制在某一个范围之内，此范围就称为决策允许集合。</p>
<p>4.策略和最优策略<br>
所有阶段一次排列构成问题的全过程。<br>
全过程中各阶段决策变量所组成的有序总体称为策略。<br>
在实际问题中，从决策允许集合中找出最优效果的策略称为最优策略。</p>
<p>5.状态转移方程<br>
前一阶段的终点就是后一阶段的起点，对前一阶段的状态做出某种决策，产生后一种阶段的状态，这种关系描述了从 i<br>
阶段到 i+1 阶段状态的演变规律，称为状态转移方程。</p>
<p>从 n 个数中取出 k 个数，使得他们的和最大。<br>
f[i][j] 表示现在考虑到了第 i 个数，已经选出了 j 个数。<br>
阶段：枚举到第i个数<br>
状态：已经选出了 j 个数。<br>
决策：第i个数选或不选<br>
策略：和最大<br>
状态转移方程：f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[i])</p>
<h4 id="动态规划的性质">动态规划的性质</h4>
<p>什么样的“多阶段决策问题”才可以用动态规划的方法来求解呢？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_a514107a6b-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_cda6e35a6b-2.png" alt="2.png" loading="lazy"><br>
对于不能划分阶段的题，不能用动态规划来解。<br>
不符合最优化原理，不能用动态规划来解。<br>
不具备无后效性原则的，不能用动态规划来解。<br>
误用动态规划解决问题会得到错误的结果</p>
<h4 id="动态规划设计方法">动态规划设计方法</h4>
<p>正推：从初始状态开始，通过对中间阶段的决策的选择，达到结束状态。我们也称递推。<br>
倒推：从结束状态开始，通过对中间阶段的决策的选择，达到开始状态。我们可以把这种方法看成记忆化搜索。</p>
<h4 id="动态规划设计方法的一般模式">动态规划设计方法的一般模式</h4>
<ol>
<li>划分阶段</li>
<li>确定状态和状态变量</li>
<li>确定决策并写出状态转移方程</li>
<li>寻找边界条件</li>
<li>设计并实现程序</li>
</ol>
<h4 id="动态规划与记忆化搜索">动态规划与记忆化搜索</h4>
<p>实现一个函数，用“搜索”的方法实现 DP 的更新。<br>
通常用于解决转移顺序不方便人为确定的 DP。<br>
数字三角形<br>
5<br>
7<br>
3 8<br>
8 1 0<br>
2 7 4 4<br>
4 5 2 6 5<br>
设 f[i][j] 表示走到了第 i 行第 j 列的最大值。<br>
正常 DP：<br>
f[i][j] = max(f[i – 1][j], f[i – 1][j – 1]) + a[i][j]</p>
<p>搜索：</p>
<pre><code>int dp(int i, int j)
{
if (i == 0) return 0;
    return a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
}
</code></pre>
<p>这样有很多状态其实会重复计算。<br>
对于计算过的 dp(i, j)，我们用 f[i][j] 来存。<br>
f 初始化为 -1<br>
记忆化搜索：</p>
<pre><code>int dp(int i, int j){
    if (i == 0) return 0;
    if (f[i][j] &gt;= 0) return f[i][j];
    f[i][j] = a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
    return f[i][j];
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/903/">acwing901</a><br>
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=310;
int h[N][N];
int f[N][N];
int n,m;
int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};

int dp(int x,int y)
{
    if(f[x][y]!=-1)
        return f[x][y];
    
    f[x][y]=1;
    for(int i=0;i&lt;4;i++)
    {
        int a=x+dx[i],b=y+dy[i];
        if(a&gt;=1 &amp;&amp; a&lt;=n &amp;&amp; b&gt;=1 &amp;&amp; b&lt;=m &amp;&amp; h[x][y]&gt;h[a][b])
            f[x][y]=max(f[x][y],dp(a,b)+1);
    }
    return f[x][y];
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf(&quot;%d&quot;,&amp;h[i][j]);
    memset(f,-1,sizeof f);
    
    int res=0;    
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            res=max(res,dp(i,j));
    printf(&quot;%d\n&quot;,res);
    return 0;
}
</code></pre>
<h4 id="线性模型">线性模型</h4>
<p>这里的线性指的是状态的排布是呈线性的。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_004ef4346c-3.png" alt="3.png" loading="lazy"></p>
<p>最长上升子序列问题。<br>
f[i] 表示以 a[i] 结尾的最长上升子序列问题。<br>
计算 f[i] 的时候，只需要去考虑 f[1], f[2], …, f[i-1] 看是否能够转移即可。<br>
f[i] = max{ f[j] + 1 | 1≤j&lt;i, a[j]&lt;a[i] }<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_ce5ad9da6c-5.png" alt="5.png" loading="lazy"><br>
贪心思想，数越小形成的最长上升子序列长度可能越大。</p>
<pre><code>#include&lt;cstdio&gt;//最长上升子序列，优化算法，时间复杂度O(nlogn)
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
int d[maxn];//d[]表示从最长上升序列的元素
int a[maxn];

int main()
{
    int n;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
    int len=1;
    d[1]=a[1];
    for(int i=2;i&lt;=n;i++)
	{
		if(a[i] &gt; d[len])
            d[++len]=a[i];
        else//a[i]覆盖d[]中第一个大于a[i]的数 
        	*lower_bound(d+1,d+len+1,a[i])=a[i];
    }
    printf(&quot;%d\n&quot;,len);
    return 0;
}
</code></pre>
<p>如果题目要求严格递增，则必须用lower_bound，因为要替换掉相同的元素而不是增长序列。<br>
如果题目要求最长不下降子序列，则必须用 upper_bound。</p>
<p><a href="https://vjudge.net/problem/POJ-3486">poj3486</a><br>
你想保证 n 年中你都有一台电脑，一开始你有一台。<br>
如果你在第 y (1≤y≤n) 年购买了一台电脑，那么你需要花费 c的代价。<br>
如果你这台电脑一直用到了第 z 年，在第 z 年又买了一台新的，您需要在您拥有该计算机的每一年中支付维护成本m（y，z）<br>
给定 n，c，数组 m。求最小花费</p>
<p>首先划分阶段。<br>
每一年可以划分为一个阶段。<br>
f[i] 表示直到第 i 年f[0], f[1],…,f[i-1]你手里都有一台电脑的最小花费。<br>
f[i] 需要从 转移过来。<br>
如何转移？<br>
枚举上一次买电脑是哪一年</p>
<p>假设上一次买电脑是第 j 年。<br>
那么1~j-1年就是一个子问题，我们已经算出了 f[j-1] 是满足<br>
这个子问题的最优解，后面我们就不用考虑前 j-1年的情况，<br>
且它也不会影响我们后面的决策。<br>
第 j 年到第 i 年的维修费用是 m(j, i)，花费是 c<br>
因此可以用 f[j-1]+m(j,i)+c 来更新 f[i]<br>
f[i] = min{ f[j-1]+m(j,i) + c | 1≤j≤i }</p>
<p>边界条件：<br>
f[0] = 0<br>
f[1], f[2], …, f[n] 一开始都应该初始化为 +∞<br>
<a href="https://paste.ubuntu.com/p/R4NjkRS6NT/">code</a></p>
<p><a href="https://www.acwing.com/problem/content/280/">acwing278</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_be96b3666c-4.png" alt="4.png" loading="lazy"></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">hdu1003</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_d1d214a06c-6.png" alt="6.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=100005;
int a[maxn],dp[maxn];//dp[i]表示从start开始到第i个元素的最大子段和 
int main()
{
	int t,n,cas=0;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);//也可以省略原数组，直接用dp[] 
		int l=1,r=1;//记录区间
		int start=1;//记录起点
		dp[1]=a[1];
		
		int ans=dp[1];
		for(int i=2;i&lt;=n;i++)
		{
            if(dp[i-1]&gt;=0)//dp[i-1]大于等于0，则累加，否则重新开始 
                dp[i]=dp[i-1]+a[i];
            else
            {
            	dp[i]=a[i];
            	start=i;//重新开始
			}	
            if(dp[i]&gt;ans)//更新最值
            {
            	ans=dp[i];
				l=start;
         	    r=i;
            }
		}
		if(cas)
			printf(&quot;\n&quot;);
		printf(&quot;Case %d:\n&quot;,++cas);
		printf(&quot;%d %d %d\n&quot;,ans,l,r);
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2479">poj2479</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_d98686626c-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_dc09d59c6c-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_f81ff4286c-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_fbc358906c-10.png" alt="10.png" loading="lazy"><br>
因为我们会从左到右枚举每一个lt[i],当然更新一遍lt[i]也没有错。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50010;
const int inf=0x3f3f3f3f;
int lt[maxn],rt[maxn];//lt[i]表示从左端开始，以i结尾的子段和最大值 
int a[maxn];
 
int main()
{
	int t,n;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);
		lt[1]=a[1];
		for(int i=2;i&lt;=n;i++)//从左向右 
			lt[i]=max(a[i],lt[i-1]+a[i]);
		rt[n]=a[n];
		for(int i=n-1;i&gt;=1;i--)//从右向左
			rt[i]=max(a[i],rt[i+1]+a[i]); 
		for(int i=n-1;i&gt;=1;i--)//更新为从右端开始n..i个元素之中最大连续子段和 
			rt[i]=max(rt[i+1],rt[i]);
		int ans=-inf;
		for(int i=2;i&lt;=n;i++)
			ans=max(ans,lt[i-1]+rt[i]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2250">poj2250</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_5f95e4ce6c-11.png" alt="11.png" loading="lazy"><br>
<a href="https://paste.ubuntu.com/p/sqtP3jt5kc/">code</a></p>
<p><a href="https://www.acwing.com/problem/content/description/1020/">acwing1018</a><br>
用f[i][j]表示当前在从（1,1）第i行第j列的最小费用；<br>
我们的状态转移方程就是：f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j]。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=109;
int n;
int g[N][N];
int f[N][N];

int main()
{
    memset(f, 0x3f ,sizeof f);

    scanf(&quot;%d&quot;, &amp;n);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            scanf(&quot;%d&quot;,&amp;g[i][j]);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)        
            if(i==1 &amp;&amp; j==1)
                f[i][j]=g[i][j];
            else 
            {
                if(i&gt;1)
                    f[i][j]=min(f[i][j],f[i-1][j]+g[i][j]);
                if(j&gt;1)
                    f[i][j]=min(f[i][j],f[i][j-1]+g[i][j]);
            }

    printf(&quot;%d\n&quot;, f[n][n]);
    
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1029/">acwing1027</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/15/9969_e5c124707e-19.PNG" alt="19.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=13;
int n;
int g[N][N];
int f[N][N][N*2];

int main()
{
    cin&gt;&gt;n;
    int a,b,c;
    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c &amp;&amp; a)
        g[a][b]=c;

    for(int i1=1;i1&lt;=n;i1++)
        for(int i2=1;i2&lt;=n;i2++)
            for(int k=2;k&lt;=2*n;k++)
            {
                int j1=k-i1,j2=k-i2;
                int &amp;x=f[i1][i2][k];
                int t=g[i1][j1]+g[i2][j2];
                if(j1&gt;=1 &amp;&amp; j1&lt;=n &amp;&amp; j2&gt;=1 &amp;&amp; j2&lt;=n)
                {
                    if(i1 == i2)    
                        t/=2;
                    x=max(x,f[i1-1][i2][k-1]);
                    x=max(x,f[i1][i2-1][k-1]);
                    x=max(x,f[i1][i2][k-1]);
                    x=max(x,f[i1-1][i2-1][k-1]);
                    x+=t;
                }
            }
    cout&lt;&lt;f[n][n][n*2]&lt;&lt;endl;
    return 0;
    
}
</code></pre>
<p>如果用两次的动规取每次的最大值，其实是贪心的思想，因为分别跑时并没有考虑到另一次的路程。所以这种只是具体过程中用的是动态规划而已（下面的简单例子即可说明为何不行）：<br>
0 3 5<br>
2 6 0<br>
0 4 0<br>
第一次求最大值的话，是0-&gt;3-&gt;6-&gt;4-&gt;0<br>
第二次求最大值的话，是0-&gt;3（已经被去掉了，为了方便看）-&gt;5-&gt;0-&gt;0<br>
合起来是18，而实际答案应该是20：<br>
第一次：0-&gt;3-&gt;5-&gt;0-&gt;0<br>
第二次：0-&gt;2-&gt;6-&gt;4-&gt;0<br>
所以这题其实是经典的思维DP，我们用数组dp[i][j][k][l]表示第一次走到(i,j)时和第二次走到(k,l)时的最大值能取到多少。</p>
<p><a href="https://www.acwing.com/problem/content/277/">acwing275</a></p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=55;
int n,m;
int g[N][N];
int f[N&lt;&lt;1][N][N];

int main()
{
    cin&gt;&gt;m&gt;&gt;n;
    for(int i=1;i&lt;=m;i++)   
        for(int j=1;j&lt;=n;j++)
            cin&gt;&gt;g[i][j];

    for(int k=1;k&lt;=n+m;k++)
        for(int i=1;i&lt;=m;i++)   
            for(int j=1;j&lt;=m;j++)
            {
                int a=k-i,b=k-j;
                if(a&gt;=1 &amp;&amp; a&lt;=n &amp;&amp; b&gt;=1 &amp;&amp; b&lt;=n)
                {
                    int t=g[i][a]+g[j][b];
                    if(i == j) t/=2;
                    f[k][i][j]=max(f[k][i][j],f[k-1][i-1][j]);
                    f[k][i][j]=max(f[k][i][j],f[k-1][i][j-1]);
                    f[k][i][j]=max(f[k][i][j],f[k-1][i][j]);
                    f[k][i][j]=max(f[k][i][j],f[k-1][i-1][j-1]);
                    f[k][i][j]+=t;
                }
            }
    cout&lt;&lt;f[n+m][m][m]&lt;&lt;endl;
    return 0;

}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1019/">acwing1019</a><br>
确定滑行方向后就转化为了LIS问题,原问题相当于正向和反向以ai为结尾的最长上升子序列长度，<br>
分别正向和反向各进行一次LIS，取得最大值即可。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=110;
int q[N];
int f[N];

int main()
{
    int t;
    cin&gt;&gt;t;
    while(t--)
    {
        int n;
        cin&gt;&gt;n;
        for(int i=1;i&lt;=n;i++)
            cin&gt;&gt;q[i];
        int res=0;
        for(int i=1;i&lt;=n;i++)
        {
            f[i]=1;
            for(int j=1;j&lt;=i;j++)
                if(q[j]&lt;q[i])
                    f[i]=max(f[i],f[j]+1);
            res=max(res,f[i]);
        }

        for(int i=n;i;i--)
        {
            f[i]=1;
            for(int j=n;j&gt;i;j--)
                if(q[j]&lt;q[i])
                    f[i]=max(f[i],f[j]+1);
            res=max(res,f[i]);
        }
        cout&lt;&lt;res&lt;&lt;endl;
    }
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=110;
int d[N];
int a[N];
int n;

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;a[i]);

        int res=0;
        int len=1;
        d[1]=a[1];
        for(int i=2;i&lt;=n;i++)
        {
            if(a[i] &gt; d[len])
                d[++len]=a[i];
            else 
                *lower_bound(d+1,d+len+1,a[i])=a[i];
        }
    
        res=max(res,len);
        
        len=1;
        d[1]=a[n];
        for(int i=n-1;i;i--)
        {
            if(a[i] &gt; d[len])
                d[++len]=a[i];
            else 
                *lower_bound(d+1,d+len+1,a[i])=a[i];
        }
        
        res=max(res,len);
        
        cout&lt;&lt;res&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1016/">acwing1014</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/16/9969_ede6e4ee7f-33.PNG" alt="33.PNG" loading="lazy"></p>
<p><a href="https://www.acwing.com/problem/content/1014/">acwing1012</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/16/9969_1aa680567f-35.PNG" alt="35.PNG" loading="lazy"></p>
<ul>
<li>航道交叉也就是a1&gt;=a2&amp;b1&lt;=b2(其中a，b表示两岸)</li>
<li>将一岸升序排序，另一岸找最长上升子序列</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define x first
#define y second
typedef pair&lt;int,int&gt; PII;
const int N=5010;
PII a[N];
int f[N];
int n;

int main()
{
	cin&gt;&gt;n;
	
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
	
	sort(a+1,a+n+1);
	
	int res=0;
	for(int i=1;i&lt;=n;i++)
	{
		f[i]=1;
		for(int j=1;j&lt;i;j++)
			if(a[j].y &lt; a[i].y)
				f[i]=max(f[i],f[j]+1);
		res=max(res,f[i]);	
	}
	
	cout&lt;&lt;res&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define x first
#define y second
typedef pair&lt;int,int&gt; PII;
const int N=5010;
PII a[N];
int d[N];
int n;

int main()
{
	cin&gt;&gt;n;
	
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
	
	sort(a+1,a+n+1);
	
	int len=1;
	d[1]=a[1].y;
	for(int i=2;i&lt;=n;i++)
	{
		if(a[i].y &gt; d[len])
			d[++len]=a[i].y;
		else 
			*lower_bound(d+1,d+len+1,a[i].y)=a[i].y;
	}
	
	cout&lt;&lt;len&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/description/1018/">最大上升子序列和 </a>状态表示：<br>
f[i] 表示前i个数中的最大子序列和<br>
状态转移：<br>
对于每一个小于a[i]的a[j] (j &lt; i) f[i] = max(f[i], f[j] + a[i])</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int N=1010;
int q[N];
int f[N];

int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;q[i];
    
    int res=0;
    for(int i=0;i&lt;n;i++)
    {
        f[i]=q[i];
        for(int j=0;j&lt;i;j++)
            if(q[j]&lt;q[i])
                f[i]=max(f[i],f[j]+q[i]);
        res=max(res,f[i]);
    }
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/1012/">acwing1010</a><br>
1、对于问一直接用O（n*logn）的方法求最长不升子序列即可。</p>
<p>2、对于问二求整个数列的最长上升子序列即可。证明如下：</p>
<p>（1）假设打导弹的方法是这样的：取任意一个导弹，从这个导弹开始将能打的导弹全部打完。而这些导弹全部记为为同一组，再在没打下来的导弹中任选一个重复上述步骤，直到打完所有导弹。</p>
<p>（2）假设我们得到了最小划分的K组导弹，从第a(1&lt;=a&lt;=K)组导弹中任取一个导弹，必定可以从a+1组中找到一个导弹的高度比这个导弹高（因为假如找不到，那么它就是比a+1组中任意一个导更高，在打第a组时应该会把a+1组所有导弹一起打下而不是另归为第a+1组），同样从a+1组到a+2组也是如此。那么就可以从前往后在每一组导弹中找一个更高的连起来，连成一条上升子序列，其长度即为K;</p>
<p>（3）设最长上升子序列长度为P，则有K&lt;=P;又因为最长上升子序列中任意两个不在同一组内(否则不满足单调不升)，则有<br>
P&gt;=K，所以K=P。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;sstream&gt;
using namespace std;
const int N=100010;
int a[N];
int d1[N],d2[N];
int n;

int main()
{
	string s;
	getline(cin,s);
	stringstream ss(s);
	
	while(ss&gt;&gt;a[n]) n++;
	
	int len1=1,len2=1;
	d1[1]=d2[1]=a[0];
	
	for(int i=1;i&lt;n;i++)
	{
		if(a[i] &lt;= d1[len1]) d1[++len1]=a[i];
		else *upper_bound(d1+1,d1+len1+1,a[i],greater&lt;int&gt;())=a[i];
		
		if(a[i] &gt; d2[len2]) d2[++len2]=a[i];
		else *lower_bound(d2+1,d2+len2+1,a[i])=a[i];
	}
	
	cout&lt;&lt;len1&lt;&lt;endl&lt;&lt;len2&lt;&lt;endl;
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1140">P1140</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/28/9969_3c7d486889-48.PNG" alt="48.PNG" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/28/9969_4d55767489-49.PNG" alt="49.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=110,INF=0x3f3f3f3f;
int w[5][5]={
    {5,-1,-2,-1,-3},
    {-1,5,-3,-2,-4},
    {-2,-3,5,-2,-2},
    {-1,-2,-2,5,-1},
    {-3,-4,-2,-1,0}
};
int f[N][N];
char sa[N],sb[N];
int a[N],b[N];
int n,m;

int get(char c)
{
	if(c == 'A') return 0;
	else if(c == 'C') return 1;
	else if(c == 'G') return 2;
	else return 3;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;sa+1;
	cin&gt;&gt;m&gt;&gt;sb+1;
	
	for(int i=1;i&lt;=n;i++)
		a[i]=get(sa[i]);
	for(int i=1;i&lt;=m;i++)
		b[i]=get(sb[i]);
		
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			f[i][j]=-INF;
	f[0][0]=0;
	for(int i=1;i&lt;=n;i++)
		f[i][0]=f[i-1][0]+w[a[i]][4];
	for(int i=1;i&lt;=m;i++)
		f[0][i]=f[0][i-1]+w[4][b[i]];
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
		{
			f[i][j]=max(f[i][j],f[i][j-1]+w[4][b[j]]);
			f[i][j]=max(f[i][j],f[i-1][j]+w[a[i]][4]);
			f[i][j]=max(f[i][j],f[i-1][j-1]+w[a[i]][b[j]]);
		}
	
	printf(&quot;%d\n&quot;,f[n][m]);
		
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1508">P1508</a><br>
【题目分析】<br>
一个人从最后一行中间那个点的下方开始每一次都吃正前方，左前方和右前方的食物,求一直吃到第一行能够吃到的最多能量是多少</p>
<p>首先李大水牛一开始在最后一行的中间的下方故： 我么需要的答案为最后一行中间三个的最大值（及 max(dp[n][m/2+1],max(dp[n][m/2],dp[n][m/2+2])); ）</p>
<p>其次是递归公式 这是一个二维dp，dp公式是该值是他的左上、正上、右上的dp结果的最大值+自身（及 dp[i][j]=max(max(dp[i-1][j],dp[i-1][j+1]),dp[i-1][j-1])+dp[i][j]; ）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=1010;
int f[N][N];
int a[N][N];
int n,m;

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			cin&gt;&gt;a[i][j];
			
	int sx=n+1,sy=m/2+1;
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			f[i][j]=max(f[i-1][j],max(f[i-1][j-1],f[i-1][j+1]))+a[i][j];
	
	cout&lt;&lt;max(f[sx-1][sy],max(f[sx-1][sy-1],f[sx-1][sy+1]));
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1280">P1280</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/04/28/9969_925872c289-47.PNG" alt="47.PNG" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int N=10010;
int f[N];
vector&lt;int&gt; v[N];
int n,k;

int main()
{
	cin&gt;&gt;n&gt;&gt;k;
	
	for(int i=0;i&lt;k;i++)
	{
		int s,t;
		cin&gt;&gt;s&gt;&gt;t;
		v[s].push_back(t);
	}
	
	for(int i=n;i;i--)
	{
		if(v[i].size())
			for(int j=0;j&lt;v[i].size();j++)
				f[i]=max(f[i],f[i+v[i][j]]);
		else 
			f[i]=f[i+1]+1;
	}
	
	printf(&quot;%d&quot;,f[1]);
	
	return 0;
}
</code></pre>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/">
                                <h3 class="post-title">
                                    字符串复习（一）
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%86%B3%E7%AD%96%E9%97%AE%E9%A2%98">多阶段决策问题</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">动态规划的基本概念</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%A7%E8%B4%A8">动态规划的性质</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">动态规划设计方法</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F">动态规划设计方法的一般模式</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2">动态规划与记忆化搜索</a></li>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B">线性模型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>