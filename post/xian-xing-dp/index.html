<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    线性dp | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1585901820726">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1585901820726" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            线性dp
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-03-26</time>
                            
                                <a href="https://caifxh.github.io/tag/hLQFdtGuD/" class="post-tag i-tag
                            i-tag-info">
                            #DP
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_063efe606b-34.png" alt="34.png" loading="lazy"></figure>
<h4 id="多阶段决策问题">多阶段决策问题</h4>
<p>有一类活动的过程，可以分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效。<br>
当然，各个阶段的决策的选取不是任意确定的，它依赖于当前的状态，又会影响以后的发展。</p>
<p>当各个阶段决策决定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。<br>
这种把一个问题看做是一个前后关联、具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为<code>多阶段决策问题</code>。</p>
<p>各个阶段采取的决策， 一般来说是与阶段有关的。<br>
决策依赖于当前的状态，又随即引起状态的转移。<br>
一个决策序列就是在变化的状态中产生出来的。<br>
称这种解决多阶段决策最优化的过程为<code>动态规划（DP）</code>。</p>
<p>动态规划（Dynamic Programming）程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。<br>
由于各种问题的性质不同，确定最优解的条件也互不相同，因此不存在一种万能的动态规划算法可以解决各类最优化问题。</p>
<p>常见的 DP 类型有：<br>
线性模型<br>
区间 DP<br>
背包 DP<br>
数位 DP<br>
状态压缩 DP<br>
树状 DP</p>
<p>常见的 DP 优化方法有：<br>
滚动数组优化<br>
矩阵乘法优化<br>
斜率优化<br>
四边形不等式优化<br>
决策单调性优化<br>
数据结构优化</p>
<h4 id="动态规划的基本概念">动态规划的基本概念</h4>
<p>1.阶段和阶段变量<br>
将问题的全过程恰当地分成若干个相互联系的阶段。<br>
阶段的划分一般根据时间和空间的自然特征去划分。<br>
阶段的划分要便于把问题转化成多阶段决策问题。</p>
<p>2.状态和状态变量<br>
通常一个阶段包含若干状态。<br>
状态可由变量来描述。</p>
<p>3.决策、决策变量和决策允许集合。<br>
在对问题的处理中作出的每种选择性的行动就是决策。<br>
即从该阶段的每一个状态出发， 通过一次选择性的行动转移至下一阶段的相应状态。<br>
一个实际问题可能需要有多次决策和多个决策点，在每一个阶段的每一个状态中都需要有一次决策，<br>
决策也可以用变量来描述，称这种变量为决策变量。<br>
在实际问题中，决策变量的取值往往限制在某一个范围之内，此范围就称为决策允许集合。</p>
<p>4.策略和最优策略<br>
所有阶段一次排列构成问题的全过程。<br>
全过程中各阶段决策变量所组成的有序总体称为策略。<br>
在实际问题中，从决策允许集合中找出最优效果的策略称为最优策略。</p>
<p>5.状态转移方程<br>
前一阶段的终点就是后一阶段的起点，对前一阶段的状态做出某种决策，产生后一种阶段的状态，这种关系描述了从 i<br>
阶段到 i+1 阶段状态的演变规律，称为状态转移方程。</p>
<p>从 n 个数中取出 k 个数，使得他们的和最大。<br>
f[i][j] 表示现在考虑到了第 i 个数，已经选出了 j 个数。<br>
阶段：枚举到第i个数<br>
状态：已经选出了 j 个数。<br>
决策：第i个数选或不选<br>
策略：和最大<br>
状态转移方程：f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[i])</p>
<h4 id="动态规划的性质">动态规划的性质</h4>
<p>什么样的“多阶段决策问题”才可以用动态规划的方法来求解呢？<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_a514107a6b-1.png" alt="1.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/22/9969_cda6e35a6b-2.png" alt="2.png" loading="lazy"><br>
对于不能划分阶段的题，不能用动态规划来解。<br>
不符合最优化原理，不能用动态规划来解。<br>
不具备无后效性原则的，不能用动态规划来解。<br>
误用动态规划解决问题会得到错误的结果</p>
<h4 id="动态规划设计方法">动态规划设计方法</h4>
<p>正推：从初始状态开始，通过对中间阶段的决策的选择，达到结束状态。我们也称递推。<br>
倒推：从结束状态开始，通过对中间阶段的决策的选择，达到开始状态。我们可以把这种方法看成记忆化搜索。</p>
<h4 id="动态规划设计方法的一般模式">动态规划设计方法的一般模式</h4>
<ol>
<li>划分阶段</li>
<li>确定状态和状态变量</li>
<li>确定决策并写出状态转移方程</li>
<li>寻找边界条件</li>
<li>设计并实现程序</li>
</ol>
<h4 id="动态规划与记忆化搜索">动态规划与记忆化搜索</h4>
<p>实现一个函数，用“搜索”的方法实现 DP 的更新。<br>
通常用于解决转移顺序不方便人为确定的 DP。<br>
数字三角形<br>
5<br>
7<br>
3 8<br>
8 1 0<br>
2 7 4 4<br>
4 5 2 6 5<br>
设 f[i][j] 表示走到了第 i 行第 j 列的最大值。<br>
正常 DP：<br>
f[i][j] = max(f[i – 1][j], f[i – 1][j – 1]) + a[i][j]</p>
<p>搜索：</p>
<pre><code>int dp(int i, int j)
{
if (i == 0) return 0;
    return a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
}
</code></pre>
<p>这样有很多状态其实会重复计算。<br>
对于计算过的 dp(i, j)，我们用 f[i][j] 来存。<br>
f 初始化为 -1<br>
记忆化搜索：</p>
<pre><code>int dp(int i, int j){
    if (i == 0) return 0;
    if (f[i][j] &gt;= 0) return f[i][j];
    f[i][j] = a[i][j] + max(dp(i - 1, j), dp(i - 1, j - 1));
    return f[i][j];
}
</code></pre>
<p><a href="https://www.acwing.com/problem/content/903/">acwing901</a><br>
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=310;
int h[N][N];
int f[N][N];
int n,m;
int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};

int dp(int x,int y)
{
    if(f[x][y]!=-1)
        return f[x][y];
    
    f[x][y]=1;
    for(int i=0;i&lt;4;i++)
    {
        int a=x+dx[i],b=y+dy[i];
        if(a&gt;=1 &amp;&amp; a&lt;=n &amp;&amp; b&gt;=1 &amp;&amp; b&lt;=m &amp;&amp; h[x][y]&gt;h[a][b])
            f[x][y]=max(f[x][y],dp(a,b)+1);
    }
    return f[x][y];
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf(&quot;%d&quot;,&amp;h[i][j]);
    memset(f,-1,sizeof f);
    
    int res=0;    
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            res=max(res,dp(i,j));
    printf(&quot;%d\n&quot;,res);
    return 0;
}
</code></pre>
<h4 id="线性模型">线性模型</h4>
<p>这里的线性指的是状态的排布是呈线性的。<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_004ef4346c-3.png" alt="3.png" loading="lazy"></p>
<p>最长上升子序列问题。<br>
f[i] 表示以 a[i] 结尾的最长上升子序列问题。<br>
计算 f[i] 的时候，只需要去考虑 f[1], f[2], …, f[i-1] 看是否能够转移即可。<br>
f[i] = max{ f[j] + 1 | 1≤j&lt;i, a[j]&lt;a[i] }<br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_ce5ad9da6c-5.png" alt="5.png" loading="lazy"><br>
贪心思想，数越小形成的最长上升子序列长度可能越大。</p>
<pre><code>#include&lt;cstdio&gt;//最长上升子序列，优化算法，时间复杂度O(nlogn)
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
int d[maxn];//d[]表示从最长上升序列的元素
int a[maxn];

int main()
{
    int n;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
    int len=1;
    d[1]=a[1];
    for(int i=2;i&lt;=n;i++)
	{
		if(a[i] &gt; d[len])
            d[++len]=a[i];
        else//a[i]覆盖d[]中第一个大于a[i]的数 
        	*lower_bound(d+1,d+len+1,a[i])=a[i];
    }
    printf(&quot;%d\n&quot;,len);
    return 0;
}
</code></pre>
<p>如果题目要求严格递增，则必须用lower_bound，因为要替换掉相同的元素而不是增长序列。<br>
如果题目要求最长不下降子序列，则必须用 upper_bound。</p>
<p><a href="https://vjudge.net/problem/POJ-3486">poj3486</a><br>
你想保证 n 年中你都有一台电脑，一开始你有一台。<br>
如果你在第 y (1≤y≤n) 年购买了一台电脑，那么你需要花费 c的代价。<br>
如果你这台电脑一直用到了第 z 年，在第 z 年又买了一台新的，您需要在您拥有该计算机的每一年中支付维护成本m（y，z）<br>
给定 n，c，数组 m。求最小花费</p>
<p>首先划分阶段。<br>
每一年可以划分为一个阶段。<br>
f[i] 表示直到第 i 年f[0], f[1],…,f[i-1]你手里都有一台电脑的最小花费。<br>
f[i] 需要从 转移过来。<br>
如何转移？<br>
枚举上一次买电脑是哪一年</p>
<p>假设上一次买电脑是第 j 年。<br>
那么1~j-1年就是一个子问题，我们已经算出了 f[j-1] 是满足<br>
这个子问题的最优解，后面我们就不用考虑前 j-1年的情况，<br>
且它也不会影响我们后面的决策。<br>
第 j 年到第 i 年的维修费用是 m(j, i)，花费是 c<br>
因此可以用 f[j-1]+m(j,i)+c 来更新 f[i]<br>
f[i] = min{ f[j-1]+m(j,i) + c | 1≤j≤i }</p>
<p>边界条件：<br>
f[0] = 0<br>
f[1], f[2], …, f[n] 一开始都应该初始化为 +∞<br>
<a href="https://paste.ubuntu.com/p/R4NjkRS6NT/">code</a></p>
<p><a href="https://www.acwing.com/problem/content/280/">acwing278</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_be96b3666c-4.png" alt="4.png" loading="lazy"></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">hdu1003</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_d1d214a06c-6.png" alt="6.png" loading="lazy"></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=100005;
int a[maxn],dp[maxn];//dp[i]表示从start开始到第i个元素的最大子段和 
int main()
{
	int t,n,cas=0;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);//也可以省略原数组，直接用dp[] 
		int l=1,r=1;//记录区间
		int start=1;//记录起点
		dp[1]=a[1];
		
		int ans=dp[1];
		for(int i=2;i&lt;=n;i++)
		{
            if(dp[i-1]&gt;=0)//dp[i-1]大于等于0，则累加，否则重新开始 
                dp[i]=dp[i-1]+a[i];
            else
            {
            	dp[i]=a[i];
            	start=i;//重新开始
			}	
            if(dp[i]&gt;ans)//更新最值
            {
            	ans=dp[i];
				l=start;
         	    r=i;
            }
		}
		if(cas)
			printf(&quot;\n&quot;);
		printf(&quot;Case %d:\n&quot;,++cas);
		printf(&quot;%d %d %d\n&quot;,ans,l,r);
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2479">poj2479</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_d98686626c-7.png" alt="7.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_dc09d59c6c-8.png" alt="8.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_f81ff4286c-9.png" alt="9.png" loading="lazy"><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_fbc358906c-10.png" alt="10.png" loading="lazy"><br>
因为我们会从左到右枚举每一个lt[i],当然更新一遍lt[i]也没有错。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50010;
const int inf=0x3f3f3f3f;
int lt[maxn],rt[maxn];//lt[i]表示从左端开始，以i结尾的子段和最大值 
int a[maxn];
 
int main()
{
	int t,n;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);
		lt[1]=a[1];
		for(int i=2;i&lt;=n;i++)//从左向右 
			lt[i]=max(a[i],lt[i-1]+a[i]);
		rt[n]=a[n];
		for(int i=n-1;i&gt;=1;i--)//从右向左
			rt[i]=max(a[i],rt[i+1]+a[i]); 
		for(int i=n-1;i&gt;=1;i--)//更新为从右端开始n..i个元素之中最大连续子段和 
			rt[i]=max(rt[i+1],rt[i]);
		int ans=-inf;
		for(int i=2;i&lt;=n;i++)
			ans=max(ans,lt[i-1]+rt[i]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p><a href="https://vjudge.net/problem/POJ-2250">poj2250</a><br>
<img src="https://cdn.acwing.com/media/article/image/2020/03/23/9969_5f95e4ce6c-11.png" alt="11.png" loading="lazy"><br>
<a href="https://paste.ubuntu.com/p/sqtP3jt5kc/">code</a></p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/">
                                <h3 class="post-title">
                                    字符串复习（一）
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%86%B3%E7%AD%96%E9%97%AE%E9%A2%98">多阶段决策问题</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">动态规划的基本概念</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%A7%E8%B4%A8">动态规划的性质</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">动态规划设计方法</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F">动态规划设计方法的一般模式</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2">动态规划与记忆化搜索</a></li>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B">线性模型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>