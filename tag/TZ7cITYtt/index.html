<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    其他算法 | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1586491016728">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1586491016728" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        其他算法</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/chi-qu-fa/">
                        尺取法
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-10</time>
                    
                        <a href="https://caifxh.github.io/tag/TZ7cITYtt/" class="post-tag i-tag
                            i-tag-primary">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            尺取法
尺取法（又称为：双指针、twopointers），是算法竞赛中一个常用的优化技巧，用来解决序列的区间问题，操作简单、容易编程。
如果区间是单调的，也常常用二分法来求解，所以很多问题用尺取法和二分法都行。
尺取法：顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。之所以需要掌握这个技巧，是因为尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以尺取法是一种高效的枚举区间的方法，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案。
使用尺取法时应清楚以下四点：
1、  什么情况下能使用尺取法?
2、何时推进区间的端点？
3、如何推进区间的端点？
4、何时结束区间的枚举？
尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。
尺取法的概念
什么是尺取法？为什么尺取法能优化呢？
考虑下面的应用背景：
（1）给定一个序列。有时候需要它是有序的，先排序。
（2）问题和序列的区间有关，且需要操作2个变量，可以用两个下标（指针）i、j扫描区间。
对于上面的应用，一般的做法，是用i、j分别扫描区间，有两重循环，复杂度O(n2)。以反向扫描（即i、j方向相反，后文有解释）为例，代码是：
for(int i = 0; i &amp;lt; n; i++)           //i从头扫到尾
	for(int j = n-1; j &amp;gt;= 0; j--){   //j从尾扫到头
        ......
    }

下面用尺取法来优化上面的算法。
实际上，尺取法就是把两重循环变成了一个循环，在这个循环中一起处理i和j。复杂度也就从O(n2n^2n2)变成了O(n)。仍以上面的反向扫描为例，代码是：
//用while实现：
int i = 0, j = n - 1;
while (i &amp;lt; j) {      //i和j在中间相遇。这样做还能防止i、j越界
        ......       //满足题意的操作
        i++;         //i从头扫到尾
        j--;         //j从尾扫到头
}
//用for实现：
for (int i = 0, j = n - 1; i &amp;lt; j; i++, j--) {
    ......
}

在尺取法中，这两个指针i、j，有两种扫描方向：
（a）反向扫描。i、j方向相反，i从头到尾，j从尾到头，在中间相会。
（b）同向扫描。i、j方向相同，都从头到尾，可以让j跑在i前面。
把同向扫描的i、j指针称为“快慢指针”，把反向扫描的i、j指针称为“左右指针”，更加形象。快慢指针在序列上产生了一个大小可变的“滑动窗口”，有灵活的应用
反向扫描
1.找指定和的整数对
这个问题是尺取法最经典，也最简单直接的应用。
输入n ( n≤100,000)个整数，放在数组a[]中。找出其中的两个数，它们之和等于整数m(假定肯定有解)。题中所有整数都是int型。
样例输入：
21 4 5 6 13 65 32 9 23
28
样例输出：
5 23
说明：样例输入的第一行是数组a[]，第2行是m = 28。样例输出5和23，相加得28。
为了说明尺取法的优势，下面给出四种方法：
（1）用两重循环暴力搜，枚举所有的取数方法，复杂度O(n2)，超时。暴力法不需要排序。
（2）二分法。首先对数组从小到大排序，复杂度O(nlogn)；然后，从头到尾处理数组中的每个元素a[i]，在大于a[i]的数中二分查找是否存在一个等于 m - a[i]的数，复杂度也是O(nlogn)。两部分相加，总复杂度仍然是O(nlogn)。
（3）Hash。分配一个hash空间s，把n个数放进去。逐个检查a[]中的n个数，例如a[i]，检查m - a[i]在s中是否有值，如果有，那么存在一个答案。复杂度是O(n)。
hash方法很快，但是需要一个额外的、可能很大的hash空间。
（4）尺取法。这是标准解法。首先对数组从小到大排序；然后，设置两个变量i和j，分别指向头和尾，i初值是0，j初值是n-1，然后让i和j逐渐向中间移动，检查a[i]+a[j]，如果大于m，就让j减1，如果小于m，就让i加1，直至a[i]+a[j] = m。排序复杂度O(nlogn)，检查的复杂度O(n)，合起来总复杂度O(nlogn)。
void find_sum(int a[], int n, int m){ 
     sort(a, a + n - 1);      //先排序，复杂度O(nlogn)
     int i = 0, j = n - 1;    //i指向头，j指向尾
     while (i &amp;lt; j){           //复杂度O(n)
		    int sum = a[i] + a[j];
		    if (sum &amp;gt; m)   j--;
		    if (sum &amp;lt; m)   i++;
		    if (sum == m){     
			    cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; a[j] &amp;lt;&amp;lt; endl;  //打印一种情况
                i++;          //可能有多个答案，继续
		    }
	  }
}

判断回文串
2.给一个字符串，判断它是不是回文串。
“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”就是回文串。写一个程序判断读入的字符串是否是“回文”。如果是，输出“yes”，否则输出“no”。
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main(){
    int n;
    cin &amp;gt;&amp;gt; n;                         //n是测试用例个数
    while(n--){
        string s;  cin &amp;gt;&amp;gt; s;          //读一个字符串
        bool ans = true;
        int i = 0, j = s.size() - 1;  //双指针
        while(i &amp;lt; j){ 
            if(s[i] != s[j]){
                ans = false;
                break;
            }
            i++;   j--;               //移动双指针
        }
        if(ans)   cout &amp;lt;&amp;lt; &amp;quot;yes&amp;quot; &amp;lt;&amp;lt; endl;
        else      cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot;  &amp;lt;&amp;lt; endl;
    }
    return 0;
}

允许删除（或插入，本题只考虑删除）最多1个字符，判断是否能构成回文字符串。
设反向扫描双指针为i、j。如果 s[i]和s[j]相同，i++、j–；如果s[i]和s[j]不同，那么，或者删除s[i]，或者删除s[j]，看剩下的字符串是否是回文串即可。
同向扫描
1.寻找区间和
这是用尺取法产生“滑动窗口”的典型例子。
给定一个长度为n的数组a[]和一个数s，在这个数组中找一个区间，使得这个区间之和等于s。输出区间的起点和终点位置。
样例输入：
15
6 1 2 3 4 6 4 2 8 9 10 11 12 13 14
6
样例输出：
0 0
1 3
5 5
6 7
说明：样例输入的第1行是n=15，第2行是数组a[]，第3行是区间和s=6。样例输出，共有4个情况。
题解
指针i和j，i&amp;lt;=j，都从头向尾扫描，判断区间[i,j]的和是否等于s。
如何寻找区间和等于s的区间？如果简单地对i和j做二重循环，复杂度是O(n2n^2n2)。用尺取法，复杂度O(n)，操作步骤是：
（1）初始值i=0、j=0，即开始都指向第一个元素a[0]。定义sum是区间[i, j]的和，初始值sum = a[0]。
（2）如果sum等于s，输出一个解。继续，把sum减掉元素a[i]，并把i往后移动一位。
（3）如果sum大于s，让sum减掉元素a[i]，并把i往后移动一位。
（4）如果sum小于s，把j往后挪一位，并把sum的值加上这个新元素。
在上面的步骤中，有2个关键技巧：
（1）滑动窗口的实现。窗口就是区间[i,j]，随着i和j从头到尾移动，窗口就“滑动”扫描了整个序列，检索了所有的数据。i和j并不是同步增加的，窗口像一只蚯蚓伸缩前进，它的长度是变化的，这个变化，正对应了对区间和的计算。
（2）sum的使用。如何计算区间和？暴力的方法是从a[i]到a[j]累加，但是，这个累加的复杂度是O(n)的，会超时。如果利用sum，每次移动i或j的时候，只需要把sum加或减一次，就得到了区间和，复杂度是O(1)。这是“前缀和”递推思想的应用。
以下是几个经典的使用尺取法的例题，都是从挑战书上引用的。（尺取法通常会需要对某些量进行预处理，以便能在使用时快速地判断。
poj3061
题意：给定一个序列，找出最短的子序列长度，使得其和大于或等于S。


分析：首先，序列都是正数，如果一个区间其和大于等于S了，那么不需要在向后推进右端点了，因为其和也肯定大于等于S但长度更长，所以，当区间和小于S时右端点向右移动，和大于等于S时，左端点向右移动以进一步找到最短的区间，如果右端点移动到区间末尾其和还不大于等于S，结束区间的枚举。
Input：
10 15
5 1 3 5 10 7 4 9 2 8

二分+前缀和：
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int s[N];
int n,m;

bool check(int mid)
{
	for(int i=1;i&amp;lt;=n-mid+1;i++)
		if(s[i+mid-1]-s[i-1] &amp;gt;= m)
			return 1;
	return 0;
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
		
		for(int i=1;i&amp;lt;=n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i]),s[i]+=s[i-1];
			
		if(s[n] &amp;lt; m) 
		{
			cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl;
			continue;
		}
		
		int l=1,r=n;
		while(l&amp;lt;r)
		{
			int mid=l+r&amp;gt;&amp;gt;1;
			if(check(mid))
				r=mid;
			else 
				l=mid+1;
		}
		
		printf(&amp;quot;%d\n&amp;quot;,l);
	}
	return 0;
}

尺取法：
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int a[N];
int n,m;

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
		for(int i=0;i&amp;lt;n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		int ans=n+1;
		int sum=0;
		int l=0,r=0;
		while(1)
		{
			while(r&amp;lt;n &amp;amp;&amp;amp; sum&amp;lt;m)
				sum+=a[r],r++;
			
			if(sum &amp;lt; m) break;
			
			ans=min(ans,r-l);
			sum-=a[l++];//左端点向右移动以进一步找到最短的区间
		}
		
		if(ans == n+1) ans=0;
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

poj3320
题意：一本书有P页，每一页都一个知识点，求去最少的连续页数覆盖所有的知识点。
和上面的题一样的思路，如果一个区间的子区间满足条件，那么在区间推进到该处时，右端点会固定，左端点会向右移动到其子区间，且其子区间会是更短的，只是需要存储所选取的区间的知识点的数量，那么使用map进行映射以快速判断是否所选取的页数是否覆盖了所有的知识点。

当前区间若可行，则需在保证可行的前提下，缩小区间范围，将l指针右移
当前区间若不可行，则需要扩大区间范围，将r指针右移
当r已到末尾且l已经最优时，结束枚举

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;map&amp;gt;
using namespace std;
const int N=1000010;
int a[N],cnt[N];
map&amp;lt;int,int&amp;gt; m;
int tot;
int n;

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		if(!m[a[i]]) m[a[i]]=++tot;
		a[i]=m[a[i]];
	}
	
	int ans=n;
	int l=1,r=1;
	int sum=0;
	
	while(1)
	{
		while(r&amp;lt;=n &amp;amp;&amp;amp; sum&amp;lt;tot)
			if(cnt[a[r++]]++ == 0)
				sum++;
			
		if(sum &amp;lt; tot) break;
		ans=min(ans,r-l);
		if(--cnt[a[l++]] == 0) sum--;
	}
	
	printf(&amp;quot;%d\n&amp;quot;,ans);
	
	return 0;
}

poj2566
题意：给你n个数字，这些数字可正可负，再给你个数字t,求在这个数列中一个连续的子序列，和的绝对值与t相差最小
一般来说，我们必须要保证数列单调性，才能使用尺取法。
预处理出前i个数的前缀和，和编号i一起放入pair中，然而根据前缀和大小进行排序。由于
abs(sum[i]-sum[j]) =  abs(sum[j]-sum[i])
可以忽视数列前缀和的前后关系。此时，sum[r]-sum[l]有单调性。
因此我们可以先比较当前sum[r]-sum[l]与t的差，并更新答案。
如果当前sum[r]-sum[l]&amp;lt;t,说明和还可以更大，r++。
同理，如果sum[r]-sum[l]&amp;gt;t，说明和还可以更小，l++。
如果sum[r]-sum[l]=t，必定是最小答案。

尺取的前提是一个有序的，可判定的序列，由于题目说的是连续序列和的绝对值，也就是说我们只需要知道两个端点
利用前缀和来进行判定，我们来枚举前缀和的两个端点，从而可以找到一个最接近询问值的数，
我们在存前缀和的同时还得把相应的坐标给存上，

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
#define x first
#define y second
typedef pair&amp;lt;int,int&amp;gt; PII;
const int N=100010,INF=0x3f3f3f3f;
PII s[N];
int n,m;
int ans,st,ed;

int main()
{
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m))
	{
		if(!n &amp;amp;&amp;amp; !m) break;
		s[0]=make_pair(0,0);
		for(int i=1;i&amp;lt;=n;i++)
		{
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i].x);
			s[i].y=i;
			s[i].x+=s[i-1].x;
		}
		
		sort(s,s+n+1);
		
		while(m--)
		{
			int t;
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
			int l=0,r=1;
			int mi=INF;
			while(r&amp;lt;=n)                                            
			{
				int val=s[r].x-s[l].x;
				if(abs(val-t) &amp;lt; mi)
				{                              
					mi=abs(val-t);
					ans=val;
					st=s[l].y;
					ed=s[r].y;
				}
				
				if(val &amp;lt; t) r++;
				else if(val &amp;gt; t) l++;
				else break;
				
				if(l == r) r++;
			}
			
			if(st &amp;gt; ed) swap(st,ed);
			
			printf(&amp;quot;%d %d %d\n&amp;quot;,ans,st+1,ed);
		}
	}
	return 0;
}


由于序列不能为空，如果l==r,则r++。
我们更新答案的时候左右区间端点为乱序，输出的时候调整一下。

poj2739
题意：找到某一个区间使得区间内的数的和等于某一给定值k。
设输入为x，只要判断x是否可以表示为x=y(i)+y(i+1)+y(i+2)+...+y(i+m)，即可，其中y为某一个素数。只要设置两个变量i，j，分别指向这个连续素数串的头和尾，不停的移动寻找解即可。不过首先需要得到10000以内的所有素数，如果每次输入都计算这些素数，没有必要而且可能会超时，所以先把所有素数计算出来并存储在一个数组中。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=10010;
int primes[N],cnt;
int n;

bool isprime(int x)
{
	for(int i=2;i*i&amp;lt;=x;i++)
		if(x%i == 0) 
			return false;
	return true;
}

void init(int n)
{
	for(int i=2;i&amp;lt;=n;i++)
		if(isprime(i))
			primes[cnt++]=i;
}

int main()
{
	init(N-1);

	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n))
	{
	    if(!n) break;
	    int l=0,r=0;
    	int ans=0;
    	int sum=0;
    	
    	while(1)
	    {
    		while(r&amp;lt;cnt &amp;amp;&amp;amp; sum&amp;lt;n)
    			sum+=primes[r++];
    		if(sum &amp;lt;n) break;
    		
    		if(sum == n)
    			ans++;
    		sum-=primes[l++];
	    }
	    
	    printf(&amp;quot;%d\n&amp;quot;,ans);
	}

	return 0;
}

poj2100
题意:给你一个数，询问有多少种连续自然数的平方和等于这个数，输出所有可能
题解:尺取法遍历所有符合条件的区间，满足的话记录左边界以及右边界，计数器+1。
尺取法过程:


1.初始化左右端点


2.不断扩大右端点，直到满足条件


3.如果第二步中无法满足条件，则终止，否则更新结果


4.将左端点扩大1，然后回到第二步


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
#define x first 
#define y second
typedef long long LL;
typedef pair&amp;lt;int,int&amp;gt; PII;
const int N=1e7+10;
vector&amp;lt;PII&amp;gt; ans;
LL n;

int main()
{
	while(~scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n))
	{
		ans.clear();
		
		LL l=1,r=1;
		LL sum=0;
		
		while(1)
		{
			while(r*r &amp;lt;= n &amp;amp;&amp;amp; sum &amp;lt; n)
				sum+=r*r,r++;
			
			if(sum &amp;lt; n) break;
			
			if(sum == n) ans.push_back(make_pair(l,r-1));
			
			sum-=l*l,l++;
		}
		
		printf(&amp;quot;%d\n&amp;quot;,ans.size());
		for(int i=0;i&amp;lt;ans.size();i++)
		{
			printf(&amp;quot;%d &amp;quot;,ans[i].y-ans[i].x+1);
			for(int j=ans[i].x;j&amp;lt;ans[i].y;j++)
				printf(&amp;quot;%d &amp;quot;,j);
			printf(&amp;quot;%d\n&amp;quot;,ans[i].y);
		}	
	}
	
	return 0;
}

hdu5672

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=1e6+10;
char s[N];
int cnt[30];
int k;

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		memset(cnt,0,sizeof cnt);
		scanf(&amp;quot;%s&amp;quot;,s);
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
		int n=strlen(s);
		int l=0,r=0;
		LL ans=0;
		int sum=0;
		
		while(1)
		{
			while(r&amp;lt;n &amp;amp;&amp;amp; sum&amp;lt;k)
				if(cnt[s[r++]-&#39;a&#39;]++ == 0)
					sum++;
			
			if(sum &amp;lt; k) break;
			
			ans+=n-r+1;
			
			if(--cnt[s[l++]-&#39;a&#39;] == 0) sum--;
		}
		
		printf(&amp;quot;%lld\n&amp;quot;,ans);
	}
	return 0;
}

P1638
博览馆正在展出由世上最佳的 M 位画家所画的图画。
wangjy想到博览馆去看这几位大师的作品。
可是，那里的博览馆有一个很奇怪的规定，就是在购买门票时必须说明两个数字，a和b，代表他要看展览中的第 a 幅至第 b 幅画(包含 a 和 b)之间的所有图画，而门票的价钱就是一张图画一元。
为了看到更多名师的画，wangjy希望入场后可以看到所有名师的图画(至少各一张)。
可是他又想节省金钱。。。
作为wangjy的朋友，他请你写一个程序决定他购买门票时的 a 值和 b 值。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1e6+10,M=2010;
int a[N],cnt[M];
int n,m;

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		
	int l=1,r=1;
	int sum=0;
	int ans=n;
	int al=1,ar=n;//初始化
	
	while(1)
	{
		while(r&amp;lt;=n &amp;amp;&amp;amp; sum&amp;lt;m)
			if(cnt[a[r++]]++ == 0)
				sum++;
		
		if(sum &amp;lt; m) break;
		
		if(ans &amp;gt; r-l) ans=r-l,al=l,ar=r-1;
		
		if(--cnt[a[l++]] == 0) sum--;
	}
	
	printf(&amp;quot;%d %d\n&amp;quot;,al,ar);
	
	return 0;
}

hdu5056

如果有一段字符刚刚好满足条件，那么后面的包含这个串的子串全部满足，我们可以尺取l和r，对于一个r满足的话，后面len  -  r + 1个子串也满足，然后更新l就可以了，因为l和r是分开更新的，所以复杂度是O(n)。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
char s[N];
int cnt[30];
int k;

int main()
{
    int T;
    cin&amp;gt;&amp;gt;T;
    while(T--)
    {
        memset(cnt,0,sizeof cnt);
        scanf(&amp;quot;%s&amp;quot;,s);
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
        int n=strlen(s);
        int l=0,r=0;
        LL ans=0;
        
        while(l&amp;lt;n)
        {
            while(r&amp;lt;n)
            {
                cnt[s[r]-&#39;a&#39;]++;
                if(cnt[s[r]-&#39;a&#39;] &amp;lt;= k)
                    ans+=r-l+1,r++;
                else 
                {
                    cnt[s[r]-&#39;a&#39;]--;
                    break;
                }
            }
                
            cnt[s[l]-&#39;a&#39;]--,l++;
        }
        printf(&amp;quot;%lld\n&amp;quot;,ans);
    }
    return 0;
}

hdu5358
log2(f(i,j))表示f(i,j)转换为2进制的长度，然后我们经过分析log2(f(i,j))+1的值域为[1,34]然后我们枚举log2(f(i,j))+1的值，例如我们枚举其值为k，对于一个k我们找到所有满足条件的区间(i,j),这个条件的代数表达为
2k−1+1&amp;lt;=f(i,j)+1&amp;lt;=2k2^{k-1}+1&amp;lt;= f(i,j)+1 &amp;lt;=2^k2k−1+1&amp;lt;=f(i,j)+1&amp;lt;=2k;
因此我们需要再枚举一个区间的左端点，对于一个给定的左端点，因为f(i,j)在给定i的情况下单调，我们可以用尺取法求得一个区间[l,r]，使得区间内的j (l&amp;lt;=j&amp;lt;=r)都瞒住log2sum(i,j)+1=klog_2sum(i,j)+1=klog2​sum(i,j)+1=k;
区间(i+j)的和可以表示为 i*(r-l+1) + (r+l)*(r-l+1)/2
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
LL s[N];
int n;

int main()
{
	//cout&amp;lt;&amp;lt;log2(1e10)&amp;lt;&amp;lt;endl;
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		
		for(int i=1;i&amp;lt;=n;i++)
		{
			scanf(&amp;quot;%lld&amp;quot;,&amp;amp;s[i]);
			s[i]+=s[i-1];
		}
		
		LL ans=0;
		for(LL k=1;k&amp;lt;=34;k++)
		{
			LL l=1,r=1;
			LL lmax=1ll&amp;lt;&amp;lt;(k-1),rmax=1ll&amp;lt;&amp;lt;k;
			if(k == 1) lmax=0;
			for(LL i=1;i&amp;lt;=n;i++)
			{
				l=max(l,i),r=max(r,i);
				while(l&amp;lt;=n &amp;amp;&amp;amp; s[l]-s[i-1] &amp;lt; lmax)
					l++;
				while(r&amp;lt;=n &amp;amp;&amp;amp; s[r]-s[i-1] &amp;lt; rmax)
					r++;
				r--;
				ans+=k*(i*(r-l+1)+(l+r)*(r-l+1)/2);
			}
		}
		printf(&amp;quot;%lld\n&amp;quot;,ans);
	}
	
	return 0;
}

P1102
我们考虑题目要求求出所有A-B=C的数对，我们可以先将原数组排序，然后就会发现每个数A，对应的数B一定是一段连续的区间。
然后我们再考虑如何去找到这个区间。
我们显然是要找到这个连续区间的左端点和右端点。
考虑到排序之后序列的有序性，我们枚举每个数，他们的左端点和右端点都是单调不降的，因此我们可以用双指针来维护这个东西。
具体的实现就是，我们维护两个右端点r1 , r2，每次r1右移到a[r1] - a[l] &amp;lt;c的最后位置的下一位，r2右移到满足a[r2] - a[l] &amp;lt;= c最后一位.
也就是说， 此时如果a[r2-1] - a[l] == c &amp;amp;&amp;amp; a[r1] - a[l] == c，中间的那一段一定都是满足条件的，我们让ans += r2 - r1即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=200010;
int a[N];

int main()
{
	int n,c;
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;c;
	for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;a[i];
	
	sort(a,a+n);
	
	int l=0,r1=0,r2=0;
	LL ans=0;
	
	while(l&amp;lt;n)
	{
		while(r1&amp;lt;n &amp;amp;&amp;amp; a[r1]-a[l] &amp;lt; c) r1++;
		while(r2&amp;lt;n &amp;amp;&amp;amp; a[r2]-a[l] &amp;lt;= c) r2++;
		if(a[r2-1] - a[l] == c &amp;amp;&amp;amp; a[r1]-a[l] == c)
			ans+=r2-r1;
		l++;
	}
	printf(&amp;quot;%lld\n&amp;quot;,ans);
	
	return 0;
}

uva11572
给出 n个数，找尽量长的一个子序列，使得该子序列中没有重复的元素。
右指针往右跳到不重复的最远位置,更新答案,然后左指针往右跳一位,左右指针都只跳了n次,所以查询的复杂度是O(n)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;map&amp;gt;
using namespace std;
const int N=1e6+10;
int a[N],b[N],cnt[N];
int n;

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i=0;i&amp;lt;n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]),b[i]=a[i];
			
		sort(b,b+n);
		
		int tot=unique(b,b+n)-b;
		
		for(int i=0;i&amp;lt;n;i++)
			a[i]=lower_bound(b,b+tot,a[i])-b;

		int l=0,r=0;
		int ans=0;
		
		for(int i=0;i&amp;lt;tot;i++) cnt[i]=0;
		
		while(r&amp;lt;n)
		{
			while(r&amp;lt;n &amp;amp;&amp;amp; cnt[a[r]] == 0)
				cnt[a[r++]]++;
			
			ans=max(ans,r-l);
			
			cnt[a[l++]]--;
		}
		
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

cf660C
大意：给定一个包含nn个元素的数组aa。数组a的每个元素不是00就是11。
现在，让我们用f(a)表示a中连续元素序列中最长子段的长度，它只包含数字1。并且你最多可以将k个0更改为1来得到最大的f(a)。
贪心：对于一个含0的区间，我们让区间中的0都填满是最优的
于是维护一段区间，保证区间中的0的个数≤k就可以
于是就可以对于0的个数≤k时右移右端点，增添新的位置，扩大区间；
当[l,r]中0的个数＞k时右移l，到[l,r]中0的个数≤k时为止
注意边界和初始化
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=3e5+10;
int a[N];
int n,k;

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k);
	for(int i=1;i&amp;lt;=n;i++)	
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		
	int l=1,r=1;
	int ans=0;
	int sum=0;
	int al=0,ar=0;
	
	while(r&amp;lt;=n)
	{
		while(r&amp;lt;=n &amp;amp;&amp;amp; sum&amp;lt;=k)
		{
			if(!a[r])
			{
				if(sum == k) break;//注意点！
				else sum++;
			}
			r++;
		}
		
		if(ans &amp;lt; r-l) ans=r-l,al=l,ar=r-1;
		
		if(!a[l++]) sum--;
	}
	
	printf(&amp;quot;%d\n&amp;quot;,ans);
	for(int i=1;i&amp;lt;=n;i++)
		if(i&amp;gt;=al &amp;amp;&amp;amp; i&amp;lt;=ar)
			printf(&amp;quot;1 &amp;quot;);
		else 
			printf(&amp;quot;%d &amp;quot;,a[i]);
		
	return 0;
}

尺取法的模型便是这样：根据区间的特征交替推进左右端点求解问题，其高效的原因在于避免了大量的无效枚举，其区间枚举都是根据区间特征有方向的枚举。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/chi-qu-fa/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/qian-zhui-he-chai-fen/">
                        前缀和 差分
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-08</time>
                    
                        <a href="https://caifxh.github.io/tag/TZ7cITYtt/" class="post-tag i-tag
                            i-tag-primary">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            前缀和
给定一个序列a[1−n]a[1-n]a[1−n]。
有很多次询问，每个询问形如:l r  询问a[l,r]a[l,r]a[l,r]的区间和。
每次询问的复杂度要求 O(1)

预处理时间复杂度O(n)O(n)O(n)
for(int i=1;i&amp;lt;=n;i++)
{
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
    s[i]=s[i-1]+a[i];
}

a[l,r]a[l,r]a[l,r]的区间和: s[r]-s[l-1]
查询时间复杂度O(1)O(1)O(1)
while(m--)
{
    int l,r;
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l,&amp;amp;r);
    printf(&amp;quot;%d\n&amp;quot;,s[r]-s[l-1]);
}

PS:前缀和下标从1开始
区间加/差分
给定一个序列a[1−n]a[1-n]a[1−n](初值全为0)。
有很多次操作，每个操作形如:l r  将a[l,r]a[l,r]a[l,r]的每个值加上k。
最后输出整个数组。复杂度要求O(n)O(n)O(n)

区间加[l,r]，实际上是发生了这两件事：
a[l]比前一个元素多了k;
a[r+1]比前一个元素少了k.

我们用数组b表示刚刚的差值，b[i]=a[i]-a[i-1].
那么：区间加[𝒍,𝒓]，可以化为这两个操作： b[l]+=k; b[r+1]-=k;
void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}

因此，一次区间加只修改这两个元素； 最后利用b数组求出a数组(a数组为b数组的前缀和)，对b数组求一遍前缀和即为答案。
for(int i=1;i&amp;lt;=n;i++)
{
    b[i]+=b[i-1];
    printf(&amp;quot;%d &amp;quot;,b[i]);
}

PS:数组a初值为0，进行n次插入操作可得到数组a。
for(int i=1;i&amp;lt;=n;i++)
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
for(int i=1;i&amp;lt;=n;i++)
    insert(i,i,a[i]);

总结：差分无需构造，前缀和需构造
通过上述的两个方法，我们能轻易地处理这两类问题：

数组固定，然后大量询问；
大量做区间加，最后要你给出这个数组。

例题
Luogu2879
有好几头牛从１到n线性排列，每头牛的高度为h[i]现在告诉你这里面的牛的最大高 度为maxH,而且有r组关系，每组关系输入两个数字，假设为a和b,表示第a头牛能看到第b头牛，能看到的条件是a, b之间的其它牛的高度都严格小于min(h[a], h[b]),而 h[b] &amp;gt;= h[a] 最后求所有牛的可能最高身高输出
思路：
首先假设所有牛都是最高身高。 读入的约束信息需要去重，这个利用排序或者set可以解决。 可以发现对于每个位置h[i],假设它被覆盖了x次，最后答案就是h[i]-x. 如果出现了一对[l,r]，把区间(l,r)的数都-1就可以了。（注意区间开闭）
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;set&amp;gt; 
using namespace std;
const int N=10010;
int height[N];
set&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; S;

int main()
{
	int n,i,h,r;
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;i&amp;gt;&amp;gt;h&amp;gt;&amp;gt;r;
	height[1]=h;//差分数组 
	
	while(r--)
	{
		int a,b;
		cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
		if(a&amp;gt;b)
			swap(a,b);
		if(!S.count({a,b}))
		{
			S.insert({a,b});
			height[a+1]--;
			height[b]++;
		}
	}
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		height[i]+=height[i-1];
		cout&amp;lt;&amp;lt;height[i]&amp;lt;&amp;lt;endl;
	}
	return 0;
 } 

Luogu3406
该铁路经过N个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好 ，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车 票。第i段铁路连接了城市i和城市i+1(1&amp;lt;=i&amp;lt;N)。如果搭乘的比较远，需要购买多张 车票。第i段铁路购买纸质单程票需要Ai博艾元。 虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了IC卡。对于第i段 铁路，需要花Ci博艾元的工本费购买一张IC卡，然后乘坐这段铁路一次就只要扣 Bi(Bi&amp;lt;Ai)元。IC卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应 的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于 第i段铁路的IC卡，无法乘坐别的铁路的车。 Uim现在需要出差，要去M个城市，从城市P1出发分别按照P1,P2,P3...PM的顺序访 问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且 不会是同一个城市。 现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和 充值的总费用。
直接模拟每段铁路的覆盖即可
 #include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
 int a[N];
 int b[N];//差分数组 
 typedef long long LL;
 
 int main()
 {
 	int n,m;
 	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
 	for(int i=1;i&amp;lt;=m;i++)
 		cin&amp;gt;&amp;gt;a[i];
 	for(int i=1;i&amp;lt;m;i++)
 	{
 		b[min(a[i],a[i+1])]++;
 		b[max(a[i],a[i+1])]--;
	 }
	 
	 for(int i=1;i&amp;lt;=n;i++)
	 	b[i]+=b[i-1];
	
//	for(int i=1;i&amp;lt;=n;i++)
//		cout&amp;lt;&amp;lt;&amp;quot;--&amp;quot;&amp;lt;&amp;lt;b[i]&amp;lt;&amp;lt;&#39; &#39;;
	
	LL sum=0;
	for(int i=1;i&amp;lt;n;i++)
	{
		LL ai,bi,ci;
		cin&amp;gt;&amp;gt;ai&amp;gt;&amp;gt;bi&amp;gt;&amp;gt;ci;
		sum+=min(ai*b[i],ci+bi*b[i]);
	}
	
	cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;
	return 0;
 }

Luogu1083
思路1：
利用差分数组存每天的教室使用情况，然后求前缀和，如果发现不符合要求，就从后往前撤回订单，直到每天都符合要求，那么我们撤回的最后一个（也就是最靠前的一个）即为ans
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int l[N],r[N],d[N];
int res=INF;

int main()
{
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	
	for(int i=1;i&amp;lt;=m;i++)
	{
		scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;d[i],&amp;amp;l[i],&amp;amp;r[i]);
		b[l[i]]+=d[i];
		b[r[i]+1]-=d[i];
	}
	
	int j=m;//从后往前撤回订单，直至满足要求 
	int sum=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		sum+=b[i];
		//cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;&#39; &#39;;
		if(sum&amp;gt;a[i])
		{
			//从后往前撤回 
			while(sum&amp;gt;a[i])
			{
				b[l[j]]-=d[j];
				b[r[j]+1]+=d[j];
				if(i&amp;gt;=l[j] &amp;amp;&amp;amp; i&amp;lt;=r[j])
					sum-=d[j];
				j--;
			}
			res=min(res,j);
		}	
	}
	
	if(res==INF)
		cout&amp;lt;&amp;lt;&amp;quot;0&amp;quot;;
    else 
		cout&amp;lt;&amp;lt;&amp;quot;-1&amp;quot;&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;res+1&amp;lt;&amp;lt;endl;
    return 0;
}

思路2：
在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int s[N],t[N],d[N];

bool check(int x)//判断前x份订单能否全部满足 
{
	memset(b,0,sizeof b);
	for(int i=1;i&amp;lt;=x;i++)
	{
		b[s[i]]+=d[i];
		b[t[i]+1]-=d[i];
	}

	for(int i=1;i&amp;lt;=n;i++)
	{
		b[i]+=b[i-1];
		if(b[i]&amp;gt;a[i])
			return false;
	}
	return true;
}

int main()
{
//	freopen(&amp;quot;test.in.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin);
//	freopen(&amp;quot;test.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	
	for(int i=1;i&amp;lt;=m;i++)
	{
		scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;d[i],&amp;amp;s[i],&amp;amp;t[i]);
	}
	if(check(m))
	{
		puts(&amp;quot;0&amp;quot;);
		return 0;
	}
	int l=0,r=m;//l取成0，防止无解情况 
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(check(mid))
			l=mid;
		else	
			r=mid-1;
	}
	cout&amp;lt;&amp;lt;-1&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;l+1&amp;lt;&amp;lt;endl;

    return 0;
}

前缀和+差分
luoguP3948
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N=80010;
typedef long long LL;
LL b[N];
int sum[N];
int n,opt,minn,maxx,l,r,x,f;
LL mod;
char ch[5];

int main()
{
    scanf(&amp;quot;%d%d%lld%d%d&amp;quot;,&amp;amp;n,&amp;amp;opt,&amp;amp;mod,&amp;amp;minn,&amp;amp;maxx);
    for(int j=1;j&amp;lt;=opt;j++){
        scanf(&amp;quot;%s%d%d%&amp;quot;,&amp;amp;ch,&amp;amp;l,&amp;amp;r);
        if(ch[0]==&#39;A&#39;){
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
            b[l]+=x;
            b[r+1]-=x;
        }
        else{
            int ans=0;
			LL now=0;
            for(int i=1;i&amp;lt;=r;i++){
                now+=b[i];
                if(i&amp;gt;=l&amp;amp;&amp;amp;(now*i)%mod&amp;gt;=minn&amp;amp;&amp;amp;(now*i)%mod&amp;lt;=maxx)ans++;
            }
            printf(&amp;quot;%d\n&amp;quot;,ans);
        }
    }
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;f);
    for(int i=1;i&amp;lt;=n;i++){
        b[i]+=b[i-1];
        if((b[i]*i)%mod&amp;gt;=minn&amp;amp;&amp;amp;(b[i]*i)%mod&amp;lt;=maxx)sum[i]=sum[i-1]+1;
        else sum[i]=sum[i-1];
    }
    for(int j=1;j&amp;lt;=f;j++){
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l,&amp;amp;r);
        printf(&amp;quot;%d\n&amp;quot;,sum[r]-sum[l-1]);
    }
    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/qian-zhui-he-chai-fen/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/">
                        单调数据结构
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-08</time>
                    
                        <a href="https://caifxh.github.io/tag/TZ7cITYtt/" class="post-tag i-tag
                            i-tag-success">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            单调栈

给定一个序列。对序列中的每个元素，求出它左侧的第一个小于它 的元素的位置。若没有这样的元素，输出0。

样例输入：
4
5 3 7 4
样例输出：
0 0 2 2

模板题1
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
int stk[N],top;

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    while(n--)
    {
        int x;
        cin&amp;gt;&amp;gt;x;
        while(top&amp;amp;&amp;amp;stk[top]&amp;gt;=x)
            top--;
        if(top)  
            cout&amp;lt;&amp;lt;stk[top]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        else 
            cout&amp;lt;&amp;lt;-1&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        stk[++top]=x;
    }
    return 0;
}

模板题2
找出第 i 个元素之后第一个大于 ai的元素的下标
分析：
从后往前枚举，对于i&amp;lt;j,若a[i]&amp;gt;=a[j],则j不可能成为下标小于i的元素的答案。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=3e6+10;
int stk[N],top;
int n;
int a[N];
int ans[N];

int main()
{
	cin&amp;gt;&amp;gt;n;
	for(int i=1;i&amp;lt;=n;i++) scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	
	for(int i=n;i&amp;gt;=1;i--)
	{
		while(top &amp;amp;&amp;amp; a[stk[top]] &amp;lt;= a[i]) top--;
		
		if(top) ans[i]=stk[top];
		else ans[i]=0;
		
		stk[++top]=i;
		
	}
	
	for(int i=1;i&amp;lt;=n;i++) printf(&amp;quot;%d &amp;quot;,ans[i]);
	return 0;
}

例题
poj2559

首先考虑最大面积的矩形X的左右边界的性质：
设其左边界为L，右边界为R，则其高H = min{h[i] | L &amp;lt;= i &amp;lt;= R}
此时最大面积为 (R - L + 1) * H
若此时左边界的左边那个矩形的高度 h[L-1] &amp;gt;= H
则左边界可以向左拓展，则新的面积为：
(R - (L-1) + 1) * H &amp;gt; 原面积
则与原假设条件冲突
故左边界左边的那个矩形的高度 :h[L-1] &amp;lt; H
同理右边界右边的那个矩形的高度： h[R+1] &amp;lt; H
设H = h[i]
所以左边界L是满足h[j-1] &amp;lt; h[i]的最大的j，即从i点向左遍历的第一个高度比i小的点的右边一个点
而右边界R是满足 h[j+1] &amp;lt; h[i]的最小的j，即从i点向右遍历第一个高度比i小的点的左边一个点
所以我们可以利用单调栈的性质得到每个确定点，即确定高度的最大面积矩形的左右边界，然后枚举取最大即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
int h[N];
int l[N],r[N];
int stk[N],top;
int n;

int main()
{
	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		top=0;
		for(int i=1;i&amp;lt;=n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i]);
		
		for(int i=1;i&amp;lt;=n;i++)//找出h[i]左边第一个小于h[i]的位置 
		{
			while(top &amp;amp;&amp;amp; h[stk[top]] &amp;gt;= h[i]) 
				top--;
			
			if(top) l[i]=stk[top]+1;
			else l[i]=1;//表示左边没有比h[i]小的位置 
			
			stk[++top]=i;
		}
		
		top=0;
		for(int i=n;i&amp;gt;=1;i--)//找出h[i]右边第一个小于h[i]的位置 
		{
			while(top &amp;amp;&amp;amp; h[stk[top]] &amp;gt;= h[i])
				top--;
			if(top) r[i]=stk[top]-1;
			else r[i]=n;//表示右边没有比h[i]大的位置 
				
			stk[++top]=i; 
		}
		
		LL ans=0;
		for(int i=1;i&amp;lt;=n;i++)
			ans=max(ans,(LL)h[i]*(r[i]-l[i]+1));
	
		printf(&amp;quot;%lld\n&amp;quot;,ans);
	}
	return 0;
}

P1901
对于一个新的信号塔:

当他加入栈中时,会挡住之前比它低的塔的传播,同时 , 也会接受到比它低的塔的信号
所以将栈顶所有比它低的塔删除,(因为他们已经不能再传播给其他塔信号了),同时 , 新的塔接收到的能量加上 删掉的塔传播的能量
对于原有的高度比它高的信号塔,离此新的信号塔最近的(当前栈顶元素),会接受到新的塔的信号
再将此新的信号塔加入栈中,最后O(n)扫一遍后,输出最大值即可

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1e6+10;
int stk[N],top;
int sum[N];
int h[N],w[N];
int n;

int main()
{
	cin&amp;gt;&amp;gt;n;
	for(int i=1;i&amp;lt;=n;i++)
	{
		cin&amp;gt;&amp;gt;h[i]&amp;gt;&amp;gt;w[i];
		
		while(top &amp;amp;&amp;amp; h[stk[top]] &amp;lt;= h[i])
			sum[i]+=w[stk[top--]];
		sum[stk[top]]+=w[i];
		
		stk[++top]=i;
	}
	
	int ans=0;
	for(int i=1;i&amp;lt;=n;i++)
		ans=max(ans,sum[i]);
	
	printf(&amp;quot;%d\n&amp;quot;,ans);
	return 0;
}

P1823
先假设每个人身高不同，脑补一下走过整个队列。

观察队伍中的一个人A。如果我们他后面找到了一个比他不知道高到哪里去了的B，A就不能与B后面的人谈笑风生了。
因此我们可以维护一个单调栈，记录我们已经找到过的高人，显然栈上的高人们按高度的降序排列，栈顶的人最矮。
当我们找到一个新的高人时，他可以向栈里比他矮的人传授人生经验，并让他们出栈。如果出栈之后栈非空，他还可以与栈顶的高人谈笑风生。然后我们再另请这位高明进栈。
我们还要考虑两个人身高相同的情况。我们可以在栈里存pair&amp;lt;身高，人数&amp;gt;并维护它。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef pair&amp;lt;int,int&amp;gt; PII;
#define x first
#define y second
typedef long long LL;
const int N=500010;
int h[N];
PII stk[N];
int top;
int n;

int main()
{
	cin&amp;gt;&amp;gt;n;
	LL ans=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i]);
		
		PII p=make_pair(h[i],1);
		while(top &amp;amp;&amp;amp; stk[top].x &amp;lt;= h[i])
		{
			if(stk[top].x == h[i]) 
				p.y+=stk[top].y;
			ans+=stk[top].y;
			top--;
		}
		
		if(top) ans++;
		stk[++top]=p;
	}
	printf(&amp;quot;%lld\n&amp;quot;,ans);
	return 0;
}

单调队列

模板题

单调队列与普通队列不一样的地方就在于单调队列既可以从队首出队，也可以从队尾出队。
那么我们应该怎样实现单调队列呢?
就拿样例来谈谈，设以最小的为标准。

8 3
1 3 -1 -3 5 3 6 7
下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。


由于此时队中没有一个元素，我们直接令1进队。此时，q={1},p={1}。


现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q={1,3},p={1,2}


下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从队尾出队。同理，1从队尾出队。最后-1进队，此时q={-1},p={3}


出现-3，同上面分析，-1&amp;gt;-3，-1从队尾出队,-3从队尾进队。q={-3}，p={4}。


出现5，因为5&amp;gt;-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q={-3,5},p={4,5}


出现3。3先与队尾的5比较，3&amp;lt;5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q={-3,3},p={4,6}


出现6。6与3比较，因为3&amp;lt;6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从队首出队。此时，q={3,6},p={6,7}


出现7。队尾元素6小于7，7进队。此时，q={3,6,7},p={6,7,8}。


那么，我们对单调队列的基本操作已经分析完毕。因为单调队列中元素大小单调递(增/减/自定义比较)，因此，队首元素必定是最值。按题意输出即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1000010;
int a[N];
int q[N];
int n,k;

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k);
	
	int hh=0,tt=-1;
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		
	for(int i=1;i&amp;lt;=n;i++)//求滑动窗口最小值 
	{
		if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-k&amp;gt;= q[hh]) hh++;
		while(hh &amp;lt;= tt &amp;amp;&amp;amp; a[q[tt]] &amp;gt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &amp;gt;= k)
			printf(&amp;quot;%d &amp;quot;,a[q[hh]]);
	}
	puts(&amp;quot;&amp;quot;);
	
	hh=0,tt=-1;
	for(int i=1;i&amp;lt;=n;i++)
	{
		if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-k&amp;gt;=q[hh]) hh++;
		while(hh &amp;lt;= tt &amp;amp;&amp;amp; a[q[tt]] &amp;lt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &amp;gt;= k)
			printf(&amp;quot;%d &amp;quot;,a[q[hh]]);
	}
	return 0;
}

acwing135

#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int N = 300010, INF = 0x3f3f3f3f;
int n, m;
int s[N];
int q[N];

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i ++ ) scanf(&amp;quot;%d&amp;quot;, &amp;amp;s[i]), s[i] += s[i - 1];

    int res = -INF;
    int hh = 0, tt = -1;
    q[++tt]=0;//将s[0]入队
    for (int i = 1; i &amp;lt;= n; i ++ )
    {
        if(hh&amp;lt;=tt &amp;amp;&amp;amp; i-m &amp;gt; q[hh]) hh++;
        res=max(res,s[i]-s[q[hh]]);
        while (hh &amp;lt;= tt &amp;amp;&amp;amp; s[q[tt]] &amp;gt;= s[i]) tt -- ;
        q[ ++ tt] = i;
    }

    printf(&amp;quot;%d\n&amp;quot;, res);

    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/gao-jing-du/">
                        高精度
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-08</time>
                    
                        <a href="https://caifxh.github.io/tag/TZ7cITYtt/" class="post-tag i-tag
                            i-tag-other_4">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            高精度加法
当进行加法运算的数字较大时，受存储范围限制，无法使用int或longlong型变量进行存储。
考虑到加法运算的本质，不妨将数字拆开来存储。
对于一个超过变量存储数据范围的数字，可以将这个数字拆开，拆成一位一位的，或者是几位几位的存储到一个数组中， 用一个数组去表示一个数字
采用用顺序存储数据方式，会有一个问题：最高位进位变得很困难。
最高位在num[0]，所以一旦有进位，需要将num[]数组中每一位都往后移，时间复杂度O(len)
·倒序存储·：num[]数组从0到len-1依次存储整数个位到最高位。则最高位进位时，只需要num[len++]=t，t为最高位数字
进位：
方法一：设一个变量t，记录当前进位
边计算边进位和逐位相加不进位最后再统一进位效果是一样的如下，先进行一遍逐位相加。
然后，从0开始遍历一遍ans.num[]，将本位大于9的部分进位给更高位。
最后判断是否最高位有进位，有则ans.len++
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=510;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum add(bignum a,bignum b)
{
	bignum c;
	c.len=max(a.len , b.len);
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]+b.m[i];
	for(int i=0;i&amp;lt;c.len;i++)
		if(c.m[i] &amp;gt; 9)
		{
			c.m[i+1]+=1;
			c.m[i]-=10;
		}
	if(c.m[c.len]) c.len++;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	scanf(&amp;quot;%s&amp;quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&amp;lt;len;i++)
		b.m[len-i-1]=s[i]-&#39;0&#39;;
	bignum c=add(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

高精度减法

判断正负
基本和加法一模一样，只不过从进位变成退位
退位后更新结果长度
模板题

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=10100;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

int judge(bignum a,bignum b)
{
	if(a.len &amp;gt; b.len) return 1;
	if(a.len &amp;lt; b.len) return -1;
	for(int i=a.len-1;i&amp;gt;=0;i--)
	{
		if(a.m[i] &amp;gt; b.m[i]) return 1;
		if(a.m[i] &amp;lt; b.m[i]) return -1;
	}
	return 0;
}

bignum Minus(bignum a,bignum b)
{
	if(judge(a,b) == -1)
	{
		printf(&amp;quot;-&amp;quot;);
		return Minus(b,a);
	}

	bignum c;
	c.len=a.len;
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]-b.m[i];
	for(int i=0;i&amp;lt;c.len;i++)
		if(c.m[i] &amp;lt; 0)
		{
			c.m[i+1]-=1;
			c.m[i]+=10;
		}
	while(c.len &amp;gt; 1 &amp;amp;&amp;amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	scanf(&amp;quot;%s&amp;quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&amp;lt;len;i++)
		b.m[len-i-1]=s[i]-&#39;0&#39;;
	bignum c=Minus(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

高精度乘法
1.高精*低精
将加法运算改为乘法运算即可。
注意：

进位的运算
最高位进位的处理，可能不止进一位
模板题

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]*b;
	for(int i=0;i&amp;lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
		if(i == c.len-1 &amp;amp;&amp;amp; c.m[i+1]) c.len++;
	}

	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	int b;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;b);

	bignum c=mul(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

2.高精*高精
乘法竖式中，a.num[i]和b.num[j]相乘的结果，放在了ans.num[i+j]的位置。
a,b都为正整数时，长度为a.len和b.len的数字相乘得到ans，则

模拟上例竖式运算过程即可
{模板题](https://www.luogu.com.cn/problem/P1303}
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=4010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,bignum b)
{
	bignum c;
	c.len=a.len+b.len;
	for(int i=0;i&amp;lt;a.len;i++)
		for(int j=0;j&amp;lt;b.len;j++)
			c.m[i+j]+=a.m[i]*b.m[j];
	for(int i=0;i&amp;lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
	}
	while(c.len &amp;gt; 1 &amp;amp;&amp;amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	scanf(&amp;quot;%s&amp;quot;,s);
	b.len=len=strlen(s);
	for(int i=0;i&amp;lt;len;i++)
		b.m[len-i-1]=s[i]-&#39;0&#39;;
	bignum c=mul(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

高精度除法
1.高精/低精
除法是从高位到低位进行运算的。使用一个临时变量来记录余数，注意细节
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};
int t;

bignum Div(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	t=0;
	for(int i=c.len-1;i&amp;gt;=0;i--)
	{
		t=t*10+a.m[i];
		c.m[i]=t/b;
		t%=b;
	}
	while(c.len &amp;gt; 1 &amp;amp;&amp;amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	int b;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;b);
	bignum c=Div(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	printf(&amp;quot;%d\n&amp;quot;,t);

	return 0;
}

数楼梯
斐波那契递推
code

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/gao-jing-du/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/bei-zeng-st-biao-rmq/">
                        倍增 ST表 RMQ
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-28</time>
                    
                        <a href="https://caifxh.github.io/tag/TZ7cITYtt/" class="post-tag i-tag
                            i-tag-other_2">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            倍增





ST表


ST表创建



ST表查询


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;//使用log函数
/*log():以e为底的对数，exp(5)=e^5,log(exp(5))=5
  log10():以10为底的对数
  log2():以2为底的对数 
  任何一个其它的对数logm(n)=log(n)/log(m)*/
using namespace std;
const int maxn=105;
int n,a[maxn],F[maxn][maxn];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

void ST_create()
{
	for(int i=1;i&amp;lt;=n;i++)//初始化 
		F[i][0]=a[i];
	int k=log2(n);//log(n)/log(2);
	for(int j=1;j&amp;lt;=k;j++)
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)//n-2^j+1
			F[i][j]=max(F[i][j-1],F[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
}

int ST_query(int l,int r)//求区间[l..r]的最值 
{
	int k=log2(r-l+1);
	return max(F[l][k],F[r-(1&amp;lt;&amp;lt;k)+1][k]);//取两个区间最值 
}

int ST_print()
{
	int k=log2(n);
	for(int j=0;j&amp;lt;=k;j++)
	{	
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)//n-2^j+1,打印第一列 
			cout&amp;lt;&amp;lt;F[i][j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
		cout&amp;lt;&amp;lt;endl;
	}
}

int ST_print2()//按列打印 
{
	int k=log2(n);
	for(int i=1;i&amp;lt;=n;i++)
	{
		for(int j=0;j&amp;lt;=k;j++)
			cout&amp;lt;&amp;lt;F[i][j]&amp;lt;&amp;lt;&#39; &#39;;
		cout&amp;lt;&amp;lt;endl;
	}
}

int main()
{
	int l,r;
	int i,v;
	cin&amp;gt;&amp;gt;n;
	for(i=1;i&amp;lt;=n;i++)
		cin&amp;gt;&amp;gt;a[i];//5 3 7 2 12 1 6 4 8 15
	ST_create();//创建ST表
	ST_print();
	cout&amp;lt;&amp;lt;&amp;quot;输入查询最值的区间l r:&amp;quot;&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;
	cout&amp;lt;&amp;lt;ST_query(l,r)&amp;lt;&amp;lt;endl;//求区间[l..r]的最值
	return 0;
}

例题
poj3264

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;//min,max
#include&amp;lt;cmath&amp;gt;//log
using namespace std;
const int maxn=50010;
int h[maxn];
int Fmax[maxn][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j
int Fmin[maxn][20];
int N,Q;

void ST_create()
{
	for(int i=1;i&amp;lt;=N;i++)//初始化 
		Fmax[i][0]=Fmin[i][0]=h[i];
	int k=log2(N);//log(N)/log(2.0);
	for(int j=1;j&amp;lt;=k;j++)
		for(int i=1;i&amp;lt;=N-(1&amp;lt;&amp;lt;j)+1;i++)//N-2^j+1
		{
			Fmax[i][j]=max(Fmax[i][j-1],Fmax[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
			Fmin[i][j]=min(Fmin[i][j-1],Fmin[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
		}			
}

int RMQ(int l,int r)//求区间[l..r]的最值差 
{
	int k=log2(r-l+1);
	int m1=max(Fmax[l][k],Fmax[r-(1&amp;lt;&amp;lt;k)+1][k]);
	int m2=min(Fmin[l][k],Fmin[r-(1&amp;lt;&amp;lt;k)+1][k]);
	return m1-m2;//取两个区间最值差 
}

int main()
{
	int a,b;
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;Q))
	{
		for(int i=1;i&amp;lt;=N;i++)//下标从1开始 
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i]);
		ST_create();
		for(int j=1;j&amp;lt;=Q;j++)
		{
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
			printf(&amp;quot;%d\n&amp;quot;,RMQ(a,b));
		}
	}
	return 0;
}

poj3368



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int lb[N];		
int f[N][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

int n,Q;
int a[N];

void ST_create()
{	
	for(int j=1;j&amp;lt;=lb[n];j++)
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
			f[i][j]=max(f[i][j-1],f[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);	
}

int RMQ(int l,int r)
{
	if(l &amp;gt; r)
		return 0;
	int k=lb[r-l+1];
	return max(f[l][k],f[r-(1&amp;lt;&amp;lt;k)+1][k]);
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&amp;lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;amp;(i-1));
	while(~scanf(&amp;quot;%d%&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;Q);
		for(int i=1;i&amp;lt;=n;i++)
		{
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
			if(i == 1)
			{
				f[i][0]=1;
				continue;
			}
			if(a[i] == a[i-1])
				f[i][0]=f[i-1][0]+1;
			else 
				f[i][0]=1;
		}
		ST_create();
		for(int j=1;j&amp;lt;=Q;j++)
		{
			int l,r;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l,&amp;amp;r);
			int t=l;
			while(t&amp;lt;=r &amp;amp;&amp;amp; a[t] == a[t-1])
				t++;
			printf(&amp;quot;%d\n&amp;quot;,max(t-l,RMQ(t,r)));
		}
	}
	return 0;
}

hdu3468

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=200010;
int a[N];
int n,k;
int F[N][20],lb[N];

void Initlog()
{
	lb[0]=-1;
    for(int i=1;i&amp;lt;=N;i++)
        lb[i]=lb[i-1]+(i&amp;amp;(i-1)?0:1);
}

void ST()
{
    for(int i=1;i&amp;lt;=n;i++)
		F[i][0]=a[i];
    for(int j=1;j&amp;lt;=lb[n];j++)
        for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
            F[i][j]=max(F[i][j-1],F[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
}

int query(int l,int r)
{
    int k=lb[r-l+1];
    return max(F[l][k],F[r-(1&amp;lt;&amp;lt;k)+1][k]);
}

bool check(int mid)
{
    int t=n/mid,s=0;
    for(int i=0;i&amp;lt;mid;i++)
		s+=query(t*i+1,t*i+t);
    return s&amp;gt;k;
}

int main()
{
    lb[0]=-1;
	for(int i=1;i&amp;lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;amp;(i-1));
	while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k),n&amp;gt;=0||k&amp;gt;=0)
    {
        int sum=0;
        for(int i=1;i&amp;lt;=n;i++)
        {
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
            sum+=a[i];
        }
        if(sum&amp;lt;=k)
		{
			printf(&amp;quot;-1\n&amp;quot;);
			continue;
		}
		ST();
		int l=1,r=n;
		while(l&amp;lt;r)//二分找划分数 
    	{
	        int mid=(l+r)/2;
	        if(check(mid)) r=mid;
	        else l=mid+1;
    	}
		printf(&amp;quot;%d\n&amp;quot;,l);
    }
    return 0;
}

poj2019

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
const int maxn=260,INF=0x3f3f3f3f;
using namespace std;
int a[maxn][maxn],lb[maxn];
int Fmax[maxn][maxn][8],Fmin[maxn][maxn][8];
int n,m,k;

void ST()
{
	for(int k=1;k&amp;lt;=n;k++)//多一维 
        for(int i=1;i&amp;lt;=n;i++)
            Fmax[k][i][0]=Fmin[k][i][0]=a[k][i];	
	for(int k=1;k&amp;lt;=n;k++)
		for(int j=1;j&amp;lt;=lb[n];j++)
			for(int i=1;i+(1&amp;lt;&amp;lt;j)-1&amp;lt;=n;i++)
			{
				Fmax[k][i][j]=max(Fmax[k][i][j-1],Fmax[k][i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
				Fmin[k][i][j]=min(Fmin[k][i][j-1],Fmin[k][i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
			}
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&amp;lt;maxn;i++)
		lb[i]=(i&amp;amp;(i-1))?lb[i-1]:lb[i-1]+1;
	while(~scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k))
	{
		for(int i=1;i&amp;lt;=n;i++)
			for(int j=1;j&amp;lt;=n;j++)
				scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]);	
		ST();
		for(int i=0;i&amp;lt;k;i++)
		{
			int x,y;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
			int k=lb[m];
    		int maxx=-INF;
			int minx=INF;
    		int l=y,r=y+m-1;//从坐标为(x,y)的地方开始，右下扩展B长度 
    		for(int i=x;i&amp;lt;x+m;i++)//查询每一行的最值 
		    {
		        maxx=max(maxx,max(Fmax[i][l][k],Fmax[i][r-(1&amp;lt;&amp;lt;k)+1][k]));
		        minx=min(minx,min(Fmin[i][l][k],Fmin[i][r-(1&amp;lt;&amp;lt;k)+1][k]));
		    }
			printf(&amp;quot;%d\n&amp;quot;,maxx-minx);
		}
	}
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/bei-zeng-st-biao-rmq/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://caifxh.github.io/images/avatar.png?v=1586491016728)">
        </div>
        <h1 class="id_card-title">
            fxh
        </h1>
        <h2 class="id_card-description">
            菜
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>