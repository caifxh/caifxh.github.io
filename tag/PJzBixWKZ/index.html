<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    其他算法 | fxh&#39;blog
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1594530304239">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1594530304239" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh&#39;blog
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        其他算法</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/stl/">
                        STL
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-30</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-other_4">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            STL的lower_bound()和upper_bound()
如果只是简单地找x或x附近的数，就用STL的lower_bound()和upper_bound()函数。有以下情况：
（1）查找第一个大于x的元素的位置：upper_bound()。代码例如：
pos = upper_bound(a, a+n, test) - a;
（2）查找第一个等于或者大于x的元素：lower_bound()。
（3）查找第一个与x相等的元素：lower_bound()且 = x。
（4）查找最后一个与x相等的元素：upper_bound()的前一个且 = x。
（5）查找最后一个等于或者小于x的元素：upper_bound()的前一个。
（6）查找最后一个小于x的元素：lower_bound()的前一个。
（7）单调序列中数x的个数：upper_bound() - lower_bound()。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/stl/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/tan-xin/">
                        贪心
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-14</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-info">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            贪心法正确性证明方法
方法一：数学归纳法
主要步骤如下：
（1）叙述一个论证算法正确性的与自然数相关的命题P(n)，这里的n可以代表算法步数或者实例规模。例如：
对于任何正整数n，贪心法的前n步选择将导致最优解。
对于任何正整数n，贪心法对于规模为n的任何实例都得到最优解。
（2）使用第一或者第二数学归纳法证明上述命题P(n)。
第一数学归纳法：
证：
P(1)为真；
若P(n)为真，则P(n+1)为真。
第二数学归纳法：
证：
P(1)为真；
若对所有k&amp;lt;n，有P(k)为真， 则P(n)为真。
方法二：交换论证法
主要步骤如下：
（1）分析一般最优解与贪心法的解的区别，然后定义一种转换规则，使得从任意一个最优解出发，经过不断对解的某些成分的排列次序进行交换或者用其他元素替换，将这个解最终能够转变成贪心法的解。
（2）证明在上述转换中解得优化函数值不会变坏。
（3）证明上述转换在有限步结束。
1.活动安排问题
acwing908

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;

struct Range
{
    int l,r;
    bool operator&amp;lt; (const Range &amp;amp;w)const
    {
        return r&amp;lt;w.r;
    }
}ranges[N];

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    for(int i=0;i&amp;lt;n;i++)
    {
        int l,r;
        cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;
        ranges[i]={l,r};
    }
    
    sort(ranges,ranges+n);
    int res=0,ed=-2e9;
    for(int i=0;i&amp;lt;n;i++)
        if(ranges[i].l&amp;gt;ed)
        {
            res++;
            ed=ranges[i].r;
        }
    cout&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl;
    return 0;
}

2.区间覆盖问题
acwing907

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int N = 100010;
struct Range
{
    int l, r;
    bool operator&amp;lt; (const Range &amp;amp;W)const
    {
        return l &amp;lt; W.l;
    }
}range[N];
int n;

int main()
{
    int st, ed;
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;st, &amp;amp;ed);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    for (int i = 0; i &amp;lt; n; i ++ )
    {
        int l, r;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;l, &amp;amp;r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    int res = 0;
    int j=0;
    while(st &amp;lt; ed)
    {
        int r=-2e9;
        while(j &amp;lt; n &amp;amp;&amp;amp; range[j].l &amp;lt;= st)
            r=max(r,range[j].r),j++;
        
        if(r &amp;lt; st)
        {
            res=-1;
            break;
        }
        st=r;
        res++;
    }
    
    printf(&amp;quot;%d\n&amp;quot;, res);

    return 0;
}

3.最优装载
hdu2570
有n种体积V都相同，浓度为Pi%的万能药水，挑选尽可能多的万能药水混合，需满足混合后的浓度≤W%。
解题思路：
此题是一道贪心题，为了能够选择尽可能多的万能药水，所以我们应该先选浓度低的，可以达到降低混合后浓度的作用。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=110;
int a[N];
int n,v,w;

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;v,&amp;amp;w);
		
		for(int i=1;i&amp;lt;=n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		
		sort(a+1,a+1+n);
		
		double sum=0;
		int cnt=0;
		int i;
		for(i=1;i&amp;lt;=n;i++)
			if((sum+a[i])/i &amp;lt;= w)
				sum+=a[i],cnt++;
			else 
				break;
		
		if(cnt==0) printf(&amp;quot;0 0.00\n&amp;quot;);
		else printf(&amp;quot;%d %.2lf\n&amp;quot;,cnt*v,sum/100/cnt);
	}
	return 0;
}

4.多机调度
设有n个独立的作业，由m台相同的机器进行加工处理。作业i所需的处理时间为t[i]。任何作业可以在任何一台机器上面加工处理，但未完工之前不允许中断处理。任何作业不能拆分成更小的作业。要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。
采用最长处理时间作业优先的贪心选择策略，可以设计出解多机调度问题较好的近似算法。


当n&amp;lt;=m(作业数小于机器数)时，只要将机器 i 的 时间区间分配给作业 i 即可


当n&amp;gt;m时，首先将n个作业从大到小排序，然后依此顺序将作业分配给空闲的处理机。也就是说从剩下的作业中，选择需要处理时间最长的，然后依次选择处理时间次长的，直到所有的作业全部处理完毕，或者机器不能再处理其他作业为止。如果我们每次是将需要处理时间最短的作业分配给空闲的机器，那么可能就会出现其它所有作业都处理完了只剩所需时间最长的作业在处理的情况，这样势必效率较低。



                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/tan-xin/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/er-fen/">
                        二分
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-13</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-other_2">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            P1462
∎题目描述
　给定无向图，n个点，m条双向边，每个点有点权fi（这个点的过路费），有边权ci（这条路的血量）。求起点1到终点N的所有可能路径中，在总边权（总血量）不超过给定的b的前提下，所经过的路径中最大点权（这条路径上过路费最大的那个点）的最小值是多少。
题目数据：n≤10000，m≤50000，fi，ci，B≤1e9。
　　
∎题解
对点权fi进行二分，用dijkstra求最短路，检验总边权是否小于b。二分法是最小化最大值问题。
这一题是二分法和最短路算法的简单结合。
（1）对点权（过路费）二分。题目的要求是：从1到N有很多路径，其中的一个可行路径Pi，它有一个点的过路费最大，记为Fi；在所有可行路径中，找到那个有最小F的路径，输出F。解题方案是：先对所有点的fi排序，然后用二分法，找符合要求的最小的fi。二分次数log(fi)=log(1e9) &amp;lt; 30。
（2）在检查某个fi时，删除所有大于fi的点，在剩下的点中，求1到N的最短路，看总边权是否小于b，如果满足，这个fi是合适的（如果最短路的边权都大于b，那么其他路径的总边权就更大，肯定不符合要求）。一次Dijkstra求最短路，复杂度是O(mlogn)。
总复杂度满足要求。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=10010,M=100010,INF=0x3f3f3f3f;
int h[N],e[M],ne[M],w[M],idx;
int n,m,b;
int f[N],cost[N];
int dist[N];
typedef pair&amp;lt;int,int&amp;gt; PII;
bool st[N];
int sum;

void add(int a,int b,int c)
{
    e[idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx++;
}

bool check(int x)
{
    memset(dist,0x3f,sizeof dist);
    memset(st,false,sizeof st);
    dist[1]=0;
    priority_queue&amp;lt;PII,vector&amp;lt;PII&amp;gt;,greater&amp;lt;PII&amp;gt; &amp;gt; heap;
    heap.push({0,1});

    while(heap.size())
    {
        PII t=heap.top();
        heap.pop();
        int distance=t.first,ver=t.second;
        if(st[ver])
            continue;
        st[ver]=true;
        for(int i=h[ver];~i;i=ne[i])
        {
            int j=e[i];
            if(dist[j] &amp;gt; distance + w[i] &amp;amp;&amp;amp; cost[j] &amp;lt;= x)
            {
                dist[j] = distance + w[i];
                heap.push({dist[j],j});
            }
        }
    }

    if(dist[n] &amp;lt;= b)
        return true;
    else
        return false;
}

int main()
{
    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;b);
    memset(h,-1,sizeof h);
    for(int i=1;i&amp;lt;=n;i++)
    {
        cin&amp;gt;&amp;gt;f[i];
        cost[i]=f[i];
    }
    while(m--)
    {
        int a,b,c;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
        add(a,b,c);
        add(b,a,c);
    }

    sort(f+1,f+n+1);

    int l=1,r=n;

    //在点权最大的情况下，依旧大于b，不满足
    if(!check(f[n]+10))
    {
        cout&amp;lt;&amp;lt;&amp;quot;AFK&amp;quot;&amp;lt;&amp;lt;endl;
        return 0;
    }
    while(l &amp;lt; r)
    {
        int mid=l+r&amp;gt;&amp;gt;1;
        if(check(f[mid]))
            r=mid;
        else
            l=mid+1;
    }

    cout&amp;lt;&amp;lt;f[l]&amp;lt;&amp;lt;endl;
    return 0;
}

P1624
在一条很长的直线上，指定n个坐标点（x1, …, xn）。有c头牛，安排每头牛站在其中一个点（牛棚）上。这些牛喜欢打架，所以尽量距离远一些。问最近的两头牛之间距离的最大值可以是多少。
这个题目里，所有的牛棚两两之间的距离有个最小值，题目要求使得这个最小值最大化。
∎题解
（1）暴力法。从小到大枚举最小距离的值dis，然后检查，如果发现有一次不行，那么上次枚举的就是最大值。如何检查呢？用贪心法：第一头牛放在x1，第二头牛放在xj≥x1+dis的点xi,第三头牛放在xk≥xj+dis的点xk，等等，如果在当前最小距离下，不能放c条牛，那么这个dis就不可取。复杂度O(nc)。
（2）二分。分析从小到大检查dis的过程，发现可以用二分的方法找这个dis。这个dis符合二分法：它有上下边界、它是单调递增的。复杂度O(nlogn)。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int q[N];
int n,c;

//相距x，是否能放置c头牛
bool check(int dist)
{
    int cnt=1,last=0;

    for(int i=1;i&amp;lt;n;i++)
    {
        if(q[i] - q[last] &amp;gt;= dist)
        {
            cnt++;
            last=i;
        }
    }

    if(cnt &amp;gt;= c)
        return true;
    else
        return false;
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;c;

    for(int i=0;i&amp;lt;n;i++)
        cin&amp;gt;&amp;gt;q[i];
    sort(q,q+n);
    int l=1,r=q[n-1]-q[0];
    while(l &amp;lt; r)
    {
        int mid=l+r+1&amp;gt;&amp;gt;1;
        if(check(mid))
            l=mid;
        else
            r=mid-1;
    }

    cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;endl;
    return 0;
}

实数二分
const double eps =1e-7;        //精度。如果下面用for，可以不要eps
while(right - left &amp;gt; eps){     //for(int i = 0; i&amp;lt;100; i++){
      double mid = left+(right-left)/2;
      if (check(mid)) right = mid;           //判定，然后继续二分
      else            left  = mid;
}

其中，循环用2种方法都可以：
while(right - left &amp;gt; eps)  　{ ... }
或者：
for(int i = 0; i &amp;lt; 100; i++) { ... }

如果用for循环，由于循环内用了二分，执行100次，相当于实现了 1/21001/2^{100}1/2100的精度，一般比eps更精确。
for循环的100次，比while的循环次数要多。如果时间要求不是太苛刻，用for循环更简便
poj3122
主人过生日，m个人来庆生，有n块半径不同的圆形蛋糕，由m+1个人（加上主人）分，每人的蛋糕必须一样重，而且是一整块（不能是几个蛋糕碎块，也就是说，每个人的蛋糕都是从一块圆蛋糕中切下来的完整一块）。问每个人能分到的最大蛋糕是多大。
∎题解
最小值最大化问题。设每人能分到的蛋糕大小是x，用二分法枚举x。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const double PI=acos(-1.0);
const int eps=1e-8;
const int N=100010;
double s[N];
int n,m;

bool check(double mid)
{
	int sum=0;
	for(int i=0;i&amp;lt;n;i++)
		sum+=int(s[i]/mid);
	
	if(sum &amp;gt;= m) return 1;
	else return 0;
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
		m++;
		
		double l=0,r=0;
		for(int i=0;i&amp;lt;n;i++)
		{
			int x;
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
			s[i]=PI*x*x;
			r=max(r,s[i]);
		}
		
		for(int i=0;i&amp;lt;100;i++)
		{
			double mid=l+(r-l)/2;
			if(check(mid)) l=mid;
			else r=mid;
		}
		
		printf(&amp;quot;%.4f\n&amp;quot;,l);
	}
	return 0;
}

P1419
题意理解
就是给你一些区间,要求选择的区间包含以下条件.

选取区间总长度最大
选取的区间之间不得用重叠部分,包括区间左右端点部分

状态设计
解决一道动态规划的题目,最主要的就是状态设计和状态转移
一个个区间,都包含了[l,r],因此我们可以设置.每一个点,作为分段点
因此,我们得出了.f[i]表示[1,i]区间的最大利润
状态转移
假如说,我们现在位于i这个节点处.那么对于这个点而言,显然包含它的区间的右端点一定为i
换种表达为,[s,i]为包含这个端点的区间
当然s是属于一类集合,也就是,所有右端点为i的区间.
因此我们不难推导出转移方程.
f[i]=f[i−1]不选择当前任何一个区间
f[i]=max(f[i],f[sj]+(i−sj+1))选择[sj,i]这个区间i−sj+1为该区间的利润
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
const int N=3e6+10;
int f[N];
vector&amp;lt;int&amp;gt; g[N];
int n;

int main()
{
	cin&amp;gt;&amp;gt;n;
	
	int r=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		int a,b;
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
		r=max(r,b);
		g[b].push_back(a);
	}
	
	for(int i=1;i&amp;lt;=r;i++)
	{
		f[i]=f[i-1];
		for(int j=0;j&amp;lt;g[i].size();j++)
        {
            int t=g[i][j];
			f[i]=max(f[i],f[t-1]+(i-t+1));
        }
	}
	
	printf(&amp;quot;%d\n&amp;quot;,f[r]);
	
	return 0;
}

二分+DP

线段不重复，可以借用贪心的思想，对右端点进行从小到大的排序，排除后效性。
以 f[i]表示前 i 条线段中选出若干条（必选第 i 条）的最大总长度。
简单地说，就是只要保证后一条线段不与当前线段重合，就可以添加当前线段。
f[i]=max(f[j],r(j)&amp;lt;l(i)+length(i)

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
const int N=150010;
int f[N];
struct line
{
	int l,r;
	int val;
	
	bool operator&amp;lt;(const line &amp;amp;W) const
	{
		return r&amp;lt;W.r;
	}
}g[N];
int n;

int find(int l,int r,int key)
{
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(g[mid].r &amp;lt; key) l=mid;
		else r=mid-1;
	}
	
	return l;
}

int main()
{
	cin&amp;gt;&amp;gt;n;

	for(int i=1;i&amp;lt;=n;i++)
	{
		int x,y;
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
		g[i].l=x,g[i].r=y,g[i].val=y-x+1;
	}
	
	sort(g+1,g+n+1);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		f[i]=f[i-1];
		int t=find(0,i-1,g[i].l);
		f[i]=max(f[i],f[t]+g[i].val);
		
	}
	
	printf(&amp;quot;%d\n&amp;quot;,f[n]);
	
	return 0;
}

P1419
题意：求一个连续子段，其长度在[S,T]之间，使其平均值最大。保留三位小数


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
double a[N];
double s[N];
int q[N];
int n;
int S,T;

bool check(double mid)
{
	for(int i=1;i&amp;lt;=n;i++)	
		s[i]=s[i-1]+a[i]-mid;
		
	int hh=0,tt=-1;

	for(int i=S;i&amp;lt;=n;i++)
	{
		if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-T &amp;gt; q[hh])
			hh++;

		while(hh &amp;lt;= tt &amp;amp;&amp;amp; s[q[tt]] &amp;gt;= s[i-S])
			tt--;
		q[++tt]=i-S;
		
		if(hh&amp;lt;=tt &amp;amp;&amp;amp; s[i] &amp;gt;= s[q[hh]])
			return true;
	}
	return false;
}

int main()
{
	cin&amp;gt;&amp;gt;n;
	cin&amp;gt;&amp;gt;S&amp;gt;&amp;gt;T;
	
	double l=10000,r=-10000;
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%lf&amp;quot;,&amp;amp;a[i]);
		r=max(r,a[i]);
		l=min(l,a[i]);
	}
	
	while(r-l&amp;gt;1e-5)
	{
		double mid=l+(r-l)/2;
		if(check(mid))
			l=mid;
		else 
			r=mid;
	}
		
	printf(&amp;quot;%.3f\n&amp;quot;,l);
	
	return 0;
}

反思
一直没有推到最后一步。依然在判断a[l]+...+a[r]≥k∗(r−l+1)的子序列的存在问题。
事实上这样的判断让二分没有意义了。我们是在找最大的一段a了，跟k完全没有关系。因为是求平均值，一段和较大的子序列不一定平均值就大了。我们巧妙地通过将k移项，使平均值问题转化为了求和问题。
P1258
由题意知，若要二人一起到达B点时耗时相同且最短，则二人走的路程、坐车的路程以及走和坐车的时间相同，并且车只能回接一次。设第一个人走的路程为x、时间为t1，坐车的时间为t2，车返回接另一个人所用时间为t3，
则t1=x/a，t2=(s-x)/b，t3=(s-2x)/b;（甲和乙走的路程均为x）
t2+t3=t1=(2s-3x)/b=x/a,解得x=2as/(3a+b) 故轻松地用数学解出此题。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;

int main()
{
	double s,a,b;
	cin&amp;gt;&amp;gt;s&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	double x=2*a*s/(3*a+b);
	
	printf(&amp;quot;%.6f\n&amp;quot;,x/a+(s-x)/b);
	
	return 0;
}

既然是个二分题，当然也可以用二分做了。我们可以二分车回接另一个人时的位置，算出若在此位置车回接，二人到终点分别的总耗时t1、t2，若t1==t2，输出答案，若t1&amp;gt;t2，使左端点等于mid，若t1&amp;lt;t2，则使右端点等于mid，直至有答案产生或两端点的差距小于1e-8为止。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const double eps=1e-8;
double s,a,b;

int main()
{
	cin&amp;gt;&amp;gt;s&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	
	double l=0,r=s;
	while(r-l&amp;gt;1e-8)
	{
		double mid=l+(r-l)/2;
		
		double t1=(s-mid)/a+mid/b;
		double t2=mid/b+
				(mid-mid/b*a)/(a+b)+
				(s-(mid/b+(mid-mid/b*a)/(a+b))*a)/b;
		if(t1 &amp;gt; t2)
			l=mid;
		else 
			r=mid;
	}
	
	printf(&amp;quot;%.6f\n&amp;quot;,l/b+(s-l)/a);
	
	return 0;
}

P2678
可以去模拟这个跳石头的过程。开始你在i(i=0)位置，我在跳下一步的时候去判断我这个当前跳跃的距离，如果这个跳跃距离比二分出来的mid小，那这就是一个不合法的石头，应该移走。为什么？我们二分的是最短跳跃距离，已经是最短了，如果跳跃距离比最短更短岂不是显然不合法，是这样的吧。移走之后要怎么做？先把计数器加上1，再考虑向前跳啊。去看移走之后的下一块石头，再次判断跳过去的距离，如果这次的跳跃距离比最短的长，那么这样跳是完全可以的，我们就跳过去，继续判断，如果跳过去的距离不合法就再拿走，这样不断进行这个操作，直到i = n+1，为啥是n+1？河中间有n块石头，显然终点在n+1处。
模拟完这个过程，我们查看计数器的值，这个值代表的含义是我们以mid作为答案需要移走的石头数量，然后判断这个数量 是不是超了就行。如果超了就返回false，不超就返回true。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=50010;
int d[N];
int L,n,m;

bool check(int mid)
{
	int cnt=0,last=0;
	for(int i=1;i&amp;lt;=n;i++)
		if(d[i]-last &amp;lt; mid) cnt++;
		else last=d[i];
		
	return cnt&amp;lt;=m;
}

int main()
{
	cin&amp;gt;&amp;gt;L&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	
	for(int i=1;i&amp;lt;=n;i++)
		cin&amp;gt;&amp;gt;d[i];
		
	d[++n]=L;
	int l=0,r=L;
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(check(mid))
			l=mid;
		else 
			r=mid-1;
	}
	
	cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;endl;
	
	return 0;
}

acwing499

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=2e5+10;
int w[N],v[N];
int l[N],r[N];
LL s[N];
int cnt[N];
LL n,m,S;
LL ans;

LL get(int mid)
{
	for(int i=1;i&amp;lt;=n;i++)
	{
		if(w[i] &amp;gt;= mid)
		{
			s[i]=s[i-1]+v[i];
			cnt[i]=cnt[i-1]+1;
		}
		else 
		{
			s[i]=s[i-1];
			cnt[i]=cnt[i-1];
		}
	}
	
	LL res=0;
	for(int i=1;i&amp;lt;=m;i++)
		res+=((cnt[r[i]]-cnt[l[i]-1])*(s[r[i]]-s[l[i]-1]));
	
	return res;
}

int main()
{
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;S;
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;w[i],&amp;amp;v[i]);
		
	for(int i=1;i&amp;lt;=m;i++)
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l[i],&amp;amp;r[i]);
		
	int l=1,r=1e6+1;//r要多1，才能枚举到一个都不选的情况 
	
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(get(mid) &amp;gt;= S)
			l=mid;
		else 
			r=mid-1;
	}
	
	cout &amp;lt;&amp;lt; min(abs(get(r) - S), abs(get(r + 1)-S)) &amp;lt;&amp;lt; endl;
	//r为&amp;gt;=S的情况下最小值，而求的是abs最小，需要和r+1情况下的最小值比较一下 
	
	return 0;
}

poj3104


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1e5+10;
typedef long long LL;
int a[N];
int n,k;

bool check(int mid)
{
	LL sumt=0;
	for(int i=0;i&amp;lt;n;i++)
	{
		if(a[i] &amp;gt; mid)
			sumt+=(a[i]-mid+k-2)/(k-1);//上取整 
	}
	
	return sumt &amp;lt;= mid;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	int l=1,r=0;
	for(int i=0;i&amp;lt;n;i++) scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]),r=max(r,a[i]);
	
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
	
	if(k == 1)
	{
		cout&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl;
		return 0;
	}

	while(l&amp;lt;r)
	{
		int mid=l+r&amp;gt;&amp;gt;1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	
	cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;endl;
	
	return 0;
}

poj2002


解题思路：

把输入数据放入哈希表
根据两个点（x1,y1）,(x2,y2），得到另外2个点（x3,y3）,(x4,y4），在哈希表中查找是否存在，如果存在，计数；
根据两个点（x1,y1）,(x2,y2），得到另外2个点（x5,y5）,(x6,y6），在哈希表中查找是否存在，如果存在，计数；
计数时每个正方形每条边都枚举了一次，所以答案除以4。。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=1010,mod=1003;
typedef pair&amp;lt;int,int&amp;gt; PII;
int px[N],py[N];
int h[N],ne[N],idx;
PII e[N];
int n;

void insert(int x,int y)
{
	int k=(x*x+y*y)%mod;
	e[idx]=make_pair(x,y);
	ne[idx]=h[k];
	h[k]=idx++;
}

bool find(int x,int y)
{
	int k=(x*x+y*y)%mod;
	for(int i=h[k];~i;i=ne[i])
	{
		PII t=e[i];
		if(t.first == x &amp;amp;&amp;amp; t.second == y) return true;
	}
	return false;
}

int main()
{
	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		memset(h,-1,sizeof h);
		idx=0;
		for(int i=0;i&amp;lt;n;i++)
		{
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;px[i],&amp;amp;py[i]);
			insert(px[i],py[i]);
		}
		
		int ans=0;
		for(int i=0;i&amp;lt;n;i++)
			for(int j=i+1;j&amp;lt;n;j++)
			{
				int x1=px[i]+(py[j]-py[i]);
				int y1=py[i]+(px[i]-px[j]);
				int x2=px[j]+(py[j]-py[i]);
				int y2=py[j]+(px[i]-px[j]);
				if(find(x1,y1) &amp;amp;&amp;amp; find(x2,y2))
					ans++;
			}
		
		for(int i=0;i&amp;lt;n;i++)
			for(int j=i+1;j&amp;lt;n;j++)
			{
				int x1=px[i]-(py[j]-py[i]);
				int y1=py[i]-(px[i]-px[j]);
				int x2=px[j]-(py[j]-py[i]);
				int y2=py[j]-(px[i]-px[j]);
				if(find(x1,y1) &amp;amp;&amp;amp; find(x2,y2))
					ans++;
			}
		
		ans&amp;gt;&amp;gt;=2;
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/er-fen/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/chi-qu-fa/">
                        尺取法
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-10</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-other_3">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            尺取法
尺取法（又称为：双指针、twopointers），是算法竞赛中一个常用的优化技巧，用来解决序列的区间问题，操作简单、容易编程。
如果区间是单调的，也常常用二分法来求解，所以很多问题用尺取法和二分法都行。
尺取法：顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。之所以需要掌握这个技巧，是因为尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以尺取法是一种高效的枚举区间的方法，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案。
使用尺取法时应清楚以下四点：
1、  什么情况下能使用尺取法?
2、何时推进区间的端点？
3、如何推进区间的端点？
4、何时结束区间的枚举？
尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。
尺取法的概念
什么是尺取法？为什么尺取法能优化呢？
考虑下面的应用背景：
（1）给定一个序列。有时候需要它是有序的，先排序。
（2）问题和序列的区间有关，且需要操作2个变量，可以用两个下标（指针）i、j扫描区间。
对于上面的应用，一般的做法，是用i、j分别扫描区间，有两重循环，复杂度O(n2)。以反向扫描（即i、j方向相反，后文有解释）为例，代码是：
for(int i = 0; i &amp;lt; n; i++)           //i从头扫到尾
	for(int j = n-1; j &amp;gt;= 0; j--){   //j从尾扫到头
        ......
    }

下面用尺取法来优化上面的算法。
实际上，尺取法就是把两重循环变成了一个循环，在这个循环中一起处理i和j。复杂度也就从O(n2n^2n2)变成了O(n)。仍以上面的反向扫描为例，代码是：
//用while实现：
int i = 0, j = n - 1;
while (i &amp;lt; j) {      //i和j在中间相遇。这样做还能防止i、j越界
        ......       //满足题意的操作
        i++;         //i从头扫到尾
        j--;         //j从尾扫到头
}
//用for实现：
for (int i = 0, j = n - 1; i &amp;lt; j; i++, j--) {
    ......
}

在尺取法中，这两个指针i、j，有两种扫描方向：
（a）反向扫描。i、j方向相反，i从头到尾，j从尾到头，在中间相会。
（b）同向扫描。i、j方向相同，都从头到尾，可以让j跑在i前面。
把同向扫描的i、j指针称为“快慢指针”，把反向扫描的i、j指针称为“左右指针”，更加形象。快慢指针在序列上产生了一个大小可变的“滑动窗口”，有灵活的应用
反向扫描
1.找指定和的整数对
这个问题是尺取法最经典，也最简单直接的应用。
输入n ( n≤100,000)个整数，放在数组a[]中。找出其中的两个数，它们之和等于整数m(假定肯定有解)。题中所有整数都是int型。
样例输入：
21 4 5 6 13 65 32 9 23
28
样例输出：
5 23
说明：样例输入的第一行是数组a[]，第2行是m = 28。样例输出5和23，相加得28。
为了说明尺取法的优势，下面给出四种方法：
（1）用两重循环暴力搜，枚举所有的取数方法，复杂度O(n2)，超时。暴力法不需要排序。
（2）二分法。首先对数组从小到大排序，复杂度O(nlogn)；然后，从头到尾处理数组中的每个元素a[i]，在大于a[i]的数中二分查找是否存在一个等于 m - a[i]的数，复杂度也是O(nlogn)。两部分相加，总复杂度仍然是O(nlogn)。
（3）Hash。分配一个hash空间s，把n个数放进去。逐个检查a[]中的n个数，例如a[i]，检查m - a[i]在s中是否有值，如果有，那么存在一个答案。复杂度是O(n)。
hash方法很快，但是需要一个额外的、可能很大的hash空间。
（4）尺取法。这是标准解法。首先对数组从小到大排序；然后，设置两个变量i和j，分别指向头和尾，i初值是0，j初值是n-1，然后让i和j逐渐向中间移动，检查a[i]+a[j]，如果大于m，就让j减1，如果小于m，就让i加1，直至a[i]+a[j] = m。排序复杂度O(nlogn)，检查的复杂度O(n)，合起来总复杂度O(nlogn)。
void find_sum(int a[], int n, int m){ 
     sort(a, a + n - 1);      //先排序，复杂度O(nlogn)
     int i = 0, j = n - 1;    //i指向头，j指向尾
     while (i &amp;lt; j){           //复杂度O(n)
		    int sum = a[i] + a[j];
		    if (sum &amp;gt; m)   j--;
		    if (sum &amp;lt; m)   i++;
		    if (sum == m){     
			    cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; a[j] &amp;lt;&amp;lt; endl;  //打印一种情况
                i++;          //可能有多个答案，继续
		    }
	  }
}

判断回文串
2.给一个字符串，判断它是不是回文串。
“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”就是回文串。写一个程序判断读入的字符串是否是“回文”。如果是，输出“yes”，否则输出“no”。
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main(){
    int n;
    cin &amp;gt;&amp;gt; n;                         //n是测试用例个数
    while(n--){
        string s;  cin &amp;gt;&amp;gt; s;          //读一个字符串
        bool ans = true;
        int i = 0, j = s.size() - 1;  //双指针
        while(i &amp;lt; j){ 
            if(s[i] != s[j]){
                ans = false;
                break;
            }
            i++;   j--;               //移动双指针
        }
        if(ans)   cout &amp;lt;&amp;lt; &amp;quot;yes&amp;quot; &amp;lt;&amp;lt; endl;
        else      cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot;  &amp;lt;&amp;lt; endl;
    }
    return 0;
}

允许删除（或插入，本题只考虑删除）最多1个字符，判断是否能构成回文字符串。
设反向扫描双指针为i、j。如果 s[i]和s[j]相同，i++、j–；如果s[i]和s[j]不同，那么，或者删除s[i]，或者删除s[j]，看剩下的字符串是否是回文串即可。
同向扫描
1.寻找区间和
这是用尺取法产生“滑动窗口”的典型例子。
给定一个长度为n的数组a[]和一个数s，在这个数组中找一个区间，使得这个区间之和等于s。输出区间的起点和终点位置。
样例输入：
15
6 1 2 3 4 6 4 2 8 9 10 11 12 13 14
6
样例输出：
0 0
1 3
5 5
6 7
说明：样例输入的第1行是n=15，第2行是数组a[]，第3行是区间和s=6。样例输出，共有4个情况。
题解
指针i和j，i&amp;lt;=j，都从头向尾扫描，判断区间[i,j]的和是否等于s。
如何寻找区间和等于s的区间？如果简单地对i和j做二重循环，复杂度是O(n2n^2n2)。用尺取法，复杂度O(n)，操作步骤是：
（1）初始值i=0、j=0，即开始都指向第一个元素a[0]。定义sum是区间[i, j]的和，初始值sum = a[0]。
（2）如果sum等于s，输出一个解。继续，把sum减掉元素a[i]，并把i往后移动一位。
（3）如果sum大于s，让sum减掉元素a[i]，并把i往后移动一位。
（4）如果sum小于s，把j往后挪一位，并把sum的值加上这个新元素。
在上面的步骤中，有2个关键技巧：
（1）滑动窗口的实现。窗口就是区间[i,j]，随着i和j从头到尾移动，窗口就“滑动”扫描了整个序列，检索了所有的数据。i和j并不是同步增加的，窗口像一只蚯蚓伸缩前进，它的长度是变化的，这个变化，正对应了对区间和的计算。
（2）sum的使用。如何计算区间和？暴力的方法是从a[i]到a[j]累加，但是，这个累加的复杂度是O(n)的，会超时。如果利用sum，每次移动i或j的时候，只需要把sum加或减一次，就得到了区间和，复杂度是O(1)。这是“前缀和”递推思想的应用。
以下是几个经典的使用尺取法的例题，都是从挑战书上引用的。（尺取法通常会需要对某些量进行预处理，以便能在使用时快速地判断。
poj3061
题意：给定一个序列，找出最短的子序列长度，使得其和大于或等于S。


分析：首先，序列都是正数，如果一个区间其和大于等于S了，那么不需要在向后推进右端点了，因为其和也肯定大于等于S但长度更长，所以，当区间和小于S时右端点向右移动，和大于等于S时，左端点向右移动以进一步找到最短的区间，如果右端点移动到区间末尾其和还不大于等于S，结束区间的枚举。
Input：
10 15
5 1 3 5 10 7 4 9 2 8

二分+前缀和：
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int s[N];
int n,m;

bool check(int mid)
{
	for(int i=1;i&amp;lt;=n-mid+1;i++)
		if(s[i+mid-1]-s[i-1] &amp;gt;= m)
			return 1;
	return 0;
}

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
		
		for(int i=1;i&amp;lt;=n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i]),s[i]+=s[i-1];
			
		if(s[n] &amp;lt; m) 
		{
			cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl;
			continue;
		}
		
		int l=1,r=n;
		while(l&amp;lt;r)
		{
			int mid=l+r&amp;gt;&amp;gt;1;
			if(check(mid))
				r=mid;
			else 
				l=mid+1;
		}
		
		printf(&amp;quot;%d\n&amp;quot;,l);
	}
	return 0;
}

尺取法：
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int a[N];
int n,m;

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
		for(int i=0;i&amp;lt;n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		int ans=n+1;
		int sum=0;
		int l=0,r=0;
		while(1)
		{
			while(r&amp;lt;n &amp;amp;&amp;amp; sum&amp;lt;m)
				sum+=a[r],r++;
			
			if(sum &amp;lt; m) break;
			
			ans=min(ans,r-l);
			sum-=a[l++];//左端点向右移动以进一步找到最短的区间
		}
		
		if(ans == n+1) ans=0;
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

poj3320
题意：一本书有P页，每一页都一个知识点，求去最少的连续页数覆盖所有的知识点。
和上面的题一样的思路，如果一个区间的子区间满足条件，那么在区间推进到该处时，右端点会固定，左端点会向右移动到其子区间，且其子区间会是更短的，只是需要存储所选取的区间的知识点的数量，那么使用map进行映射以快速判断是否所选取的页数是否覆盖了所有的知识点。

当前区间若可行，则需在保证可行的前提下，缩小区间范围，将l指针右移
当前区间若不可行，则需要扩大区间范围，将r指针右移
当r已到末尾且l已经最优时，结束枚举

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;map&amp;gt;
using namespace std;
const int N=1000010;
int a[N],cnt[N];
map&amp;lt;int,int&amp;gt; m;
int tot;
int n;

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		if(!m[a[i]]) m[a[i]]=++tot;
		a[i]=m[a[i]];
	}
	
	int ans=n;
	int l=1,r=1;
	int sum=0;
	
	while(1)
	{
		while(r&amp;lt;=n &amp;amp;&amp;amp; sum&amp;lt;tot)
			if(cnt[a[r++]]++ == 0)
				sum++;
			
		if(sum &amp;lt; tot) break;
		ans=min(ans,r-l);
		if(--cnt[a[l++]] == 0) sum--;
	}
	
	printf(&amp;quot;%d\n&amp;quot;,ans);
	
	return 0;
}

poj2566
题意：给你n个数字，这些数字可正可负，再给你个数字t,求在这个数列中一个连续的子序列，和的绝对值与t相差最小
一般来说，我们必须要保证数列单调性，才能使用尺取法。
预处理出前i个数的前缀和，和编号i一起放入pair中，然而根据前缀和大小进行排序。由于
abs(sum[i]-sum[j]) =  abs(sum[j]-sum[i])
可以忽视数列前缀和的前后关系。此时，sum[r]-sum[l]有单调性。
因此我们可以先比较当前sum[r]-sum[l]与t的差，并更新答案。
如果当前sum[r]-sum[l]&amp;lt;t,说明和还可以更大，r++。
同理，如果sum[r]-sum[l]&amp;gt;t，说明和还可以更小，l++。
如果sum[r]-sum[l]=t，必定是最小答案。

尺取的前提是一个有序的，可判定的序列，由于题目说的是连续序列和的绝对值，也就是说我们只需要知道两个端点
利用前缀和来进行判定，我们来枚举前缀和的两个端点，从而可以找到一个最接近询问值的数，
我们在存前缀和的同时还得把相应的坐标给存上，

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
#define x first
#define y second
typedef pair&amp;lt;int,int&amp;gt; PII;
const int N=100010,INF=0x3f3f3f3f;
PII s[N];
int n,m;
int ans,st,ed;

int main()
{
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m))
	{
		if(!n &amp;amp;&amp;amp; !m) break;
		s[0]=make_pair(0,0);
		for(int i=1;i&amp;lt;=n;i++)
		{
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i].x);
			s[i].y=i;
			s[i].x+=s[i-1].x;
		}
		
		sort(s,s+n+1);
		
		while(m--)
		{
			int t;
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
			int l=0,r=1;
			int mi=INF;
			while(r&amp;lt;=n)                                            
			{
				int val=s[r].x-s[l].x;
				if(abs(val-t) &amp;lt; mi)
				{                              
					mi=abs(val-t);
					ans=val;
					st=s[l].y;
					ed=s[r].y;
				}
				
				if(val &amp;lt; t) r++;
				else if(val &amp;gt; t) l++;
				else break;
				
				if(l == r) r++;
			}
			
			if(st &amp;gt; ed) swap(st,ed);
			
			printf(&amp;quot;%d %d %d\n&amp;quot;,ans,st+1,ed);
		}
	}
	return 0;
}


由于序列不能为空，如果l==r,则r++。
我们更新答案的时候左右区间端点为乱序，输出的时候调整一下。

poj2739
题意：找到某一个区间使得区间内的数的和等于某一给定值k。
设输入为x，只要判断x是否可以表示为x=y(i)+y(i+1)+y(i+2)+...+y(i+m)，即可，其中y为某一个素数。只要设置两个变量i，j，分别指向这个连续素数串的头和尾，不停的移动寻找解即可。不过首先需要得到10000以内的所有素数，如果每次输入都计算这些素数，没有必要而且可能会超时，所以先把所有素数计算出来并存储在一个数组中。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=10010;
int primes[N],cnt;
int n;

bool isprime(int x)
{
	for(int i=2;i*i&amp;lt;=x;i++)
		if(x%i == 0) 
			return false;
	return true;
}

void init(int n)
{
	for(int i=2;i&amp;lt;=n;i++)
		if(isprime(i))
			primes[cnt++]=i;
}

int main()
{
	init(N-1);

	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n))
	{
	    if(!n) break;
	    int l=0,r=0;
    	int ans=0;
    	int sum=0;
    	
    	while(1)
	    {
    		while(r&amp;lt;cnt &amp;amp;&amp;amp; sum&amp;lt;n)
    			sum+=primes[r++];
    		if(sum &amp;lt;n) break;
    		
    		if(sum == n)
    			ans++;
    		sum-=primes[l++];
	    }
	    
	    printf(&amp;quot;%d\n&amp;quot;,ans);
	}

	return 0;
}

poj2100
题意:给你一个数，询问有多少种连续自然数的平方和等于这个数，输出所有可能
题解:尺取法遍历所有符合条件的区间，满足的话记录左边界以及右边界，计数器+1。
尺取法过程:


1.初始化左右端点


2.不断扩大右端点，直到满足条件


3.如果第二步中无法满足条件，则终止，否则更新结果


4.将左端点扩大1，然后回到第二步


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
#define x first 
#define y second
typedef long long LL;
typedef pair&amp;lt;int,int&amp;gt; PII;
const int N=1e7+10;
vector&amp;lt;PII&amp;gt; ans;
LL n;

int main()
{
	while(~scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n))
	{
		ans.clear();
		
		LL l=1,r=1;
		LL sum=0;
		
		while(1)
		{
			while(r*r &amp;lt;= n &amp;amp;&amp;amp; sum &amp;lt; n)
				sum+=r*r,r++;
			
			if(sum &amp;lt; n) break;
			
			if(sum == n) ans.push_back(make_pair(l,r-1));
			
			sum-=l*l,l++;
		}
		
		printf(&amp;quot;%d\n&amp;quot;,ans.size());
		for(int i=0;i&amp;lt;ans.size();i++)
		{
			printf(&amp;quot;%d &amp;quot;,ans[i].y-ans[i].x+1);
			for(int j=ans[i].x;j&amp;lt;ans[i].y;j++)
				printf(&amp;quot;%d &amp;quot;,j);
			printf(&amp;quot;%d\n&amp;quot;,ans[i].y);
		}	
	}
	
	return 0;
}

hdu5672

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=1e6+10;
char s[N];
int cnt[30];
int k;

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		memset(cnt,0,sizeof cnt);
		scanf(&amp;quot;%s&amp;quot;,s);
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
		int n=strlen(s);
		int l=0,r=0;
		LL ans=0;
		int sum=0;
		
		while(1)
		{
			while(r&amp;lt;n &amp;amp;&amp;amp; sum&amp;lt;k)
				if(cnt[s[r++]-&#39;a&#39;]++ == 0)
					sum++;
			
			if(sum &amp;lt; k) break;
			
			ans+=n-r+1;
			
			if(--cnt[s[l++]-&#39;a&#39;] == 0) sum--;
		}
		
		printf(&amp;quot;%lld\n&amp;quot;,ans);
	}
	return 0;
}

P1638
博览馆正在展出由世上最佳的 M 位画家所画的图画。
wangjy想到博览馆去看这几位大师的作品。
可是，那里的博览馆有一个很奇怪的规定，就是在购买门票时必须说明两个数字，a和b，代表他要看展览中的第 a 幅至第 b 幅画(包含 a 和 b)之间的所有图画，而门票的价钱就是一张图画一元。
为了看到更多名师的画，wangjy希望入场后可以看到所有名师的图画(至少各一张)。
可是他又想节省金钱。。。
作为wangjy的朋友，他请你写一个程序决定他购买门票时的 a 值和 b 值。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1e6+10,M=2010;
int a[N],cnt[M];
int n,m;

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		
	int l=1,r=1;
	int sum=0;
	int ans=n;
	int al=1,ar=n;//初始化
	
	while(1)
	{
		while(r&amp;lt;=n &amp;amp;&amp;amp; sum&amp;lt;m)
			if(cnt[a[r++]]++ == 0)
				sum++;
		
		if(sum &amp;lt; m) break;
		
		if(ans &amp;gt; r-l) ans=r-l,al=l,ar=r-1;
		
		if(--cnt[a[l++]] == 0) sum--;
	}
	
	printf(&amp;quot;%d %d\n&amp;quot;,al,ar);
	
	return 0;
}

hdu5056

如果有一段字符刚刚好满足条件，那么后面的包含这个串的子串全部满足，我们可以尺取l和r，对于一个r满足的话，后面len  -  r + 1个子串也满足，然后更新l就可以了，因为l和r是分开更新的，所以复杂度是O(n)。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
char s[N];
int cnt[30];
int k;

int main()
{
    int T;
    cin&amp;gt;&amp;gt;T;
    while(T--)
    {
        memset(cnt,0,sizeof cnt);
        scanf(&amp;quot;%s&amp;quot;,s);
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
        int n=strlen(s);
        int l=0,r=0;
        LL ans=0;
        
        while(l&amp;lt;n)
        {
            while(r&amp;lt;n)
            {
                cnt[s[r]-&#39;a&#39;]++;
                if(cnt[s[r]-&#39;a&#39;] &amp;lt;= k)
                    ans+=r-l+1,r++;
                else 
                {
                    cnt[s[r]-&#39;a&#39;]--;
                    break;
                }
            }
                
            cnt[s[l]-&#39;a&#39;]--,l++;
        }
        printf(&amp;quot;%lld\n&amp;quot;,ans);
    }
    return 0;
}

hdu5358
log2(f(i,j))表示f(i,j)转换为2进制的长度，然后我们经过分析log2(f(i,j))+1的值域为[1,34]然后我们枚举log2(f(i,j))+1的值，例如我们枚举其值为k，对于一个k我们找到所有满足条件的区间(i,j),这个条件的代数表达为
2k−1+1&amp;lt;=f(i,j)+1&amp;lt;=2k2^{k-1}+1&amp;lt;= f(i,j)+1 &amp;lt;=2^k2k−1+1&amp;lt;=f(i,j)+1&amp;lt;=2k;
因此我们需要再枚举一个区间的左端点，对于一个给定的左端点，因为f(i,j)在给定i的情况下单调，我们可以用尺取法求得一个区间[l,r]，使得区间内的j (l&amp;lt;=j&amp;lt;=r)都瞒住log2sum(i,j)+1=klog_2sum(i,j)+1=klog2​sum(i,j)+1=k;
区间(i+j)的和可以表示为 i*(r-l+1) + (r+l)*(r-l+1)/2
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
LL s[N];
int n;

int main()
{
	//cout&amp;lt;&amp;lt;log2(1e10)&amp;lt;&amp;lt;endl;
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		
		for(int i=1;i&amp;lt;=n;i++)
		{
			scanf(&amp;quot;%lld&amp;quot;,&amp;amp;s[i]);
			s[i]+=s[i-1];
		}
		
		LL ans=0;
		for(LL k=1;k&amp;lt;=34;k++)
		{
			LL l=1,r=1;
			LL lmax=1ll&amp;lt;&amp;lt;(k-1),rmax=1ll&amp;lt;&amp;lt;k;
			if(k == 1) lmax=0;
			for(LL i=1;i&amp;lt;=n;i++)
			{
				l=max(l,i),r=max(r,i);
				while(l&amp;lt;=n &amp;amp;&amp;amp; s[l]-s[i-1] &amp;lt; lmax)
					l++;
				while(r&amp;lt;=n &amp;amp;&amp;amp; s[r]-s[i-1] &amp;lt; rmax)
					r++;
				r--;
				ans+=k*(i*(r-l+1)+(l+r)*(r-l+1)/2);
			}
		}
		printf(&amp;quot;%lld\n&amp;quot;,ans);
	}
	
	return 0;
}

P1102
我们考虑题目要求求出所有A-B=C的数对，我们可以先将原数组排序，然后就会发现每个数A，对应的数B一定是一段连续的区间。
然后我们再考虑如何去找到这个区间。
我们显然是要找到这个连续区间的左端点和右端点。
考虑到排序之后序列的有序性，我们枚举每个数，他们的左端点和右端点都是单调不降的，因此我们可以用双指针来维护这个东西。
具体的实现就是，我们维护两个右端点r1 , r2，每次r1右移到a[r1] - a[l] &amp;lt;c的最后位置的下一位，r2右移到满足a[r2] - a[l] &amp;lt;= c最后一位.
也就是说， 此时如果a[r2-1] - a[l] == c &amp;amp;&amp;amp; a[r1] - a[l] == c，中间的那一段一定都是满足条件的，我们让ans += r2 - r1即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=200010;
int a[N];

int main()
{
	int n,c;
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;c;
	for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;a[i];
	
	sort(a,a+n);
	
	int l=0,r1=0,r2=0;
	LL ans=0;
	
	while(l&amp;lt;n)
	{
		while(r1&amp;lt;n &amp;amp;&amp;amp; a[r1]-a[l] &amp;lt; c) r1++;
		while(r2&amp;lt;n &amp;amp;&amp;amp; a[r2]-a[l] &amp;lt;= c) r2++;
		if(a[r2-1] - a[l] == c &amp;amp;&amp;amp; a[r1]-a[l] == c)
			ans+=r2-r1;
		l++;
	}
	printf(&amp;quot;%lld\n&amp;quot;,ans);
	
	return 0;
}

uva11572
给出 n个数，找尽量长的一个子序列，使得该子序列中没有重复的元素。
右指针往右跳到不重复的最远位置,更新答案,然后左指针往右跳一位,左右指针都只跳了n次,所以查询的复杂度是O(n)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;map&amp;gt;
using namespace std;
const int N=1e6+10;
int a[N],b[N],cnt[N];
int n;

int main()
{
	int T;
	cin&amp;gt;&amp;gt;T;
	while(T--)
	{
		
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i=0;i&amp;lt;n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]),b[i]=a[i];
			
		sort(b,b+n);
		
		int tot=unique(b,b+n)-b;
		
		for(int i=0;i&amp;lt;n;i++)
			a[i]=lower_bound(b,b+tot,a[i])-b;

		int l=0,r=0;
		int ans=0;
		
		for(int i=0;i&amp;lt;tot;i++) cnt[i]=0;
		
		while(r&amp;lt;n)
		{
			while(r&amp;lt;n &amp;amp;&amp;amp; cnt[a[r]] == 0)
				cnt[a[r++]]++;
			
			ans=max(ans,r-l);
			
			cnt[a[l++]]--;
		}
		
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

cf660C
大意：给定一个包含nn个元素的数组aa。数组a的每个元素不是00就是11。
现在，让我们用f(a)表示a中连续元素序列中最长子段的长度，它只包含数字1。并且你最多可以将k个0更改为1来得到最大的f(a)。
贪心：对于一个含0的区间，我们让区间中的0都填满是最优的
于是维护一段区间，保证区间中的0的个数≤k就可以
于是就可以对于0的个数≤k时右移右端点，增添新的位置，扩大区间；
当[l,r]中0的个数＞k时右移l，到[l,r]中0的个数≤k时为止
注意边界和初始化
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=3e5+10;
int a[N];
int n,k;

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k);
	for(int i=1;i&amp;lt;=n;i++)	
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		
	int l=1,r=1;
	int ans=0;
	int sum=0;
	int al=0,ar=0;
	
	while(r&amp;lt;=n)
	{
		while(r&amp;lt;=n &amp;amp;&amp;amp; sum&amp;lt;=k)
		{
			if(!a[r])
			{
				if(sum == k) break;//注意点！
				else sum++;
			}
			r++;
		}
		
		if(ans &amp;lt; r-l) ans=r-l,al=l,ar=r-1;
		
		if(!a[l++]) sum--;
	}
	
	printf(&amp;quot;%d\n&amp;quot;,ans);
	for(int i=1;i&amp;lt;=n;i++)
		if(i&amp;gt;=al &amp;amp;&amp;amp; i&amp;lt;=ar)
			printf(&amp;quot;1 &amp;quot;);
		else 
			printf(&amp;quot;%d &amp;quot;,a[i]);
		
	return 0;
}

尺取法的模型便是这样：根据区间的特征交替推进左右端点求解问题，其高效的原因在于避免了大量的无效枚举，其区间枚举都是根据区间特征有方向的枚举。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/chi-qu-fa/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/qian-zhui-he-chai-fen/">
                        前缀和 差分
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-08</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            前缀和
给定一个序列a[1−n]a[1-n]a[1−n]。
有很多次询问，每个询问形如:l r  询问a[l,r]a[l,r]a[l,r]的区间和。
每次询问的复杂度要求 O(1)

预处理时间复杂度O(n)O(n)O(n)
for(int i=1;i&amp;lt;=n;i++)
{
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
    s[i]=s[i-1]+a[i];
}

a[l,r]a[l,r]a[l,r]的区间和: s[r]-s[l-1]
查询时间复杂度O(1)O(1)O(1)
while(m--)
{
    int l,r;
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l,&amp;amp;r);
    printf(&amp;quot;%d\n&amp;quot;,s[r]-s[l-1]);
}

PS:前缀和下标从1开始
区间加/差分
给定一个序列a[1−n]a[1-n]a[1−n](初值全为0)。
有很多次操作，每个操作形如:l r  将a[l,r]a[l,r]a[l,r]的每个值加上k。
最后输出整个数组。复杂度要求O(n)O(n)O(n)

区间加[l,r]，实际上是发生了这两件事：
a[l]比前一个元素多了k;
a[r+1]比前一个元素少了k.

我们用数组b表示刚刚的差值，b[i]=a[i]-a[i-1].
那么：区间加[𝒍,𝒓]，可以化为这两个操作： b[l]+=k; b[r+1]-=k;
void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}

因此，一次区间加只修改这两个元素； 最后利用b数组求出a数组(a数组为b数组的前缀和)，对b数组求一遍前缀和即为答案。
for(int i=1;i&amp;lt;=n;i++)
{
    b[i]+=b[i-1];
    printf(&amp;quot;%d &amp;quot;,b[i]);
}

PS:数组a初值为0，进行n次插入操作可得到数组a。
for(int i=1;i&amp;lt;=n;i++)
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
for(int i=1;i&amp;lt;=n;i++)
    insert(i,i,a[i]);

总结：差分无需构造，前缀和需构造
通过上述的两个方法，我们能轻易地处理这两类问题：

数组固定，然后大量询问；
大量做区间加，最后要你给出这个数组。

例题
Luogu2879
有好几头牛从１到n线性排列，每头牛的高度为h[i]现在告诉你这里面的牛的最大高 度为maxH,而且有r组关系，每组关系输入两个数字，假设为a和b,表示第a头牛能看到第b头牛，能看到的条件是a, b之间的其它牛的高度都严格小于min(h[a], h[b]),而 h[b] &amp;gt;= h[a] 最后求所有牛的可能最高身高输出
思路：
首先假设所有牛都是最高身高。 读入的约束信息需要去重，这个利用排序或者set可以解决。 可以发现对于每个位置h[i],假设它被覆盖了x次，最后答案就是h[i]-x. 如果出现了一对[l,r]，把区间(l,r)的数都-1就可以了。（注意区间开闭）
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;set&amp;gt; 
using namespace std;
const int N=10010;
int height[N];
set&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; S;

int main()
{
	int n,i,h,r;
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;i&amp;gt;&amp;gt;h&amp;gt;&amp;gt;r;
	height[1]=h;//差分数组 
	
	while(r--)
	{
		int a,b;
		cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
		if(a&amp;gt;b)
			swap(a,b);
		if(!S.count({a,b}))
		{
			S.insert({a,b});
			height[a+1]--;
			height[b]++;
		}
	}
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		height[i]+=height[i-1];
		cout&amp;lt;&amp;lt;height[i]&amp;lt;&amp;lt;endl;
	}
	return 0;
 } 

Luogu3406
该铁路经过N个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好 ，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车 票。第i段铁路连接了城市i和城市i+1(1&amp;lt;=i&amp;lt;N)。如果搭乘的比较远，需要购买多张 车票。第i段铁路购买纸质单程票需要Ai博艾元。 虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了IC卡。对于第i段 铁路，需要花Ci博艾元的工本费购买一张IC卡，然后乘坐这段铁路一次就只要扣 Bi(Bi&amp;lt;Ai)元。IC卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应 的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于 第i段铁路的IC卡，无法乘坐别的铁路的车。 Uim现在需要出差，要去M个城市，从城市P1出发分别按照P1,P2,P3...PM的顺序访 问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且 不会是同一个城市。 现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和 充值的总费用。
直接模拟每段铁路的覆盖即可
 #include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
 int a[N];
 int b[N];//差分数组 
 typedef long long LL;
 
 int main()
 {
 	int n,m;
 	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
 	for(int i=1;i&amp;lt;=m;i++)
 		cin&amp;gt;&amp;gt;a[i];
 	for(int i=1;i&amp;lt;m;i++)
 	{
 		b[min(a[i],a[i+1])]++;
 		b[max(a[i],a[i+1])]--;
	 }
	 
	 for(int i=1;i&amp;lt;=n;i++)
	 	b[i]+=b[i-1];
	
//	for(int i=1;i&amp;lt;=n;i++)
//		cout&amp;lt;&amp;lt;&amp;quot;--&amp;quot;&amp;lt;&amp;lt;b[i]&amp;lt;&amp;lt;&#39; &#39;;
	
	LL sum=0;
	for(int i=1;i&amp;lt;n;i++)
	{
		LL ai,bi,ci;
		cin&amp;gt;&amp;gt;ai&amp;gt;&amp;gt;bi&amp;gt;&amp;gt;ci;
		sum+=min(ai*b[i],ci+bi*b[i]);
	}
	
	cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;
	return 0;
 }

Luogu1083
思路1：
利用差分数组存每天的教室使用情况，然后求前缀和，如果发现不符合要求，就从后往前撤回订单，直到每天都符合要求，那么我们撤回的最后一个（也就是最靠前的一个）即为ans
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int l[N],r[N],d[N];
int res=INF;

int main()
{
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	
	for(int i=1;i&amp;lt;=m;i++)
	{
		scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;d[i],&amp;amp;l[i],&amp;amp;r[i]);
		b[l[i]]+=d[i];
		b[r[i]+1]-=d[i];
	}
	
	int j=m;//从后往前撤回订单，直至满足要求 
	int sum=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		sum+=b[i];
		//cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;&#39; &#39;;
		if(sum&amp;gt;a[i])
		{
			//从后往前撤回 
			while(sum&amp;gt;a[i])
			{
				b[l[j]]-=d[j];
				b[r[j]+1]+=d[j];
				if(i&amp;gt;=l[j] &amp;amp;&amp;amp; i&amp;lt;=r[j])
					sum-=d[j];
				j--;
			}
			res=min(res,j);
		}	
	}
	
	if(res==INF)
		cout&amp;lt;&amp;lt;&amp;quot;0&amp;quot;;
    else 
		cout&amp;lt;&amp;lt;&amp;quot;-1&amp;quot;&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;res+1&amp;lt;&amp;lt;endl;
    return 0;
}

思路2：
在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
int n,m;
const int N=1000010,INF=0x3f3f3f3f;
int a[N];
int b[N];
int s[N],t[N],d[N];

bool check(int x)//判断前x份订单能否全部满足 
{
	memset(b,0,sizeof b);
	for(int i=1;i&amp;lt;=x;i++)
	{
		b[s[i]]+=d[i];
		b[t[i]+1]-=d[i];
	}

	for(int i=1;i&amp;lt;=n;i++)
	{
		b[i]+=b[i-1];
		if(b[i]&amp;gt;a[i])
			return false;
	}
	return true;
}

int main()
{
//	freopen(&amp;quot;test.in.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin);
//	freopen(&amp;quot;test.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	
	for(int i=1;i&amp;lt;=m;i++)
	{
		scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;d[i],&amp;amp;s[i],&amp;amp;t[i]);
	}
	if(check(m))
	{
		puts(&amp;quot;0&amp;quot;);
		return 0;
	}
	int l=0,r=m;//l取成0，防止无解情况 
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(check(mid))
			l=mid;
		else	
			r=mid-1;
	}
	cout&amp;lt;&amp;lt;-1&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;l+1&amp;lt;&amp;lt;endl;

    return 0;
}

前缀和+差分
luoguP3948
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N=80010;
typedef long long LL;
LL b[N];
int sum[N];
int n,opt,minn,maxx,l,r,x,f;
LL mod;
char ch[5];

int main()
{
    scanf(&amp;quot;%d%d%lld%d%d&amp;quot;,&amp;amp;n,&amp;amp;opt,&amp;amp;mod,&amp;amp;minn,&amp;amp;maxx);
    for(int j=1;j&amp;lt;=opt;j++){
        scanf(&amp;quot;%s%d%d%&amp;quot;,&amp;amp;ch,&amp;amp;l,&amp;amp;r);
        if(ch[0]==&#39;A&#39;){
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
            b[l]+=x;
            b[r+1]-=x;
        }
        else{
            int ans=0;
			LL now=0;
            for(int i=1;i&amp;lt;=r;i++){
                now+=b[i];
                if(i&amp;gt;=l&amp;amp;&amp;amp;(now*i)%mod&amp;gt;=minn&amp;amp;&amp;amp;(now*i)%mod&amp;lt;=maxx)ans++;
            }
            printf(&amp;quot;%d\n&amp;quot;,ans);
        }
    }
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;f);
    for(int i=1;i&amp;lt;=n;i++){
        b[i]+=b[i-1];
        if((b[i]*i)%mod&amp;gt;=minn&amp;amp;&amp;amp;(b[i]*i)%mod&amp;lt;=maxx)sum[i]=sum[i-1]+1;
        else sum[i]=sum[i-1];
    }
    for(int j=1;j&amp;lt;=f;j++){
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l,&amp;amp;r);
        printf(&amp;quot;%d\n&amp;quot;,sum[r]-sum[l-1]);
    }
    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/qian-zhui-he-chai-fen/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/">
                        单调数据结构
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-08</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            单调栈

给定一个序列。对序列中的每个元素，求出它左侧的第一个小于它 的元素的位置。若没有这样的元素，输出0。

样例输入：
4
5 3 7 4
样例输出：
0 0 2 2

模板题1
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
int stk[N],top;

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    while(n--)
    {
        int x;
        cin&amp;gt;&amp;gt;x;
        while(top&amp;amp;&amp;amp;stk[top]&amp;gt;=x)
            top--;
        if(top)  
            cout&amp;lt;&amp;lt;stk[top]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        else 
            cout&amp;lt;&amp;lt;-1&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        stk[++top]=x;
    }
    return 0;
}

模板题2
找出第 i 个元素之后第一个大于 ai的元素的下标
分析：
从后往前枚举，对于i&amp;lt;j,若a[i]&amp;gt;=a[j],则j不可能成为下标小于i的元素的答案。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=3e6+10;
int stk[N],top;
int n;
int a[N];
int ans[N];

int main()
{
	cin&amp;gt;&amp;gt;n;
	for(int i=1;i&amp;lt;=n;i++) scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	
	for(int i=n;i&amp;gt;=1;i--)
	{
		while(top &amp;amp;&amp;amp; a[stk[top]] &amp;lt;= a[i]) top--;
		
		if(top) ans[i]=stk[top];
		else ans[i]=0;
		
		stk[++top]=i;
		
	}
	
	for(int i=1;i&amp;lt;=n;i++) printf(&amp;quot;%d &amp;quot;,ans[i]);
	return 0;
}

例题
poj2559

首先考虑最大面积的矩形X的左右边界的性质：
设其左边界为L，右边界为R，则其高H = min{h[i] | L &amp;lt;= i &amp;lt;= R}
此时最大面积为 (R - L + 1) * H
若此时左边界的左边那个矩形的高度 h[L-1] &amp;gt;= H
则左边界可以向左拓展，则新的面积为：
(R - (L-1) + 1) * H &amp;gt; 原面积
则与原假设条件冲突
故左边界左边的那个矩形的高度 :h[L-1] &amp;lt; H
同理右边界右边的那个矩形的高度： h[R+1] &amp;lt; H
设H = h[i]
所以左边界L是满足h[j-1] &amp;lt; h[i]的最大的j，即从i点向左遍历的第一个高度比i小的点的右边一个点
而右边界R是满足 h[j+1] &amp;lt; h[i]的最小的j，即从i点向右遍历第一个高度比i小的点的左边一个点
所以我们可以利用单调栈的性质得到每个确定点，即确定高度的最大面积矩形的左右边界，然后枚举取最大即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const int N=100010;
int h[N];
int l[N],r[N];
int stk[N],top;
int n;

int main()
{
	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		top=0;
		for(int i=1;i&amp;lt;=n;i++)
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i]);
		
		for(int i=1;i&amp;lt;=n;i++)//找出h[i]左边第一个小于h[i]的位置 
		{
			while(top &amp;amp;&amp;amp; h[stk[top]] &amp;gt;= h[i]) 
				top--;
			
			if(top) l[i]=stk[top]+1;
			else l[i]=1;//表示左边没有比h[i]小的位置 
			
			stk[++top]=i;
		}
		
		top=0;
		for(int i=n;i&amp;gt;=1;i--)//找出h[i]右边第一个小于h[i]的位置 
		{
			while(top &amp;amp;&amp;amp; h[stk[top]] &amp;gt;= h[i])
				top--;
			if(top) r[i]=stk[top]-1;
			else r[i]=n;//表示右边没有比h[i]大的位置 
				
			stk[++top]=i; 
		}
		
		LL ans=0;
		for(int i=1;i&amp;lt;=n;i++)
			ans=max(ans,(LL)h[i]*(r[i]-l[i]+1));
	
		printf(&amp;quot;%lld\n&amp;quot;,ans);
	}
	return 0;
}

P1901
对于一个新的信号塔:

当他加入栈中时,会挡住之前比它低的塔的传播,同时 , 也会接受到比它低的塔的信号
所以将栈顶所有比它低的塔删除,(因为他们已经不能再传播给其他塔信号了),同时 , 新的塔接收到的能量加上 删掉的塔传播的能量
对于原有的高度比它高的信号塔,离此新的信号塔最近的(当前栈顶元素),会接受到新的塔的信号
再将此新的信号塔加入栈中,最后O(n)扫一遍后,输出最大值即可

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1e6+10;
int stk[N],top;
int sum[N];
int h[N],w[N];
int n;

int main()
{
	cin&amp;gt;&amp;gt;n;
	for(int i=1;i&amp;lt;=n;i++)
	{
		cin&amp;gt;&amp;gt;h[i]&amp;gt;&amp;gt;w[i];
		
		while(top &amp;amp;&amp;amp; h[stk[top]] &amp;lt;= h[i])
			sum[i]+=w[stk[top--]];
		sum[stk[top]]+=w[i];
		
		stk[++top]=i;
	}
	
	int ans=0;
	for(int i=1;i&amp;lt;=n;i++)
		ans=max(ans,sum[i]);
	
	printf(&amp;quot;%d\n&amp;quot;,ans);
	return 0;
}

P1823
先假设每个人身高不同，脑补一下走过整个队列。

观察队伍中的一个人A。如果我们他后面找到了一个比他不知道高到哪里去了的B，A就不能与B后面的人谈笑风生了。
因此我们可以维护一个单调栈，记录我们已经找到过的高人，显然栈上的高人们按高度的降序排列，栈顶的人最矮。
当我们找到一个新的高人时，他可以向栈里比他矮的人传授人生经验，并让他们出栈。如果出栈之后栈非空，他还可以与栈顶的高人谈笑风生。然后我们再另请这位高明进栈。
我们还要考虑两个人身高相同的情况。我们可以在栈里存pair&amp;lt;身高，人数&amp;gt;并维护它。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef pair&amp;lt;int,int&amp;gt; PII;
#define x first
#define y second
typedef long long LL;
const int N=500010;
int h[N];
PII stk[N];
int top;
int n;

int main()
{
	cin&amp;gt;&amp;gt;n;
	LL ans=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i]);
		
		PII p=make_pair(h[i],1);
		while(top &amp;amp;&amp;amp; stk[top].x &amp;lt;= h[i])
		{
			if(stk[top].x == h[i]) 
				p.y+=stk[top].y;
			ans+=stk[top].y;
			top--;
		}
		
		if(top) ans++;
		stk[++top]=p;
	}
	printf(&amp;quot;%lld\n&amp;quot;,ans);
	return 0;
}

单调队列

模板题

单调队列与普通队列不一样的地方就在于单调队列既可以从队首出队，也可以从队尾出队。
那么我们应该怎样实现单调队列呢?
就拿样例来谈谈，设以最小的为标准。

8 3
1 3 -1 -3 5 3 6 7
下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。


由于此时队中没有一个元素，我们直接令1进队。此时，q={1},p={1}。


现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q={1,3},p={1,2}


下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从队尾出队。同理，1从队尾出队。最后-1进队，此时q={-1},p={3}


出现-3，同上面分析，-1&amp;gt;-3，-1从队尾出队,-3从队尾进队。q={-3}，p={4}。


出现5，因为5&amp;gt;-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q={-3,5},p={4,5}


出现3。3先与队尾的5比较，3&amp;lt;5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q={-3,3},p={4,6}


出现6。6与3比较，因为3&amp;lt;6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从队首出队。此时，q={3,6},p={6,7}


出现7。队尾元素6小于7，7进队。此时，q={3,6,7},p={6,7,8}。


那么，我们对单调队列的基本操作已经分析完毕。因为单调队列中元素大小单调递(增/减/自定义比较)，因此，队首元素必定是最值。按题意输出即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=1000010;
int a[N];
int q[N];
int n,k;

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k);
	
	int hh=0,tt=-1;
	
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		
	for(int i=1;i&amp;lt;=n;i++)//求滑动窗口最小值 
	{
		if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-k&amp;gt;= q[hh]) hh++;
		while(hh &amp;lt;= tt &amp;amp;&amp;amp; a[q[tt]] &amp;gt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &amp;gt;= k)
			printf(&amp;quot;%d &amp;quot;,a[q[hh]]);
	}
	puts(&amp;quot;&amp;quot;);
	
	hh=0,tt=-1;
	for(int i=1;i&amp;lt;=n;i++)
	{
		if(hh &amp;lt;= tt &amp;amp;&amp;amp; i-k&amp;gt;=q[hh]) hh++;
		while(hh &amp;lt;= tt &amp;amp;&amp;amp; a[q[tt]] &amp;lt;= a[i])
			tt--;
		q[++tt]=i;
		if(i &amp;gt;= k)
			printf(&amp;quot;%d &amp;quot;,a[q[hh]]);
	}
	return 0;
}

acwing135

#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int N = 300010, INF = 0x3f3f3f3f;
int n, m;
int s[N];
int q[N];

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i ++ ) scanf(&amp;quot;%d&amp;quot;, &amp;amp;s[i]), s[i] += s[i - 1];

    int res = -INF;
    int hh = 0, tt = -1;
    q[++tt]=0;//将s[0]入队
    for (int i = 1; i &amp;lt;= n; i ++ )
    {
        if(hh&amp;lt;=tt &amp;amp;&amp;amp; i-m &amp;gt; q[hh]) hh++;
        res=max(res,s[i]-s[q[hh]]);
        while (hh &amp;lt;= tt &amp;amp;&amp;amp; s[q[tt]] &amp;gt;= s[i]) tt -- ;
        q[ ++ tt] = i;
    }

    printf(&amp;quot;%d\n&amp;quot;, res);

    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/dan-diao-shu-ju-jie-gou/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/gao-jing-du/">
                        高精度
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-08</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-other_1">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            高精度加法
当进行加法运算的数字较大时，受存储范围限制，无法使用int或longlong型变量进行存储。
考虑到加法运算的本质，不妨将数字拆开来存储。
对于一个超过变量存储数据范围的数字，可以将这个数字拆开，拆成一位一位的，或者是几位几位的存储到一个数组中， 用一个数组去表示一个数字
采用用顺序存储数据方式，会有一个问题：最高位进位变得很困难。
最高位在num[0]，所以一旦有进位，需要将num[]数组中每一位都往后移，时间复杂度O(len)
·倒序存储·：num[]数组从0到len-1依次存储整数个位到最高位。则最高位进位时，只需要num[len++]=t，t为最高位数字
进位：
方法一：设一个变量t，记录当前进位
边计算边进位和逐位相加不进位最后再统一进位效果是一样的如下，先进行一遍逐位相加。
然后，从0开始遍历一遍ans.num[]，将本位大于9的部分进位给更高位。
最后判断是否最高位有进位，有则ans.len++
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=510;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum add(bignum a,bignum b)
{
	bignum c;
	c.len=max(a.len , b.len);
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]+b.m[i];
	for(int i=0;i&amp;lt;c.len;i++)
		if(c.m[i] &amp;gt; 9)
		{
			c.m[i+1]+=1;
			c.m[i]-=10;
		}
	if(c.m[c.len]) c.len++;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	scanf(&amp;quot;%s&amp;quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&amp;lt;len;i++)
		b.m[len-i-1]=s[i]-&#39;0&#39;;
	bignum c=add(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

高精度减法

判断正负
基本和加法一模一样，只不过从进位变成退位
退位后更新结果长度
模板题

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=10100;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

int judge(bignum a,bignum b)
{
	if(a.len &amp;gt; b.len) return 1;
	if(a.len &amp;lt; b.len) return -1;
	for(int i=a.len-1;i&amp;gt;=0;i--)
	{
		if(a.m[i] &amp;gt; b.m[i]) return 1;
		if(a.m[i] &amp;lt; b.m[i]) return -1;
	}
	return 0;
}

bignum Minus(bignum a,bignum b)
{
	if(judge(a,b) == -1)
	{
		printf(&amp;quot;-&amp;quot;);
		return Minus(b,a);
	}

	bignum c;
	c.len=a.len;
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]-b.m[i];
	for(int i=0;i&amp;lt;c.len;i++)
		if(c.m[i] &amp;lt; 0)
		{
			c.m[i+1]-=1;
			c.m[i]+=10;
		}
	while(c.len &amp;gt; 1 &amp;amp;&amp;amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	scanf(&amp;quot;%s&amp;quot;,s);
	len=strlen(s);
	b.len=len;
	for(int i=0;i&amp;lt;len;i++)
		b.m[len-i-1]=s[i]-&#39;0&#39;;
	bignum c=Minus(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

高精度乘法
1.高精*低精
将加法运算改为乘法运算即可。
注意：

进位的运算
最高位进位的处理，可能不止进一位
模板题

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]*b;
	for(int i=0;i&amp;lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
		if(i == c.len-1 &amp;amp;&amp;amp; c.m[i+1]) c.len++;
	}

	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	int b;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;b);

	bignum c=mul(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

2.高精*高精
乘法竖式中，a.num[i]和b.num[j]相乘的结果，放在了ans.num[i+j]的位置。
a,b都为正整数时，长度为a.len和b.len的数字相乘得到ans，则

模拟上例竖式运算过程即可
{模板题](https://www.luogu.com.cn/problem/P1303}
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=4010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};

bignum mul(bignum a,bignum b)
{
	bignum c;
	c.len=a.len+b.len;
	for(int i=0;i&amp;lt;a.len;i++)
		for(int j=0;j&amp;lt;b.len;j++)
			c.m[i+j]+=a.m[i]*b.m[j];
	for(int i=0;i&amp;lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
	}
	while(c.len &amp;gt; 1 &amp;amp;&amp;amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a,b;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	scanf(&amp;quot;%s&amp;quot;,s);
	b.len=len=strlen(s);
	for(int i=0;i&amp;lt;len;i++)
		b.m[len-i-1]=s[i]-&#39;0&#39;;
	bignum c=mul(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	return 0;
}

高精度除法
1.高精/低精
除法是从高位到低位进行运算的。使用一个临时变量来记录余数，注意细节
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010;
char s[N];
struct bignum
{
	int m[N],len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};
int t;

bignum Div(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	t=0;
	for(int i=c.len-1;i&amp;gt;=0;i--)
	{
		t=t*10+a.m[i];
		c.m[i]=t/b;
		t%=b;
	}
	while(c.len &amp;gt; 1 &amp;amp;&amp;amp; !c.m[c.len-1]) c.len--;
	return c;
}

int main()
{
	scanf(&amp;quot;%s&amp;quot;,s);
	bignum a;
	int len=strlen(s);
	a.len=len;
	for(int i=0;i&amp;lt;len;i++)
		a.m[len-i-1]=s[i]-&#39;0&#39;;
	
	int b;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;b);
	bignum c=Div(a,b);
	for(int i=c.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,c.m[i]);
	puts(&amp;quot;&amp;quot;);
	printf(&amp;quot;%d\n&amp;quot;,t);

	return 0;
}

数楼梯
斐波那契递推
code
P1249
【思路】
1、这道题预先需要知道的一点是：数越多，乘积越大。
“1”对于乘积是没有收益的，我们要从2~n-1中选出尽可能多的数，使它们的和为n。然后把选出的数相乘就是答案。
2、两个特例，“3”和“4”。这两个只能从拆成“1+2”和“1+3”
【流程】
输入——选数——高精度乘法——输出。（选数时和高精度乘法无关）
【如何选数】
我们就以13为例，“2”、“3”、“4”都可以选，但是“5”如果选了，sum（2，3，4，5）=14超过13，5不能选。此时sum（2，3，4）=9，还余4，我们把4这个值分配到“2”、“3”、“4”这三个数上。
怎么分最好？这里有两个原则：
（1）增长的数的个数越多，乘积越大。“2+1”、“3+1”、“4+2”优于“2”、“3”、“4+4”；
（2）若只有部分数能增长，那么本身大的增长后，乘积更大。“2”、“3”、“4+1”优于“2+1”、“3”、“4”
所以对于 “2”、“3”、“4”，余4 来说。
可以都增长，那么变成 “2+1”、“3+1”、“4+1”，余1 。
不能都增长，那么变成 “3”、“4”、“5+1”，余0
【高精度乘法】
选数之后就是把所有选择的数相乘，因为最终值可能很大，所以需要用到高精度乘法，关于高精度乘法，不赘述。
【代码】
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
const int N=40010;
struct bignum
{
	int m[N];
	int len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};
vector&amp;lt;int&amp;gt; num;
int n;

void init()
{
	int sum=0;
	for(int i=2;i&amp;lt;n;i++)
		if(sum + i &amp;gt; n)
		{
			int remain=n-sum;
			while(remain)
			{
				for(int j=num.size()-1;j&amp;gt;=0;j--)
				{
					remain--;
					num[j]++;
					if(!remain) return;
				}
			}
		}
		else num.push_back(i),sum+=i;
}

bignum mul(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]*b;
	for(int i=0;i&amp;lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
		if(i == c.len-1 &amp;amp;&amp;amp; c.m[i+1]) c.len++;
	}
	return c;
}

int main()
{
	cin&amp;gt;&amp;gt;n;
	
	if(n == 3)
	{
		cout&amp;lt;&amp;lt;1&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;2&amp;lt;&amp;lt;endl;
		cout&amp;lt;&amp;lt;2&amp;lt;&amp;lt;endl;
	}
	else if(n == 4)
	{
		cout&amp;lt;&amp;lt;1&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;3&amp;lt;&amp;lt;endl;
		cout&amp;lt;&amp;lt;3&amp;lt;&amp;lt;endl;
	}
	else 
	{
		init();
		
		bignum ans;
		ans.m[0]=1,ans.len=1;
		
		for(int i=0;i&amp;lt;num.size();i++)
			ans=mul(ans,num[i]);
		
		for(int i=0;i&amp;lt;num.size();i++)
			cout&amp;lt;&amp;lt;num[i]&amp;lt;&amp;lt;&#39; &#39;;
		cout&amp;lt;&amp;lt;endl;
		
		for(int i=ans.len-1;i&amp;gt;=0;i--)
			printf(&amp;quot;%d&amp;quot;,ans.m[i]);
		puts(&amp;quot;&amp;quot;);
	}
	return 0;
}


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int N=10010,M=40010,INF=0x3f3f3f3f;
struct bignum
{
	int m[M];
	int len;
	bignum()
	{
		memset(m,0,sizeof m);
		len=0;
	}
};
double w[N];
double f[N];
int trans[N];
vector&amp;lt;int&amp;gt; num;
int n;

bignum mul(bignum a,int b)
{
	bignum c;
	c.len=a.len;
	for(int i=0;i&amp;lt;c.len;i++) c.m[i]=a.m[i]*b;
	
	for(int i=0;i&amp;lt;c.len;i++)
	{
		c.m[i+1]+=c.m[i]/10;
		c.m[i]%=10;
		if(i == c.len-1 &amp;amp;&amp;amp; c.m[i+1]) c.len++;
	}
	return c;
}

int main()
{
	cin&amp;gt;&amp;gt;n;
	
	for(int i=1;i&amp;lt;=n;i++) w[i]=log(i);
	
	for(int i=1;i&amp;lt;=n;i++) f[i]=-INF;
	
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=n;j&amp;gt;=i;j--)
			if(f[j-i]+w[i] &amp;gt; f[j])
				f[j]=f[j-i]+w[i],trans[j]=j-i;
				
	for(int p=n;p;p=trans[p])
		num.push_back(p-trans[p]);
 
	bignum ans;
	ans.m[0]=1,ans.len=1;
	
	for(int i=num.size()-1;i&amp;gt;=0;i--)
		ans=mul(ans,num[i]);
	
	for(int i=num.size()-1;i&amp;gt;=0;i--)
		cout&amp;lt;&amp;lt;num[i]&amp;lt;&amp;lt;&#39; &#39;;
	cout&amp;lt;&amp;lt;endl;
	
	for(int i=ans.len-1;i&amp;gt;=0;i--)
		printf(&amp;quot;%d&amp;quot;,ans.m[i]);
	puts(&amp;quot;&amp;quot;);
	
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/gao-jing-du/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/bei-zeng-st-biao-rmq/">
                        倍增 ST表 RMQ
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-28</time>
                    
                        <a href="https://caifxh.github.io/tag/PJzBixWKZ/" class="post-tag i-tag
                            i-tag-success">
            #其他算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            倍增





ST表


ST表创建



ST表查询


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;//使用log函数
/*log():以e为底的对数，exp(5)=e^5,log(exp(5))=5
  log10():以10为底的对数
  log2():以2为底的对数 
  任何一个其它的对数logm(n)=log(n)/log(m)*/
using namespace std;
const int maxn=105;
int n,a[maxn],F[maxn][maxn];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

void ST_create()
{
	for(int i=1;i&amp;lt;=n;i++)//初始化 
		F[i][0]=a[i];
	int k=log2(n);//log(n)/log(2);
	for(int j=1;j&amp;lt;=k;j++)
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)//n-2^j+1
			F[i][j]=max(F[i][j-1],F[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
}

int ST_query(int l,int r)//求区间[l..r]的最值 
{
	int k=log2(r-l+1);
	return max(F[l][k],F[r-(1&amp;lt;&amp;lt;k)+1][k]);//取两个区间最值 
}

int ST_print()
{
	int k=log2(n);
	for(int j=0;j&amp;lt;=k;j++)
	{	
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)//n-2^j+1,打印第一列 
			cout&amp;lt;&amp;lt;F[i][j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
		cout&amp;lt;&amp;lt;endl;
	}
}

int ST_print2()//按列打印 
{
	int k=log2(n);
	for(int i=1;i&amp;lt;=n;i++)
	{
		for(int j=0;j&amp;lt;=k;j++)
			cout&amp;lt;&amp;lt;F[i][j]&amp;lt;&amp;lt;&#39; &#39;;
		cout&amp;lt;&amp;lt;endl;
	}
}

int main()
{
	int l,r;
	int i,v;
	cin&amp;gt;&amp;gt;n;
	for(i=1;i&amp;lt;=n;i++)
		cin&amp;gt;&amp;gt;a[i];//5 3 7 2 12 1 6 4 8 15
	ST_create();//创建ST表
	ST_print();
	cout&amp;lt;&amp;lt;&amp;quot;输入查询最值的区间l r:&amp;quot;&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;
	cout&amp;lt;&amp;lt;ST_query(l,r)&amp;lt;&amp;lt;endl;//求区间[l..r]的最值
	return 0;
}

例题
poj3264

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;//min,max
#include&amp;lt;cmath&amp;gt;//log
using namespace std;
const int maxn=50010;
int h[maxn];
int Fmax[maxn][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j
int Fmin[maxn][20];
int N,Q;

void ST_create()
{
	for(int i=1;i&amp;lt;=N;i++)//初始化 
		Fmax[i][0]=Fmin[i][0]=h[i];
	int k=log2(N);//log(N)/log(2.0);
	for(int j=1;j&amp;lt;=k;j++)
		for(int i=1;i&amp;lt;=N-(1&amp;lt;&amp;lt;j)+1;i++)//N-2^j+1
		{
			Fmax[i][j]=max(Fmax[i][j-1],Fmax[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
			Fmin[i][j]=min(Fmin[i][j-1],Fmin[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
		}			
}

int RMQ(int l,int r)//求区间[l..r]的最值差 
{
	int k=log2(r-l+1);
	int m1=max(Fmax[l][k],Fmax[r-(1&amp;lt;&amp;lt;k)+1][k]);
	int m2=min(Fmin[l][k],Fmin[r-(1&amp;lt;&amp;lt;k)+1][k]);
	return m1-m2;//取两个区间最值差 
}

int main()
{
	int a,b;
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;Q))
	{
		for(int i=1;i&amp;lt;=N;i++)//下标从1开始 
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;h[i]);
		ST_create();
		for(int j=1;j&amp;lt;=Q;j++)
		{
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
			printf(&amp;quot;%d\n&amp;quot;,RMQ(a,b));
		}
	}
	return 0;
}

poj3368



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=100010;
int lb[N];		
int f[N][20];//F(i,j)表示区间[i，i+2^j-1]的最值，区间长度为2^j

int n,Q;
int a[N];

void ST_create()
{	
	for(int j=1;j&amp;lt;=lb[n];j++)
		for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
			f[i][j]=max(f[i][j-1],f[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);	
}

int RMQ(int l,int r)
{
	if(l &amp;gt; r)
		return 0;
	int k=lb[r-l+1];
	return max(f[l][k],f[r-(1&amp;lt;&amp;lt;k)+1][k]);
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&amp;lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;amp;(i-1));
	while(~scanf(&amp;quot;%d%&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;Q);
		for(int i=1;i&amp;lt;=n;i++)
		{
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
			if(i == 1)
			{
				f[i][0]=1;
				continue;
			}
			if(a[i] == a[i-1])
				f[i][0]=f[i-1][0]+1;
			else 
				f[i][0]=1;
		}
		ST_create();
		for(int j=1;j&amp;lt;=Q;j++)
		{
			int l,r;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l,&amp;amp;r);
			int t=l;
			while(t&amp;lt;=r &amp;amp;&amp;amp; a[t] == a[t-1])
				t++;
			printf(&amp;quot;%d\n&amp;quot;,max(t-l,RMQ(t,r)));
		}
	}
	return 0;
}

hdu3468

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=200010;
int a[N];
int n,k;
int F[N][20],lb[N];

void Initlog()
{
	lb[0]=-1;
    for(int i=1;i&amp;lt;=N;i++)
        lb[i]=lb[i-1]+(i&amp;amp;(i-1)?0:1);
}

void ST()
{
    for(int i=1;i&amp;lt;=n;i++)
		F[i][0]=a[i];
    for(int j=1;j&amp;lt;=lb[n];j++)
        for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
            F[i][j]=max(F[i][j-1],F[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
}

int query(int l,int r)
{
    int k=lb[r-l+1];
    return max(F[l][k],F[r-(1&amp;lt;&amp;lt;k)+1][k]);
}

bool check(int mid)
{
    int t=n/mid,s=0;
    for(int i=0;i&amp;lt;mid;i++)
		s+=query(t*i+1,t*i+t);
    return s&amp;gt;k;
}

int main()
{
    lb[0]=-1;
	for(int i=1;i&amp;lt;N;i++)//求解所有log值,保存到数组lb[] 
		lb[i]=lb[i-1]+!(i&amp;amp;(i-1));
	while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k),n&amp;gt;=0||k&amp;gt;=0)
    {
        int sum=0;
        for(int i=1;i&amp;lt;=n;i++)
        {
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
            sum+=a[i];
        }
        if(sum&amp;lt;=k)
		{
			printf(&amp;quot;-1\n&amp;quot;);
			continue;
		}
		ST();
		int l=1,r=n;
		while(l&amp;lt;r)//二分找划分数 
    	{
	        int mid=(l+r)/2;
	        if(check(mid)) r=mid;
	        else l=mid+1;
    	}
		printf(&amp;quot;%d\n&amp;quot;,l);
    }
    return 0;
}

poj2019

#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
const int maxn=260,INF=0x3f3f3f3f;
using namespace std;
int a[maxn][maxn],lb[maxn];
int Fmax[maxn][maxn][8],Fmin[maxn][maxn][8];
int n,m,k;

void ST()
{
	for(int k=1;k&amp;lt;=n;k++)//多一维 
        for(int i=1;i&amp;lt;=n;i++)
            Fmax[k][i][0]=Fmin[k][i][0]=a[k][i];	
	for(int k=1;k&amp;lt;=n;k++)
		for(int j=1;j&amp;lt;=lb[n];j++)
			for(int i=1;i+(1&amp;lt;&amp;lt;j)-1&amp;lt;=n;i++)
			{
				Fmax[k][i][j]=max(Fmax[k][i][j-1],Fmax[k][i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
				Fmin[k][i][j]=min(Fmin[k][i][j-1],Fmin[k][i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
			}
}

int main()
{
	lb[0]=-1;
	for(int i=1;i&amp;lt;maxn;i++)
		lb[i]=(i&amp;amp;(i-1))?lb[i-1]:lb[i-1]+1;
	while(~scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k))
	{
		for(int i=1;i&amp;lt;=n;i++)
			for(int j=1;j&amp;lt;=n;j++)
				scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]);	
		ST();
		for(int i=0;i&amp;lt;k;i++)
		{
			int x,y;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
			int k=lb[m];
    		int maxx=-INF;
			int minx=INF;
    		int l=y,r=y+m-1;//从坐标为(x,y)的地方开始，右下扩展B长度 
    		for(int i=x;i&amp;lt;x+m;i++)//查询每一行的最值 
		    {
		        maxx=max(maxx,max(Fmax[i][l][k],Fmax[i][r-(1&amp;lt;&amp;lt;k)+1][k]));
		        minx=min(minx,min(Fmin[i][l][k],Fmin[i][r-(1&amp;lt;&amp;lt;k)+1][k]));
		    }
			printf(&amp;quot;%d\n&amp;quot;,maxx-minx);
		}
	}
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/bei-zeng-st-biao-rmq/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://caifxh.github.io/images/avatar.png?v=1594530304239)">
        </div>
        <h1 class="id_card-title">
            fxh&#39;blog
        </h1>
        <h2 class="id_card-description">
            菜鸡一枚
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>