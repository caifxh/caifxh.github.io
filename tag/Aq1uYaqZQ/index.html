<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    图论 | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1586059488314">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1586059488314" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        图论</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/ou-la-lu-jing/">
                        欧拉路径
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-04</time>
                    
                        <a href="https://caifxh.github.io/tag/Aq1uYaqZQ/" class="post-tag i-tag
                            i-tag-other_3">
            #图论
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            欧拉路
通过图（无向图或有向图）中所有边一次且仅一次行遍图中所有顶点的通路称为欧拉通路，通过图中所有边一次且仅一次行遍所有顶点的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。




(注意：这里说有向图连通，说的是有向图是弱连通图。即把有向图中的边变成无向边，只要该图连通，那么原有向图即是弱连通图。实际中可用并查集判断是否弱连通)



• 欧拉回路的求解方法主要有两种：

DFS搜索
Fleury算法

用 DFS 搜索思想求解欧拉回路的思路为：

利用欧拉定理判断出一个图存在欧拉通路或欧拉回路。
选择一个正确的起始顶点，用 DFS 算法遍历所有的边（每条边
只遍历一次），遇到走不通就回退。 • 在搜索前进方向上将遍历过的边按顺序记录下来。
这组边的排列就组成了一条欧拉通路或欧拉回路。

例题
给定 n 张骨牌，每张骨牌有左右两个点数（从 1 到 6）。问能不能
通过交换骨牌的顺序和交换左右两个点数，使得任意两个相邻骨牌的
相邻段为相等的数字。
原始： (1 2)(2 4)(2 4)(6 4)(2 1)
重排后： (4 2)(2 1)(1 2)(2 4)(4 6)
本题可以转化成欧拉回路或欧拉通路的求解问题。

首先要构造一个图？
每张骨牌当一个点？
如何解决交换骨牌内部两个点数？

图建好之后，先判断是否存在欧拉通路或欧拉回路。
总结：存在 ➔ 选择正确的起点 ➔ 6 ➔ 开始 DFS
acwing1123
我们将这个图看成有向图，对于每输入一组数据加两条有向边，需要每条边都至少走一遍
我们先回想一下存在有向图的欧拉路径的充分必要条件

所有点的入度都等于出度
除了两个点以外的点入度等于出度，

这两个点一个 入度 = 出度 + 1，另一个 入度 = 出度 - 1
因此，我们考虑每加一条边，每个点的入度和出度都加1
所以，每个点的入度都一定等于出度,符合上述的第一条
故这个图存在欧拉路径，并且可以选任意点为起点
所以我们只需统计所有的边的长度总和，跟据20km/h 算出时间即可
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;

using namespace std;

int main()
{
    double x1, y1, x2, y2;
    cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1;

    double sum = 0;
    while (cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2)
    {
        double dx = x1 - x2;
        double dy = y1 - y2;
        sum += sqrt(dx * dx + dy * dy) * 2;
    }

    int minutes = round(sum / 1000 / 20 * 60);
    int hours = minutes / 60;
    minutes %= 60;

    printf(&amp;quot;%d:%02d\n&amp;quot;, hours, minutes);

    return 0;
}

acwing1124
无向图的欧拉路径&amp;amp;欧拉回路裸题
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=510;
int n=500,m;
int g[N][N];
int ans[1100];
int cnt;
int d[N];

void dfs(int u)
{
    for(int i=1;i&amp;lt;=n;i++)//从小到大枚举，字典序最小
    {
        if(g[u][i])
        {
            g[u][i]--,g[i][u]--;
            dfs(i);
        }
    }
    
    ans[cnt++]=u;
}

int main()
{
    cin&amp;gt;&amp;gt;m;
    
    int l=500,r=1;
    while(m--)
    {
        int a,b;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
        l=min(l,min(a,b));
        r=max(r,max(a,b));
        g[a][b]++,g[b][a]++;
        d[a]++,d[b]++;
    }
    
    int start=l;
    for(int i=l;i&amp;lt;=r;i++)
    {
        if(d[i] % 2)
        {
            start=i;
            break;
        }
    }
    
    dfs(start);//欧拉回路从哪开始都可以搜，欧拉路要从奇点开始
    
    for(int i=cnt-1;i&amp;gt;=0;i--)//逆序输出
        printf(&amp;quot;%d\n&amp;quot;,ans[i]);
    return 0;
}

acwing1185
有向图，首尾连单词，可用DFS和并查集判断连通性
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
const int N = 26, L = 1005;
int n, cnt, g[N][N], in[N], out[N];
char s[L];

void dfs(int u) {
    for (int i = 0; i &amp;lt; 26; i++) {
        if(g[u][i]) {
            cnt++;
            g[u][i] --;
            dfs(i);
        }
    }
}
int main() {
    int T; scanf(&amp;quot;%d&amp;quot;, &amp;amp;T);
    while(T--) {
        cnt = 0;
        memset(g, 0, sizeof g);
        memset(in, 0, sizeof in);
        memset(out, 0, sizeof out);
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
        for (int i = 0; i &amp;lt; n; i++) {
            scanf(&amp;quot;%s&amp;quot;, s);
            int u = s[0] - &#39;a&#39;, v = s[strlen(s) - 1] - &#39;a&#39;;
            g[u][v]++;
            out[u]++, in[v]++;
        }

        bool ok = true;
        int s = 0, t = 0;
        for (int i = 0; i &amp;lt; 26; i++) {
            if(in[i] != out[i]) {
                if(in[i] == out[i] + 1) t ++;
                else if(in[i] + 1 == out[i]) s++;
                else { ok = false; break; }
            }
        }


        if(!(!s &amp;amp;&amp;amp; !t || (s == 1 &amp;amp;&amp;amp; t == 1))) ok = false;

        s = 0;
        while(!out[s]) s++;
        for (int i = 0; i &amp;lt; 26; i++)
            if(in[i] + 1 == out[i]) { s = i; break; }

        dfs(s);

        if(cnt &amp;lt; n) ok = false;
        puts(ok ? &amp;quot;Ordering is possible.&amp;quot; : &amp;quot;The door cannot be opened.&amp;quot;);
    }
    return 0;
}

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=30;
int n;
int din[N], dout[N], p[N];
bool st[N];


int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int t;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
    while(t--)
    {
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        memset(din,0,sizeof din);
        memset(dout,0,sizeof dout);
        memset(st,0,sizeof st);
        for(int i=0;i&amp;lt;26;i++)
            p[i]=i;
        
        for(int i=0;i&amp;lt;n;i++)
        {
            char str[1010];
            scanf(&amp;quot;%s&amp;quot;,str);
            int len=strlen(str);
            int a=str[0]-&#39;a&#39;,b=str[len-1]-&#39;a&#39;;
            st[a]=st[b]=true;
            dout[a]++,din[b]++;
            p[find(a)]=find(b);
        }
        
        int start=0,end=0;
        bool success=true;
        for(int i=0;i&amp;lt;26;i++)
            if(din[i] != dout[i])
            {
                if(din[i] == dout[i] + 1)
                    end++;
                else if(din[i] + 1 == dout[i])
                    start++;
                else
                {
                    success=false;
                    break;
                }
            }
            
        if(!(!start &amp;amp;&amp;amp; !end ||start == 1 &amp;amp;&amp;amp; end == 1))
            success=false;
        int rep = -1;
        for (int i = 0; i &amp;lt; 26; i ++ )
            if (st[i])
            {
                if (rep == -1) rep = find(i);
                else if (rep != find(i))
                {
                    success = false;
                    break;
                }
            }

        if (success) puts(&amp;quot;Ordering is possible.&amp;quot;);
        else puts(&amp;quot;The door cannot be opened.&amp;quot;);

    }
    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/ou-la-lu-jing/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/er-fen-tu/">
                        二分图
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-03</time>
                    
                        <a href="https://caifxh.github.io/tag/Aq1uYaqZQ/" class="post-tag i-tag
                            i-tag-primary">
            #图论
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            一、定义
二分图：是图论中的一种特殊模型。若能将无向图G=(V,E)的顶点V划分为两个交集为空的顶点集，并且任意边的两个端点都分属于两个集合，则称图G为一个为二分图。
二分图判定定理：一张无向图是二分图：当且仅当图中不存在奇环（奇环是指长度为奇数的环）
匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。

我们定义匹配点、匹配边、未匹配点、非匹配边，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。
最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。
完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。
举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。

交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边...形成的路径叫交替路。
增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：


增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。
二、二分图判定
据定义，可以知道如果对于一个图，我们将它的节点用黑白染色，那么如果它是二分图，它的每一条边的两端，都可以实现一黑一白。
所以在判定时，只需要根据这样的性质，对于每一个点，把它所有的未遍历的子节点染上和它不一样的颜色，如果最后没有哪一条边两端颜色一样，就说明它是一个二分图，否则就不是。
在代码实现的时候可以写成对于每一个点，把未遍历的子接点染上与它不同的颜色，如果存在子节点已经染过色了并且与它颜色相同，可以直接判定它不是一个二分图。、
看一个这样的图

会有这样的染色过程

最后4和5都是白色，gg。
到此我们就得到了整个图的算法：
1.选取一个未染色的点u进行染色
2.遍历u的相邻节点v：若v未染色，则染色成与u不同的颜色，并对v重复第2步；若v已经染色，如果 u和v颜色相同，判定不可行退出遍历。
3,若所有节点均已染色，则判定可行。
模板题
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c)
{
    color[u] = c;

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
        add(a, b), add(b, a);
    }

    bool flag = true;
    for (int i = 1; i &amp;lt;= n; i ++ )
        if (!color[i])
        {
            if (!dfs(i, 1))
            {
                flag = false;
                break;
            }
        }

    if (flag) puts(&amp;quot;Yes&amp;quot;);
    else puts(&amp;quot;No&amp;quot;);

    return 0;
}

（如果图是不连通的，要枚举起点）
acwing257
二分+染色法
为了让监狱内部的怨气值越小，则需要尽量把怨气值大的罪犯分开


check(x)：表示将任意怨气值大于x的两名罪犯放在两个监狱，且两个监狱内部的最大怨气值均不超过x，符合返回true，符合返回false


check(x)函数的实现，验证该图中是否为一个二分图，即监狱内部怨气值小于x的边均去掉，用染色法验证


注意：两个罪犯的怨气值最小的情况下是1，若监狱内部发生冲突事件怨气值的最大值一定大于等于1，而本年内监狱中未发生任何冲突事件，输出是0，因此二分的初始范围是l = 0，r = 10910^9109,
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=20010,M=200010;
int h[N],e[M],ne[M],w[M],idx;
int n,m;
int color[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u,int c,int mid)
{
    color[u]=c;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(w[i] &amp;lt;= mid)
            continue;
        if(!color[j])
        {
            if(!dfs(j,3-c,mid))
                return false;
        }
        else if(color[j] == c)
            return false;
    }
    return true;
}

bool check(int mid)
{
    memset(color,0,sizeof color);
    
    for(int i=1;i&amp;lt;=n;i++)
        if(!color[i])
            if(!dfs(i,1,mid))
                return false;
    
    return true;
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
    memset(h,-1,sizeof h);
    
    while(m--)
    {
        int a,b,c;
        scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);
        add(a,b,c);
        add(b,a,c);
    }
    
    int l=0,r=1e9;
    while(l&amp;lt;r)
    {
        int mid=l+r&amp;gt;&amp;gt;1;
        if(check(mid))
            r=mid;
        else
            l=mid+1;
    }
    
    cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;endl;
    
    return 0;
}

三、二分图最大匹配
看这么个图

ABCD是四个死宅，而1234是四个可爱的纸片人小姐姐
图中的连线表示死宅喜欢的小姐姐
现在我们要给他们配对
从A开始，A喜欢1

然后，B也喜欢1，那么反正A还可以要3，本着礼让的精神，A就让给了B

然后发现，C也喜欢1，反正B还可以找2，就把1让给C

D也喜欢1，但是C如果没有1，就找不到小姐姐了，那么作为一个死宅他是不会退让的。
这样我们就模拟了二分图匹配的全过程，这种方法就是匈牙利算法。
用不太正经的方法来说，匈牙绿算法就是一个绿与被绿协商与退让的过程。
模板题
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

int main()
{
    scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n1, &amp;amp;n2, &amp;amp;m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
        add(a, b);
    }

    int res = 0;
    for (int i = 1; i &amp;lt;= n1; i ++ )
    {
        memset(st, false, sizeof st);
        if (find(i)) res ++ ;
    }

    printf(&amp;quot;%d\n&amp;quot;, res);

    return 0;
}


acwing372

#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

#define x first
#define y second

using namespace std;

typedef pair&amp;lt;int, int&amp;gt; PII;

const int N = 110;

int n, m;
PII match[N][N];
bool g[N][N], st[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

bool find(int x, int y)
{
    for (int i = 0; i &amp;lt; 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a &amp;amp;&amp;amp; a &amp;lt;= n &amp;amp;&amp;amp; b &amp;amp;&amp;amp; b &amp;lt;= n &amp;amp;&amp;amp; !g[a][b] &amp;amp;&amp;amp; !st[a][b])
        {
            st[a][b] = true;
            PII t=match[a][b];
            if (t.x == -1 || find(t.x, t.y))
            {
                match[a][b] = {x, y};
                return true;
            }
        }
    }

    return false;
}

int main()
{
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

    while (m -- )
    {
        int x, y;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x][y] = true;
    }

    memset(match, -1, sizeof match);

    int res = 0;
    for (int i = 1; i &amp;lt;= n; i ++ )
        for (int j = 1; j &amp;lt;= n; j ++ )
            if ((i + j) % 2 &amp;amp;&amp;amp; !g[i][j])
            {
                memset(st, 0, sizeof st);
                if (find(i, j)) res ++ ;
            }

    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    return 0;
}

acwing373
将行标号当做二分图的左图，列标号当做二分图的右图，放置一枚車则表示对应的行和对应的列之间有边。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int MAXN=210;
bool g[MAXN][MAXN];
bool vis[MAXN];
int m,match[MAXN];
bool find(int x){
    for(int i=1;i&amp;lt;=m;i++){
        if(vis[i] || g[x][i])continue;
        vis[i]=1;
        if(!match[i] || find(match[i]))
        {
            match[i]=x;
            return true;
        }
    }
    return false;
}
int main()
{
    int n,t;
    scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;t);
    for(int i=1;i&amp;lt;=t;i++){
        int x,y;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
        g[x][y]=true;
    }
    int ans=0;
    for(int i=1;i&amp;lt;=n;i++)//枚举行
    {
        memset(vis,0,sizeof(vis));
        if(find(i)) ans++;
    }
    printf(&amp;quot;%d\n&amp;quot;,ans);
    return 0;
}

四、最小点覆盖
图G=(V,E),在图G中选取尽可能少的点，使得图中每一条边至少有一个端点被选中。换句话说，假如选了一个点就相当于覆盖了以它为端点的所有边，你需要选择最少的点来覆盖所有的边。
这个问题在二分图问题中被称为最小点覆盖问题。即用最少的点去覆盖所有的边。
König定理，二分图最小点覆盖 = 二分图最大匹配数
那么，怎么证明它是正确的呢？又怎么才能求出需要哪些点呢？
匈牙利算法中 我们从左边一个没有匹配的点，沿着一条满足“一条不被匹配，一条被匹配，下一条又没有被匹配”的路（交错路径）的路走。但是现在，最大匹配已经完成，没有这样的路了。也就是说，我们可以找到很多增广路，但是它们的终点不再是没匹配的。
我们可以从左边所有没匹配的点出发，按照“交错出现（走一个匹配过的再走一个没匹配的）”的要求走，标记经过的所有点（左右的点要分开标记详见代码）。

（蓝色细线为最大匹配，粗线为不完整的增广路，红点为最小点覆盖集，对号是标记）
可以发现，最小覆盖点集即左边没标记的和右边标记了的

为什么这样得到的点集点的个数恰好有M个呢？

因为每个点都是某个匹配边的其中一个端点。如果左边的哪个点是没有匹配过的，那么它就会被当成起点被标记；如果右边的哪个点是没有匹配过的，那就走不到它那里去（否则就找到了一条完整的增广路）。而一个匹配边又不可能右端点是标记了的，同时左端点是没标记的（不然的话左边的点就可以经过这条边到达了）。因此，最后我们圈起来的点与匹配边一一对应。

为什么这样得到的点集可以覆盖所有的边呢？

因为不可能存在某一条边，它的右端点是没有标记的，而左端点是有标记的。原因如下：如果这条边不属于我们的匹配边，那么右端点就可以通过这条边到达（从而得到标记）；如果这条边属于我们的匹配边，那么左端点不可能是一条路径的起点，于是它的标记只能是从这条边的右端点过来的，右端点就应该有标记。

为什么这是最小的点覆盖集呢？

因为不可能有比M还小的点覆盖集了，因为要覆盖这M条匹配边至少就需要M个点（再次回到匹配的定义）。
acwing376
题目描述到每台机器每次转换模式都需要启动一次，每个任务要么在A机器的a[i]模式进行，要么在B机器的b[i]模式进行，模式a[i]和模式b[i]连上一条边（这条边就对应于这个任务）。每条边至少选择1个模式点（这个点上可执行所有可在该模式下执行的任务），最少能选多少个模式(点)覆盖所有边，即求最小点覆盖问题
注意：两台机器一开始的模式是0，因此每个任务如果可以在模式为0的情况下进行，则不需要进行重启，可以舍去。
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 110;

int n, m, k;
int match[N];
bool g[N][N], st[N];

bool find(int x)
{
    for (int i = 0; i &amp;lt; m; i ++ )
        if (!st[i] &amp;amp;&amp;amp; g[x][i])
        {
            st[i] = true;
            if (match[i] == -1 || find(match[i]))
            {
                match[i] = x;
                return true;
            }
        }

    return false;
}

int main()
{
    while (cin &amp;gt;&amp;gt; n, n)
    {
        cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
        memset(g, 0, sizeof g);
        memset(match, -1, sizeof match);

        while (k -- )
        {
            int t, a, b;
            cin &amp;gt;&amp;gt; t &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
            if (!a || !b) continue;
            g[a][b] = true;
        }

        int res = 0;
        for (int i = 0; i &amp;lt; n; i ++ )
        {
            memset(st, 0, sizeof st);
            if (find(i)) res ++ ;
        }

        cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;
    }

    return 0;
}

uva11419
目大意：给定一个n行m列的网格图,某些网格上有敌人.请你选择一些行和一些列,覆盖所有敌人.并且使得选择的行与列数量之和最小
X集合表示行号，Y集合表示列号，如果在（i,j）的地方有目标则在X集合的i位置与Y集合的j位置连边，只要一条边有一个端点被选中则说明这个目标被打掉，这道题就转化为二分图的最小点覆盖数量
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
const int N = 1010;
int n, m, k;
int match[N];
bool g[N][N], st[N];
bool vis[N];
int pl[N],pr[N];

bool find(int x)
{
    for (int i = 1; i &amp;lt;= m; i ++ )
        if (!st[i] &amp;amp;&amp;amp; g[x][i])
        {
            st[i] = true;
            if (!match[i] || find(match[i]))
            {
                match[i] = x;
                vis[x]=true;//标记左边匹配的点 
                return true;
            }
        }

    return false;
}

void dfs(int x)
{
	pl[x]=true;
	for(int i=1;i&amp;lt;=m;i++)
		if(g[x][i])
		{
			if(match[i] &amp;amp;&amp;amp; !pr[i] &amp;amp;&amp;amp; !pl[match[i]])//v有一条匹配了的边&amp;amp;&amp;amp;v未被标记&amp;amp;&amp;amp;v的匹配对象未被标记
			{
				pr[i]=true;
				dfs(match[i]);
			}
		}
}

void print()
{
	memset(pl,0,sizeof pl);
	memset(pr,0,sizeof pr);
	for(int i=1;i&amp;lt;=n;i++)
		if(!vis[i])
			dfs(i);//以左侧未匹配点为起点
	
	for(int i=1;i&amp;lt;=n;i++)
		if(!pl[i])
			printf(&amp;quot;r%d &amp;quot;,i);//左侧的未标记点
		
	for(int i=1;i&amp;lt;=m;i++)
		if(pr[i])
			printf(&amp;quot;c%d &amp;quot;,i);//右侧的标记点
	
	printf(&amp;quot;\n&amp;quot;);
}

int main()
{
    while (cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k, n)
    {
        memset(g, 0, sizeof g);
        memset(match, 0, sizeof match);
		memset(vis,0,sizeof vis);
        while (k -- )
        {
            int a, b;
            cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
            g[a][b] = true;
        }

        int res = 0;
        for (int i = 1; i &amp;lt;= n; i ++ )
        {
            memset(st, 0, sizeof st);
            if (find(i)) res ++ ;
        }

        printf(&amp;quot;%d &amp;quot;,res);
        print(); 
    }

    return 0;
}

五、最大独立集
图G=(V,E)，在图G中选取尽可能多的点，使得任意两个点之间没有连边。找出一个包含顶点数最多的独立集称为最大独立集。
这个问题在二分图问题中被称为最大独立集问题。
方法：最大独立集=所有顶点数-最小顶点覆盖=所有顶点数-最大匹配数

在上面这个图中最小顶点覆盖=3，即2,4,7构成最小顶点覆盖，则其他点6个构成最大独立集。且其他点不可能相连。假设其他点相连则这条边必定没有被2,4,7 覆盖，与2,4,7是最小顶点覆盖矛盾。因此其他点之间必定没有边。而2,4,7是最小顶点覆盖，所谓最小就是不能再小了，因此我们的独立集就是最大了。
对应地，任意两点之间都有一条边相连的子图被称为无向图的“团”。点数最多的团被称为图的最大团。
定理：无向图G的最大团等于其补图G&#39;的最大独立集。
补图的定义是：对于图中点x和点y，若x和y之间有边，那么在补图中没有，否则有。
acwing378
两个格子的马若能互相攻击，则这两个格子能连上一条边，与棋盘覆盖 的题目相似，若两只马能够互相攻击则两只马的格子一定是两种类型的格子，如下图所示，选出最多个格子，使得选出的格子之间没有边，即求最大独立集问题

#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

#define x first
#define y second

using namespace std;

typedef pair&amp;lt;int, int&amp;gt; PII;

const int N = 110;

int n, m, k;
PII match[N][N];
bool g[N][N], st[N][N];

int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

bool find(int x, int y)
{
    for (int i = 0; i &amp;lt; 8; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a &amp;lt; 1 || a &amp;gt; n || b &amp;lt; 1 || b &amp;gt; m) continue;
        if (g[a][b]) continue;
        if (st[a][b]) continue;

        st[a][b] = true;

        PII t = match[a][b];
        if (t.x == 0 || find(t.x, t.y))
        {
            match[a][b] = {x, y};
            return true;
        }
    }

    return false;
}

int main()
{
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;

    for(int i=0;i&amp;lt;k;i++)
    {
        int x, y;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x][y] = true;
    }

    int res = 0;
    for (int i = 1; i &amp;lt;= n; i ++ )
        for (int j = 1; j &amp;lt;= m; j ++ )
        {
            if(!g[i][j] &amp;amp;&amp;amp; (i+j)%2)
            {
                memset(st, 0, sizeof st);
                if (find(i, j)) res ++ ;
            }
        }

    cout &amp;lt;&amp;lt; n * m - k - res &amp;lt;&amp;lt; endl;

    return 0;
}

六、DAG的最小路径点覆盖
定义：在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。
最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。

最小不相交路径覆盖：每一条路径经过的顶点各不相同。如图，其最小路径覆盖数为3。即1-&amp;gt;3&amp;gt;4，2，5。
最小可相交路径覆盖：每一条路径经过的顶点可以相同。如果其最小路径覆盖数为2。即1-&amp;gt;3-&amp;gt;4，2-&amp;gt;3&amp;gt;5。
特别的，每个点自己也可以称为是路径覆盖，只不过路径的长度是0。
DAG的最小不相交路径覆盖
DAG的最小路径覆盖是指找最小数目的互相不相交的有向路径,满足DAG的所有顶点都被覆盖.
公式:DAG的最小路径覆盖数=DAG图中的节点数-相应二分图中的最大匹配数.
下面我们来解释上面公式为什么成立
对应一个DAG,如何构造相应的二分图?对于DAG中的一个顶点p,二分图中有两个顶点p和p&#39;,对应DAG中的一条有向边p-&amp;gt;q,二分图中有p-q&#39;的一条无向边.二分图中p属于S集合,p&#39;属于T集合.

证明：上图中,对应左边的DAG建立构造右边的二分图,可以找到二分图的一个最大匹配M:1-3&#39;,3-4&#39;,那么M中的这两条匹配边怎样对应DAG中的路径的边?
使二分图中一条边对应DAG中的一条有向边,1-3&#39;对应DAG图中的有向边1-&amp;gt;3,这样DAG中1就会有一个后继顶点(3会是1的唯一后继,因为二分图中一个顶点至多关联一条边!),所以1不会成为DAG中一条路径中的结尾顶点,同样,3-4&#39;对应DAG中3-&amp;gt;4,3也不会成为结尾顶点,那么原图中总共4个顶点,减去2个有后继的顶点,就剩下没有后继的顶点,即DAG路径的结尾顶点,而每个结尾顶点正好对应DAG中的一条路径,二分图中寻找最大匹配M,就是找到了对应DAG中的非路径结尾顶点的最大数目,那么DAG中顶点数-|M|就是DAG中结尾顶点的最小数目,即DAG的最小路径覆盖数.
因为路径之间不能有公共点，所以加的边之间也不能有公共点，这是匹配的定义。
poj1422
题目大意：有n个点和m条有向边，现在要在点上放一些伞兵，然后伞兵沿着图走，直到不能走为止,每条边只能是一个伞兵走过，问最少放多少个伞兵
思路：
这是一个很明显的最小路径覆盖，用二分图来做,对于这样的一个有向图做最小路径覆盖。
首先建图，先拆点，将每个点分为两个点，左边是1到n个点，右边是1-n个点，然后每一条有向边对应左边的点指向右边的点，这样建好图之后求最大匹配数。
最小路径覆盖=点数-最大匹配数
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=130;
int n,m;				//交叉路口和街道的个数
int g[N][N];
int match[N];
bool st[N];
 
bool find(int x)
{
	for(int i=1;i&amp;lt;=n;i++)
		if(g[x][i] &amp;amp;&amp;amp; !st[i])
		{		
			st[i]=true;
			if (!match[i] || find(match[i]))
            {
                match[i] = x;
                return true;
            }
		}
		
	return false;
}
 
int main()
{
	int a,b,t;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
	while(t--)
	{
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
		memset(g,0,sizeof g);
		memset(match,0,sizeof match);
		for(int i=0;i&amp;lt;m;i++)
		{
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
			g[a][b]=1;
		}
		
		int res=0;
		for(int i=1;i&amp;lt;=n;i++)
		{
			memset(st,0,sizeof st);
			if(find(i)) res++;
		}
		
		cout&amp;lt;&amp;lt;n-res&amp;lt;&amp;lt;endl;
	}
	return 0;
}

DAG的最小可相交路径覆盖
先用floyd求出原图的传递闭包，即如果a到b有路径a-&amp;gt;...-&amp;gt;x-&amp;gt;...b，那么就加边a-&amp;gt;b。然后就转化成了最小不相交路径覆盖问题。
证明：为了连通两个点，某条路径可能经过其它路径的中间点。比如1-&amp;gt;3-&amp;gt;4，2-&amp;gt;4-&amp;gt;5。但是如果两个点a和b是连通的，只不过中间需要经过其它的点，那么可以在这两个点之间加边，那么a就可以直达b，不必经过中点的，那么就转化成了最小不相交路径覆盖。
poj2594
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=510;
int n,m;				//交叉路口和街道的个数
bool g[N][N];
int match[N];
bool st[N];

void floyd()
{
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=1;j&amp;lt;=n;j++)
			for(int k=1;k&amp;lt;=n;k++)
				g[i][j] |= g[i][k] &amp;amp;&amp;amp; g[k][j];
}
 
bool find(int x)
{
	for(int i=1;i&amp;lt;=n;i++)
		if(g[x][i] &amp;amp;&amp;amp; !st[i])
		{		
			st[i]=true;
			if (!match[i] || find(match[i]))
            {
                match[i] = x;
                return true;
            }
		}
		
	return false;
}
 
int main()
{
	while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m) &amp;amp;&amp;amp; n)
	{
		memset(g,0,sizeof g);
		memset(match,0,sizeof match);
		for(int i=0;i&amp;lt;m;i++)
		{
			int a,b;
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
			g[a][b]=1;
		}
		floyd();
		
		int res=0;
		for(int i=1;i&amp;lt;=n;i++)
		{
			memset(st,0,sizeof st);
			if(find(i)) res++;
		}
		
		cout&amp;lt;&amp;lt;n-res&amp;lt;&amp;lt;endl;
	}

	return 0;
}

其他题：
https://vjudge.net/contest/249592#overview

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/er-fen-tu/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/shu-shang-chai-fen/">
                        树上差分
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-03</time>
                    
                        <a href="https://caifxh.github.io/tag/Aq1uYaqZQ/" class="post-tag i-tag
                            i-tag-success">
            #图论
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            树上差分
树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。这就是树上差分的基本操作。
树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs遍历求出差分数组的前缀和，就可以达到降低复杂度的目的。
需要知道的树的性质:

树上任意两个点的路径唯一.
任何子节点的父亲节点唯一.(可以认为根节点是没有父亲的)

类比于差分数组,树上差分利用的思想也是前缀和思想.(在这里应该是子树和思想.
当我们记录树上节点被经过的次数,记录某条边被经过的次数的时候.
如果每次强制dfs去标记的话,时间复杂度将高到爆炸!
因此我们引入了树上差分!
与树上差分在一起的使用的是DFS，因为在回溯的时候,我们可以计算出子树的大小.
定义数组 cnticnt_icnti​为节点i被经过的次数.
1.点的差分
例如,我们从 s--&amp;gt;t ,求这条路径上的点被经过的次数.
很明显的,我们需要找到他们的LCA,(因为这个点是中转点啊
我们需要让cnt[s]++,让cnt[t]++，而让他们的cnt[lca]--，cnt[faher(lca)]--;
如图，绿色的数字代表经过次数.

根据刚刚所讲,我们的标记应该是这样的↓

考虑：我们搜索到s,向上回溯.
下面以u表示当前节点,sonison_isoni​代表i的儿子节点.(如果一些son不给出下标,即代表当前节点u的儿子
每个u统计它的子树大小,顺着路径标起来.(即cnt[u]+=cnt[son])
我们会发现第一次从s回溯到它们的LCA时候,cnt[LCA]+=cnt[son[LCA]]
此时cnt[LCA]=0! &amp;quot;不是LCA会被经过一次嘛,为什么是0!&amp;quot;
别急,我们继续搜另一边.
继续：我们搜索到t,向上回溯.
依旧统计每个u的子树大小cnt[u]+=cnt[son]
再度回到LCA 依旧 是cnt[LCA]+=cnt[son[LCA]]
这个时候 cnt[LCA]=1 这就达到了我们要的效果。
担忧： 万一我们再从LCA向上回溯的时候使得其父亲节点的子树和为1怎么办?
这样我们不就使得其父亲节点被经过了一次? 因此我们需要在cnt[faher(lca)]--
这样就达到了标记我们路径上的点的要求!
模板题：luoguP3128
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int N=50010,M=N*2;
int h[N],e[M],ne[M],idx;
int n,m;
int dep[N];
int q[N];
int fa[N][16];
int p[N];

void add(int a,int b)
{
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

void bfs()
{
	memset(dep,0x3f,sizeof dep);
	dep[0]=0,dep[1]=1;
	int hh=0,tt=0;
	q[0]=1;
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=h[t];~i;i=ne[i])
		{
			int j=e[i];
			if(dep[j] &amp;gt; dep[t] +1)
			{
				dep[j] = dep[t] + 1;
				q[++tt]=j;
				fa[j][0]=t;
				for(int k=1;k&amp;lt;=15;k++)
					fa[j][k]=fa[fa[j][k-1]][k-1];
			}
		}
	}
}

int lca(int a,int b)
{
	if(dep[a] &amp;lt; dep[b])
		swap(a,b);
	for(int  k=15;k&amp;gt;=0;k--)
		if(dep[fa[a][k]] &amp;gt;= dep[b])
			a=fa[a][k];
		
	if(a == b)
		return a;
	for(int k=15;k&amp;gt;=0;k--)
		if(fa[a][k] != fa[b][k])
		{
			a=fa[a][k];
			b=fa[b][k];
		}
		
	return fa[a][0]; 
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j != fa)
		{
			dfs(j,u);
			p[u]+=p[j];
		}
	}
}

int main()
{
	//cout&amp;lt;&amp;lt;log2(50000)&amp;lt;&amp;lt;endl;
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	memset(h,-1,sizeof h);
	for(int i=0;i&amp;lt;n-1;i++)
	{
		int u,v;
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;u,&amp;amp;v);
		add(u,v);
		add(v,u);
	}
	
	bfs();
	
	while(m--)
	{
		int a,b;
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
		int anc=lca(a,b);
		p[a]++,p[b]++,p[anc]--,p[fa[anc][0]]--;
	}
	
	dfs(1,-1);
	
	int res=0;
	for(int i=1;i&amp;lt;=n;i++)	
		res=max(res,p[i]);
	printf(&amp;quot;%d\n&amp;quot;,res);
	return 0;
}

luoguP3258
很明显,这是一道点差分.但是不同的是,我们需要在每个位置”中转“一下.

即会重复经过除了起点和终点外的点。
还要注意的是,当我们到达 ana_nan​ 这一位置的时候,小熊会吃饭 ,即在这里不会有糖果吃. 所以这个位置的经过次数也需要减一
只放个主函数，其他都是模板。。。
int main()
{
	//cout&amp;lt;&amp;lt;log2(300000)&amp;lt;&amp;lt;endl;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	memset(h,-1,sizeof h);
	for(int i=1;i&amp;lt;=n;i++)	
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;w[i]);
	for(int i=0;i&amp;lt;n-1;i++)
	{
		int u,v;
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;u,&amp;amp;v);
		add(u,v);
		add(v,u);
	}
	
	bfs();
	
	for(int i=1;i&amp;lt;n;i++)
	{
		int a=w[i],b=w[i+1];
		int anc=lca(a,b);
		p[a]++,p[b]++,p[anc]--,p[fa[anc][0]]--;
	}
	
	dfs(1,-1);
	
	for(int i=2;i&amp;lt;=n;i++)
		p[w[i]]--;

	for(int i=1;i&amp;lt;=n;i++)	
		printf(&amp;quot;%d\n&amp;quot;,p[i]);
	return 0;
}

2.边的差分
我们对边进行差分需要把边塞给点,但是,这里的标记并不是同点差分一样.
把边塞给点的话,是塞给这条边所连的深度较深的节点. (即塞给儿子节点
红色边为需要经过的边,绿色的数字代表经过次数
正常的话,我们的图是这样的.↓

但是由于我们把边塞给了点,因此我们的图应该是这样的↓

但是根据我们点差分的标记方式来看的话显然是行不通的,
这样的话我们会经过father[LCA]--&amp;gt; LCA这一路径.
因此考虑如何标记我们的点,来达到经过红色边的情况
聪明的你一定想到了,这样来标记
cnt[s]+=1， cnt[t]+=1 ，cnt[LCA]-=2
这样回溯的话,我们即可只经过图中红色边啦!
acwing352
“主要边” 构成一棵树，而一条 “附加边” 必然会和其两端的 LCA 形成环，

那么，每一条主要边存在三种情况：
1、没有被任何环覆盖

2、只被一个环给覆盖

3、被2个及以上的环覆盖



对于第一种情况，我们切掉一条“主要边”后其实已经将整张图切成了两部分，但根据题意，还要再切掉一条“附加边”，很显然，随便切哪条都可以，因此此时的方案数即为“附加边”的个数 M。


对于第二种情况，我们切掉一条“主要边”后，由于它是在一个环中，所以只能切掉它所在环中的唯一一条“附加边”，因此此时的方案数为 1。


对于第三种情况，由于“主要边”存在于2个及以上的环中，因此切掉它之后会使覆盖它的其中两个环合并成一个新环，而我们知道要将一个环切开（此时只有把环切断才能将整张图切开）必须要切两刀，但我们只能再切一刀，所以我们无论如何都不能切开整张图了，因此此时的方案数为 0。


分类讨论完了，我们该怎么去统计每条边被环覆盖的次数呢？
我们就可以用树上差分来做。
与它父亲节点之间的边被环覆盖的次数。

最后，根据加法原理，我们只要依次统计每条主要边能产生的方案贡献，累加起来即可。

#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 100010, M = N * 2;
int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][17];
int p[N];
int q[N];
int ans;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    q[0] = 1;

    while (hh &amp;lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &amp;gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k &amp;lt;= 16; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] &amp;lt; depth[b]) swap(a, b);
    for (int k = 16; k &amp;gt;= 0; k -- )
        if (depth[fa[a][k]] &amp;gt;= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 16; k &amp;gt;= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != fa)
        {
            dfs(j, u);
            p[u]+=p[j];
        }
            
    }
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &amp;lt; n - 1; i ++ )//主要边 
    {
        int a, b;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
        add(a, b), add(b, a);
    }

    bfs();

    for (int i = 0; i &amp;lt; m; i ++ )//附加边 
    {
        int a, b;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
        int anc = lca(a, b);
        p[a] ++, p[b] ++, p[anc] -= 2;
    }
    dfs(1, -1);
    
    for(int i=2;i&amp;lt;=n;i++)//边的差分特判根结点 
    {
    	if(!p[i])
    		ans+=m;
    	if(p[i] == 1)
    		ans++;
	}
	cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
	return 0;
    	

    return 0;
}

luoguP
读完题,我们发现,这是一道边差分的题.
为了使得最长的路径最短,我们自然地想到二分答案
简单分析 于是建完边我们先dfs一遍预处理出根节点到每个节点的距离.并把边权塞给点。
预处理距离的话只需要再在dfs中加入一句即可,然后我们可以计算出每条航道间的距离
我们需要将被经过次数最多,且边权最大的边删去.
这样能使我们所用总时间最大值尽可能小
要求最大值最小? 很明显,我们想到了二分答案.
那么如何将二分答案转移到树上呢?
不妨考虑二分最终所有请求的最大树上距离,最后只需判断是否能够通过删掉一条边的边权,最终能否达到这个最大距离即可,样就将一个求解问题转化为了判定问题
解法

既然想到了二分答案,那我们就二分路径的长度.(即工作时间.
如果一些路径长度大于当前二分的mid,我们就需要记录这些路径上的边其被经过次数.
(比mid小的路径一定已经合法,我们可以在mid时间内完成任务.)
假设路径长度大于mid的有num个
(我们找到被这些路径共同经过的最大的边权,删去它,使得这些路径长度都小于mid,那么这个mid就是合法的.
小细节
我们可以通过排序得到最大的路径长度,如果这条最长的路径减去被经过次数&amp;lt;=mid,那这个mid就是合法的,我们就可以去寻找更优解.
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int N = 300010, M = N * 2;
int n, m;
int h[N], e[M],w[M], ne[M], idx;
int depth[N], fa[N][19];
int p[N];
int q[N];
int ans;
int dist[N];
struct Node
{
	int x,y,anc,dis;
	bool operator&amp;lt; (const Node &amp;amp;W) const 
	{
		return dis &amp;gt; W.dis;
	}
}query[N];
int edge[N];


void add(int a, int b,int c)
{
    e[idx] = b, w[idx]=c, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    q[0] = 1;

    while (hh &amp;lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &amp;gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                dist[j]=dist[t]+w[i];
                edge[j]=w[i];
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k &amp;lt;= 18; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] &amp;lt; depth[b]) swap(a, b);
    for (int k = 18; k &amp;gt;= 0; k -- )
        if (depth[fa[a][k]] &amp;gt;= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 18; k &amp;gt;= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != fa)
        {
            dfs(j, u);
            p[u]+=p[j];
        }  
    }
}

bool check(int mid)
{
	memset(p,0,sizeof p);
	int num=0,maxd=0;
	for(int i=0;i&amp;lt;m;i++)
	{
		if(query[i].dis &amp;lt;= mid)
			continue;
		p[query[i].x]++;
		p[query[i].y]++;
		p[query[i].anc]-=2;
		num++;
	}
	
	dfs(1,-1);
	
	for(int i=2;i&amp;lt;=n;i++)
		if(p[i] == num)
			maxd=max(maxd,edge[i]);
	
	if(query[0].dis - maxd &amp;lt;= mid)
		return true;
	return false;
}

int main()
{
	//cout&amp;lt;&amp;lt;log2(300000)&amp;lt;&amp;lt;endl;
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &amp;lt; n - 1; i ++ )//主要边 
    {
        int a, b,c;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b,&amp;amp;c);
        add(a, b,c), add(b, a,c);
    }

    bfs();
	
	int l=0,r=0;
    for (int i = 0; i &amp;lt; m; i ++ )//附加边 
    {
        int a, b;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
        int anc = lca(a, b);
        int d=dist[a]+dist[b]-2*dist[anc];
        query[i]={a,b,anc,d};
        r=max(r,d);
    }
    
    sort(query,query+m);
    
    while(l&amp;lt;r)
    {
    	int mid=l+r&amp;gt;&amp;gt;1;
    	if(check(mid))
    		r=mid;
    	else 
    		l=mid+1;
	}
	
	cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;endl;
	return 0;

}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/shu-shang-chai-fen/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/wu-xiang-tu-you-xiang-tu-de-lian-tong-xing-fu-xi/">
                        无向图/有向图的连通性复习
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-01</time>
                    
                        <a href="https://caifxh.github.io/tag/Aq1uYaqZQ/" class="post-tag i-tag
                            i-tag-other_4">
            #图论
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            相关概念
1.无向图


2.有向图


3.割点和桥










4.tarjan算法


4.1无向图的桥

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&amp;gt;dfn[u])
				cout&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;—&amp;quot;&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot;是桥&amp;quot;&amp;lt;&amp;lt;endl; 
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
				tarjan(1,0);
	}
	return 0;
}

4.2无向图的割点



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt,root;
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	int count=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]&amp;gt;=dfn[u])
			{
				count++;
				if(u!=root||count&amp;gt;1)
					cout&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot;是割点&amp;quot;&amp;lt;&amp;lt;endl; 
			}	
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
			add(v,u);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i,0);
			 } 
	}
	return 0;
}

有向图的强连通分量（SCC）

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
stack&amp;lt;int&amp;gt;s;
bool ins[maxn];
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		cout&amp;lt;&amp;lt;&amp;quot;连通分量：&amp;quot;;
		do
		{
			v=s.top();
			s.pop();
			cout&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
			ins[v]=false;
		}while(v!=u);
		cout&amp;lt;&amp;lt;endl;
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(ins,0,sizeof(ins));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
	}
	return 0;
}

例题
poj1144
求割点数
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=105;
int n,root;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn*maxn];

int low[maxn],dfn[maxn],num;
bool cut[maxn];
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u)
{
	dfn[u]=low[u]=++num;
	int flag=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]&amp;gt;=dfn[u])
			{
				flag++;
				if(u!=root||flag&amp;gt;1)//u不是根或者u是根但至少有两个子结点
					cut[u]=true; 			
			}
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(cut,false,sizeof(cut));
	cnt=num=0;
}

int main()
{ 
	while(cin&amp;gt;&amp;gt;n&amp;amp;&amp;amp;n)
	{
		init(); 
		int u,v;
		while(cin&amp;gt;&amp;gt;u&amp;amp;&amp;amp;u)
		{
			while(1)
			{
				char c=getchar();
				if(c==&#39;\n&#39;)
					break;
				cin&amp;gt;&amp;gt;v;
				add(u,v);
				add(v,u);
			}
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
			{
				root=i;
				tarjan(i);
			}
		int ans=0;
		for(int i=1;i&amp;lt;=n;i++)
			if(cut[i])
				ans++;
		cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj3352
最少加几条边，才能使无向图变成边双连通图。



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=1000+5;
int n,m;
int head[maxn],cnt;
struct Edge
{
	int to,next;
}e[maxn&amp;lt;&amp;lt;1];

int low[maxn],dfn[maxn],degree[maxn],num;
void add(int u,int v)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;	
}
void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++num;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		if(!dfn[v])
		{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		}
		else
			low[u]=min(low[u],dfn[v]);
	}
}

void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	memset(degree,0,sizeof(degree));
	cnt=num=0;
}

int main()
{
	while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
	{
		init();
		int u,v;
		while(m--)
		{
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
			add(v,u);
		}
		tarjan(1,-1);
		for(int u=1;u&amp;lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(low[u]!=low[v])
					degree[low[u]]++;
			}
		int leaf=0;
		for(int i=1;i&amp;lt;=n;i++)
			if(degree[i]==1)
				leaf++;
		cout&amp;lt;&amp;lt;(leaf+1)/2&amp;lt;&amp;lt;endl;
	}
	return 0;
}

换种写法：(可求得所有点双连通分量)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=5010,M=200010;
int h[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
int d[N];
bool is_bridge[M];
int id[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u,int fa)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j == fa)
            continue;
        if(!dfn[j])
        {
            tarjan(j,u);
            low[u]=min(low[u],low[j]);
            if(dfn[u] &amp;lt; low[j])
                is_bridge[i]=is_bridge[i^1]=true;
        }
        else
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++dcc_cnt;
        int y;
        do{
            y=stk[top--];
            id[y]=dcc_cnt;
        }while(y != u);
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        add(a,b);
        add(b,a);
    }
    
    tarjan(1,-1);
    
    for(int i=0;i&amp;lt;idx;i++)
        if(is_bridge[i])
            d[id[e[i]]]++;
            
    int cnt=0;
    for(int i=1;i&amp;lt;=dcc_cnt;i++)
        if(d[i] == 1)
            cnt++;
    cout&amp;lt;&amp;lt;(cnt+1)/2&amp;lt;&amp;lt;endl;
    return 0;
}



poj2553

求解强连通分量，缩点，计算缩点的出度，统计出度为0的顶点。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;
const int maxn=5050;
int n,m;
bool ins[maxn];//标记是否在栈内 
int head[maxn],id[maxn],dout[maxn];
int low[maxn],dfn[maxn];
stack&amp;lt;int&amp;gt; s;
int cnt,num,scc_cnt;
struct Egde
{
	int to,next;
}e[maxn*maxn];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(ins,false,sizeof(ins));
	memset(dout,0,sizeof(dout));
	memset(id,0,sizeof(id));
	cnt=num=0;
	scc_cnt=0;
}
void tarjan(int u)
{
	low[u]=dfn[u]=++num;
	ins[u]=true;
	s.push(u);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		++scc_cnt;
		do
		{
			v=s.top();
			s.pop();
			id[v]=scc_cnt;
			ins[v]=false;
		}while(v!=u);
	}
}

int main()
{
	while((cin&amp;gt;&amp;gt;n)&amp;amp;&amp;amp;n)
	{
		cin&amp;gt;&amp;gt;m;
		init();
		while(m--)
		{
			int u,v;
			cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v;
			add(u,v);
		}
		for(int i=1;i&amp;lt;=n;i++)
			if(!dfn[i])
				tarjan(i);
		for(int u=1;u&amp;lt;=n;u++)
			for(int i=head[u];i;i=e[i].next)
			{
				int v=e[i].to;
				if(id[u]!=id[v])
					dout[id[u]]++; 
			}
		int flag=1;
		for(int i=1;i&amp;lt;=n;i++)
		{
			if(!dout[id[i]])
			{
				if(flag)
					flag=0;
				else
					cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
				cout&amp;lt;&amp;lt;i;
			}		
		}
		cout&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj1236/acwing367
至少添加几条边，使得有向图为强连通图



#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=110,M=N*N;
int n;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N];
int stk[N],top;
bool in_stk[N];
int scc_cnt,timestamp;
int id[N];
int dout[N],din[N];

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    in_stk[u]=true;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(in_stk[j])
            low[u]=min(low[u],dfn[j]);
    }   
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            //cout&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&#39; &#39;;
            in_stk[y]=false;
            id[y]=scc_cnt;
        }while(y != u);
        //cout&amp;lt;&amp;lt;endl;
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n;
    memset(h,-1,sizeof h);
    for(int i=1;i&amp;lt;=n;i++)
    {
        int x;
        while(cin&amp;gt;&amp;gt; x &amp;amp;&amp;amp; x)
            add(i,x);
    }
        
    
    for(int i=1;i&amp;lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
    
    // for(int i=1;i&amp;lt;=n;i++)
    // {
    //     cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;id[i]&amp;lt;&amp;lt;endl;
    // }
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                dout[a]++;
                din[b]++;
            }
        }
     
    int a=0,b=0;  
    for(int i=1;i&amp;lt;=scc_cnt;i++)
    {
        if(!din[i])
            a++;
        if(!dout[i])
            b++;
    }
    
    cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;
    if(scc_cnt == 1)
        cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl;
    else
        cout&amp;lt;&amp;lt;max(a,b)&amp;lt;&amp;lt;endl;
    return 0;
}

acwing1174
（1）若采用暴力求解，先建反图，判断从每个点出发能否到达所有点。时间复杂度：$O(n(n+m))
（2）若为拓扑图，则只需判断出度为0的点，若出度为0的点大于1个，则答案为0，若出度为0的点为1，则答案为1.
先求出所有强连通分量，然后缩点，判断出度为0的分量，答案为该分量里的点的数目。
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int N = 10010, M = 50010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, cnt[N];//强连通分量编号，每个分量里点的数目
int dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            cnt[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
        add(a, b);
    }

    for (int i = 1; i &amp;lt;= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 1; i &amp;lt;= n; i ++ )
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b) dout[a] ++ ;
        }

    int zeros = 0, sum = 0;
    for (int i = 1; i &amp;lt;= scc_cnt; i ++ )
        if (!dout[i])
        {
            zeros ++ ;
            sum += cnt[i];
            if (zeros &amp;gt; 1)
            {
                sum = 0;
                break;
            }
        }

    printf(&amp;quot;%d\n&amp;quot;, sum);

    return 0;
}

acwing1175
求最大半连通子图的结点数和最大半连通子图数。
(1)对于任何一个强连通分量（tarjan），一定是半连通分量。
(2)缩点，建图得到一个有向无环图（拓扑图），求拓扑图上的最长链（最长链包含的结点数即为最大半连通子图的结点数）。缩完点之后的图中出现了重边怎么办,那就会使方案数莫名增多.所以对于缩完点后的图还要判重边
(3)最长链的条数即为最大半连通子图数。
求最长链采用dp，跑最长路,我们只需要找出一条点权最大的路径就行了，不限制点的个数。
所以首先对这个图进行tarjan缩点，并记录下每个连通块的大小，和每个点所在的连通块。
缩点之后，会发现这个图变成了一个dag（有向无环图），我们要对这个dag求出最长链的大小和个数。
因为这个图是无环的，所以我们可以按照拓扑序进行DP
Tarjan缩点后的点的标号顺序是逆拓扑序，所以不需要对新图进行拓扑排序
状态表示: f[i]表示到第i个连通块的最长链大小，g[i]表示个数。
很容易就想到了转移的方法：
1.{g[i]=g[i]+g[j]}(条件：f[j]+number[i]==f[i])
2.{g[i]=g[j],f[i]=f[j]+number[i]}(条件：f[j]+number[i]&amp;gt;f[i])。
按照这个转移状态就可以啦。
总结：强连通分量+缩点+去重+DAGdp
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;unordered_set&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=100010,M=2000010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m,mod;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N],g[N];
typedef pair&amp;lt;int,int&amp;gt; PII;
int stk[N],top;
bool ins[N];
typedef long long LL;

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]++;
        }while(y != u);
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;mod;
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&amp;lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    unordered_set&amp;lt;LL&amp;gt; S;//(u,v)-&amp;gt;u*1000000+v
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            LL hash=a*1000000ll+b;
            if(a != b &amp;amp;&amp;amp; !S.count(hash))
            {
                add(hs,a,b);
                S.insert(hash);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
        if (!f[i])//代表它是入度为0的点 
        {
            f[i] = Size[i];
            g[i] = 1;
        }
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&amp;lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
                g[k]=g[i];
            }
            else if(f[k] == f[i] + Size[k])
                g[k]=(g[k]+g[i])%mod;
        }
    }
    
    int maxf=0,sum=0;
    for(int i=1;i&amp;lt;=scc_cnt;i++)
        if(f[i]&amp;gt;maxf)
        {
            maxf=f[i];
            sum=g[i];
        }
        else if(f[i] == maxf)
            sum=(sum+g[i])%mod;
    
    cout&amp;lt;&amp;lt;maxf&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;
    return 0;
    
}

补一个缩点的模板缩点`
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=10010,M=200010;
int h[N],hs[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],timestamp;
int id[N],scc_cnt,Size[N];
int f[N];
int stk[N],top;
bool ins[N];
int p[N];//点权 

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,ins[u]=true;
    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(ins[j])
            low[u]=min(low[u],dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        ++scc_cnt;
        int y;
        do{
            y=stk[top--];
            ins[y]=false;
            id[y]=scc_cnt;
            Size[scc_cnt]+=p[y];
        }while(y != u);
    }
}

int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    for(int i=1;i&amp;lt;=n;i++)
    	cin&amp;gt;&amp;gt;p[i];
    memset(h,-1,sizeof h);
    memset(hs,-1,sizeof hs);
    while(m--)
    {
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        add(h,a,b);
    }
    
    for(int i=1;i&amp;lt;=n;i++)
        if(!dfn[i])
            tarjan(i);
        
    for(int i=1;i&amp;lt;=n;i++)
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a != b)
            {
                add(hs,a,b);
            }
        }
    
    for(int i=scc_cnt;i;i--)//缩点后的顺序为逆拓扑序 
    {
    	if(!f[i])
    	{
    		f[i]=Size[i];
		}
        for(int j=hs[i];~j;j=ne[j])
        {
            int k=e[j];
            if(f[k]&amp;lt;f[i]+Size[k])
            {
                f[k]=f[i]+Size[k];
            }
        }
    }
    
    int maxf=0;
    for(int i=1;i&amp;lt;=scc_cnt;i++)
  		maxf=max(maxf,f[i]);
    cout&amp;lt;&amp;lt;maxf&amp;lt;&amp;lt;endl;
    return 0;
    
}

再补一个DAGdp的简单题P1137
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=100000+15;
int n,m,idx;
int head[maxn],din[maxn],dp[maxn];
struct EDGE
{
    int to;
	int next;
}edge[maxn&amp;lt;&amp;lt;2];
int q[maxn],hh,tt=-1;

void add(int x,int y)
{
    edge[++idx].next=head[x];
    edge[idx].to=y;
    head[x]=idx;
}

void topsort()
{
    
    for (int i=1;i&amp;lt;=n;i++)
	    if (din[i]==0) 
			q[++tt]=i;
			
    while (hh&amp;lt;=tt)
    {
        int t=q[hh++];
        for (int i=head[t];i;i=edge[i].next)
        {
            int v=edge[i].to;
            din[v]--;
            if (din[v]==0)
            	q[++tt]=v;
        }
    }
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
    for (int i=1;i&amp;lt;=m;i++)
    {
        int u,v;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;u,&amp;amp;v);
        add(u,v);
        din[v]++;
    }
    
    topsort();
    
    for (int i=1;i&amp;lt;=n;i++)
    {
        int u=q[i-1];
        if(!dp[u])
        	dp[u]=1;
        for (int j=head[u];j;j=edge[j].next)
        {
            int v=edge[j].to;
            dp[v]=max(dp[v],dp[u]+1);
        }
    }
    for (int i=1;i&amp;lt;=n;i++)
    	printf(&amp;quot;%d\n&amp;quot;,dp[i]);
    return 0;
}

acwing1183
题意：求删除一个点后，图中最多有多少个连通块。
/*
1.统计连通块数量
2.枚举每一个连通块删除割点后所得的最大连通块数ans
3.ans+cnt-1即为答案
*/
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=10010,M=30010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int ans;
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &amp;gt;= dfn[u])
            {
                cnt++;
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }

    if(u != root &amp;amp;&amp;amp; cnt)//不是根节点，还要加上父节点的那一块连通分量
        cnt++;
    ans=max(ans,cnt);//每一个连通块删除割点后所得的最大连通块数ans
}

int main()
{
    while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m &amp;amp;&amp;amp; n)
    {
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(low,0,sizeof low);
        idx=timestamp=0;
        ans=0;

        while(m--)
        {
            int a,b;
            cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
            add(a,b);
            add(b,a);
        }

        int cnt=0;
        for(root=0;root&amp;lt;n;root++)
            if(!dfn[root])
            {
                cnt++;//连通块数
                tarjan(root);
            }
        
        cout&amp;lt;&amp;lt;ans+cnt-1&amp;lt;&amp;lt;endl;
    }
    return 0;
}

acwing396
题意：
就是有很多个点，在某个时候一个点将会塌陷，你要建造一些点，使任意一点塌陷时其他点都能成功逃脱
情况一：当前连通块内没有一个割点
那么此时至少要建立两个点，使得在任意一点坍塌时能顺利逃脱，那么此时要建立的点的个数就是2，
而方案数则是Cn2=n(n−1)2C_n^2 = \frac{n(n−1)}{2}Cn2​=2n(n−1)​,n为点数

情况二：当前连通块中有一个割点
此时在当前点双连通分量中非割点位置任意选取一个顶点建立1个出口即可，方案数为；cnt-1（cnt为当前连通分量中点数）

情况三：当前连通块中中有一个割点以上，无需设置出口（一个割点时已设置出口，且各个v-dcc连通，无论删去任意一个出口or割点or普通点，都可保证剩下点可成功逃离）
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 1010, M = 1010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int stk[N],top;
int dcc_cnt;
vector&amp;lt;int&amp;gt; dcc[N];
bool cut[N];
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    if(u == root &amp;amp;&amp;amp; h[u] == -1)
    {
        dcc_cnt++;
        dcc[dcc_cnt].push_back(u);
        return;
    }
    
    int cnt=0;
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if(low[j] &amp;gt;= dfn[u])
            {
                cnt++;
                if(u != root || cnt &amp;gt;1)
                    cut[u]=true;
                ++dcc_cnt;
                int y;
                do{
                    y=stk[top--];
                    dcc[dcc_cnt].push_back(y);
                }while(y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else 
            low[u]=min(low[u],dfn[j]);
    }
}

int main()
{
    int kase=1;
    while(cin&amp;gt;&amp;gt;m &amp;amp;&amp;amp; m)
    {
        for(int i=1;i&amp;lt;=dcc_cnt;i++)
            dcc[i].clear();
        idx=n=timestamp=top=dcc_cnt=0;
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(cut,0,sizeof cut);
        
        while(m--)
        {
            int a,b;
            cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
            n=max(n,a),n=max(n,b);
            add(a,b);
            add(b,a);
        }
        
        for(root = 1; root &amp;lt;= n; root ++)
        {
            if(!dfn[root])
                tarjan(root);
        }
        
        int res=0;
        ULL num=1;
        for(int i=1;i&amp;lt;=dcc_cnt;i++)
        {
            int cnt=0;//统计当前v-dcc中割点的数量
            for(int j=0;j&amp;lt;dcc[i].size();j++)
                if(cut[dcc[i][j]])
                    cnt++;
            
            if(cnt == 0)
            {
                if(dcc[i].size()&amp;gt;1)
                    res+=2,num*=dcc[i].size()*(dcc[i].size()-1)/2;
                else 
                    res++;//孤立点
            }
            else if (cnt == 1)
            {
                res++,num*=dcc[i].size()-1;
            }
        }
         printf(&amp;quot;Case %d: %d %llu\n&amp;quot;, kase++, res, num);
    }
    return 0;
}

acwing368
图片转自@xxh的题解


#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 600010;

int n, m;
int h[N], hs[N], e[M], ne[M], w[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, size[N];
int dist[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    for (int i = 1; i &amp;lt;= n; i ++ ) add(h, 0, i, 1);

    while (m -- )
    {
        int t, a, b;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;t, &amp;amp;a, &amp;amp;b);
        if (t == 1) add(h, b, a, 0), add(h, a, b, 0);
        else if (t == 2) add(h, a, b, 1);
        else if (t == 3) add(h, b, a, 0);
        else if (t == 4) add(h, b, a, 1);
        else add(h, a, b, 0);
    }

    tarjan(0);//从超级源点可到所有点

    bool success = true;
    for (int i = 0; i &amp;lt;= n; i ++ )
    {
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a == b)
            {
                if (w[j] &amp;gt; 0)//只要任意一个SCc里有边权大于0的边，则存在正环
                {
                    success = false;
                    break;
                }
            }
            else 
                add(hs, a, b, w[j]);
        }
        if (!success) 
            break;
    }

    if (!success) puts(&amp;quot;-1&amp;quot;);
    else
    {
        for (int i = scc_cnt; i; i -- )
        {
            //入度为0的点dist为0
            for (int j = hs[i]; ~j; j = ne[j])
            {
                int k = e[j];
                dist[k] = max(dist[k], dist[i] + w[j]);
            }
        }

        LL res = 0;
        for (int i = 1; i &amp;lt;= scc_cnt; i ++ ) 
            res += (LL)dist[i] * size[i];

        printf(&amp;quot;%lld\n&amp;quot;, res);
    }

    return 0;
}

P3627
题意：
在有向图中找一条路径，使得经过的点的点权和最大（每个点可以经过多次，但只有一次对答案的贡献
思路：
首先看见可以重复走路径，那么就想到其实这些路口可以构成一个个强连通分量（因为只要我们能到达一个强连通分量其中某一个点，那么我们就能到达这个强连通分量的其余所有点，根据贪心策略，这样得到的答案保证更优）。那就很容易想到缩点加最长路。
缩点+spfa最长路code
推荐博客：
https://blog.csdn.net/acmmmm/article/details/16361033
https://blog.csdn.net/sentimental_dog/article/details/53790582

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/wu-xiang-tu-you-xiang-tu-de-lian-tong-xing-fu-xi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://caifxh.github.io/images/avatar.png?v=1586059488314)">
        </div>
        <h1 class="id_card-title">
            fxh
        </h1>
        <h2 class="id_card-description">
            菜
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>