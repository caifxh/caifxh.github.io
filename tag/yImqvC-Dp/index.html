<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    字符串 | fxh
</title>
<link rel="shortcut icon" href="https://caifxh.github.io/favicon.ico?v=1588691348423">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caifxh.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://caifxh.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://caifxh.github.io">
                <img class="avatar" src="https://caifxh.github.io/images/avatar.png?v=1588691348423" alt="">
            </a>
            <div class="site-title">
                <h1>
                    fxh
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        字符串</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/ac-zi-dong-ji/">
                        AC自动机
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-10</time>
                    
                        <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-error">
            #字符串
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            AC自动机











每个结点的26个指针都有指向
匹配时判断后缀是不是单词，若为单词则也需要统计上
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=5e5+10,M=1e6+10;
int trie[N][26],cnt[N],idx;
char s[M];
int q[N],ne[N];
int n;

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-&#39;a&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;26;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;26;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	int res=0;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-&#39;a&#39;;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			res+=cnt[p];
			cnt[p]=0;
			p=ne[p];
		}
	}
	return res;
}

void print()
{
	for(int i=0;i&amp;lt;idx;i++)
	{
		cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;ne[i]&amp;lt;&amp;lt;&amp;quot;: &amp;quot;;
		for(int j=0;j&amp;lt;26;j++)
			if(trie[i][j])
			    cout&amp;lt;&amp;lt;char(j+&#39;a&#39;)&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;trie[i][j]&amp;lt;&amp;lt;&amp;quot;  &amp;quot;;
		cout&amp;lt;&amp;lt;endl;
	}
	cout&amp;lt;&amp;lt;endl;
}

int main()
{
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		memset(ne,0,sizeof ne);
		idx=0;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		
		for(int i=0;i&amp;lt;n;i++)
		{
			char str[55];
			scanf(&amp;quot;%s&amp;quot;,str);
			insert(str);
		}
		
		build();
		//print();
		scanf(&amp;quot;%s&amp;quot;,s);
		printf(&amp;quot;%d\n&amp;quot;,query(s));
	}
	return 0;
}

hdu2896
小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1e5+10,M=10010;
int trie[N][128],idx;
char s[M];
int q[N],ne[N];
int n,m;
int ans[N],cnt;
int id[N];
int tot;

void insert(char *s,int i)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-32;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	id[p]=i;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;128;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;128;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	bool flag = false;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-32;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			if(id[p])
			{
				flag=true;
				ans[cnt++]=id[p];
				//cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;id[p]&amp;lt;&amp;lt;endl;
			}
			p=ne[p];
		}
	}
	return flag;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		char str[210];
		scanf(&amp;quot;%s&amp;quot;,str);
		insert(str,i);
	}
	
	build();

	scanf(&amp;quot;%d&amp;quot;,&amp;amp;m);
	for(int i=1;i&amp;lt;=m;i++)
	{
		scanf(&amp;quot;%s&amp;quot;,s);
		cnt=0;
		if(query(s))
		{
			tot++;
			printf(&amp;quot;web %d:&amp;quot;,i);
			cnt=unique(ans,ans+cnt)-ans;
			sort(ans,ans+cnt);
			for(int i=0;i&amp;lt;cnt;i++)
				printf(&amp;quot; %d&amp;quot;,ans[i]);
			puts(&amp;quot;&amp;quot;);
		}
	}
	
	printf(&amp;quot;total: %d\n&amp;quot;,tot);
	return 0;
}

1.本题不是计数，不需判重复，只需标记病毒编号为true，多次标记不影响最终答案
2.多个主串，字典树下一次还要再查询，不能改变字典树
附：ASCII表

poj2778






#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=110,mod=100000;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n,m;
int q[N];
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
	matrix(int c[][N])
	{
		memcpy(m,c,sizeof m);
	}
};

int get(char c)
{
	switch(c)
	{
		case &#39;A&#39; : return 0;
		case &#39;G&#39; : return 1;
		case &#39;C&#39; : return 2;
		case &#39;T&#39; : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;	
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&amp;lt;=idx;i++)
		for(int j=0;j&amp;lt;=idx;j++)
			for(int k=0;k&amp;lt;=idx;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&amp;lt;=idx;i++)
		res.m[i][i]=1;
	while(k)
	{
		if(k &amp;amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return res;
}

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	for(int i=0;i&amp;lt;n;i++)
	{
		char str[15];
		scanf(&amp;quot;%s&amp;quot;,str);
		insert(str);
	}
	
	build();
	
	matrix g;
	for(int i=0;i&amp;lt;=idx;i++)
	{
		if(cnt[i]) continue;
		for(int j=0;j&amp;lt;4;j++)
		{
			int p=trie[i][j];
			if(!cnt[p])
				g.m[i][p]=(g.m[i][p]+1)%mod;
		}
	}
	
//	for(int i=0;i&amp;lt;=idx;i++)
//	{
//		for(int j=0;j&amp;lt;=idx;j++)
//			cout&amp;lt;&amp;lt;g.m[i][j]&amp;lt;&amp;lt;&#39; &#39;;
//		cout&amp;lt;&amp;lt;endl;
//	}
	
	g=qmi(g,m);
	int res=0;
	for(int i=0;i&amp;lt;=idx;i++)
		res=(res+g.m[0][i])%mod;
	
	printf(&amp;quot;%d&amp;quot;,res);
	
	return 0;
}

最后的答案为什么是g.m[0][i]求和?
矩阵g的n次幂表示构造长度为n的DNA序列的方案数（g的i次幂表示构造长度为n的DNA序列的方案数），类似离散数学中二元关系的复合运算，二元关系&amp;lt;1,2&amp;gt; ,&amp;lt;2,3&amp;gt; 复合一次可得到关系&amp;lt;1,3&amp;gt;
由于从根结点出发构造序列，且根结点idx为0.g.m[0][i]表示从根结点走i步的方案数，即从根节点开始构造长度为i的序列的方案数。
poj3691
AC自动机+DP
为每个结点构造失败指针的同时，检查其失败指针所指向的节点是否为危险节点，如果是的话也需要把当前节点标记为危险节点。
所谓的危险节点，就是指以当前节点为结尾的字符串是某个病毒串，或者包含了某个病毒串。如果在bfs的同时进行这项操作的时候就非常方便，在构造完当前失败指针的同时检查其所指向的节点是否为危险节点。
根据危险DNA序列所建的字典树，我们用模拟的方式 ，从第一个字符开始构造， 依次递增，找到一个满足要求的字符串，在构造此字符串的同时，比较该字符串和输入要判断的序列S，若该位置i的字符和s[i]，相同，则表示，此位置的字符不需要改变，反则，需要把s[i]该为词字符，为一次改变操作.
状态表示：dp[i][j]，表示到达查找串第i个字符时，对应于AC自动机的j节点所需要的最小改变数。
状态转移为dp[i][son[j]] = min( dp[i][son[j]], dp[i-1][j] + s[i-1]!=k )
读到i个字符时，对应于j状态（DP的过程要两重循环i和j），要转移到son[j]（j的子节点状态，在这里用k在[0,3]一重循环遍历所有可以转字符），如果第i个字符跟所要转移到的字符相同，则代价为0，因为不需要改变；否则代价为1，因为需要改变。
如果当前状态不可达，则不需要对其进行后续运算。
如果子节点为危险节点，则不可以进行转移，即不可以使用上面的状态方程。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n;
char s[N];
int f[N][N];
int q[N];

int get(char c)
{
	switch(c)
	{
		case &#39;A&#39; : return 0;
		case &#39;G&#39; : return 1;
		case &#39;C&#39; : return 2;
		case &#39;T&#39; : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

void print()
{
    for(int i=0;i&amp;lt;=idx;i++)
    {
        cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;ne[i]&amp;lt;&amp;lt;&amp;quot;: &amp;quot;;
        for(int j=0;j&amp;lt;4;j++)
            if(trie[i][j])
                cout&amp;lt;&amp;lt;trie[i][j]&amp;lt;&amp;lt;&#39; &#39;;
        cout&amp;lt;&amp;lt;endl;
    }
}

int main()
{
	int kas=1;
	while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		memset(trie,0,sizeof trie);
		memset(ne,0,sizeof ne);
		memset(cnt,0,sizeof cnt);
		idx=0;
		for(int i=0;i&amp;lt;n;i++)
		{
			char str[25];
			scanf(&amp;quot;%s&amp;quot;,str);
			insert(str);
		}
		
		build();
		
		//print();
		
		scanf(&amp;quot;%s&amp;quot;,s+1);
		int len=strlen(s+1);
		
		memset(f,0x3f,sizeof f);
		f[0][0]=0;
		for(int i=1;i&amp;lt;=len;i++)
			for(int j=0;j&amp;lt;=idx;j++)
				for(int k=0;k&amp;lt;4;k++)
				{
					int t=get(s[i]) != k;
					int p=trie[j][k];
					if(!cnt[p])
						f[i][p]=min(f[i][p],f[i-1][j]+ t);
				}
				
		int res=INF;
		for(int i=0;i&amp;lt;=idx;i++)
			res=min(res,f[len][i]);
		
		if(res == INF)
			res=-1;
		printf(&amp;quot;Case %d: %d\n&amp;quot;,kas++,res);
	}
	return 0;
}

最后，循环dp[len][j]，即在读完最后一个字符后检查所有状态的最终值，取其最小。如果均不可达，则返回-1。
类似题：求主串至少包含一个模式串的方案数，正难则反。
代码
hdu2233
长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？
比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为
(2个) aa,ab,
(26个)aaa,aab,aac...aaz,
(26个)aba,abb,abc...abz,
(25个)baa,caa,daa...zaa,
(25个)bab,cab,dab...zab。







代码
若要求长度正好为L，原矩阵的L次幂即可
长度不超过L，需要累加
acwing1285
每次插入一个单词时把所有路径上的点都+1，每个单词的出现次数就是其结尾节点的fail树子树和。因为其fail指针指向的节点一定包含当前字符串。
统计贡献时要从下往上按照拓扑排序加，
代码
hdu3695
给出 n 个模式串，给出一个长串 S，找出 S 中出现了几种模式串。注意模式串在 S 中正着出现和反着出现都算出
现。S 可能有些段是压缩过的，格式为[tx]，t 是一个数字，x 是一个字母，代表有 t 个 x。把 a[3b]c 解压后会得到
abbbc。
n≤250，模式串的长度不超过1000，t≤5·1e6, 解压后的长串的长度不超过 5100000.

样例输入：
3
2
AB DCB
DACB
3
ABC CDE GHI
ABCCDEFIHG
4
ABB ACDEE BBB FEEE
A[2B]CD[4E]F
样例输出：
0
3
2
我们可以把这 n 个串插入 Trie 树，建成 AC 自动机。然后把解压后的 S 正着在 AC 自动机上跑一遍，再反着在
AC 自动机上跑一遍，对于覆盖过的模式串，打一个标记。最后统计标记的总数即可
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=250010,M=5100010;
int trie[N][26],idx;
char s[M],tmp[M];
int ne[N];
int dar[N];
int n;
int q[N];

void insert(char *s,int k)
{
    int p=0;
    for(int i=0;s[i];i++)
    {
        int k=s[i]-&#39;A&#39;;
        if(!trie[p][k])
        {
        	trie[p][k]=++idx;
        	memset(trie[idx],0,sizeof trie[idx]);
        	dar[idx]=0;
		}
        p=trie[p][k];
    }
   	dar[p]++;
}

void build()
{
    int hh=0,tt=-1;
    for(int i=0;i&amp;lt;26;i++)
        if(trie[0][i])
        {
        	int t=trie[0][i];
        	q[++tt]=t;
        	ne[t]=0;
		}
    
    while(hh &amp;lt;= tt)
    {
        int t=q[hh++];
        for(int i=0;i&amp;lt;26;i++)
        {
            int p=trie[t][i];
            if(!p) trie[t][i]=trie[ne[t]][i];
            else 
            {
                ne[p]=trie[ne[t]][i];
                q[++tt]=p;
            }
        }
    }
}

int query(char *s,int type)
{
    int len=strlen(s);
    if(type)
        reverse(s,s+len);
    //cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;
    int res=0;
    for(int i=0,j=0;s[i];i++)
    {
        int k=s[i]-&#39;A&#39;;
        j=trie[j][k];
        int p=j;
        while(p)
        {
        	if(dar[p])
        	{
        		res+=dar[p];
        		dar[p]=0;
			}
			else 
				break;
            p=ne[p];
        }
    }
    return res;
}

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    while(T--)
    {
    	memset(trie[0],0,sizeof trie[0]);
    	ne[0]=0;
    	dar[0]=0;
        idx=0;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        for(int i=1;i&amp;lt;=n;i++)
        {
            char str[1010];
            scanf(&amp;quot;%s&amp;quot;,str);
            insert(str,i);
        }
        
        build();
        
        scanf(&amp;quot;%s&amp;quot;,s);
        int l=0;
        for(int i=0;s[i];i++)
        {
            if(s[i] !=&#39;[&#39;)
                tmp[l++]=s[i];
            else
            {
                i++;
                int len=0;
                while(s[i] &amp;gt;=&#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;=&#39;9&#39;)
                {
                    len=len*10+s[i]-&#39;0&#39;;
                    i++;
                }
                for(int k=0;k&amp;lt;len;k++)
                    tmp[l++]=s[i];
                i++;
            }
        }
        tmp[l]=0;
        
        printf(&amp;quot;%d\n&amp;quot;,query(tmp,0)+query(tmp,1));
    }
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/ac-zi-dong-ji/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/trie/">
                        Trie
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-10</time>
                    
                        <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-primary">
            #字符串
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            trie





void insert(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-&#39;a&#39;;
        if(!trie[p][k])
            trie[p][k]=++idx;
        p=trie[p][k];
    }
    cnt[p]=true;
}


int query(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-&#39;a&#39;;
        p=trie[p][k];
        if(!p)
            return 0;
    }
    return cnt[p];
}

模板题





例题
poj2503
您刚从滑铁卢搬到大城市。 这里的人说的是一门不可理解的外语。 幸运的是，您有一本字典来帮助您理解它们。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;sstream&amp;gt;
using namespace std;
const int N=1000010,M=26;
int trie[N][M];
int cnt[N],idx=1;
char word[N][15];

void insert(string str,int k)
{
	int len=str.size(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=str[i]-&#39;a&#39;;
		if(!trie[p][ch])
			trie[p][ch]=++idx;
		p=trie[p][ch];
	}
	cnt[p]=k;
}

int query(string str)
{
	int len=str.size(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=str[i]-&#39;a&#39;;
		p=trie[p][k];
		if(!p)
			return 0;
	}
	return cnt[p];
}

int main()
{
	string s,str;
	int k=1;
	while(getline(cin,s))
	{
		if(s.empty())
			break;
		stringstream ss(s);
		ss&amp;gt;&amp;gt;word[k]&amp;gt;&amp;gt;str;
		insert(str,k);
		k++;
	}
	
	while(cin&amp;gt;&amp;gt;s)
	{
		int k=query(s);
		if(k)
			cout&amp;lt;&amp;lt;word[k]&amp;lt;&amp;lt;endl;
		else 
			cout&amp;lt;&amp;lt;&amp;quot;eh&amp;quot;&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj3630

给定一个电话号码列表，判断它是否一致，即没有号码是另一个号码的前缀。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;sstream&amp;gt;
using namespace std;
const int N=100010,M=10;
int trie[N][M];
bool cnt[N];
int idx;
int n;

bool insert(char *s)
{
	int p=1;
	int len=strlen(s);
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=s[i]-&#39;0&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		else if(i == len-1)//字符串处理完毕，仍不空，说明该串是其它串的前缀 
			return true;
		p=trie[p][k];
		if(cnt[p])//其他串是该串前缀 
			return true;
	}
	cnt[p]=true;
	return false;
}

int main()
{
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		idx=1;
		bool ans=false;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i=1;i&amp;lt;=n;i++)
		{
			char s[15];
			scanf(&amp;quot;%s&amp;quot;,s);
			if(ans)
				continue;
			if(insert(s))//不能立即结束，仍要读取n个串 
				ans=true;
		}
		if(ans)
			cout&amp;lt;&amp;lt;&amp;quot;NO&amp;quot;&amp;lt;&amp;lt;endl;//有前缀输出NO 
		else
			cout&amp;lt;&amp;lt;&amp;quot;YES&amp;quot;&amp;lt;&amp;lt;endl;
	}
	return 0;
}

hdu1251
Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=500005;
const int maxz=26;//不同字符个数，例如数字10，小写字母26
int trie[maxn][maxz];
int cnt[maxn];//计数器 
void insert(string s)//将字符串s插入到字典树中 
{
	int len=s.length(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=s[i]-&#39;a&#39;;//转换成数字
		if(!trie[p][ch]) 
			trie[p][ch]=++tot;//记录下标 
		p=trie[p][ch];
		cnt[p]++;//统计有多少个单词经过 
	}
}

int query(string s)
{
	int len=s.length(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=s[i]-&#39;a&#39;;//转换成数字
		p=trie[p][ch];
		if(!p)
			return 0;
	}
	return cnt[p];	
}

int main()
{	
	string s;
	memset(trie,0,sizeof(trie));
	memset(cnt,0,sizeof(cnt));
	tot=1;
	while(getline(cin,s))
	{
		if(!s.size())
			break;
		insert(s);
	}
	while(cin&amp;gt;&amp;gt;s)
		cout&amp;lt;&amp;lt;query(s)&amp;lt;&amp;lt;endl;
	return 0;
}

若反过来问，单词表中有多少单词是当前查询单词的前缀，只需统计查询时经过的end标记数量即可。
poj2513
给你一堆木棍。 每个棍子的每个端点都带有某种颜色。是否可以将操纵杆沿一条直线对齐，以使触摸的端点的颜色具有相同的颜色？


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=500010,M=26;
int trie[N][M];
int cnt[N];
int d[N];
int idx=1;
int color;
int p[N];

int find(int x)
{
	if(x != p[x])
		p[x]=find(p[x]);
	return p[x];
}

int insert(char *s)
{
	int len=strlen(s),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=s[i]-&#39;a&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	if(cnt[p])
		return cnt[p];
	else 
	{
	    cnt[p]=++color;
	    return cnt[p];
	}
}

int main()
{
	for(int i=1;i&amp;lt;N;i++)
		p[i]=i;
	char a[15],b[15];
	while(~scanf(&amp;quot;%s%s&amp;quot;,a,b))
	{
		int i=insert(a);
		int j=insert(b);
		d[i]++;
		d[j]++;
		//cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
		int pi=find(i);
		int pj=find(j);
		p[pi]=pj;
	}
	
	int s=find(1);
	int num=0;
	for(int i=1;i&amp;lt;=color;i++)
	{
		if(d[i] % 2 == 1)
			num++;
		if(num &amp;gt; 2 || find(i) != s)
 		{
 			puts(&amp;quot;Impossible&amp;quot;);
			return 0;
		}
 	}
	if(num == 0 || num == 2)
		puts(&amp;quot;Possible&amp;quot;);
	else 
		puts(&amp;quot;Impossible&amp;quot;);
	return 0;
}

poj3764
给出n个节点的树，每条边有边权w。 • 请你找一条路径，使得这条路径上所有边权的异或和最大。
• 数据范围
• n &amp;lt;= 100,000, 0 &amp;lt; w &amp;lt; 2^31
暴力的做法：
• 枚举每个点当根
• dfs整颗树，获得根到每个节点的路径异或和s[]
• 时间复杂度O(n^2)
异或的性质
x xor x = 0
• 一个数异或两次会抵消掉。
• x到y的路径异或和就等于s[x] xor s[y] !

这样只要任取一个点为根，dfs得到s[]数组后，枚举x， y即可，还是O(n^2)
现在的问题是，给定一个s[]数组，找两个元素，使得他
们的异或和最大。
• 给一个数x，在数组s中找一个数y使其和x的异或和最大。
• 涉及二进制的题，我们可以选择按位来考虑。
假设x的二进制有31位，我们把它的二进制写出来，最高位称为第30位，最低位称为第0位。
因为要让异或值最大，所以我们从高位开始考虑。
• 如果x的第30位是1 —— if (x &amp;gt;&amp;gt; 30 &amp;amp; 1)
• 那我们一定希望y的第30位是0，这样异或之后的第30位 是1.
• 否则就算第29～0位异或后都是1，也比2^30小。
• 同理，如果x的第30位是0，我们希望y的第30位是1.
运用贪心的思想，假设现在枚举到x的第i位
• if x第i位是1 我们要尽可能找第i位为0的y
• if x第i位是0 我们要尽可能找第i位为1的y
涉及前缀判断，采用trie
先把所有的数的二进制当作字符串，存进trie中。
• 从高往低枚举二进制位时，设置一个指针p，一开始指向trie的根节点。
• if x第i位是1 我们要尽可能找第i位为0的y 如果说明存在第i位为0的数，我们就让p往0节点走，答案中的第i位为1。
• 如果不存在第i位为0的数，我们只能退而求其次，让p往1节点走，答案中的第i位为0.
• if x第i位是0 我们要尽可能找第i位为1的y ， 同理
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010*31,M=N&amp;lt;&amp;lt;1;
int trie[N][2],tot=1;
int d[N];
int n;
int h[N],e[M],ne[M],w[M],idx;

void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j == fa)
			continue;
		d[j]=d[u]^w[i];
		dfs(j,u);
	}
}

void insert(int x)
{
	int p=1;
	for(int i=30;i&amp;gt;=0;i--)
	{
		int u=x&amp;gt;&amp;gt;i&amp;amp;1;
		if(!trie[p][u])
			trie[p][u]=++tot;
		p=trie[p][u];
	}
}

int query(int x)
{
	int p=1;
	int res=0;
	for(int i=30;i&amp;gt;=0;i--)
	{
		int k=x&amp;gt;&amp;gt;i&amp;amp;1;
		if(trie[p][!k])
		{
			res+=1&amp;lt;&amp;lt;i;
			p=trie[p][!k];
		}	
		else 
			p=trie[p][k];
	}
	return res;
}

int main()
{
	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n))
	{
		memset(h,-1,sizeof h);
		memset(d,0,sizeof d);
		memset(trie,0,sizeof trie);
		idx=0;
		tot=1;
		for(int i=0;i&amp;lt;n-1;i++)
		{
			int a,b,c;
			scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);
			a++,b++;
			add(a,b,c);add(b,a,c);
		}
		dfs(1,-1);
		int res=0;
//		for(int i=1;i&amp;lt;=n;i++)
//			cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&#39; &#39;;
		
		for(int i=1;i&amp;lt;=n;i++)
		{
			insert(d[i]);
			res=max(res,query(d[i]));
		}
		printf(&amp;quot;%d\n&amp;quot;,res);
	}
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/trie/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/manacher/">
                        Manacher
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-10</time>
                    
                        <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-other_1">
            #字符串
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Manacher
回文串:对于一个长度为 n 的字符串 str，如果它正着读和反着读一样，即 str[i] = str[n - i + 1] (1 &amp;lt;= i &amp;lt; n - i + 1),如 aba，acbbca 就是回文串，abc，abab 就不是回文串。
Manacher 算法可以求出以每个位置为中心，向两边能扩展的最长回文子串长度 p[i]，它的时间复杂度是 O(n) 的。
注意到回文子串的长度可能是偶数， 如 abba，中心不是某个字符（中心是两个 b 之间的空隙），所以先要在相邻的
字符中插入一个标识符，例如 #,这样例如 #a#b#b#a# 的中心就是 # 了。
我们用 abbabcba 来举例。
先插入 # 得到 #a#b#b#a#b#c#b#a#。
然后用 Manacher 可以得到如下的 p 数组。
对于每个 p[i]，一定有 str[i + j] == str[i - j] (1 ≤ j &amp;lt; p[i])

类比 Z 算法，我们也维护一个 mx 和 id，表示对于当前计算的所有 i，i + p[i] 的最大值是 mx，mx 对应的 i 记为id。
当你现在开始计算 p[i] 时，默认 p[1..i-1] 都已经算出。

计算最长回文子串长度
以字符串&amp;quot;cabbaf&amp;quot;为例，将预处理后的新字符串&amp;quot;#c#a#b#b#a#f#&amp;quot;变成一个字符数组arr，定义一个辅助数组int[] p，p的长度与arr等长，p[i]表示以arr[i]字符为中心的最长回文半径，p[i]=1表示只有arr[i]字符本身是回文子串。
i       0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i]  # c # a # b # b # a #  f  #
p[i]    1 2 1 2 1 2 5 2 1 2 1  2  1

我们来比对分下一下最长回文半径和原字符串之间的关系。在上面例子中，最长回文子串是&amp;quot;#a#b#b#a#&amp;quot;，它以arr[6]为中心，半径是5，其代表的原始字符串是&amp;quot;abba&amp;quot;，而&amp;quot;abba&amp;quot;的长度为4，可以通过5减去1得到，是字符串&amp;quot;cabbaf&amp;quot;中的最长回文子串，那么我们是不是可以得出最长回文半径和最长回文子串长度之间的关系？
让我们再多看几个例子，如&amp;quot;aba&amp;quot;，转换后是&amp;quot;#a#b#a#&amp;quot;，以字符&#39;b&#39;为中心的回文，半径是4，减1得到3，3是原字符串的最长回文子串长度。
再例如&amp;quot;effe&amp;quot;，转换后是&amp;quot;#e#f#f#e#&amp;quot;，以最中间的&#39;#&#39;为中心的回文，半径是5，减1得到4，4是原字符串的最长回文子串长度。
因此，最后我们得到最长回文半径和最长回文子串长度之间的关系：int maxLength = p[i]-1。maxLength表示最长回文子串长度。
计算最长回文子串起始索引
知道了最长回文子串的长度，我们还需要知道它的起始索引值，这样才能截取出完整的最长回文子串。
继续以第三步中的字符串&amp;quot;cabbaf&amp;quot;为例，p[6]=5，是最长半径，用6(i)减去最长半径5(p[i])得到1，而1恰好是最长回文子串&amp;quot;abba&amp;quot;的起始索引。
我们再来看一个奇回文的例子。例如&amp;quot;aba&amp;quot;，转换后是&amp;quot;#a#b#a#&amp;quot;，p[3]=4，最长半径是4，i为3，用i减去4得到-1，数组下标越界了。
在偶回文的情况下，可以满足i减最长半径，而奇回文却会下标越界，我们需要在转换后的字符串前面再加一个字符，解决下标越界的问题，不能是&#39;#&#39;，那就加个&#39;$&#39;字符吧，但是加过一个字符后，字符串的长度不是奇数了，只能在尾部再加一个不会重复出现的字符，比如&#39;@&#39;(也可不加，因为字符串结尾为&#39;\0&#39;)，这样字符串的长度依旧是奇数了，满足前面第三部分的条件。
加多一个字符后，奇回文可以正常做减法了，偶回文呢？
i       0 1 2 3 4 5 6 7 8 9 10 11 12 13
arr[i]  $ # c # a # b # b # a  #  f  #
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1

在补上字符&#39;$&#39;后，p[7]=5，用i减去最长半径，7-5=2，而理想的结果应该是1，那就再除以2吧，这样就能得到1了。而奇回文&amp;quot;aba&amp;quot;在用i减去最长半径后得到的是0，除以2后还是0，可以完美解决下标越界的问题。
结论：最长回文子串的起始索引int index = (i - p[i])/2。
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=11000010;
char s[N];
charma[N&amp;lt;&amp;lt;1];
int p[N&amp;lt;&amp;lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i]&amp;gt;mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s))
	{
		int len=strlen(s);
		manacher(s,len);
		int ans=0;
		for(int i=0;i&amp;lt;2*len+2;i++)
			ans=max(ans,p[i]-1);
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

Codeforces 17E
给出一个字符串 s。 求 s 有多少对相交的回文子串。包含也算作相交。
如 babb 一共有 6 对相交的回文子串：
s[1..1] and s[1..3]
s[1..3] and s[2..2]
s[1..3] and s[3..3]
s[1..3] and s[3..4]
s[3..3] and s[3..4]
s[3..4] and s[4..4]
|s| ≤ 2·e6
正难则反
统计不相交的回文子串对数。
不相交的回文子串假设端点分别为 x1,y1,x2,y2
那么一定有 x1 &amp;lt;= y1 &amp;lt; x2 &amp;lt;= y2
我们只要统计出以 i 为起点的回文串个数 st[i]，和以 i为终点的回文串个数 ed[i]。
然后计算

在使用 manacher 算法的时候，对每个 i 都计算出了 p[i]
那么我们就要把[i-p[i], i+p[i]] 这个极大回文子串对 st和 ed 的贡献算进去。
对于 st: [i-p[i]+1, i] 这些点每个位置都要 +1
对于 ed：[i, i+p[i]-1] 这些点每个位置都要 +1
只需要通过差分转化为单点修改即可。
最后用总的回文子串对数减去不相交的回文子串对数即是答案
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=2e6+10,mod=51123987;
char s[N];
int p[N&amp;lt;&amp;lt;1];
int n;
char ma[N&amp;lt;&amp;lt;1];
int l[N&amp;lt;&amp;lt;1],r[N&amp;lt;&amp;lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,s);
	manacher(s,n);
	n=n*2+2;
	
	int ans=0;
	for(int i=0;i&amp;lt;n;i++)
	{
		l[i-p[i]+1]++,l[i+1]--;
		r[i]++,r[i+p[i]]--;
		ans=(ans+p[i]/2)%mod;
	}
	ans=(LL)ans*(ans-1)/2%mod;
	
	int sum=0;
	for(int i=1;i&amp;lt;n;i++)
	{
		l[i]+=l[i-1];r[i]+=r[i-1];
		if(i&amp;amp;1) continue;
		ans=(ans-(LL)sum*l[i]%mod+mod)%mod;
		sum=(sum+r[i])%mod;
	}
	printf(&amp;quot;%d&amp;quot;,ans);
}

BZOJ 2565
定义双回文串 T，满足存在 T = ab，其中 a 和 b 都是回文串。
给定字符串 S，求一个 S 的最长的双回文子串 T。
|S| ≤ 1e6

Lmax是一个点往左扩展，越靠右越可能长，所以做逆推；Rmax是一个点往右扩展，越靠左越可能长，所以做顺推。递推式子见代码。处理好之后扫一遍就出解了。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
int n;
int l[N*2],r[N*2],p[N*2];
char ma[N*2],a[N];

void manacher(char *s,int len)
{
    int k=0;
    ma[k++]=&#39;$&#39;;
    ma[k++]=&#39;#&#39;;
    for(int i=0;i&amp;lt;len;i++)
    {
        ma[k++]=s[i];
        ma[k++]=&#39;#&#39;;
    }
    ma[k]=0;
    int mx=0,id=0;
    for(int i=0;i&amp;lt;k;i++)
    {
        if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]] == ma[i-p[i]])
            p[i]++;
        if(i+p[i]&amp;gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
        l[i+p[i]-1]=max(l[i+p[i]-1],p[i]-1);
        //cout&amp;lt;&amp;lt;l[i+p[i]-1]&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;p[i]-1&amp;lt;&amp;lt;endl;
        r[i-p[i]+1]=max(r[i-p[i]+1],p[i]-1);
        //cout&amp;lt;&amp;lt;r[i-p[i]+1]&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;p[i]-1&amp;lt;&amp;lt;endl;
    }
}

 
int main()
{
	scanf(&amp;quot;%s&amp;quot;,a);
	
	int n=strlen(a);
	manacher(a,n);
	n=n*2+2;
	
	for(int i=1;i&amp;lt;n;i+=2) r[i]=max(r[i],r[i-2]-2);
	for(int i=n-1;i&amp;gt;=1;i-=2) l[i]=max(l[i],l[i+2]-2);
	
	int ans=0;
	for(int i=1;i&amp;lt;n;i++) 
		if(l[i] &amp;amp;&amp;amp; r[i])
			ans=max(ans,l[i]+r[i]);
	cout&amp;lt;&amp;lt;ans;
	
	return 0;
}

bzoj4755
有两个长度均为 N 的字符串 A 和 B。
扭动的字符串 S(i,j,k) 定义为 A[i..j]+B[j..k] 若 A=’xyz’, B=‘uvw’, 则 S(1,2,3)=‘xyvw’
定义扭动的回文串为如下情况中的一个；
A 中的一个回文串
B 中的一个回文串
某一个回文的扭动字符串S(i,j,k)
求最长的扭动回文串
1≤N≤100000，字符串只含大写字母

样例：
5
ABCDE
BAECB
答案：
5
最长的扭动回文串是 S(2,3,5) = BCECB
对于前两种情况，我们只需要用 manacher 算法求出每个位置的回文扩展半径，然后取一个最大值即可。
对于第三种情况，需要在两个字符串中各取一段拼起来。
我们可以把答案字符串分解为 STS’
其中 S’ 是 S 的反串，T 是回文串。
可以发现一定是 S 在一个串，TS’ 在另一个串；或者 ST 在一个串，S’在另一个串。
且T 一定是极大的回文子串。
那么我们只要枚举极大回文子串 T 即可。
假设中心在 A 中，枚举中心 i。
(1)假设A[i-p[i], i+p[i]] 是极大回文子串。
枚举 A[i+p[i]+1..n] 的前缀和 B[1..i-p[i]] 的后缀最长能匹配上多少。
(2)假设B[i-p[i], i+p[i]] 是极大回文子串。
枚举 A[1..i-p[i]-1] 的后缀 和 B[i + p[i]..n] 的前缀最长能匹配上多少。
这两部分的最大值 * 2 + 极大回文子串的长度就是答案了。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N=100010,M=N&amp;lt;&amp;lt;1,P=131;
char a[N],b[N];
char ma[M];
int pa[M],pb[M];
int n;
ULL ha[N],hb[N],p[N];
int ans;

ULL getha(int l,int r)
{
	return ha[r]-ha[l-1]*p[r-l+1];
}

ULL gethb(int l,int r)
{
	return hb[l]-hb[r+1]*p[r-l+1];
}

void manacher(char *s,int len,int p[])
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=1;i&amp;lt;=len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l++]=0;
	
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx &amp;gt; i) p[i]=min(p[2*id-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}	
}

int search(int L,int R)
{
	int l=0,r=min(L,n-R+1);
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(getha(L-mid+1,L) == gethb(R,R+mid-1))
			l=mid;
		else 
			r=mid-1;
	}
	return l;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,a+1);
	scanf(&amp;quot;%s&amp;quot;,b+1);
	
	p[0]=1;
	for(int i=1;i&amp;lt;=n;i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&amp;lt;=n;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=n;i&amp;gt;=1;i--)
		hb[i]=hb[i+1]*P+b[i];
	
	manacher(a,n,pa);
	manacher(b,n,pb);
	n=n*2+1;
	for(int i=1;i&amp;lt;=n;i++) ans=max(ans,pa[i]-1);
	for(int i=1;i&amp;lt;=n;i++) ans=max(ans,pb[i]-1);
	for(int i=1;i&amp;lt;=n;i++)
	{
		int l=(i-pa[i])/2+1,r=(i+pa[i])/2-1;//下标从1开始
		if(l&amp;lt;=r)
			ans=max(ans,pa[i]-1+search(l-1,r)*2);
	}
	for(int i=1;i&amp;lt;=n;i++)
	{
		int l=(i-pb[i])/2+1,r=(i+pb[i])/2-1;
		if(l&amp;lt;=r)
			ans=max(ans,pb[i]-1+search(l,r+1)*2);
	}
	printf(&amp;quot;%d&amp;quot;,ans);
	return 0;
}

SP7586
求一个串中包含几个回文串
用马拉车求出以每个字母为对称轴的回文串长度，因为一个回文串长度/2就是这个回文串包含的子回文串长度，所以最后统计一下即可
代码
BZOJ 2084 Antisymmetry
给定一个长度为 n 的01串，问有多少个子串满足翻转并取反后和原来一样。
比如0101翻转并取反后还是和原来一样。
只要定义 0 = 1， 0 ≠ 0，1 ≠ 1 即可。跑一遍 Manacher 即可。
以 0/1 扩展的 p[i] 一定是 0 （即没有奇数长度的合法子串）
以 # 扩展的累加起来即可
接下来我们来考虑如果我们确定了一个中心后，向外扩展出一个最大可能的反对称串，那么这个串中一定含有len/2个满足条件的串，其中len为串长，因为要想大的满足条件，则在里面的小串必须满足是反对称的
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=500010;
char s[N];
char ma[N&amp;lt;&amp;lt;1];
int p[N&amp;lt;&amp;lt;1];
int n;

void manacher(char *s,int len)
{
    int l=0;
    ma[l++]=&#39;$&#39;;
    ma[l++]=&#39;#&#39;;
    for(int i=0;i&amp;lt;len;i++)
    {
        ma[l++]=s[i];
        ma[l++]=&#39;#&#39;;
    }
    ma[l]=0;
    int mx=0,id=0;
    for(int i=1;i&amp;lt;l;i+=2)
    {
        if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]]-&#39;0&#39;+ma[i-p[i]]-&#39;0&#39;==1 || (ma[i+p[i]]==ma[i-p[i]] &amp;amp;&amp;amp; ma[i+p[i]]==&#39;#&#39;))
            p[i]++;
        if(i+p[i]&amp;gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
    }
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,s);
    manacher(s,n);
    long long ans=0;
    for(int i=1;i&amp;lt;n*2+2;i+=2)
    	ans+=p[i]/2;
	
    printf(&amp;quot;%lld\n&amp;quot;,ans);
    return 0;
}

BZOJ 3790
母亲节就要到了，小 H 准备送给她一个特殊的项链。这个项链可以看作一个用小写字母组成的字符串，每个小写字母表示一种颜色。为了制作这个项链，小 H 购买了两个机器。第一个机器可以生成所有形式的回文串，第二个机器可以把两个回文串连接起来，而且第二个机器还有一个特殊的性质：假如一个字符串的后缀和一个字符串的前缀是完全相同的，那么可以将这个重复部分重叠。
例如：aba和aca连接起来，可以生成串abaaca或 abaca。现在给出目标项链的样式，询问你需要使用第二个机器多少次才能生成这个特殊的项链。

样例：
abcdcba （答案：0）
abacada （答案：2）
abcdef （答案：5）
题目的意思就是用尽可能少的回文子串去覆盖原串。
我们可以先跑一遍 Manacher 算法得到每个位置的覆盖半径。
问题转化为了有许多个区间 [i-p[i], i+p[i]]，要选出尽可能少的区间来覆盖 [1, n] 区间
贪心即可。
对所有的区间按照左端点从小到大排序。
每次都选右端点最远的那个区间。
设当前覆盖到的右端点为 right。
每次找出左端点在[1, right] 中的右端点的最大的那个线段，再做一次覆盖。
时间复杂度 O(n log n)

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=50010,M=N&amp;lt;&amp;lt;1;
char s[N],ma[M];
int p[M];
struct Node
{
	int l,r;
	bool operator&amp;lt;(const Node &amp;amp;W) const
	{
		return l&amp;lt;W.l;
	}
}e[M];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
		e[i].l=i-p[i]+1,e[i].r=i+p[i]-1;
	}
}

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s))
	{
		int n=strlen(s);
		manacher(s,n);
		
		n=n*2+1;
		sort(e+1,e+n+1);
		
		int st=1,j=1,ed=n;
		int res=0;
		
		while(st &amp;lt; ed)
		{
			int r=0;
			while(j &amp;lt;= n &amp;amp;&amp;amp; e[j].l &amp;lt;= st)
				r=max(r,e[j].r),j++;
			
			st=r;
			res++;
		}
		printf(&amp;quot;%d\n&amp;quot;,res-1);
	}
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/manacher/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/kuo-zhan-kmp/">
                        扩展KMP
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-03</time>
                    
                        <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-">
            #字符串
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Z算法




r[5] = 7
r[6] = 7
l[5] = 5
l[6] = 5

对于 Z[2] 我们需要暴力计算。
也就是暴力计算 S[1..|S|] 和 S[2..|S|] 的最长公共前缀。
如果 Z[2] &amp;gt; 0, 那么 r = r[2], l = l[2] = 2
如果 Z[2] = 0, 那么 r = r[2] = 0, l = l[2] = 0
我们的目标就是用已有的 Z[2], Z[3], ..., Z[k-1]，来推
出 Z[k].
假设 k = 121, Z[2..120] 已经知道了
r[120] = 130, l[120] = 100

划分成[l,i-1],[i,r]





蓝色部分一定不相等，否则说明z-box可以右移
第一步：
初始化 Z[]，暴力计算 Z[2]
for(int i = 1;i &amp;lt;= n;i ++) z[i] = 0;
int l, r;
while(str[1 + z[2]] == str[2 + z[2]]) z[2] ++; 
l = 2, r = 2+ z[2]-1;

第二步：
枚举 i，分三种情况依次计算 Z[i]
for(int i = 3;i &amp;lt;= n;i ++)
{
    if(i &amp;gt; r)
    {
        while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
        l = i, r = i + z[i] - 1;
    }
    else
    {
        if(z[i - l + 1] &amp;lt; r - i + 1) z[i] = z[i - l + 1];
        else
        {
            z[i] = r - i;
            while(str[1 + z[i]] == str[i + z[i]]) z[i] ++; 
            l = i, r = i + z[i] - 1; 
        }
    } 
}

时间复杂度是 O(n) 的
扩展KMP
给定两个字符串 S 和 T（长度分别为 n 和 m）
定义 extend[i] 为 S[i..n] 与 T 的最长公共前缀的长度。
求出 extend 数组

如果 S = T，那么 extend 数组就是 Z 数组。

假设现在遍历到了 S[i]，且 S[1], S[2],…, S[i-1]都已经算出
与 Z 算法类似，设置两个变量 l 和 r，r 表示能和 T 匹
配到的最右边的位置，l 为 r 对应的起始位置。
也就是 S[l .. r] = T[1.. r-l+1]

S[i] 对应的是 T[i-l+1]
现在要计算的是 S[i..n] 与 T 的最长公共前缀
注意到此时 S[i..r] = T[i-l+1 .. r-l+1]
所以我们可以先对 T 求一遍 Z 数组，然后考察一下 Z[i-l+1]



void calc_Z(char *str) 
{
	int n = strlen(str + 1);
	for(int i = 1; i &amp;lt;= n; i ++) z[i] = 0;
	z[1] = n;
	int l, r = 0;
	for(int i = 2; i &amp;lt;= n; i ++) 
	{
		if(i &amp;gt; r) 
		{
			while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
			l = i, r = i + z[i] - 1;
		} else 
		{
			if(z[i - l + 1] &amp;lt; r - i + 1) z[i] = z[i - l + 1];
			else 
			{
				z[i] = r - i + 1;
				while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
				l = i, r = i + z[i] - 1;
			}
		}
	}
}

void calc_extend(char *S, char *T) 
{
	calc_Z(T);
	int l, r = 0;
	int n = strlen(S + 1);
	int m = strlen(T + 1);
	for (int i = 1; i &amp;lt;= n; i ++) 
	{
		if (i &amp;gt; r) 
		{
			while (i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp;
			        S[i + ext[i]] == T[1 + ext[i]]) ext[i] ++;
			l = i, r = i + ext[i] - 1;
		}
		else 
		{
			if (i + z[i - l + 1] - 1 &amp;lt; r) ext[i] = z[i - l + 1];
			else 
			{
				ext[i] = r - i + 1;
				while (i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp; S[i +ext[i]] == T[1 + ext[i]]) 
					ext[i] ++;
				l = i, r = i + ext[i] - 1;
			}
		}
	}
}

例题
题意：给你n个字符串，求这n个字符串的最长公共子串
hdu4333
给一个 L 位数的正整数 N，每次可以把这个数的最后一位移到最前面来，得到一个新的数。
总共最多可以得到 n 个数，重复的只算一次。
问这些数中，等于 n 的，小于 n的，大于 n 的数分别有几个。
L ≤ 1e5

样例：
341 （答案： 1 1 1）
我们只需要把这个数复制两遍，然后只考虑长度为 n 的子串。这些子串就是移动过程中产生的数。
如何和原数 N 做比较呢
假设现在的数是 S[i .. i+L-1], N 是 S[1..L]
我们只要求出他们的最长公共前缀 x，如果 x = n 说明这两个数相等。
否则，比较 S[x] 和 S[i+x-1] 的大小，就可以确定他们的大小关系。
求 x ，就是扩展 KMP 中的 Z 算法。x = min(n, Z[i])
最后一步去重。对 N 跑一次 KMP
如果 L-next[L] 是 L 的约数，那么 L-next[L] 是 N 的最小循环节。否则 N 的 最小循环节是 L。
对循环节内的情况枚举一遍即可,或除以最小循环节个数。
时间复杂度 O(L)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=200010;
char str[N];
int ne[N];
int z[N];

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    for(int kas=1;kas&amp;lt;=T;kas++)
    {
        scanf(&amp;quot;%s&amp;quot;,str+1);
        
        int len=strlen(str+1);
        for(int i=2,j=0;i&amp;lt;=len;i++)
        {
            while(j &amp;amp;&amp;amp; str[i] != str[j+1])
                j=ne[j];
            if(str[i] == str[j+1])
                j++;
            ne[i]=j;
        }
        
        for(int i=1;i&amp;lt;=len;i++)
            str[i+len]=str[i];
        str[len*2+1]=&#39;\0&#39;;
        memset(z,0,sizeof z);
        z[1]=len*2;
        int l,r=0;
        
        for(int i=2;i&amp;lt;=len*2;i++)
        {
            if(i&amp;gt;r)
            {
                while(str[1+z[i]] == str[i+z[i]])
                    z[i]++;
                l=i,r=i+z[i]-1;
            }
            else 
            {
                if(z[i-l+1] &amp;lt; r-i+1)
                    z[i]=z[i-l+1];
                else 
                {
                    z[i]=r-i;
                    while(str[1+z[i]] == str[i+z[i]])
                        z[i]++;
                    l=i,r=i+z[i]-1;
                }
            }
        }
        
        int gre=0,eql=0,les=0;
        for(int i=1;i&amp;lt;=len;i++)
        {
            if(z[i] &amp;gt;= len)
                eql++;
            else if(str[1+z[i]] &amp;gt; str[i+z[i]])
                les++;
            else gre++;
        }
        
        int t;
        if(len%(len-ne[len]) == 0)
            t=len/(len-ne[len]);//循环节个数 
        else 
            t=1;
        printf(&amp;quot;Case %d: %d %d %d\n&amp;quot;,kas,les/t,eql/t,gre/t);
    }
}

对循环节内的情况枚举代码
poj3376
给你 n 个字符串 m[1], m[2], …, m[n]。 求 S = m[i]m[j] （1 &amp;lt;= i,j &amp;lt;= n）是回文串的数量。
n 个字符串的长度之和不超过 2·1e6

样例输入：
3a
ab
ba
答案：5（aa,aba,aba,abba,baab)
考虑什么情况下 i 和 j 拼起来会是回文串。


i的长度小于j，那么i一定是j的反串的前缀，且j的反串剩下的后缀是回文串


i的长度等于j，那么i等于j的反串


i的长度大于j，那么j的反串一定是i的前缀，且i串剩下的后缀是回文串


我们可以将这n个字符串插入trie，每个节点要维护两个值：
value1. 到当前节点的字符串个数；value2.当前节点后面的回文子串个数
我们用每个字符串的反串去trie上查找，要构成回文串有以下情况：


1.此反串是其他串的前缀，那么组合回文串的数量就要加上value2


2.此反串的前缀是某些字符串，且反串剩下的后缀是回文串，那么组合回文串的数量要加上value1


3.2的特例：此反串的前缀是某些字符串，且反串剩下的后缀为空，同样要加上value1，这种情况可以和2一起处理


留下的问题就是一个字符串的所有后缀中，哪些是回文串。
对于串 S，我们先求出正串 S 对反串 T 的 extend[i]
那么对于每个 i，如果 S[i..n] 和 T 的最长公共前缀等于
S[i..n] 的长度，说明 S[i..n] 是一个回文串。
因此整道题就在线性的时间复杂度内解决了。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=2e6+10;
int trie[N][26],tot=1;
int n;
char s[N],t[N];
int len[N];
int slen;
int z[N],ext[N];
bool flag[2][N];
int bg[N],ed[N];
typedef long long LL;
struct Node
{
	int v1,v2;
}cnt[N];

void get_z(char *s)
{
	int n=strlen(s+1);
	for(int i=1;i&amp;lt;=n;i++) z[i]=0;
	z[1]=n;
	int l,r=0;
	for(int i=2;i&amp;lt;=n;i++)
	{
		if(i&amp;gt;r)
		{
			while(s[1+z[i]] == s[i+z[i]])
				z[i]++;
			l=i,r=i+z[i]-1;
		}
		else
		{
			if(z[i-l+1] &amp;lt; r-i+1)
				z[i]=z[i-l+1];
			else
			{
				z[i]=r-i;
				while(s[1+z[i]] == s[i+z[i]])
					z[i]++;
				l=i,r=i+z[i]-1;
			}
		}
	}
}

void exkmp(int type,char *s,char *t)
{
	get_z(t);
	int n=strlen(s+1);
	int m=strlen(t+1);
	for(int i=1;i&amp;lt;=n;i++)
		ext[i]=0;
	int l,r=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		if(i&amp;gt;r)
		{
			while(i+ext[i] &amp;lt;=n &amp;amp;&amp;amp; 1+ext[i] &amp;lt;=m &amp;amp;&amp;amp;
			s[i+ext[i]] == t[1+ext[i]])
				ext[i]++;
			l=i,r=i+ext[i]-1;
		}
		else
		{
			if(z[i-l+1] &amp;lt; r-i+1)
				ext[i]=z[i-l+1];
			else
			{
				ext[i]=r-i+1;
				while(i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp; 
				s[i+ext[i]] == t[1+ext[i]])
					ext[i]++;
				l=i,r=i+ext[i]-1;
			}
		}
	}

	for(int i=1;i&amp;lt;=n;i++)
	{
		//cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;ext[i]&amp;lt;&amp;lt;endl;
		if(ext[i] == n-i+1)
			flag[type][i+slen]=true;//s[i...n]为回文串
	}
}

void insert(int k)
{
	int p=1;
	for(int i=bg[k];i&amp;lt;=ed[k];i++)
	{
		cnt[p].v2+=flag[0][i];
		int ch=s[i]-&#39;a&#39;;
		if(!trie[p][ch])
			trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	cnt[p].v1++;
}

void print(int k)
{
	int p=1;
	for(int i=bg[k];i&amp;lt;=ed[k];i++)
	{
		int ch=s[i]-&#39;a&#39;;
		p=trie[p][ch];
		cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;cnt[p].v2&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;cnt[p].v1&amp;lt;&amp;lt;endl;
	}
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;len[i]);
		scanf(&amp;quot;%s&amp;quot;,s+1+slen);
		for(int j=1;j&amp;lt;=len[i];j++)
			t[slen+j]=s[slen+len[i]+1-j];
		t[slen+len[i]+1]=&#39;\0&#39;;
		exkmp(0,s+slen,t+slen);
		exkmp(1,t+slen,s+slen);

		bg[i]=slen+1;
		slen+=len[i];
		ed[i]=slen;

		insert(i);
		//print(i);
	}

	LL ans=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		int p=1;
		bool f=true;
		for(int j=ed[i];j&amp;gt;=bg[i];j--)//用反串去trie上匹配
		{
			int k=s[j]-&#39;a&#39;;
			if(!trie[p][k])
			{
				f=false;
				break;
			}
			else
				p=trie[p][k];
			if(flag[1][bg[i]+ed[i]-j+1] || j == bg[i])
				ans+=cnt[p].v1;
		}
		if(f)
			ans+=cnt[p].v2;
	}

	printf(&amp;quot;%lld\n&amp;quot;,ans);
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/kuo-zhan-kmp/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/">
                        字符串复习（二）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-27</time>
                    
                        <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-info">
            #字符串
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Manacher
回文串:对于一个长度为 n 的字符串 str，如果它正着读和反着读一样，即 str[i] = str[n - i + 1] (1 &amp;lt;= i &amp;lt; n - i + 1),如 aba，acbbca 就是回文串，abc，abab 就不是回文串。
Manacher 算法可以求出以每个位置为中心，向两边能扩展的最长回文子串长度 p[i]，它的时间复杂度是 O(n) 的。
注意到回文子串的长度可能是偶数， 如 abba，中心不是某个字符（中心是两个 b 之间的空隙），所以先要在相邻的
字符中插入一个标识符，例如 #,这样例如 #a#b#b#a# 的中心就是 # 了。
我们用 abbabcba 来举例。
先插入 # 得到 #a#b#b#a#b#c#b#a#。
然后用 Manacher 可以得到如下的 p 数组。
对于每个 p[i]，一定有 str[i + j] == str[i - j] (1 ≤ j &amp;lt; p[i])

类比 Z 算法，我们也维护一个 mx 和 id，表示对于当前计算的所有 i，i + p[i] 的最大值是 mx，mx 对应的 i 记为id。
当你现在开始计算 p[i] 时，默认 p[1..i-1] 都已经算出。

计算最长回文子串长度
以字符串&amp;quot;cabbaf&amp;quot;为例，将预处理后的新字符串&amp;quot;#c#a#b#b#a#f#&amp;quot;变成一个字符数组arr，定义一个辅助数组int[] p，p的长度与arr等长，p[i]表示以arr[i]字符为中心的最长回文半径，p[i]=1表示只有arr[i]字符本身是回文子串。
i       0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i]  # c # a # b # b # a #  f  #
p[i]    1 2 1 2 1 2 5 2 1 2 1  2  1

我们来比对分下一下最长回文半径和原字符串之间的关系。在上面例子中，最长回文子串是&amp;quot;#a#b#b#a#&amp;quot;，它以arr[6]为中心，半径是5，其代表的原始字符串是&amp;quot;abba&amp;quot;，而&amp;quot;abba&amp;quot;的长度为4，可以通过5减去1得到，是字符串&amp;quot;cabbaf&amp;quot;中的最长回文子串，那么我们是不是可以得出最长回文半径和最长回文子串长度之间的关系？
让我们再多看几个例子，如&amp;quot;aba&amp;quot;，转换后是&amp;quot;#a#b#a#&amp;quot;，以字符&#39;b&#39;为中心的回文，半径是4，减1得到3，3是原字符串的最长回文子串长度。
再例如&amp;quot;effe&amp;quot;，转换后是&amp;quot;#e#f#f#e#&amp;quot;，以最中间的&#39;#&#39;为中心的回文，半径是5，减1得到4，4是原字符串的最长回文子串长度。
因此，最后我们得到最长回文半径和最长回文子串长度之间的关系：int maxLength = p[i]-1。maxLength表示最长回文子串长度。
计算最长回文子串起始索引
知道了最长回文子串的长度，我们还需要知道它的起始索引值，这样才能截取出完整的最长回文子串。
继续以第三步中的字符串&amp;quot;cabbaf&amp;quot;为例，p[6]=5，是最长半径，用6(i)减去最长半径5(p[i])得到1，而1恰好是最长回文子串&amp;quot;abba&amp;quot;的起始索引。
我们再来看一个奇回文的例子。例如&amp;quot;aba&amp;quot;，转换后是&amp;quot;#a#b#a#&amp;quot;，p[3]=4，最长半径是4，i为3，用i减去4得到-1，数组下标越界了。
在偶回文的情况下，可以满足i减最长半径，而奇回文却会下标越界，我们需要在转换后的字符串前面再加一个字符，解决下标越界的问题，不能是&#39;#&#39;，那就加个&#39;$&#39;字符吧，但是加过一个字符后，字符串的长度不是奇数了，只能在尾部再加一个不会重复出现的字符，比如&#39;@&#39;(也可不加，因为字符串结尾为&#39;\0&#39;)，这样字符串的长度依旧是奇数了，满足前面第三部分的条件。
加多一个字符后，奇回文可以正常做减法了，偶回文呢？
i       0 1 2 3 4 5 6 7 8 9 10 11 12 13
arr[i]  $ # c # a # b # b # a  #  f  #
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1

在补上字符&#39;$&#39;后，p[7]=5，用i减去最长半径，7-5=2，而理想的结果应该是1，那就再除以2吧，这样就能得到1了。而奇回文&amp;quot;aba&amp;quot;在用i减去最长半径后得到的是0，除以2后还是0，可以完美解决下标越界的问题。
结论：最长回文子串的起始索引int index = (i - p[i])/2。
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=11000010;
char s[N];
charma[N&amp;lt;&amp;lt;1];
int p[N&amp;lt;&amp;lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i]&amp;gt;mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s))
	{
		int len=strlen(s);
		manacher(s,len);
		int ans=0;
		for(int i=0;i&amp;lt;2*len+2;i++)
			ans=max(ans,p[i]-1);
		printf(&amp;quot;%d\n&amp;quot;,ans);
	}
	return 0;
}

Codeforces 17E
给出一个字符串 s。 求 s 有多少对相交的回文子串。包含也算作相交。
如 babb 一共有 6 对相交的回文子串：
s[1..1] and s[1..3]
s[1..3] and s[2..2]
s[1..3] and s[3..3]
s[1..3] and s[3..4]
s[3..3] and s[3..4]
s[3..4] and s[4..4]
|s| ≤ 2·e6
正难则反
统计不相交的回文子串对数。
不相交的回文子串假设端点分别为 x1,y1,x2,y2
那么一定有 x1 &amp;lt;= y1 &amp;lt; x2 &amp;lt;= y2
我们只要统计出以 i 为起点的回文串个数 st[i]，和以 i为终点的回文串个数 ed[i]。
然后计算

在使用 manacher 算法的时候，对每个 i 都计算出了 p[i]
那么我们就要把[i-p[i], i+p[i]] 这个极大回文子串对 st和 ed 的贡献算进去。
对于 st: [i-p[i]+1, i] 这些点每个位置都要 +1
对于 ed：[i, i+p[i]-1] 这些点每个位置都要 +1
只需要通过差分转化为单点修改即可。
最后用总的回文子串对数减去不相交的回文子串对数即是答案
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=2e6+10,mod=51123987;
char s[N];
int p[N&amp;lt;&amp;lt;1];
int n;
char ma[N&amp;lt;&amp;lt;1];
int l[N&amp;lt;&amp;lt;1],r[N&amp;lt;&amp;lt;1];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,s);
	manacher(s,n);
	n=n*2+2;
	
	int ans=0;
	for(int i=0;i&amp;lt;n;i++)
	{
		l[i-p[i]+1]++,l[i+1]--;
		r[i]++,r[i+p[i]]--;
		ans=(ans+p[i]/2)%mod;
	}
	ans=(LL)ans*(ans-1)/2%mod;
	
	int sum=0;
	for(int i=1;i&amp;lt;n;i++)
	{
		l[i]+=l[i-1];r[i]+=r[i-1];
		if(i&amp;amp;1) continue;
		ans=(ans-(LL)sum*l[i]%mod+mod)%mod;
		sum=(sum+r[i])%mod;
	}
	printf(&amp;quot;%d&amp;quot;,ans);
}

BZOJ 2565
定义双回文串 T，满足存在 T = ab，其中 a 和 b 都是回文串。
给定字符串 S，求一个 S 的最长的双回文子串 T。
|S| ≤ 1e6

Lmax是一个点往左扩展，越靠右越可能长，所以做逆推；Rmax是一个点往右扩展，越靠左越可能长，所以做顺推。递推式子见代码。处理好之后扫一遍就出解了。
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
const int N=100010;
int n;
int l[N*2],r[N*2],p[N*2];
char ma[N*2],a[N];

void manacher(char *s,int len)
{
    int k=0;
    ma[k++]=&#39;$&#39;;
    ma[k++]=&#39;#&#39;;
    for(int i=0;i&amp;lt;len;i++)
    {
        ma[k++]=s[i];
        ma[k++]=&#39;#&#39;;
    }
    ma[k]=0;
    int mx=0,id=0;
    for(int i=0;i&amp;lt;k;i++)
    {
        if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]] == ma[i-p[i]])
            p[i]++;
        if(i+p[i]&amp;gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
        l[i+p[i]-1]=max(l[i+p[i]-1],p[i]-1);
        //cout&amp;lt;&amp;lt;l[i+p[i]-1]&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;p[i]-1&amp;lt;&amp;lt;endl;
        r[i-p[i]+1]=max(r[i-p[i]+1],p[i]-1);
        //cout&amp;lt;&amp;lt;r[i-p[i]+1]&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;p[i]-1&amp;lt;&amp;lt;endl;
    }
}

 
int main()
{
	scanf(&amp;quot;%s&amp;quot;,a);
	
	int n=strlen(a);
	manacher(a,n);
	n=n*2+2;
	
	for(int i=1;i&amp;lt;n;i+=2) r[i]=max(r[i],r[i-2]-2);
	for(int i=n-1;i&amp;gt;=1;i-=2) l[i]=max(l[i],l[i+2]-2);
	
	int ans=0;
	for(int i=1;i&amp;lt;n;i++) 
		if(l[i] &amp;amp;&amp;amp; r[i])
			ans=max(ans,l[i]+r[i]);
	cout&amp;lt;&amp;lt;ans;
	
	return 0;
}

bzoj4755
有两个长度均为 N 的字符串 A 和 B。
扭动的字符串 S(i,j,k) 定义为 A[i..j]+B[j..k] 若 A=’xyz’, B=‘uvw’, 则 S(1,2,3)=‘xyvw’
定义扭动的回文串为如下情况中的一个；
A 中的一个回文串
B 中的一个回文串
某一个回文的扭动字符串S(i,j,k)
求最长的扭动回文串
1≤N≤100000，字符串只含大写字母

样例：
5
ABCDE
BAECB
答案：
5
最长的扭动回文串是 S(2,3,5) = BCECB
对于前两种情况，我们只需要用 manacher 算法求出每个位置的回文扩展半径，然后取一个最大值即可。
对于第三种情况，需要在两个字符串中各取一段拼起来。
我们可以把答案字符串分解为 STS’
其中 S’ 是 S 的反串，T 是回文串。
可以发现一定是 S 在一个串，TS’ 在另一个串；或者 ST 在一个串，S’在另一个串。
且T 一定是极大的回文子串。
那么我们只要枚举极大回文子串 T 即可。
假设中心在 A 中，枚举中心 i。
(1)假设A[i-p[i], i+p[i]] 是极大回文子串。
枚举 A[i+p[i]+1..n] 的前缀和 B[1..i-p[i]] 的后缀最长能匹配上多少。
(2)假设B[i-p[i], i+p[i]] 是极大回文子串。
枚举 A[1..i-p[i]-1] 的后缀 和 B[i + p[i]..n] 的前缀最长能匹配上多少。
这两部分的最大值 * 2 + 极大回文子串的长度就是答案了。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N=100010,M=N&amp;lt;&amp;lt;1,P=131;
char a[N],b[N];
char ma[M];
int pa[M],pb[M];
int n;
ULL ha[N],hb[N],p[N];
int ans;

ULL getha(int l,int r)
{
	return ha[r]-ha[l-1]*p[r-l+1];
}

ULL gethb(int l,int r)
{
	return hb[l]-hb[r+1]*p[r-l+1];
}

void manacher(char *s,int len,int p[])
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=1;i&amp;lt;=len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l++]=0;
	
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx &amp;gt; i) p[i]=min(p[2*id-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]]) p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
	}	
}

int search(int L,int R)
{
	int l=0,r=min(L,n-R+1);
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(getha(L-mid+1,L) == gethb(R,R+mid-1))
			l=mid;
		else 
			r=mid-1;
	}
	return l;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,a+1);
	scanf(&amp;quot;%s&amp;quot;,b+1);
	
	p[0]=1;
	for(int i=1;i&amp;lt;=n;i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&amp;lt;=n;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=n;i&amp;gt;=1;i--)
		hb[i]=hb[i+1]*P+b[i];
	
	manacher(a,n,pa);
	manacher(b,n,pb);
	n=n*2+1;
	for(int i=1;i&amp;lt;=n;i++) ans=max(ans,pa[i]-1);
	for(int i=1;i&amp;lt;=n;i++) ans=max(ans,pb[i]-1);
	for(int i=1;i&amp;lt;=n;i++)
	{
		int l=(i-pa[i])/2+1,r=(i+pa[i])/2-1;//下标从1开始
		if(l&amp;lt;=r)
			ans=max(ans,pa[i]-1+search(l-1,r)*2);
	}
	for(int i=1;i&amp;lt;=n;i++)
	{
		int l=(i-pb[i])/2+1,r=(i+pb[i])/2-1;
		if(l&amp;lt;=r)
			ans=max(ans,pb[i]-1+search(l,r+1)*2);
	}
	printf(&amp;quot;%d&amp;quot;,ans);
	return 0;
}

SP7586
求一个串中包含几个回文串
用马拉车求出以每个字母为对称轴的回文串长度，因为一个回文串长度/2就是这个回文串包含的子回文串长度，所以最后统计一下即可
代码
BZOJ 2084 Antisymmetry
给定一个长度为 n 的01串，问有多少个子串满足翻转并取反后和原来一样。
比如0101翻转并取反后还是和原来一样。
只要定义 0 = 1， 0 ≠ 0，1 ≠ 1 即可。跑一遍 Manacher 即可。
以 0/1 扩展的 p[i] 一定是 0 （即没有奇数长度的合法子串）
以 # 扩展的累加起来即可
接下来我们来考虑如果我们确定了一个中心后，向外扩展出一个最大可能的反对称串，那么这个串中一定含有len/2个满足条件的串，其中len为串长，因为要想大的满足条件，则在里面的小串必须满足是反对称的
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=500010;
char s[N];
char ma[N&amp;lt;&amp;lt;1];
int p[N&amp;lt;&amp;lt;1];
int n;

void manacher(char *s,int len)
{
    int l=0;
    ma[l++]=&#39;$&#39;;
    ma[l++]=&#39;#&#39;;
    for(int i=0;i&amp;lt;len;i++)
    {
        ma[l++]=s[i];
        ma[l++]=&#39;#&#39;;
    }
    ma[l]=0;
    int mx=0,id=0;
    for(int i=1;i&amp;lt;l;i+=2)
    {
        if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(ma[i+p[i]]-&#39;0&#39;+ma[i-p[i]]-&#39;0&#39;==1 || (ma[i+p[i]]==ma[i-p[i]] &amp;amp;&amp;amp; ma[i+p[i]]==&#39;#&#39;))
            p[i]++;
        if(i+p[i]&amp;gt;mx)
        {
            mx=i+p[i];
            id=i;
        }
    }
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	scanf(&amp;quot;%s&amp;quot;,s);
    manacher(s,n);
    long long ans=0;
    for(int i=1;i&amp;lt;n*2+2;i+=2)
    	ans+=p[i]/2;
	
    printf(&amp;quot;%lld\n&amp;quot;,ans);
    return 0;
}

BZOJ 3790
母亲节就要到了，小 H 准备送给她一个特殊的项链。这个项链可以看作一个用小写字母组成的字符串，每个小写字母表示一种颜色。为了制作这个项链，小 H 购买了两个机器。第一个机器可以生成所有形式的回文串，第二个机器可以把两个回文串连接起来，而且第二个机器还有一个特殊的性质：假如一个字符串的后缀和一个字符串的前缀是完全相同的，那么可以将这个重复部分重叠。
例如：aba和aca连接起来，可以生成串abaaca或 abaca。现在给出目标项链的样式，询问你需要使用第二个机器多少次才能生成这个特殊的项链。

样例：
abcdcba （答案：0）
abacada （答案：2）
abcdef （答案：5）
题目的意思就是用尽可能少的回文子串去覆盖原串。
我们可以先跑一遍 Manacher 算法得到每个位置的覆盖半径。
问题转化为了有许多个区间 [i-p[i], i+p[i]]，要选出尽可能少的区间来覆盖 [1, n] 区间
贪心即可。
对所有的区间按照左端点从小到大排序。
每次都选右端点最远的那个区间。
设当前覆盖到的右端点为 right。
每次找出左端点在[1, right] 中的右端点的最大的那个线段，再做一次覆盖。
时间复杂度 O(n log n)

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=50010,M=N&amp;lt;&amp;lt;1;
char s[N],ma[M];
int p[M];
struct Node
{
	int l,r;
	bool operator&amp;lt;(const Node &amp;amp;W) const
	{
		return l&amp;lt;W.l;
	}
}e[M];

void manacher(char *s,int len)
{
	int l=0;
	ma[l++]=&#39;$&#39;;
	ma[l++]=&#39;#&#39;;
	for(int i=0;i&amp;lt;len;i++)
	{
		ma[l++]=s[i];
		ma[l++]=&#39;#&#39;;
	}
	ma[l]=0;
	int mx=0,id=0;
	for(int i=0;i&amp;lt;l;i++)
	{
		if(mx&amp;gt;i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ma[i+p[i]] == ma[i-p[i]])
			p[i]++;
		if(i+p[i] &amp;gt; mx)
		{
			mx=i+p[i];
			id=i;
		}
		e[i].l=i-p[i]+1,e[i].r=i+p[i]-1;
	}
}

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s))
	{
		int n=strlen(s);
		manacher(s,n);
		
		n=n*2+1;
		sort(e+1,e+n+1);
		
		int st=1,j=1,ed=n;
		int res=0;
		
		while(st &amp;lt; ed)
		{
			int r=0;
			while(j &amp;lt;= n &amp;amp;&amp;amp; e[j].l &amp;lt;= st)
				r=max(r,e[j].r),j++;
			
			st=r;
			res++;
		}
		printf(&amp;quot;%d\n&amp;quot;,res-1);
	}
}

trie





void insert(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-&#39;a&#39;;
        if(!trie[p][k])
            trie[p][k]=++idx;
        p=trie[p][k];
    }
    cnt[p]=true;
}


int query(char *str)
{
    int p=1;
    for(int i=0;str[i];i++)
    {
        int k=str[i]-&#39;a&#39;;
        p=trie[p][k];
        if(!p)
            return 0;
    }
    return cnt[p];
}

模板题





例题
poj2503
您刚从滑铁卢搬到大城市。 这里的人说的是一门不可理解的外语。 幸运的是，您有一本字典来帮助您理解它们。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;sstream&amp;gt;
using namespace std;
const int N=1000010,M=26;
int trie[N][M];
int cnt[N],idx=1;
char word[N][15];

void insert(string str,int k)
{
	int len=str.size(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=str[i]-&#39;a&#39;;
		if(!trie[p][ch])
			trie[p][ch]=++idx;
		p=trie[p][ch];
	}
	cnt[p]=k;
}

int query(string str)
{
	int len=str.size(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=str[i]-&#39;a&#39;;
		p=trie[p][k];
		if(!p)
			return 0;
	}
	return cnt[p];
}

int main()
{
	string s,str;
	int k=1;
	while(getline(cin,s))
	{
		if(s.empty())
			break;
		stringstream ss(s);
		ss&amp;gt;&amp;gt;word[k]&amp;gt;&amp;gt;str;
		insert(str,k);
		k++;
	}
	
	while(cin&amp;gt;&amp;gt;s)
	{
		int k=query(s);
		if(k)
			cout&amp;lt;&amp;lt;word[k]&amp;lt;&amp;lt;endl;
		else 
			cout&amp;lt;&amp;lt;&amp;quot;eh&amp;quot;&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj3630

给定一个电话号码列表，判断它是否一致，即没有号码是另一个号码的前缀。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;sstream&amp;gt;
using namespace std;
const int N=100010,M=10;
int trie[N][M];
bool cnt[N];
int idx;
int n;

bool insert(char *s)
{
	int p=1;
	int len=strlen(s);
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=s[i]-&#39;0&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		else if(i == len-1)//字符串处理完毕，仍不空，说明该串是其它串的前缀 
			return true;
		p=trie[p][k];
		if(cnt[p])//其他串是该串前缀 
			return true;
	}
	cnt[p]=true;
	return false;
}

int main()
{
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		idx=1;
		bool ans=false;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i=1;i&amp;lt;=n;i++)
		{
			char s[15];
			scanf(&amp;quot;%s&amp;quot;,s);
			if(ans)
				continue;
			if(insert(s))//不能立即结束，仍要读取n个串 
				ans=true;
		}
		if(ans)
			cout&amp;lt;&amp;lt;&amp;quot;NO&amp;quot;&amp;lt;&amp;lt;endl;//有前缀输出NO 
		else
			cout&amp;lt;&amp;lt;&amp;quot;YES&amp;quot;&amp;lt;&amp;lt;endl;
	}
	return 0;
}

hdu1251
Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn=500005;
const int maxz=26;//不同字符个数，例如数字10，小写字母26
int trie[maxn][maxz];
int cnt[maxn];//计数器 
void insert(string s)//将字符串s插入到字典树中 
{
	int len=s.length(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=s[i]-&#39;a&#39;;//转换成数字
		if(!trie[p][ch]) 
			trie[p][ch]=++tot;//记录下标 
		p=trie[p][ch];
		cnt[p]++;//统计有多少个单词经过 
	}
}

int query(string s)
{
	int len=s.length(),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int ch=s[i]-&#39;a&#39;;//转换成数字
		p=trie[p][ch];
		if(!p)
			return 0;
	}
	return cnt[p];	
}

int main()
{	
	string s;
	memset(trie,0,sizeof(trie));
	memset(cnt,0,sizeof(cnt));
	tot=1;
	while(getline(cin,s))
	{
		if(!s.size())
			break;
		insert(s);
	}
	while(cin&amp;gt;&amp;gt;s)
		cout&amp;lt;&amp;lt;query(s)&amp;lt;&amp;lt;endl;
	return 0;
}

若反过来问，单词表中有多少单词是当前查询单词的前缀，只需统计查询时经过的end标记数量即可。
poj2513
给你一堆木棍。 每个棍子的每个端点都带有某种颜色。是否可以将操纵杆沿一条直线对齐，以使触摸的端点的颜色具有相同的颜色？


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=500010,M=26;
int trie[N][M];
int cnt[N];
int d[N];
int idx=1;
int color;
int p[N];

int find(int x)
{
	if(x != p[x])
		p[x]=find(p[x]);
	return p[x];
}

int insert(char *s)
{
	int len=strlen(s),p=1;
	for(int i=0;i&amp;lt;len;i++)
	{
		int k=s[i]-&#39;a&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	if(cnt[p])
		return cnt[p];
	else 
	{
	    cnt[p]=++color;
	    return cnt[p];
	}
}

int main()
{
	for(int i=1;i&amp;lt;N;i++)
		p[i]=i;
	char a[15],b[15];
	while(~scanf(&amp;quot;%s%s&amp;quot;,a,b))
	{
		int i=insert(a);
		int j=insert(b);
		d[i]++;
		d[j]++;
		//cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
		int pi=find(i);
		int pj=find(j);
		p[pi]=pj;
	}
	
	int s=find(1);
	int num=0;
	for(int i=1;i&amp;lt;=color;i++)
	{
		if(d[i] % 2 == 1)
			num++;
		if(num &amp;gt; 2 || find(i) != s)
 		{
 			puts(&amp;quot;Impossible&amp;quot;);
			return 0;
		}
 	}
	if(num == 0 || num == 2)
		puts(&amp;quot;Possible&amp;quot;);
	else 
		puts(&amp;quot;Impossible&amp;quot;);
	return 0;
}

poj3764
给出n个节点的树，每条边有边权w。 • 请你找一条路径，使得这条路径上所有边权的异或和最大。
• 数据范围
• n &amp;lt;= 100,000, 0 &amp;lt; w &amp;lt; 2^31
暴力的做法：
• 枚举每个点当根
• dfs整颗树，获得根到每个节点的路径异或和s[]
• 时间复杂度O(n^2)
异或的性质
x xor x = 0
• 一个数异或两次会抵消掉。
• x到y的路径异或和就等于s[x] xor s[y] !

这样只要任取一个点为根，dfs得到s[]数组后，枚举x， y即可，还是O(n^2)
现在的问题是，给定一个s[]数组，找两个元素，使得他
们的异或和最大。
• 给一个数x，在数组s中找一个数y使其和x的异或和最大。
• 涉及二进制的题，我们可以选择按位来考虑。
假设x的二进制有31位，我们把它的二进制写出来，最高位称为第30位，最低位称为第0位。
因为要让异或值最大，所以我们从高位开始考虑。
• 如果x的第30位是1 —— if (x &amp;gt;&amp;gt; 30 &amp;amp; 1)
• 那我们一定希望y的第30位是0，这样异或之后的第30位 是1.
• 否则就算第29～0位异或后都是1，也比2^30小。
• 同理，如果x的第30位是0，我们希望y的第30位是1.
运用贪心的思想，假设现在枚举到x的第i位
• if x第i位是1 我们要尽可能找第i位为0的y
• if x第i位是0 我们要尽可能找第i位为1的y
涉及前缀判断，采用trie
先把所有的数的二进制当作字符串，存进trie中。
• 从高往低枚举二进制位时，设置一个指针p，一开始指向trie的根节点。
• if x第i位是1 我们要尽可能找第i位为0的y 如果说明存在第i位为0的数，我们就让p往0节点走，答案中的第i位为1。
• 如果不存在第i位为0的数，我们只能退而求其次，让p往1节点走，答案中的第i位为0.
• if x第i位是0 我们要尽可能找第i位为1的y ， 同理
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010*31,M=N&amp;lt;&amp;lt;1;
int trie[N][2],tot=1;
int d[N];
int n;
int h[N],e[M],ne[M],w[M],idx;

void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=e[i];
		if(j == fa)
			continue;
		d[j]=d[u]^w[i];
		dfs(j,u);
	}
}

void insert(int x)
{
	int p=1;
	for(int i=30;i&amp;gt;=0;i--)
	{
		int u=x&amp;gt;&amp;gt;i&amp;amp;1;
		if(!trie[p][u])
			trie[p][u]=++tot;
		p=trie[p][u];
	}
}

int query(int x)
{
	int p=1;
	int res=0;
	for(int i=30;i&amp;gt;=0;i--)
	{
		int k=x&amp;gt;&amp;gt;i&amp;amp;1;
		if(trie[p][!k])
		{
			res+=1&amp;lt;&amp;lt;i;
			p=trie[p][!k];
		}	
		else 
			p=trie[p][k];
	}
	return res;
}

int main()
{
	while(~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n))
	{
		memset(h,-1,sizeof h);
		memset(d,0,sizeof d);
		memset(trie,0,sizeof trie);
		idx=0;
		tot=1;
		for(int i=0;i&amp;lt;n-1;i++)
		{
			int a,b,c;
			scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);
			a++,b++;
			add(a,b,c);add(b,a,c);
		}
		dfs(1,-1);
		int res=0;
//		for(int i=1;i&amp;lt;=n;i++)
//			cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&#39; &#39;;
		
		for(int i=1;i&amp;lt;=n;i++)
		{
			insert(d[i]);
			res=max(res,query(d[i]));
		}
		printf(&amp;quot;%d\n&amp;quot;,res);
	}
	return 0;
}

AC自动机











每个结点的26个指针都有指向
匹配时判断后缀是不是单词，若为单词则也需要统计上
模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=5e5+10,M=1e6+10;
int trie[N][26],cnt[N],idx;
char s[M];
int q[N],ne[N];
int n;

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-&#39;a&#39;;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;26;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;26;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	int res=0;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-&#39;a&#39;;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			res+=cnt[p];
			cnt[p]=0;
			p=ne[p];
		}
	}
	return res;
}

void print()
{
	for(int i=0;i&amp;lt;idx;i++)
	{
		cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;ne[i]&amp;lt;&amp;lt;&amp;quot;: &amp;quot;;
		for(int j=0;j&amp;lt;26;j++)
			if(trie[i][j])
			    cout&amp;lt;&amp;lt;char(j+&#39;a&#39;)&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;trie[i][j]&amp;lt;&amp;lt;&amp;quot;  &amp;quot;;
		cout&amp;lt;&amp;lt;endl;
	}
	cout&amp;lt;&amp;lt;endl;
}

int main()
{
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--)
	{
		memset(trie,0,sizeof trie);
		memset(cnt,0,sizeof cnt);
		memset(ne,0,sizeof ne);
		idx=0;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		
		for(int i=0;i&amp;lt;n;i++)
		{
			char str[55];
			scanf(&amp;quot;%s&amp;quot;,str);
			insert(str);
		}
		
		build();
		//print();
		scanf(&amp;quot;%s&amp;quot;,s);
		printf(&amp;quot;%d\n&amp;quot;,query(s));
	}
	return 0;
}

hdu2896
小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1e5+10,M=10010;
int trie[N][128],idx;
char s[M];
int q[N],ne[N];
int n,m;
int ans[N],cnt;
int id[N];
int tot;

void insert(char *s,int i)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=s[i]-32;
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	id[p]=i;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;128;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;128;i++)
		{
			int p=trie[t][i];
		    if (!p) trie[t][i] = trie[ne[t]][i];
            else
            {
                ne[p] = trie[ne[t]][i];
                q[ ++ tt] = p;
            }
		}
	}
}

int query(char *s)
{
	bool flag = false;
	for(int i=0,j=0;s[i];i++)
	{
		int k=s[i]-32;
		j=trie[j][k];
		
		int p=j;
		while(p)
		{
			if(id[p])
			{
				flag=true;
				ans[cnt++]=id[p];
				//cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;id[p]&amp;lt;&amp;lt;endl;
			}
			p=ne[p];
		}
	}
	return flag;
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		char str[210];
		scanf(&amp;quot;%s&amp;quot;,str);
		insert(str,i);
	}
	
	build();

	scanf(&amp;quot;%d&amp;quot;,&amp;amp;m);
	for(int i=1;i&amp;lt;=m;i++)
	{
		scanf(&amp;quot;%s&amp;quot;,s);
		cnt=0;
		if(query(s))
		{
			tot++;
			printf(&amp;quot;web %d:&amp;quot;,i);
			cnt=unique(ans,ans+cnt)-ans;
			sort(ans,ans+cnt);
			for(int i=0;i&amp;lt;cnt;i++)
				printf(&amp;quot; %d&amp;quot;,ans[i]);
			puts(&amp;quot;&amp;quot;);
		}
	}
	
	printf(&amp;quot;total: %d\n&amp;quot;,tot);
	return 0;
}

1.本题不是计数，不需判重复，只需标记病毒编号为true，多次标记不影响最终答案
2.多个主串，字典树下一次还要再查询，不能改变字典树
附：ASCII表

poj2778






#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
typedef long long LL;
const int N=110,mod=100000;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n,m;
int q[N];
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
	matrix(int c[][N])
	{
		memcpy(m,c,sizeof m);
	}
};

int get(char c)
{
	switch(c)
	{
		case &#39;A&#39; : return 0;
		case &#39;G&#39; : return 1;
		case &#39;C&#39; : return 2;
		case &#39;T&#39; : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;	
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&amp;lt;=idx;i++)
		for(int j=0;j&amp;lt;=idx;j++)
			for(int k=0;k&amp;lt;=idx;k++)
				res.m[i][j]=(res.m[i][j]+(LL)a.m[i][k]*b.m[k][j])%mod;
	return res;
}

matrix qmi(matrix a,int k)
{
	matrix res;
	for(int i=0;i&amp;lt;=idx;i++)
		res.m[i][i]=1;
	while(k)
	{
		if(k &amp;amp; 1)
			res=mul(res,a);
		a=mul(a,a);
		k&amp;gt;&amp;gt;=1;
	}
	return res;
}

int main()
{
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	for(int i=0;i&amp;lt;n;i++)
	{
		char str[15];
		scanf(&amp;quot;%s&amp;quot;,str);
		insert(str);
	}
	
	build();
	
	matrix g;
	for(int i=0;i&amp;lt;=idx;i++)
	{
		if(cnt[i]) continue;
		for(int j=0;j&amp;lt;4;j++)
		{
			int p=trie[i][j];
			if(!cnt[p])
				g.m[i][p]=(g.m[i][p]+1)%mod;
		}
	}
	
//	for(int i=0;i&amp;lt;=idx;i++)
//	{
//		for(int j=0;j&amp;lt;=idx;j++)
//			cout&amp;lt;&amp;lt;g.m[i][j]&amp;lt;&amp;lt;&#39; &#39;;
//		cout&amp;lt;&amp;lt;endl;
//	}
	
	g=qmi(g,m);
	int res=0;
	for(int i=0;i&amp;lt;=idx;i++)
		res=(res+g.m[0][i])%mod;
	
	printf(&amp;quot;%d&amp;quot;,res);
	
	return 0;
}

最后的答案为什么是g.m[0][i]求和?
矩阵g的n次幂表示构造长度为n的DNA序列的方案数（g的i次幂表示构造长度为n的DNA序列的方案数），类似离散数学中二元关系的复合运算，二元关系&amp;lt;1,2&amp;gt; ,&amp;lt;2,3&amp;gt; 复合一次可得到关系&amp;lt;1,3&amp;gt;
由于从根结点出发构造序列，且根结点idx为0.g.m[0][i]表示从根结点走i步的方案数，即从根节点开始构造长度为i的序列的方案数。
poj3691
AC自动机+DP
为每个结点构造失败指针的同时，检查其失败指针所指向的节点是否为危险节点，如果是的话也需要把当前节点标记为危险节点。
所谓的危险节点，就是指以当前节点为结尾的字符串是某个病毒串，或者包含了某个病毒串。如果在bfs的同时进行这项操作的时候就非常方便，在构造完当前失败指针的同时检查其所指向的节点是否为危险节点。
根据危险DNA序列所建的字典树，我们用模拟的方式 ，从第一个字符开始构造， 依次递增，找到一个满足要求的字符串，在构造此字符串的同时，比较该字符串和输入要判断的序列S，若该位置i的字符和s[i]，相同，则表示，此位置的字符不需要改变，反则，需要把s[i]该为词字符，为一次改变操作.
状态表示：dp[i][j]，表示到达查找串第i个字符时，对应于AC自动机的j节点所需要的最小改变数。
状态转移为dp[i][son[j]] = min( dp[i][son[j]], dp[i-1][j] + s[i-1]!=k )
读到i个字符时，对应于j状态（DP的过程要两重循环i和j），要转移到son[j]（j的子节点状态，在这里用k在[0,3]一重循环遍历所有可以转字符），如果第i个字符跟所要转移到的字符相同，则代价为0，因为不需要改变；否则代价为1，因为需要改变。
如果当前状态不可达，则不需要对其进行后续运算。
如果子节点为危险节点，则不可以进行转移，即不可以使用上面的状态方程。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1010,INF=0x3f3f3f3f;
int trie[N][4],idx;
int ne[N];
int cnt[N];
int n;
char s[N];
int f[N][N];
int q[N];

int get(char c)
{
	switch(c)
	{
		case &#39;A&#39; : return 0;
		case &#39;G&#39; : return 1;
		case &#39;C&#39; : return 2;
		case &#39;T&#39; : return 3;
	}
}

void insert(char *s)
{
	int p=0;
	for(int i=0;s[i];i++)
	{
		int k=get(s[i]);
		if(!trie[p][k])
			trie[p][k]=++idx;
		p=trie[p][k];
	}
	cnt[p]++;
}

void build()
{
	int hh=0,tt=-1;
	for(int i=0;i&amp;lt;4;i++)
		if(trie[0][i])
			q[++tt]=trie[0][i];
	
	while(hh &amp;lt;= tt)
	{
		int t=q[hh++];
		for(int i=0;i&amp;lt;4;i++)
		{
			int p=trie[t][i];
			if(!p) trie[t][i]=trie[ne[t]][i];
			else 
			{
				ne[p]=trie[ne[t]][i];
				q[++tt]=p;
				cnt[p] |= cnt[ne[p]];
			}
		}
	}
}

void print()
{
    for(int i=0;i&amp;lt;=idx;i++)
    {
        cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;ne[i]&amp;lt;&amp;lt;&amp;quot;: &amp;quot;;
        for(int j=0;j&amp;lt;4;j++)
            if(trie[i][j])
                cout&amp;lt;&amp;lt;trie[i][j]&amp;lt;&amp;lt;&#39; &#39;;
        cout&amp;lt;&amp;lt;endl;
    }
}

int main()
{
	int kas=1;
	while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) &amp;amp;&amp;amp; n)
	{
		memset(trie,0,sizeof trie);
		memset(ne,0,sizeof ne);
		memset(cnt,0,sizeof cnt);
		idx=0;
		for(int i=0;i&amp;lt;n;i++)
		{
			char str[25];
			scanf(&amp;quot;%s&amp;quot;,str);
			insert(str);
		}
		
		build();
		
		//print();
		
		scanf(&amp;quot;%s&amp;quot;,s+1);
		int len=strlen(s+1);
		
		memset(f,0x3f,sizeof f);
		f[0][0]=0;
		for(int i=1;i&amp;lt;=len;i++)
			for(int j=0;j&amp;lt;=idx;j++)
				for(int k=0;k&amp;lt;4;k++)
				{
					int t=get(s[i]) != k;
					int p=trie[j][k];
					if(!cnt[p])
						f[i][p]=min(f[i][p],f[i-1][j]+ t);
				}
				
		int res=INF;
		for(int i=0;i&amp;lt;=idx;i++)
			res=min(res,f[len][i]);
		
		if(res == INF)
			res=-1;
		printf(&amp;quot;Case %d: %d\n&amp;quot;,kas++,res);
	}
	return 0;
}

最后，循环dp[len][j]，即在读完最后一个字符后检查所有状态的最终值，取其最小。如果均不可达，则返回-1。
类似题：求主串至少包含一个模式串的方案数，正难则反。
代码
hdu2233
长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？
比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为
(2个) aa,ab,
(26个)aaa,aab,aac...aaz,
(26个)aba,abb,abc...abz,
(25个)baa,caa,daa...zaa,
(25个)bab,cab,dab...zab。







代码
若要求长度正好为L，原矩阵的L次幂即可
长度不超过L，需要累加
acwing1285
每次插入一个单词时把所有路径上的点都+1，每个单词的出现次数就是其结尾节点的fail树子树和。因为其fail指针指向的节点一定包含当前字符串。
统计贡献时要从下往上按照拓扑排序加，
代码
hdu3695
给出 n 个模式串，给出一个长串 S，找出 S 中出现了几种模式串。注意模式串在 S 中正着出现和反着出现都算出
现。S 可能有些段是压缩过的，格式为[tx]，t 是一个数字，x 是一个字母，代表有 t 个 x。把 a[3b]c 解压后会得到
abbbc。
n≤250，模式串的长度不超过1000，t≤5·1e6, 解压后的长串的长度不超过 5100000.

样例输入：
3
2
AB DCB
DACB
3
ABC CDE GHI
ABCCDEFIHG
4
ABB ACDEE BBB FEEE
A[2B]CD[4E]F
样例输出：
0
3
2
我们可以把这 n 个串插入 Trie 树，建成 AC 自动机。然后把解压后的 S 正着在 AC 自动机上跑一遍，再反着在
AC 自动机上跑一遍，对于覆盖过的模式串，打一个标记。最后统计标记的总数即可
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=250010,M=5100010;
int trie[N][26],idx;
char s[M],tmp[M];
int ne[N];
int dar[N];
int n;
int q[N];

void insert(char *s,int k)
{
    int p=0;
    for(int i=0;s[i];i++)
    {
        int k=s[i]-&#39;A&#39;;
        if(!trie[p][k])
        {
        	trie[p][k]=++idx;
        	memset(trie[idx],0,sizeof trie[idx]);
        	dar[idx]=0;
		}
        p=trie[p][k];
    }
   	dar[p]++;
}

void build()
{
    int hh=0,tt=-1;
    for(int i=0;i&amp;lt;26;i++)
        if(trie[0][i])
        {
        	int t=trie[0][i];
        	q[++tt]=t;
        	ne[t]=0;
		}
    
    while(hh &amp;lt;= tt)
    {
        int t=q[hh++];
        for(int i=0;i&amp;lt;26;i++)
        {
            int p=trie[t][i];
            if(!p) trie[t][i]=trie[ne[t]][i];
            else 
            {
                ne[p]=trie[ne[t]][i];
                q[++tt]=p;
            }
        }
    }
}

int query(char *s,int type)
{
    int len=strlen(s);
    if(type)
        reverse(s,s+len);
    //cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;
    int res=0;
    for(int i=0,j=0;s[i];i++)
    {
        int k=s[i]-&#39;A&#39;;
        j=trie[j][k];
        int p=j;
        while(p)
        {
        	if(dar[p])
        	{
        		res+=dar[p];
        		dar[p]=0;
			}
			else 
				break;
            p=ne[p];
        }
    }
    return res;
}

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    while(T--)
    {
    	memset(trie[0],0,sizeof trie[0]);
    	ne[0]=0;
    	dar[0]=0;
        idx=0;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        for(int i=1;i&amp;lt;=n;i++)
        {
            char str[1010];
            scanf(&amp;quot;%s&amp;quot;,str);
            insert(str,i);
        }
        
        build();
        
        scanf(&amp;quot;%s&amp;quot;,s);
        int l=0;
        for(int i=0;s[i];i++)
        {
            if(s[i] !=&#39;[&#39;)
                tmp[l++]=s[i];
            else
            {
                i++;
                int len=0;
                while(s[i] &amp;gt;=&#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;=&#39;9&#39;)
                {
                    len=len*10+s[i]-&#39;0&#39;;
                    i++;
                }
                for(int k=0;k&amp;lt;len;k++)
                    tmp[l++]=s[i];
                i++;
            }
        }
        tmp[l]=0;
        
        printf(&amp;quot;%d\n&amp;quot;,query(tmp,0)+query(tmp,1));
    }
}

hdu4763
给你一个字符串 S。
请你把这个 S 划分成 EAEBE 的形式。
其中 A 和 B 可以包含任意个（可以是0个）字符。
求 E 的最大长度。字符串的长度之和不会超过1e6

Sample Input
5
xy
abc
aaa
aaaaba
aaxoaaaaa

Sample Output
0
0
1
1
2
观察 EAEBE。
首先要保证 E 既是 S 的前缀又是 S 的后缀。
且去除掉前缀 E 和后缀 E 之后，中间剩下的还要出现一次 E。 对 S 跑一次扩展 KMP 中的 Z 算法。
如果 i+Z[i]-1 == n ，就说明 S[i..n] 可以作为 E。
那么就要求在 S[Z[i]+1..i-Z[i]] 中，还得存在一个 j 满足 Z[j] ≥ Z[i]
问题变成了先找 i+Z[i]-1 = n 的 符合条件的i
然后在[Z[i]+1..i-Z[i]] 中，查询 Z 的最大值，如果比Z[i] 大，那么就可以把 Z[i] 作为答案。最后取最大值即可。
查询区间最大值我们可以用线段树 / ST 表来维护。
最后的时间复杂度都是 O(n log n)

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-er/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/">
                        字符串复习（一）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-26</time>
                    
                        <a href="https://caifxh.github.io/tag/yImqvC-Dp/" class="post-tag i-tag
                            i-tag-success">
            #字符串
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            哈希表
如果要储存和使用线性表（1，75，324，43，1353，90，46）一般情况下我们会使用一个数组 A[1..7] 来顺序存储这些数。
但是这样的存储结构会给查询算法带来 O(n) 的时间开销。
对 A 排序，使用二分查询法，时间复杂度变为 O(log n)也可以用空间换时间的做法，用数组 A[1..1353] 来表示每个数是否出现，查找的时间复杂度变为 O(1)，但是空间上的开销变得巨大。
优化上一种做法，建立一个哈希函数 h(key) = key % 23.(1, 75, 324, 43, 1353, 90) -&amp;gt; (1, 6, 2, 20, 19, 21, 0)
我们只要用一个 A[0..22] 数组就可以快速的查询每个数是否出现。
这种线性表的结构就称为哈希表（Hash Table）。
可以看出，哈希表的基本原理是用一个下标范围比较大的数组 A 来存储元素。
设计一个函数 h，对于要存储的线性表的每个元素 node，取一个关键字 key，算出函数值 h(key) 然后把这个值作为下标，用 A[h(key)] 来存储 node。
最常见的 h 就是模函数，也就是选定一个 m，令 h(key) =key % m.
但是有一个问题，可能存在两个 key: k1, k2 使得h(k1)=h(k2)，这时也称产生了“冲突”。
解决冲突有很多种办法：
1.开放寻址法
2.拉链法：可以让 A 的每个元素都存一个链表，对于
h(k1)=h(k2)，我们可以让这两个 node 都接在 A[h(k1)]
的链表上
假设我们使用第二种方法解决冲突。
对于插入元素(node, key)：

计算 h(key)，把 node 插入 A[h(key)] 链表。

对于查询元素(node, key)：

计算 h(key)，如果 A[h(key)] 为空，说明 node 不存在。
否则遍历 A[h(key)] 链表，寻找 node。

模板题
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=100003;
int h[N],e[N],ne[N],idx;

void insert(int x)
{
    int k=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}

bool find(int x)
{
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i])
    {
        if(e[i]==x)
            return true;
    }
    return false;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    memset(h,-1,sizeof(h));
    while(n--)
    {
        char op[2];
        int x;
        scanf(&amp;quot;%s%d&amp;quot;,op,&amp;amp;x);

        if(*op==&#39;I&#39;)
            insert(x);
        else
        {
            if(find(x))
                puts(&amp;quot;Yes&amp;quot;);
            else
                puts(&amp;quot;No&amp;quot;);
        }
    }
    return 0;
}

例题
已知 X[1..4] 是 [-T, T] 中的整数，求出满足方程AX[1]+BX[2]+CX[3]+DX[4] = P的解有多少组？
|P|≤1e9，|A|,|B|,|C|,|D|≤1e4，T≤500
最直观的方法枚举 X[1..4], 时间复杂度 O(n4n^4n4)
适当优化，枚举了X[1..3] 之后，实际上 X[4] 已经确定了，时间复杂度 O(n3n^3n3)
继续优化，采用 meet in the middle 策略：
一边枚举 X[1], X[2]
一边枚举 X[4], X[3]
然后看有哪些方案可以组成方程的解
枚举 X[1], X[2], 然后算出 P-AX[1]-BX[2],把这个值存入一个哈希表，注意要统计次数。
这一步时间复杂度 O(n2n^2n2)
然后枚举 X[3], X[4], 算出 CX[3]+DX[4],去哈希表里查找这个值出现了几次。
把次数加进答案，这一步时间复杂度 O(n2n^2n2)
因此总的时间复杂度是 O(n2n^2n2)
字符串哈希
假设有 n 个长度为 L 的字符串，问其中最多有几个字符串是相等的。
直接比较两个长度为 L 的字符串是否相等时间复杂度是O(L) 的。
因此需要枚举 O(n2) 对字符串进行比较，时间复杂度 O(n2Ln^2Ln2L)
如果我们把每个字符串都用一个哈希函数映射成一个整数。
问题就变成了查找一个序列的众数。
时间复杂度变为了 O(nL)
一个设计良好的字符串哈希函数可以让我们先用 O(L) 的时间复杂度预处理，之后每次获取这个字符串的一个子串的哈希值都只要 O(1) 的时间。
BKDRHash 的基本思想就是把一个字符串当做一个 k 进制数来处理
假设字符串 s 的下标从 1 开始，长度为 n
ha[0] = 0;
    for (int i = 1;i &amp;lt;= n;i ++)
        ha[i] = (ha[i - 1] * P + str[i]) % M;

我们知道 ha[i] 就是 s[1..i] 的 BKDRHash
那么现在询问 s[x..y] 的 BKDRHash ，

因此我们预处理出 ha 数组和 k 的幂次，每次询问 s[x..y]的哈希值，只要 O(1) 的时间。
经验值，k=131，M=2642^{64}264
模板题
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 100010, P = 131;
int n, m;
char str[N];
ULL h[N], p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    scanf(&amp;quot;%s&amp;quot;, str + 1);

    p[0] = 1;
    for (int i = 1; i &amp;lt;= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf(&amp;quot;%d%d%d%d&amp;quot;, &amp;amp;l1, &amp;amp;r1, &amp;amp;l2, &amp;amp;r2);

        if (get(l1, r1) == get(l2, r2)) puts(&amp;quot;Yes&amp;quot;);
        else puts(&amp;quot;No&amp;quot;);
    }

    return 0;
}

例题
acwing160
核心问题就是：
给定两个字符串 A，B。求出 A 的每个后缀子串和 B 的最长公共前缀。
标准做法是扩展 KMP，时间复杂度线性。
我们来用 Hash 试试看
前面已经提到，我们可以用 O(n)预处理 O(1)处理出一个子串的哈希值。
求字符串 A[i..n] 与字符串 B[1..m] 的最长公共前缀？
二分长度 mid
计算出 A[i..i+mid-1] 和 B[1..mid] 的哈希值，比较是否相等。
因此时间复杂度是 O(nlog n) 的
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
typedef unsigned long long ULL;
const int N = 200010, P = 131;
int n, m,q;
char a[N];
char b[N];
ULL ha[N],hb[N],p[N];
int cnt[N];

ULL get(ULL h[],int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m,&amp;amp;q);
    scanf(&amp;quot;%s&amp;quot;, a + 1);
    scanf(&amp;quot;%s&amp;quot;,b+1);

    p[0] = 1;
    for(int i=1;i&amp;lt;=max(n,m);i++)
        p[i]=p[i-1]*P;
    for(int i=1;i&amp;lt;=n;i++)
        ha[i]=ha[i-1]*P+a[i];
    for(int i=1;i&amp;lt;=m;i++)
        hb[i]=hb[i-1]*P+b[i];
    
    for(int i=1;i&amp;lt;=n;i++)
    {
        int l=0,r=min(m,n-i+1);

        while(l&amp;lt;r)
        {
            int mid=l+r+1&amp;gt;&amp;gt;1;
            if(get(ha,i,i+mid-1) == get(hb,1,mid))
                l=mid;
            else
                r=mid-1;
        }
        cnt[l]++;
    }
    while(q--)
    {
        int x;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
        printf(&amp;quot;%d\n&amp;quot;,cnt[x]);
    }

    return 0;
}

poj2774
给出两个字符串 S 和 T，求它们的最长公共子串。|S|, |T| ≤ 1e5
思路
原始的 DP 做法（最长公共子序列），时间复杂度 O(n^2)
我们可以二分答案 len。然后计算 S 和 T 中所有长度为 len 的子串的哈希值。
这一步是 O(n) 的。
然后比较 S 的哈希值集合中和 T 的哈希值集合中有没有相同的元素。
可以再通过一步哈希找相同的值。这样总共仍然是 O(n)。
总的时间复杂度就是 O(n log n)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=100010,P=131;
char a[N],b[N];
typedef unsigned long long ULL;
ULL ha[N],hb[N],p[N];
vector&amp;lt;ULL&amp;gt; v;
int la,lb;

ULL get(ULL h[],int l,int r)
{
	return h[r]-h[l-1]*p[r-l+1];
}

bool check(int mid)
{
	v.clear();
	for(int i=mid;i&amp;lt;=la;i++)
		v.push_back(get(ha,i-mid+1,i));
	
	sort(v.begin(),v.end());
	for(int i=mid;i&amp;lt;=lb;i++)
	{
		ULL t=get(hb,i-mid+1,i);
		if(binary_search(v.begin(),v.end(),t))
			return true;
	}
	return false;
}

int main()
{
	scanf(&amp;quot;%s%s&amp;quot;,a+1,b+1);
	la=strlen(a+1);
	lb=strlen(b+1);
	
	p[0]=1;
	for(int i=1;i&amp;lt;=max(la,lb);i++)
		p[i]=p[i-1]*P;
	for(int i=1;i&amp;lt;=la;i++)
		ha[i]=ha[i-1]*P+a[i];
	for(int i=1;i&amp;lt;=lb;i++)
		hb[i]=hb[i-1]*P+b[i];
		
	int l=0,r=1e5;
	while(l&amp;lt;r)
	{
		int mid=l+r+1&amp;gt;&amp;gt;1;
		if(check(mid))
			l=mid;
		else
			r=mid-1;
	}
	printf(&amp;quot;%d\n&amp;quot;,l);
	return 0;
}

也可手写哈希表：代码
Codeforces 580E
给出一个数字串，现在有两种操作：
1: l r d: 将[l,r] 中的所有数字都改为 d
2: l r d：询问[l,r]这个子串的周期是否为 d。 1 &amp;lt;= n &amp;lt;= 1e5
首先思考对于一个字符串 S，如何判断它的周期是不是 d？
比如串 ababab 的周期是 2 串 abcabc 的周期是 3 串 abcde 的周期是 5
假设 S 的长度为 n。
只要判断 S[1..n-d+1] 和 S[d+1..n]是否相等即可。


#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
#define lc u&amp;lt;&amp;lt;1
#define rc u&amp;lt;&amp;lt;1|1
int n,m,k;
const int N=100010,P=131,mod=1e9+7;
char s[N];
typedef long long LL;
struct Node
{
	int l,r;
	int tag;
	LL key;
}tr[N&amp;lt;&amp;lt;2];
LL h[N],p[N];//p[i]表示p的i次方，h[i]表示连续i个1的字符串的hash值

void pushup(int u,int k)
{
	tr[u].key=((tr[lc].key*p[k])%mod+tr[rc].key)%mod;
}

void pushdown(int u)
{
	if(tr[u].tag)
	{
		int mid=tr[u].l+tr[u].r&amp;gt;&amp;gt;1,l=tr[u].l,r=tr[u].r;
		tr[lc].key=(tr[u].tag*h[mid-l+1])%mod;
		tr[lc].tag=tr[u].tag;
		tr[rc].key=(tr[u].tag*h[r-mid])%mod;
		tr[rc].tag=tr[u].tag;
		tr[u].tag=0;
	}
}

void build(int u,int l,int r)
{
	if(l == r)
	{
		tr[u]={l,r,0,s[l]-&#39;0&#39;+1};
		return;
	}
	tr[u]={l,r};
	int mid=l+r&amp;gt;&amp;gt;1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u,r-mid);
}

void modify(int u,int l,int r,int d)
{
	if(l &amp;lt;= tr[u].l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r)
	{
		tr[u].key=(d*h[tr[u].r-tr[u].l+1])%mod;
		//cout&amp;lt;&amp;lt;&amp;quot;-----&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].key&amp;lt;&amp;lt;endl;
		tr[u].tag=d;
		return;
	}
	pushdown(u);
	int mid=tr[u].l+tr[u].r&amp;gt;&amp;gt;1;
	if(l &amp;lt;= mid)
		modify(lc,l,r,d);
	if(r &amp;gt; mid)
		modify(rc,l,r,d);
	pushup(u,tr[u].r-mid);
}

int query(int u,int l,int r)
{
	if(tr[u].l == l &amp;amp;&amp;amp; tr[u].r == r)
		return tr[u].key;
	pushdown(u);
	int mid=tr[u].l+tr[u].r&amp;gt;&amp;gt;1;
	if(r&amp;lt;=mid)
		return query(lc,l,r);
	else if(l&amp;gt;mid)
		return query(rc,l,r);
	else 
		return (query(lc,l,mid)*p[r-mid]%mod+query(rc,mid+1,r))%mod;
}

void print(int u)
{
	if(tr[u].key)
	{
		cout&amp;lt;&amp;lt;&amp;quot;--&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].l&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].r&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;tr[u].key&amp;lt;&amp;lt;endl;
		print(lc);
		print(rc);
	}
}

int main()
{
	scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);
	scanf(&amp;quot;%s&amp;quot;,s+1);
	
	p[0]=1;
	for(int i=1;i&amp;lt;=n;i++)
	{
		h[i]=(h[i-1]*P%mod+1)%mod;
		p[i]=p[i-1]*P%mod;
	}

	build(1,1,n);
	
	m+=k;
	while(m--)
	{
		int t,l,r,d;
		scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;t,&amp;amp;l,&amp;amp;r,&amp;amp;d);
		if(t == 1)
			modify(1,l,r,d+1);//加一处理，防止d为0
		else
		{
			if(d == r - l + 1)
			{
                printf(&amp;quot;YES\n&amp;quot;);
                continue;
            }
			if(query(1,l,r-d) == query(1,l+d,r))
				puts(&amp;quot;YES&amp;quot;);
			else
				puts(&amp;quot;NO&amp;quot;);
		}
		//print(1);
	}
	return 0;
}

坑：第75组数组卡无符号64位自动溢出的hash,防ull溢出的解决方法是取模
Codeforces 955D
给出两个字符串 S 和 T。你需要在 S 中选出两个不相交的长度为 k 的子串，使得他们拼起来之后包含 T。
|T| ≤ 2k ≤ |S| ≤ 5·1e5

样例： （答案：Yes 1 5）
7 4 3
baabaab
aaaa
KMP


我们用形式化的语言来进行描述。
假设现在 T[s+1..s+k] 和 P[1..k] 匹配上了。
此时 T[s+k+1] != P[k+1]。
朴素的做法是：回到 T[s + 2] 和 P[1] 重新开始比较。
KMP算法：找到一个最大的 x，使得 T[s+1..s+k] 的后 x个字符，和 P 的前 x 个字符相同。
这部分就是能匹配上的，我们可以不用逐个判断。
又注意到 T[s+1..s+k] = P[1..k]
那么我们要求的就是一个最大的 x，满足 P[1..k] 的前 x个字符等于它的后 x 个字符。当然 x 要小于 k。
这个 x 记为 next[k]
对于 P = ababaca
我们可以计算出next数组：

有了 next 数组，现在如何匹配两个字符串呢？
for (int i = 1, j = 0; i &amp;lt;= m; i ++ )
{
    while (j &amp;amp;&amp;amp; s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == n)
    {
        printf(&amp;quot;%d &amp;quot;, i - n);
        j = ne[j];
    }
}


讲过如何匹配之后，我们还要会高效计算 next 数组。
计算 next 数组的过程就是拿 P 和 P 自己匹配的过程。
只不过要在匹配的过程中，记录每个位置下指针指向的位置，作为 next 数组。
for (int i = 2, j = 0; i &amp;lt;= n; i ++ )
{
    while (j &amp;amp;&amp;amp; p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

KMP算法复杂度
时间复杂度：O(n)
空间复杂度：O(n)
例题
poj2406
给一个字符串 S，求 S 的一个最短的循环节 e，使得 S 可以写成 eee…eee （共|S|/|e|个 e）
输出 |S|/|e| 的最大值。|S| ≤ 1e6

样例：
abcd （答案：1）
aaaa （答案：4）
ababab （答案：3）
假设这个字符串的长度为 len
如果 len 可以被 len-next[len] 整除，那么我们就可以说len-next[len] 是那个循环节的长度。
因为 next[len] 就表示: S[1..next[len]] = S[next[len] + 1..len]
可以证明满足这一条性质的字符串具有长度为 len-next[len] 的循环周期
否则答案就是 1 了。
因为如果存在一个长度为 d 的循环节，那一定满足：
S[1..len-d+1] == S[d + 1 .. len]
但是现在循环节的长度只能是 len-next[len],如果它不是 len 的因子，那就没有可能了。
时间复杂度 O(n)

定理：假设S的长度为len，则S存在最小循环节，循环节的长度L为len-next[len]，子串为S[0…len-next[len]-1]。
（1）如果len可以被len - next[len]整除，则表明字符串S可以完全由循环节循环组成，循环周期T=len/L。
（2）如果不能，说明还需要再添加几个字母才能补全。需要补的个数是循环个数L-len%L=L-(len-L)%L=L-next[len]%L，L=len-next[len]。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=1e6+10;
char s[N];
int ne[N];
int n;

int main()
{
	while(scanf(&amp;quot;%s&amp;quot;,s+1))
	{
		if(s[1] == &#39;.&#39;)
			break;
		
		n=strlen(s+1);
		for(int i=2,j=0;i&amp;lt;=n;i++)
		{
			while(j &amp;amp;&amp;amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		int t=n-ne[n];
		if(n%t == 0)
			cout&amp;lt;&amp;lt;n/t&amp;lt;&amp;lt;endl;
		else
			cout&amp;lt;&amp;lt;1&amp;lt;&amp;lt;endl;
	}
	return 0;
}

poj2752
给定一个字符串 S，求出 S 中所有的既是前缀又是后缀的子串。输出 i 代表 S[1..i]|S| ≤ 400000

样例：
ababcababababcabab（答案：2 4 9 18）
aaaaa（答案：1 2 3 4 5）
求出 next 数组。
答案就是 len, next[len], next[next[len]], …

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=4e5+10;
char s[N];
int ne[N];
int ans[N];

int main()
{
	while(~scanf(&amp;quot;%s&amp;quot;,s+1))
	{
		int n=strlen(s+1);
		for(int i=2,j=0;i&amp;lt;=n;i++)
		{
			while(j &amp;amp;&amp;amp; s[i] != s[j+1])
				j=ne[j];
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
	
		int t=ne[n],cnt=0;
		while(t)
		{
			ans[cnt++]=t;
			t=ne[t];
		}
		
		for(int i=cnt-1;i&amp;gt;=0;i--)
			printf(&amp;quot;%d &amp;quot;,ans[i]);
		printf(&amp;quot;%d\n&amp;quot;,n);

	}
	return 0;
}

hdu2594
求出最长的既是 s1 的前缀又是 s2 的后缀的子串。

样例：
riemann
marjorie
答案：rie
只要把两个串拼起来，中间用一个分隔符,s1,s1,s1s2,令len=strlen(s1$s2),则next[len]即为答案
也可不加分隔符，枚举 len, next[len], next[next[len]] ......找到小于 min(|s1|, |s2|) 的最大值即可。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=50010*2;//数组开两倍!
char s1[N],s2[N];
int ne[N];

int main()
{
	while(~scanf(&amp;quot;%s%s&amp;quot;,s1+1,s2+1))
	{
		strcat(s1+1,&amp;quot;$&amp;quot;);
		strcat(s1+1,s2+1);
		int n=strlen(s1+1);
		for(int i=2,j=0;i&amp;lt;=n;i++)
		{
			while(j &amp;amp;&amp;amp; s1[i] != s1[j+1])
				j=ne[j];
			if(s1[i] == s1[j+1])
				j++;
			ne[i]=j;
		}
		
		int ans=ne[n];
		s1[ans+1]=&#39;\0&#39;;
		if(ans == 0)
			printf(&amp;quot;0\n&amp;quot;);
		else 
			printf(&amp;quot;%s %d\n&amp;quot;,s1+1,ans);
	}
}

Codeforces 526D
给出一个字符串 s，判断其每个前缀是否可以表示成ABAB…ABA 的形式（A 和 B 都可以为空， 但是必须满足 A 有 k+1 个，B 有 k 个）
|s|, k ≤ 1e6

输入
7 2
bcabcab
输出
0000011
长度为 6 的前缀，可以取 A=“”,B=“bca”
长度为 7 的前缀，可以取 A=“b”, B=“ca”
对于前缀 P，我们可以把 P 拆成 SSSS…ST，其中 T 是 S的前缀。
这样就可以用 KMP 来做了。
首先 i-next[i] 就是S[1..i] 这一段的最小循环节的长度，
记为 e。
可以发现 e 的倍数 je 也是循环节。

#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=1e6+10;
char s[N];
int n,k;
int ne[N];

bool check(int i,int cir)
{
	int up=i/k/cir;
	int down=ceil((i/(k+1)+1)/(1.0*cir));
	return up&amp;gt;=down || (i % (k+1) == 0 &amp;amp;&amp;amp; (i / (k+1)) % cir == 0);
}

int main()
{
	while(~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k))
	{
		scanf(&amp;quot;%s&amp;quot;,s+1);
		
		int len=strlen(s+1);
		for(int i=2,j=0;i&amp;lt;=len;i++)
		{
			while(j &amp;amp;&amp;amp; s[i] != s[j+1])
				j=ne[j];
			
			if(s[i] == s[j+1])
				j++;
			ne[i]=j;
		}
		
		for(int i=1;i&amp;lt;=n;i++)
		{
			int cir=i-ne[i];
			printf(&amp;quot;%d&amp;quot;,check(i,cir));
		}
	}
}

acwing
首先我们用KMP求出 T 的 next数组。
利用 next数组在长文本中匹配模板串 T的过程：如果下一个字母不匹配，需要一直沿着next指针找：j = next[j]，直到下一个字符匹配或者next指针指向开头为止。
然后我们会发现，假设我们已经匹配完长文本的前个字母，则剩下部分的匹配过程，只跟next指针的位置有关，因此我们可以用二维数组来表示当前状态的方案数：
f[i][j]表示匹配完前 i 个字母时，next指针在 j 时的方案总数。
状态转移：对于每个状态f[i][j]，我们从&#39;a&#39;-&#39;z&#39;枚举下一个字母，然后求出对应的next指针，假设是，则将f[i][j]的方案总数累加到f[i+1][u]。
转移过程中需要注意，因为密码中不能存在 T，所以next指针要避免转移到 T的最后一个字母。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt; 
using namespace std;
const int N=55,mod=1e9+7;
int f[N][N];
int edge[N][26];
char p[N];
int ne[N];
int n;


int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;p+1;
    int m=strlen(p+1);
    
    for(int i=2,j=0;i&amp;lt;=m;i++)
    {
        while(j &amp;amp;&amp;amp; p[i] != p[j+1])
            j=ne[j];
        if(p[i] == p[j+1])
            j++;
        ne[i]=j;
    }
    
    for(int i=0;i&amp;lt;m;i++)
        for(char k=&#39;a&#39;;k&amp;lt;=&#39;z&#39;;k++)
        {
            int j=i;//已匹配了前i个字母
            while(j &amp;amp;&amp;amp; p[j+1] != k)
                j=ne[j];
            if(p[j+1] == k)
                j++;
            edge[i][k-&#39;a&#39;]=j;
        }
        
    f[0][0]=1;
    for(int i=0;i&amp;lt;n;i++)
        for(int j=0;j&amp;lt;m;j++)
            for(char k=&#39;a&#39;;k&amp;lt;=&#39;z&#39;;k++)
            {
                int u=edge[j][k-&#39;a&#39;];
                f[i+1][u]=(f[i+1][u]+f[i][j])%mod;
            }
            
    int res = 0;
    for (int i = 0; i &amp;lt; m; i ++ ) res = (res + f[n][i]) % mod;

    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    return 0;
}

luoguP3193
设f(i,j)表示以准考证号为基准递推，准考证号匹配到第i位，不吉利数字匹配到第j位时（即准考证的后j位等于不吉利数字的前j位），不出现不吉利数字的字符串数量。。
那怎么转移？
既然要以考号为基准递推，就要考虑一位考号对下一位的影响。
而考号是可以随便写的，那我们就要考虑10种数字了。
对于一个新数字new，有以下几种情况：
1.new
与不吉利数字的j+1位匹配，dp(i+1,j+1)的答案数+dp(i,j)
2.上述两者不匹配。
不匹配怎么办？这个不匹配的new一定没有贡献了？
当然不一定。
怎么讲呢，举个例子吧，不吉利数字是12212112。然后你的准考证号枚举到第9位时，前面8位已经枚举成了11112212。可以发现已经匹配了不吉利数字的前5位，现在要匹配第6位。
如果第9位枚举1，那它就匹配了，dp(9,6)+=dp(8,5)。如果第9位枚举2，那它就不匹配。但是会发现，存在 与当前已匹配的不吉利数字的后缀相同 的前缀，可以匹配上这个2！
上一个位置就是不吉利数字的第2位。
它的下一位，第3位2，刚好可以匹配枚举的第9位！
所以此时最多能匹配不吉利数字的前3位，有转移dp(9,3)+=dp(8,5)。
我们只需要沿着不吉利数字的失配指针往前走，找到第一个下一位与new匹配的位置就可以了。
为什么不用考虑再往前的下一位可以匹配new的位置？
因为这是递推，从前往后每一种状态都会被考虑，所以在考虑匹配后面的位之前，前面的位已经匹配好更前面的情况了。
比如不吉利数字1221221211。你目前枚举的准考证号前8位是12212212，现在你要枚举第9
位。很明显当枚举2时，通过找不吉利数字中 后缀相同的前缀，可知dp(8,8)可以转移到dp(9,6)。
但是我们发现也可以转移到dp(9,3)诶！
事实上，在这之前dp(8,5)已经转移到dp(9,3)过了。而dp(8,5)表示什么？它表示准考证号枚举8位，后5位与不吉利数字的前5位匹配上。
dp(8,8)同理，表示准考证号枚举前8位，后8位与不吉利数字的前8位匹配上。
这样直观看起来没什么答案关联。但是仔细考虑以下，不吉利数字的第8位的失配指针指向第5位。
这说明什么？
不吉利数字的前8位中，前5位等于后5位！
匹配5位的情况包含匹配8位的情况！（因为你匹配了8位，根据上推论可知也算在匹配了5位的情况中）
这就是别人博客中此题题解经常提到的计数方案会包含的问题。
其实按照AC自动机的构造方式，如果一个点没有字符为new的儿子边的话，它会建出一条对应的虚拟儿子边和点，儿子点上存的是沿着失配指针往回走的上一个实际存在这条字符边所指向的儿子。
当然这题m很小，不吉利数字串自己匹配自己的复杂度很小，可以直接暴力跑失配指针找第一个。

其中g(i,j)表示当前匹配到i个字符，添加一个字符变成匹配为j个字符的方案数。
不吉利数字已经知道了，g数组可以预处理出来（KMP）。
然后我们惊奇地发现n≤1e9，不让你循环推，直接就想到矩阵快速幂优化了。
观察一下转移方程，发现dp[i+1][?]总是由dp[i][?]推来，而且i还是n这个级别的。
又发现每次实际上都是乘一个固定的矩阵g，也就是说整个dp数组的某一位的值其实都是通过一些g数组乘过来的。
所以可以把dp数组直接当成g数组自己乘自己。
比如说，g(4,2)=4。
表示有4种转移情况可以让 与不吉利数字的前4位匹配的情况 在准考证号增加1位后 与不吉利数字的前2位匹配。
所以dp(x+1,2)=dp(x,4)∗g(4,2)=dp(x,4)∗4
而dp(x,4)又是哪来的？
它是通过∑i=1m\sum_{i=1}^m∑i=1m​dp(x−1,i)∗g(i,4)转移过来的。
所以一直往前推到x=0，发现dp值的n次转移都只跟转移矩阵g有关，是否与不吉利数字完全匹配等情况可以在弄g数组时就处理掉，即g数组只考虑不吉利数字被匹配0~m−1位的情况，不让它转移到j位都被匹配的情况。
所以就是对g矩阵做快速幂，求它的n次方。
时间复杂度O(log(n)∗m^3)
为什么答案是g(0,i)，for i 0~m-1
考虑g(i,j)的意义。如果g矩阵自己对自己连续进行k次转移（不进行快速幂而循环推），g(i,j)就表示：在进行k次转移前 准考证号匹配不吉利数字的前i位时，准考证号增加k个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。这是矩阵转移的基本概念。
所以进行n次转移后，g(i,j)就表示一开始准考证号匹配不吉利数字的前i位时，准考证号增加n个字符后，使不吉利数字沿失配指针（自己也可以）找到的最大的匹配位数j（算上新匹配的k位）的方案数。
我们需要取全局情况的答案，而这是很显然的。开始时准考证号匹配不吉利数字的前0位（准考证号还一位都没枚举），所以i为0；而由于已经定义过g数组只考虑不吉利数字被匹配 0~m−1位的情况，所以j在这个区间取任意值，g(0,j)都是答案的一部分。把它们都算上就是答案。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int N=25;
char p[N];
int n,m,mod;
struct matrix
{
	int m[N][N];
	matrix()
	{
		memset(m,0,sizeof m);
	}
};
int ne[N];

matrix mul(matrix a,matrix b)
{
	matrix res;
	for(int i=0;i&amp;lt;m;i++)
		for(int j=0;j&amp;lt;m;j++)
			for(int k=0;k&amp;lt;m;k++)
				res.m[i][j]=(res.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
	return res;
}

int main() 
{
	scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;mod);
	scanf(&amp;quot;%s&amp;quot;, p+1);
	
	matrix g;
	for(int i=2,j=0;i&amp;lt;=m;i++)
	{
		while(j &amp;amp;&amp;amp; p[i] != p[j+1])
			j=ne[j];
		if(p[i] == p[j+1])
			j++;
		ne[i]=j;
	}
	
	for(int i=0;i&amp;lt;m;i++)
		for(int k=0;k&amp;lt;10;k++)
		{
			int j=i;
			while(j &amp;amp;&amp;amp; p[j+1]-&#39;0&#39; != k)
				j=ne[j];
			if(p[j+1]-&#39;0&#39; == k)
				j++;
			if(j&amp;lt;m)	g.m[i][j]=(g.m[i][j]+1)%mod;
		}
	
	matrix a;
	for(int i=0;i&amp;lt;m;i++)
		a.m[i][i]=1;
	
	while(n)
	{
		if(n &amp;amp; 1) a=mul(a,g);
		g=mul(g,g);
		n&amp;gt;&amp;gt;=1;
	}
//	
//	for(int i=0;i&amp;lt;m;i++)
//	{
//		for(int j=0;j&amp;lt;m;j++)
//			cout&amp;lt;&amp;lt;a.m[i][j]&amp;lt;&amp;lt;&#39; &#39;;
//		cout&amp;lt;&amp;lt;endl;
//	}
	
	int ans = 0;
	for(int i = 0; i &amp;lt; m; ++i)
		ans = (ans + a.m[0][i]) % mod;
	
	printf(&amp;quot;%d\n&amp;quot;, ans);
	return 0;
}



Z算法




r[5] = 7
r[6] = 7
l[5] = 5
l[6] = 5

对于 Z[2] 我们需要暴力计算。
也就是暴力计算 S[1..|S|] 和 S[2..|S|] 的最长公共前缀。
如果 Z[2] &amp;gt; 0, 那么 r = r[2], l = l[2] = 2
如果 Z[2] = 0, 那么 r = r[2] = 0, l = l[2] = 0
我们的目标就是用已有的 Z[2], Z[3], ..., Z[k-1]，来推
出 Z[k].
假设 k = 121, Z[2..120] 已经知道了
r[120] = 130, l[120] = 100

划分成[l,i-1],[i,r]





蓝色部分一定不相等，否则说明z-box可以右移
第一步：
初始化 Z[]，暴力计算 Z[2]
for(int i = 1;i &amp;lt;= n;i ++) z[i] = 0;
int l, r;
while(str[1 + z[2]] == str[2 + z[2]]) z[2] ++; 
l = 2, r = 2+ z[2]-1;

第二步：
枚举 i，分三种情况依次计算 Z[i]
for(int i = 3;i &amp;lt;= n;i ++)
{
    if(i &amp;gt; r)
    {
        while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
        l = i, r = i + z[i] - 1;
    }
    else
    {
        if(z[i - l + 1] &amp;lt; r - i + 1) z[i] = z[i - l + 1];
        else
        {
            z[i] = r - i;
            while(str[1 + z[i]] == str[i + z[i]]) z[i] ++; 
            l = i, r = i + z[i] - 1; 
        }
    } 
}

时间复杂度是 O(n) 的
扩展KMP
给定两个字符串 S 和 T（长度分别为 n 和 m）
定义 extend[i] 为 S[i..n] 与 T 的最长公共前缀的长度。
求出 extend 数组

如果 S = T，那么 extend 数组就是 Z 数组。

假设现在遍历到了 S[i]，且 S[1], S[2],…, S[i-1]都已经算出
与 Z 算法类似，设置两个变量 l 和 r，r 表示能和 T 匹
配到的最右边的位置，l 为 r 对应的起始位置。
也就是 S[l .. r] = T[1.. r-l+1]

S[i] 对应的是 T[i-l+1]
现在要计算的是 S[i..n] 与 T 的最长公共前缀
注意到此时 S[i..r] = T[i-l+1 .. r-l+1]
所以我们可以先对 T 求一遍 Z 数组，然后考察一下 Z[i-l+1]



void calc_Z(char *str) 
{
	int n = strlen(str + 1);
	for(int i = 1; i &amp;lt;= n; i ++) z[i] = 0;
	z[1] = n;
	int l, r = 0;
	for(int i = 2; i &amp;lt;= n; i ++) 
	{
		if(i &amp;gt; r) 
		{
			while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
			l = i, r = i + z[i] - 1;
		} else 
		{
			if(z[i - l + 1] &amp;lt; r - i + 1) z[i] = z[i - l + 1];
			else 
			{
				z[i] = r - i + 1;
				while(str[1 + z[i]] == str[i + z[i]]) z[i] ++;
				l = i, r = i + z[i] - 1;
			}
		}
	}
}

void calc_extend(char *S, char *T) 
{
	calc_Z(T);
	int l, r = 0;
	int n = strlen(S + 1);
	int m = strlen(T + 1);
	for (int i = 1; i &amp;lt;= n; i ++) 
	{
		if (i &amp;gt; r) 
		{
			while (i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp;
			        S[i + ext[i]] == T[1 + ext[i]]) ext[i] ++;
			l = i, r = i + ext[i] - 1;
		}
		else 
		{
			if (i + z[i - l + 1] - 1 &amp;lt; r) ext[i] = z[i - l + 1];
			else 
			{
				ext[i] = r - i + 1;
				while (i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp; S[i +ext[i]] == T[1 + ext[i]]) 
					ext[i] ++;
				l = i, r = i + ext[i] - 1;
			}
		}
	}
}

例题
题意：给你n个字符串，求这n个字符串的最长公共子串
hdu4333
给一个 L 位数的正整数 N，每次可以把这个数的最后一位移到最前面来，得到一个新的数。
总共最多可以得到 n 个数，重复的只算一次。
问这些数中，等于 n 的，小于 n的，大于 n 的数分别有几个。
L ≤ 1e5

样例：
341 （答案： 1 1 1）
我们只需要把这个数复制两遍，然后只考虑长度为 n 的子串。这些子串就是移动过程中产生的数。
如何和原数 N 做比较呢
假设现在的数是 S[i .. i+L-1], N 是 S[1..L]
我们只要求出他们的最长公共前缀 x，如果 x = n 说明这两个数相等。
否则，比较 S[x] 和 S[i+x-1] 的大小，就可以确定他们的大小关系。
求 x ，就是扩展 KMP 中的 Z 算法。x = min(n, Z[i])
最后一步去重。对 N 跑一次 KMP
如果 L-next[L] 是 L 的约数，那么 L-next[L] 是 N 的最小循环节。否则 N 的 最小循环节是 L。
对循环节内的情况枚举一遍即可,或除以最小循环节个数。
时间复杂度 O(L)
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=200010;
char str[N];
int ne[N];
int z[N];

int main()
{
    int T;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
    for(int kas=1;kas&amp;lt;=T;kas++)
    {
        scanf(&amp;quot;%s&amp;quot;,str+1);
        
        int len=strlen(str+1);
        for(int i=2,j=0;i&amp;lt;=len;i++)
        {
            while(j &amp;amp;&amp;amp; str[i] != str[j+1])
                j=ne[j];
            if(str[i] == str[j+1])
                j++;
            ne[i]=j;
        }
        
        for(int i=1;i&amp;lt;=len;i++)
            str[i+len]=str[i];
        str[len*2+1]=&#39;\0&#39;;
        memset(z,0,sizeof z);
        z[1]=len*2;
        int l,r=0;
        
        for(int i=2;i&amp;lt;=len*2;i++)
        {
            if(i&amp;gt;r)
            {
                while(str[1+z[i]] == str[i+z[i]])
                    z[i]++;
                l=i,r=i+z[i]-1;
            }
            else 
            {
                if(z[i-l+1] &amp;lt; r-i+1)
                    z[i]=z[i-l+1];
                else 
                {
                    z[i]=r-i;
                    while(str[1+z[i]] == str[i+z[i]])
                        z[i]++;
                    l=i,r=i+z[i]-1;
                }
            }
        }
        
        int gre=0,eql=0,les=0;
        for(int i=1;i&amp;lt;=len;i++)
        {
            if(z[i] &amp;gt;= len)
                eql++;
            else if(str[1+z[i]] &amp;gt; str[i+z[i]])
                les++;
            else gre++;
        }
        
        int t;
        if(len%(len-ne[len]) == 0)
            t=len/(len-ne[len]);//循环节个数 
        else 
            t=1;
        printf(&amp;quot;Case %d: %d %d %d\n&amp;quot;,kas,les/t,eql/t,gre/t);
    }
}

对循环节内的情况枚举代码
poj3376
给你 n 个字符串 m[1], m[2], …, m[n]。 求 S = m[i]m[j] （1 &amp;lt;= i,j &amp;lt;= n）是回文串的数量。
n 个字符串的长度之和不超过 2·1e6

样例输入：
3a
ab
ba
答案：5（aa,aba,aba,abba,baab)
考虑什么情况下 i 和 j 拼起来会是回文串。


i的长度小于j，那么i一定是j的反串的前缀，且j的反串剩下的后缀是回文串


i的长度等于j，那么i等于j的反串


i的长度大于j，那么j的反串一定是i的前缀，且i串剩下的后缀是回文串


我们可以将这n个字符串插入trie，每个节点要维护两个值：
value1. 到当前节点的字符串个数；value2.当前节点后面的回文子串个数
我们用每个字符串的反串去trie上查找，要构成回文串有以下情况：


1.此反串是其他串的前缀，那么组合回文串的数量就要加上value2


2.此反串的前缀是某些字符串，且反串剩下的后缀是回文串，那么组合回文串的数量要加上value1


3.2的特例：此反串的前缀是某些字符串，且反串剩下的后缀为空，同样要加上value1，这种情况可以和2一起处理


留下的问题就是一个字符串的所有后缀中，哪些是回文串。
对于串 S，我们先求出正串 S 对反串 T 的 extend[i]
那么对于每个 i，如果 S[i..n] 和 T 的最长公共前缀等于
S[i..n] 的长度，说明 S[i..n] 是一个回文串。
因此整道题就在线性的时间复杂度内解决了。
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int N=2e6+10;
int trie[N][26],tot=1;
int n;
char s[N],t[N];
int len[N];
int slen;
int z[N],ext[N];
bool flag[2][N];
int bg[N],ed[N];
typedef long long LL;
struct Node
{
	int v1,v2;
}cnt[N];

void get_z(char *s)
{
	int n=strlen(s+1);
	for(int i=1;i&amp;lt;=n;i++) z[i]=0;
	z[1]=n;
	int l,r=0;
	for(int i=2;i&amp;lt;=n;i++)
	{
		if(i&amp;gt;r)
		{
			while(s[1+z[i]] == s[i+z[i]])
				z[i]++;
			l=i,r=i+z[i]-1;
		}
		else
		{
			if(z[i-l+1] &amp;lt; r-i+1)
				z[i]=z[i-l+1];
			else
			{
				z[i]=r-i;
				while(s[1+z[i]] == s[i+z[i]])
					z[i]++;
				l=i,r=i+z[i]-1;
			}
		}
	}
}

void exkmp(int type,char *s,char *t)
{
	get_z(t);
	int n=strlen(s+1);
	int m=strlen(t+1);
	for(int i=1;i&amp;lt;=n;i++)
		ext[i]=0;
	int l,r=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		if(i&amp;gt;r)
		{
			while(i+ext[i] &amp;lt;=n &amp;amp;&amp;amp; 1+ext[i] &amp;lt;=m &amp;amp;&amp;amp;
			s[i+ext[i]] == t[1+ext[i]])
				ext[i]++;
			l=i,r=i+ext[i]-1;
		}
		else
		{
			if(z[i-l+1] &amp;lt; r-i+1)
				ext[i]=z[i-l+1];
			else
			{
				ext[i]=r-i+1;
				while(i + ext[i] &amp;lt;= n &amp;amp;&amp;amp; 1 + ext[i] &amp;lt;= m &amp;amp;&amp;amp; 
				s[i+ext[i]] == t[1+ext[i]])
					ext[i]++;
				l=i,r=i+ext[i]-1;
			}
		}
	}

	for(int i=1;i&amp;lt;=n;i++)
	{
		//cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;ext[i]&amp;lt;&amp;lt;endl;
		if(ext[i] == n-i+1)
			flag[type][i+slen]=true;//s[i...n]为回文串
	}
}

void insert(int k)
{
	int p=1;
	for(int i=bg[k];i&amp;lt;=ed[k];i++)
	{
		cnt[p].v2+=flag[0][i];
		int ch=s[i]-&#39;a&#39;;
		if(!trie[p][ch])
			trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	cnt[p].v1++;
}

void print(int k)
{
	int p=1;
	for(int i=bg[k];i&amp;lt;=ed[k];i++)
	{
		int ch=s[i]-&#39;a&#39;;
		p=trie[p][ch];
		cout&amp;lt;&amp;lt;&amp;quot;---&amp;quot;&amp;lt;&amp;lt;cnt[p].v2&amp;lt;&amp;lt;&#39; &#39;&amp;lt;&amp;lt;cnt[p].v1&amp;lt;&amp;lt;endl;
	}
}

int main()
{
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	
	for(int i=1;i&amp;lt;=n;i++)
	{
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;len[i]);
		scanf(&amp;quot;%s&amp;quot;,s+1+slen);
		for(int j=1;j&amp;lt;=len[i];j++)
			t[slen+j]=s[slen+len[i]+1-j];
		t[slen+len[i]+1]=&#39;\0&#39;;
		exkmp(0,s+slen,t+slen);
		exkmp(1,t+slen,s+slen);

		bg[i]=slen+1;
		slen+=len[i];
		ed[i]=slen;

		insert(i);
		//print(i);
	}

	LL ans=0;
	for(int i=1;i&amp;lt;=n;i++)
	{
		int p=1;
		bool f=true;
		for(int j=ed[i];j&amp;gt;=bg[i];j--)//用反串去trie上匹配
		{
			int k=s[j]-&#39;a&#39;;
			if(!trie[p][k])
			{
				f=false;
				break;
			}
			else
				p=trie[p][k];
			if(flag[1][bg[i]+ed[i]-j+1] || j == bg[i])
				ans+=cnt[p].v1;
		}
		if(f)
			ans+=cnt[p].v2;
	}

	printf(&amp;quot;%lld\n&amp;quot;,ans);
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://caifxh.github.io/post/zi-fu-chuan-fu-xi-yi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://caifxh.github.io/images/avatar.png?v=1588691348423)">
        </div>
        <h1 class="id_card-title">
            fxh
        </h1>
        <h2 class="id_card-description">
            菜
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://caifxh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>